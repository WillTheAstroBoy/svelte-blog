var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[Object.keys(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// node_modules/@sveltejs/kit/dist/install-fetch.js
function dataUriToBuffer(uri) {
  if (!/^data:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  uri = uri.replace(/\r?\n/g, "");
  const firstComma = uri.indexOf(",");
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError("malformed data: URI");
  }
  const meta = uri.substring(5, firstComma).split(";");
  let charset = "";
  let base642 = false;
  const type = meta[0] || "text/plain";
  let typeFull = type;
  for (let i = 1; i < meta.length; i++) {
    if (meta[i] === "base64") {
      base642 = true;
    } else {
      typeFull += `;${meta[i]}`;
      if (meta[i].indexOf("charset=") === 0) {
        charset = meta[i].substring(8);
      }
    }
  }
  if (!meta[0] && !charset.length) {
    typeFull += ";charset=US-ASCII";
    charset = "US-ASCII";
  }
  const encoding = base642 ? "base64" : "ascii";
  const data = unescape(uri.substring(firstComma + 1));
  const buffer = Buffer.from(data, encoding);
  buffer.type = type;
  buffer.typeFull = typeFull;
  buffer.charset = charset;
  return buffer;
}
async function* toIterator(parts, clone2 = true) {
  for (let part of parts) {
    if ("stream" in part) {
      yield* part.stream();
    } else if (ArrayBuffer.isView(part)) {
      if (clone2) {
        let position = part.byteOffset;
        let end = part.byteOffset + part.byteLength;
        while (position !== end) {
          const size = Math.min(end - position, POOL_SIZE);
          const chunk = part.buffer.slice(position, position + size);
          position += chunk.byteLength;
          yield new Uint8Array(chunk);
        }
      } else {
        yield part;
      }
    } else {
      let position = 0;
      while (position !== part.size) {
        const chunk = part.slice(position, Math.min(part.size, position + POOL_SIZE));
        const buffer = await chunk.arrayBuffer();
        position += buffer.byteLength;
        yield new Uint8Array(buffer);
      }
    }
  }
}
function isFormData(object) {
  return typeof object === "object" && typeof object.append === "function" && typeof object.set === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.delete === "function" && typeof object.keys === "function" && typeof object.values === "function" && typeof object.entries === "function" && typeof object.constructor === "function" && object[NAME] === "FormData";
}
function getHeader(boundary, name2, field) {
  let header = "";
  header += `${dashes}${boundary}${carriage}`;
  header += `Content-Disposition: form-data; name="${name2}"`;
  if (isBlob(field)) {
    header += `; filename="${field.name}"${carriage}`;
    header += `Content-Type: ${field.type || "application/octet-stream"}`;
  }
  return `${header}${carriage.repeat(2)}`;
}
async function* formDataIterator(form, boundary) {
  for (const [name2, value] of form) {
    yield getHeader(boundary, name2, value);
    if (isBlob(value)) {
      yield* value.stream();
    } else {
      yield value;
    }
    yield carriage;
  }
  yield getFooter(boundary);
}
function getFormDataLength(form, boundary) {
  let length = 0;
  for (const [name2, value] of form) {
    length += Buffer.byteLength(getHeader(boundary, name2, value));
    length += isBlob(value) ? value.size : Buffer.byteLength(String(value));
    length += carriageLength;
  }
  length += Buffer.byteLength(getFooter(boundary));
  return length;
}
async function consumeBody(data) {
  if (data[INTERNALS$2].disturbed) {
    throw new TypeError(`body used already for: ${data.url}`);
  }
  data[INTERNALS$2].disturbed = true;
  if (data[INTERNALS$2].error) {
    throw data[INTERNALS$2].error;
  }
  let { body } = data;
  if (body === null) {
    return Buffer.alloc(0);
  }
  if (isBlob(body)) {
    body = import_stream.default.Readable.from(body.stream());
  }
  if (Buffer.isBuffer(body)) {
    return body;
  }
  if (!(body instanceof import_stream.default)) {
    return Buffer.alloc(0);
  }
  const accum = [];
  let accumBytes = 0;
  try {
    for await (const chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
        const error2 = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
        body.destroy(error2);
        throw error2;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    }
  } catch (error2) {
    const error_ = error2 instanceof FetchBaseError ? error2 : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error2.message}`, "system", error2);
    throw error_;
  }
  if (body.readableEnded === true || body._readableState.ended === true) {
    try {
      if (accum.every((c) => typeof c === "string")) {
        return Buffer.from(accum.join(""));
      }
      return Buffer.concat(accum, accumBytes);
    } catch (error2) {
      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error2.message}`, "system", error2);
    }
  } else {
    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
  }
}
function fromRawHeaders(headers = []) {
  return new Headers(headers.reduce((result, value, index2, array) => {
    if (index2 % 2 === 0) {
      result.push(array.slice(index2, index2 + 2));
    }
    return result;
  }, []).filter(([name2, value]) => {
    try {
      validateHeaderName(name2);
      validateHeaderValue(name2, String(value));
      return true;
    } catch {
      return false;
    }
  }));
}
async function fetch(url, options_) {
  return new Promise((resolve2, reject) => {
    const request = new Request(url, options_);
    const options2 = getNodeRequestOptions(request);
    if (!supportedSchemas.has(options2.protocol)) {
      throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${options2.protocol.replace(/:$/, "")}" is not supported.`);
    }
    if (options2.protocol === "data:") {
      const data = dataUriToBuffer$1(request.url);
      const response2 = new Response(data, { headers: { "Content-Type": data.typeFull } });
      resolve2(response2);
      return;
    }
    const send = (options2.protocol === "https:" ? import_https.default : import_http.default).request;
    const { signal } = request;
    let response = null;
    const abort = () => {
      const error2 = new AbortError("The operation was aborted.");
      reject(error2);
      if (request.body && request.body instanceof import_stream.default.Readable) {
        request.body.destroy(error2);
      }
      if (!response || !response.body) {
        return;
      }
      response.body.emit("error", error2);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = () => {
      abort();
      finalize();
    };
    const request_ = send(options2);
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    const finalize = () => {
      request_.abort();
      if (signal) {
        signal.removeEventListener("abort", abortAndFinalize);
      }
    };
    request_.on("error", (error2) => {
      reject(new FetchError(`request to ${request.url} failed, reason: ${error2.message}`, "system", error2));
      finalize();
    });
    fixResponseChunkedTransferBadEnding(request_, (error2) => {
      response.body.destroy(error2);
    });
    if (process.version < "v14") {
      request_.on("socket", (s2) => {
        let endedWithEventsCount;
        s2.prependListener("end", () => {
          endedWithEventsCount = s2._eventsCount;
        });
        s2.prependListener("close", (hadError) => {
          if (response && endedWithEventsCount < s2._eventsCount && !hadError) {
            const error2 = new Error("Premature close");
            error2.code = "ERR_STREAM_PREMATURE_CLOSE";
            response.body.emit("error", error2);
          }
        });
      });
    }
    request_.on("response", (response_) => {
      request_.setTimeout(0);
      const headers = fromRawHeaders(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
        const location = headers.get("Location");
        const locationURL = location === null ? null : new URL(location, request.url);
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            if (locationURL !== null) {
              headers.set("Location", locationURL);
            }
            break;
          case "follow": {
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOptions = {
              headers: new Headers(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: request.body,
              signal: request.signal,
              size: request.size
            };
            if (response_.statusCode !== 303 && request.body && options_.body instanceof import_stream.default.Readable) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
              requestOptions.method = "GET";
              requestOptions.body = void 0;
              requestOptions.headers.delete("content-length");
            }
            resolve2(fetch(new Request(locationURL, requestOptions)));
            finalize();
            return;
          }
          default:
            return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
        }
      }
      if (signal) {
        response_.once("end", () => {
          signal.removeEventListener("abort", abortAndFinalize);
        });
      }
      let body = (0, import_stream.pipeline)(response_, new import_stream.PassThrough(), reject);
      if (process.version < "v12.10") {
        response_.on("aborted", abortAndFinalize);
      }
      const responseOptions = {
        url: request.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers,
        size: request.size,
        counter: request.counter,
        highWaterMark: request.highWaterMark
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new Response(body, responseOptions);
        resolve2(response);
        return;
      }
      const zlibOptions = {
        flush: import_zlib.default.Z_SYNC_FLUSH,
        finishFlush: import_zlib.default.Z_SYNC_FLUSH
      };
      if (codings === "gzip" || codings === "x-gzip") {
        body = (0, import_stream.pipeline)(body, import_zlib.default.createGunzip(zlibOptions), reject);
        response = new Response(body, responseOptions);
        resolve2(response);
        return;
      }
      if (codings === "deflate" || codings === "x-deflate") {
        const raw = (0, import_stream.pipeline)(response_, new import_stream.PassThrough(), reject);
        raw.once("data", (chunk) => {
          body = (chunk[0] & 15) === 8 ? (0, import_stream.pipeline)(body, import_zlib.default.createInflate(), reject) : (0, import_stream.pipeline)(body, import_zlib.default.createInflateRaw(), reject);
          response = new Response(body, responseOptions);
          resolve2(response);
        });
        return;
      }
      if (codings === "br") {
        body = (0, import_stream.pipeline)(body, import_zlib.default.createBrotliDecompress(), reject);
        response = new Response(body, responseOptions);
        resolve2(response);
        return;
      }
      response = new Response(body, responseOptions);
      resolve2(response);
    });
    writeToStream(request_, request);
  });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
  const LAST_CHUNK = Buffer.from("0\r\n\r\n");
  let isChunkedTransfer = false;
  let properLastChunkReceived = false;
  let previousChunk;
  request.on("response", (response) => {
    const { headers } = response;
    isChunkedTransfer = headers["transfer-encoding"] === "chunked" && !headers["content-length"];
  });
  request.on("socket", (socket) => {
    const onSocketClose = () => {
      if (isChunkedTransfer && !properLastChunkReceived) {
        const error2 = new Error("Premature close");
        error2.code = "ERR_STREAM_PREMATURE_CLOSE";
        errorCallback(error2);
      }
    };
    socket.prependListener("close", onSocketClose);
    request.on("abort", () => {
      socket.removeListener("close", onSocketClose);
    });
    socket.on("data", (buf) => {
      properLastChunkReceived = Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;
      if (!properLastChunkReceived && previousChunk) {
        properLastChunkReceived = Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0;
      }
      previousChunk = buf;
    });
  });
}
var import_http, import_https, import_zlib, import_stream, import_util, import_crypto, import_url, commonjsGlobal, src, dataUriToBuffer$1, ponyfill_es2018, POOL_SIZE$1, POOL_SIZE, _Blob, Blob2, Blob$1, FetchBaseError, FetchError, NAME, isURLSearchParameters, isBlob, isAbortSignal, carriage, dashes, carriageLength, getFooter, getBoundary, INTERNALS$2, Body, clone, extractContentType, getTotalBytes, writeToStream, validateHeaderName, validateHeaderValue, Headers, redirectStatus, isRedirect, INTERNALS$1, Response, getSearch, INTERNALS, isRequest, Request, getNodeRequestOptions, AbortError, supportedSchemas;
var init_install_fetch = __esm({
  "node_modules/@sveltejs/kit/dist/install-fetch.js"() {
    init_shims();
    import_http = __toModule(require("http"));
    import_https = __toModule(require("https"));
    import_zlib = __toModule(require("zlib"));
    import_stream = __toModule(require("stream"));
    import_util = __toModule(require("util"));
    import_crypto = __toModule(require("crypto"));
    import_url = __toModule(require("url"));
    commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    src = dataUriToBuffer;
    dataUriToBuffer$1 = src;
    ponyfill_es2018 = { exports: {} };
    (function(module2, exports2) {
      (function(global2, factory2) {
        factory2(exports2);
      })(commonjsGlobal, function(exports3) {
        const SymbolPolyfill = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol : (description) => `Symbol(${description})`;
        function noop2() {
          return void 0;
        }
        function getGlobals() {
          if (typeof self !== "undefined") {
            return self;
          } else if (typeof window !== "undefined") {
            return window;
          } else if (typeof commonjsGlobal !== "undefined") {
            return commonjsGlobal;
          }
          return void 0;
        }
        const globals = getGlobals();
        function typeIsObject(x) {
          return typeof x === "object" && x !== null || typeof x === "function";
        }
        const rethrowAssertionErrorRejection = noop2;
        const originalPromise = Promise;
        const originalPromiseThen = Promise.prototype.then;
        const originalPromiseResolve = Promise.resolve.bind(originalPromise);
        const originalPromiseReject = Promise.reject.bind(originalPromise);
        function newPromise(executor) {
          return new originalPromise(executor);
        }
        function promiseResolvedWith(value) {
          return originalPromiseResolve(value);
        }
        function promiseRejectedWith(reason) {
          return originalPromiseReject(reason);
        }
        function PerformPromiseThen(promise, onFulfilled, onRejected) {
          return originalPromiseThen.call(promise, onFulfilled, onRejected);
        }
        function uponPromise(promise, onFulfilled, onRejected) {
          PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), void 0, rethrowAssertionErrorRejection);
        }
        function uponFulfillment(promise, onFulfilled) {
          uponPromise(promise, onFulfilled);
        }
        function uponRejection(promise, onRejected) {
          uponPromise(promise, void 0, onRejected);
        }
        function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
          return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
        }
        function setPromiseIsHandledToTrue(promise) {
          PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
        }
        const queueMicrotask = (() => {
          const globalQueueMicrotask = globals && globals.queueMicrotask;
          if (typeof globalQueueMicrotask === "function") {
            return globalQueueMicrotask;
          }
          const resolvedPromise = promiseResolvedWith(void 0);
          return (fn) => PerformPromiseThen(resolvedPromise, fn);
        })();
        function reflectCall(F, V, args) {
          if (typeof F !== "function") {
            throw new TypeError("Argument is not a function");
          }
          return Function.prototype.apply.call(F, V, args);
        }
        function promiseCall(F, V, args) {
          try {
            return promiseResolvedWith(reflectCall(F, V, args));
          } catch (value) {
            return promiseRejectedWith(value);
          }
        }
        const QUEUE_MAX_ARRAY_SIZE = 16384;
        class SimpleQueue {
          constructor() {
            this._cursor = 0;
            this._size = 0;
            this._front = {
              _elements: [],
              _next: void 0
            };
            this._back = this._front;
            this._cursor = 0;
            this._size = 0;
          }
          get length() {
            return this._size;
          }
          push(element) {
            const oldBack = this._back;
            let newBack = oldBack;
            if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
              newBack = {
                _elements: [],
                _next: void 0
              };
            }
            oldBack._elements.push(element);
            if (newBack !== oldBack) {
              this._back = newBack;
              oldBack._next = newBack;
            }
            ++this._size;
          }
          shift() {
            const oldFront = this._front;
            let newFront = oldFront;
            const oldCursor = this._cursor;
            let newCursor = oldCursor + 1;
            const elements = oldFront._elements;
            const element = elements[oldCursor];
            if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
              newFront = oldFront._next;
              newCursor = 0;
            }
            --this._size;
            this._cursor = newCursor;
            if (oldFront !== newFront) {
              this._front = newFront;
            }
            elements[oldCursor] = void 0;
            return element;
          }
          forEach(callback) {
            let i = this._cursor;
            let node = this._front;
            let elements = node._elements;
            while (i !== elements.length || node._next !== void 0) {
              if (i === elements.length) {
                node = node._next;
                elements = node._elements;
                i = 0;
                if (elements.length === 0) {
                  break;
                }
              }
              callback(elements[i]);
              ++i;
            }
          }
          peek() {
            const front = this._front;
            const cursor = this._cursor;
            return front._elements[cursor];
          }
        }
        function ReadableStreamReaderGenericInitialize(reader, stream) {
          reader._ownerReadableStream = stream;
          stream._reader = reader;
          if (stream._state === "readable") {
            defaultReaderClosedPromiseInitialize(reader);
          } else if (stream._state === "closed") {
            defaultReaderClosedPromiseInitializeAsResolved(reader);
          } else {
            defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
          }
        }
        function ReadableStreamReaderGenericCancel(reader, reason) {
          const stream = reader._ownerReadableStream;
          return ReadableStreamCancel(stream, reason);
        }
        function ReadableStreamReaderGenericRelease(reader) {
          if (reader._ownerReadableStream._state === "readable") {
            defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
          } else {
            defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
          }
          reader._ownerReadableStream._reader = void 0;
          reader._ownerReadableStream = void 0;
        }
        function readerLockException(name2) {
          return new TypeError("Cannot " + name2 + " a stream using a released reader");
        }
        function defaultReaderClosedPromiseInitialize(reader) {
          reader._closedPromise = newPromise((resolve2, reject) => {
            reader._closedPromise_resolve = resolve2;
            reader._closedPromise_reject = reject;
          });
        }
        function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
          defaultReaderClosedPromiseInitialize(reader);
          defaultReaderClosedPromiseReject(reader, reason);
        }
        function defaultReaderClosedPromiseInitializeAsResolved(reader) {
          defaultReaderClosedPromiseInitialize(reader);
          defaultReaderClosedPromiseResolve(reader);
        }
        function defaultReaderClosedPromiseReject(reader, reason) {
          if (reader._closedPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(reader._closedPromise);
          reader._closedPromise_reject(reason);
          reader._closedPromise_resolve = void 0;
          reader._closedPromise_reject = void 0;
        }
        function defaultReaderClosedPromiseResetToRejected(reader, reason) {
          defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
        }
        function defaultReaderClosedPromiseResolve(reader) {
          if (reader._closedPromise_resolve === void 0) {
            return;
          }
          reader._closedPromise_resolve(void 0);
          reader._closedPromise_resolve = void 0;
          reader._closedPromise_reject = void 0;
        }
        const AbortSteps = SymbolPolyfill("[[AbortSteps]]");
        const ErrorSteps = SymbolPolyfill("[[ErrorSteps]]");
        const CancelSteps = SymbolPolyfill("[[CancelSteps]]");
        const PullSteps = SymbolPolyfill("[[PullSteps]]");
        const NumberIsFinite = Number.isFinite || function(x) {
          return typeof x === "number" && isFinite(x);
        };
        const MathTrunc = Math.trunc || function(v) {
          return v < 0 ? Math.ceil(v) : Math.floor(v);
        };
        function isDictionary(x) {
          return typeof x === "object" || typeof x === "function";
        }
        function assertDictionary(obj, context) {
          if (obj !== void 0 && !isDictionary(obj)) {
            throw new TypeError(`${context} is not an object.`);
          }
        }
        function assertFunction(x, context) {
          if (typeof x !== "function") {
            throw new TypeError(`${context} is not a function.`);
          }
        }
        function isObject2(x) {
          return typeof x === "object" && x !== null || typeof x === "function";
        }
        function assertObject(x, context) {
          if (!isObject2(x)) {
            throw new TypeError(`${context} is not an object.`);
          }
        }
        function assertRequiredArgument(x, position, context) {
          if (x === void 0) {
            throw new TypeError(`Parameter ${position} is required in '${context}'.`);
          }
        }
        function assertRequiredField(x, field, context) {
          if (x === void 0) {
            throw new TypeError(`${field} is required in '${context}'.`);
          }
        }
        function convertUnrestrictedDouble(value) {
          return Number(value);
        }
        function censorNegativeZero(x) {
          return x === 0 ? 0 : x;
        }
        function integerPart(x) {
          return censorNegativeZero(MathTrunc(x));
        }
        function convertUnsignedLongLongWithEnforceRange(value, context) {
          const lowerBound = 0;
          const upperBound = Number.MAX_SAFE_INTEGER;
          let x = Number(value);
          x = censorNegativeZero(x);
          if (!NumberIsFinite(x)) {
            throw new TypeError(`${context} is not a finite number`);
          }
          x = integerPart(x);
          if (x < lowerBound || x > upperBound) {
            throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);
          }
          if (!NumberIsFinite(x) || x === 0) {
            return 0;
          }
          return x;
        }
        function assertReadableStream(x, context) {
          if (!IsReadableStream(x)) {
            throw new TypeError(`${context} is not a ReadableStream.`);
          }
        }
        function AcquireReadableStreamDefaultReader(stream) {
          return new ReadableStreamDefaultReader(stream);
        }
        function ReadableStreamAddReadRequest(stream, readRequest) {
          stream._reader._readRequests.push(readRequest);
        }
        function ReadableStreamFulfillReadRequest(stream, chunk, done) {
          const reader = stream._reader;
          const readRequest = reader._readRequests.shift();
          if (done) {
            readRequest._closeSteps();
          } else {
            readRequest._chunkSteps(chunk);
          }
        }
        function ReadableStreamGetNumReadRequests(stream) {
          return stream._reader._readRequests.length;
        }
        function ReadableStreamHasDefaultReader(stream) {
          const reader = stream._reader;
          if (reader === void 0) {
            return false;
          }
          if (!IsReadableStreamDefaultReader(reader)) {
            return false;
          }
          return true;
        }
        class ReadableStreamDefaultReader {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
            assertReadableStream(stream, "First parameter");
            if (IsReadableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readRequests = new SimpleQueue();
          }
          get closed() {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          cancel(reason = void 0) {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("cancel"));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
          }
          read() {
            if (!IsReadableStreamDefaultReader(this)) {
              return promiseRejectedWith(defaultReaderBrandCheckException("read"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("read from"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve2, reject) => {
              resolvePromise = resolve2;
              rejectPromise = reject;
            });
            const readRequest = {
              _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
              _closeSteps: () => resolvePromise({ value: void 0, done: true }),
              _errorSteps: (e) => rejectPromise(e)
            };
            ReadableStreamDefaultReaderRead(this, readRequest);
            return promise;
          }
          releaseLock() {
            if (!IsReadableStreamDefaultReader(this)) {
              throw defaultReaderBrandCheckException("releaseLock");
            }
            if (this._ownerReadableStream === void 0) {
              return;
            }
            if (this._readRequests.length > 0) {
              throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            }
            ReadableStreamReaderGenericRelease(this);
          }
        }
        Object.defineProperties(ReadableStreamDefaultReader.prototype, {
          cancel: { enumerable: true },
          read: { enumerable: true },
          releaseLock: { enumerable: true },
          closed: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamDefaultReader",
            configurable: true
          });
        }
        function IsReadableStreamDefaultReader(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_readRequests")) {
            return false;
          }
          return x instanceof ReadableStreamDefaultReader;
        }
        function ReadableStreamDefaultReaderRead(reader, readRequest) {
          const stream = reader._ownerReadableStream;
          stream._disturbed = true;
          if (stream._state === "closed") {
            readRequest._closeSteps();
          } else if (stream._state === "errored") {
            readRequest._errorSteps(stream._storedError);
          } else {
            stream._readableStreamController[PullSteps](readRequest);
          }
        }
        function defaultReaderBrandCheckException(name2) {
          return new TypeError(`ReadableStreamDefaultReader.prototype.${name2} can only be used on a ReadableStreamDefaultReader`);
        }
        const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
        }).prototype);
        class ReadableStreamAsyncIteratorImpl {
          constructor(reader, preventCancel) {
            this._ongoingPromise = void 0;
            this._isFinished = false;
            this._reader = reader;
            this._preventCancel = preventCancel;
          }
          next() {
            const nextSteps = () => this._nextSteps();
            this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
            return this._ongoingPromise;
          }
          return(value) {
            const returnSteps = () => this._returnSteps(value);
            return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
          }
          _nextSteps() {
            if (this._isFinished) {
              return Promise.resolve({ value: void 0, done: true });
            }
            const reader = this._reader;
            if (reader._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("iterate"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve2, reject) => {
              resolvePromise = resolve2;
              rejectPromise = reject;
            });
            const readRequest = {
              _chunkSteps: (chunk) => {
                this._ongoingPromise = void 0;
                queueMicrotask(() => resolvePromise({ value: chunk, done: false }));
              },
              _closeSteps: () => {
                this._ongoingPromise = void 0;
                this._isFinished = true;
                ReadableStreamReaderGenericRelease(reader);
                resolvePromise({ value: void 0, done: true });
              },
              _errorSteps: (reason) => {
                this._ongoingPromise = void 0;
                this._isFinished = true;
                ReadableStreamReaderGenericRelease(reader);
                rejectPromise(reason);
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promise;
          }
          _returnSteps(value) {
            if (this._isFinished) {
              return Promise.resolve({ value, done: true });
            }
            this._isFinished = true;
            const reader = this._reader;
            if (reader._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("finish iterating"));
            }
            if (!this._preventCancel) {
              const result = ReadableStreamReaderGenericCancel(reader, value);
              ReadableStreamReaderGenericRelease(reader);
              return transformPromiseWith(result, () => ({ value, done: true }));
            }
            ReadableStreamReaderGenericRelease(reader);
            return promiseResolvedWith({ value, done: true });
          }
        }
        const ReadableStreamAsyncIteratorPrototype = {
          next() {
            if (!IsReadableStreamAsyncIterator(this)) {
              return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
            }
            return this._asyncIteratorImpl.next();
          },
          return(value) {
            if (!IsReadableStreamAsyncIterator(this)) {
              return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
            }
            return this._asyncIteratorImpl.return(value);
          }
        };
        if (AsyncIteratorPrototype !== void 0) {
          Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
        }
        function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
          const reader = AcquireReadableStreamDefaultReader(stream);
          const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
          const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
          iterator._asyncIteratorImpl = impl;
          return iterator;
        }
        function IsReadableStreamAsyncIterator(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_asyncIteratorImpl")) {
            return false;
          }
          try {
            return x._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
          } catch (_a) {
            return false;
          }
        }
        function streamAsyncIteratorBrandCheckException(name2) {
          return new TypeError(`ReadableStreamAsyncIterator.${name2} can only be used on a ReadableSteamAsyncIterator`);
        }
        const NumberIsNaN = Number.isNaN || function(x) {
          return x !== x;
        };
        function CreateArrayFromList(elements) {
          return elements.slice();
        }
        function CopyDataBlockBytes(dest, destOffset, src2, srcOffset, n) {
          new Uint8Array(dest).set(new Uint8Array(src2, srcOffset, n), destOffset);
        }
        function TransferArrayBuffer(O) {
          return O;
        }
        function IsDetachedBuffer(O) {
          return false;
        }
        function ArrayBufferSlice(buffer, begin, end) {
          if (buffer.slice) {
            return buffer.slice(begin, end);
          }
          const length = end - begin;
          const slice = new ArrayBuffer(length);
          CopyDataBlockBytes(slice, 0, buffer, begin, length);
          return slice;
        }
        function IsNonNegativeNumber(v) {
          if (typeof v !== "number") {
            return false;
          }
          if (NumberIsNaN(v)) {
            return false;
          }
          if (v < 0) {
            return false;
          }
          return true;
        }
        function CloneAsUint8Array(O) {
          const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
          return new Uint8Array(buffer);
        }
        function DequeueValue(container) {
          const pair = container._queue.shift();
          container._queueTotalSize -= pair.size;
          if (container._queueTotalSize < 0) {
            container._queueTotalSize = 0;
          }
          return pair.value;
        }
        function EnqueueValueWithSize(container, value, size) {
          if (!IsNonNegativeNumber(size) || size === Infinity) {
            throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
          }
          container._queue.push({ value, size });
          container._queueTotalSize += size;
        }
        function PeekQueueValue(container) {
          const pair = container._queue.peek();
          return pair.value;
        }
        function ResetQueue(container) {
          container._queue = new SimpleQueue();
          container._queueTotalSize = 0;
        }
        class ReadableStreamBYOBRequest {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get view() {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("view");
            }
            return this._view;
          }
          respond(bytesWritten) {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("respond");
            }
            assertRequiredArgument(bytesWritten, 1, "respond");
            bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
            if (this._associatedReadableByteStreamController === void 0) {
              throw new TypeError("This BYOB request has been invalidated");
            }
            if (IsDetachedBuffer(this._view.buffer))
              ;
            ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
          }
          respondWithNewView(view) {
            if (!IsReadableStreamBYOBRequest(this)) {
              throw byobRequestBrandCheckException("respondWithNewView");
            }
            assertRequiredArgument(view, 1, "respondWithNewView");
            if (!ArrayBuffer.isView(view)) {
              throw new TypeError("You can only respond with array buffer views");
            }
            if (this._associatedReadableByteStreamController === void 0) {
              throw new TypeError("This BYOB request has been invalidated");
            }
            if (IsDetachedBuffer(view.buffer))
              ;
            ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
          }
        }
        Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
          respond: { enumerable: true },
          respondWithNewView: { enumerable: true },
          view: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamBYOBRequest",
            configurable: true
          });
        }
        class ReadableByteStreamController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get byobRequest() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("byobRequest");
            }
            return ReadableByteStreamControllerGetBYOBRequest(this);
          }
          get desiredSize() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("desiredSize");
            }
            return ReadableByteStreamControllerGetDesiredSize(this);
          }
          close() {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("close");
            }
            if (this._closeRequested) {
              throw new TypeError("The stream has already been closed; do not close it again!");
            }
            const state = this._controlledReadableByteStream._state;
            if (state !== "readable") {
              throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
            }
            ReadableByteStreamControllerClose(this);
          }
          enqueue(chunk) {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("enqueue");
            }
            assertRequiredArgument(chunk, 1, "enqueue");
            if (!ArrayBuffer.isView(chunk)) {
              throw new TypeError("chunk must be an array buffer view");
            }
            if (chunk.byteLength === 0) {
              throw new TypeError("chunk must have non-zero byteLength");
            }
            if (chunk.buffer.byteLength === 0) {
              throw new TypeError(`chunk's buffer must have non-zero byteLength`);
            }
            if (this._closeRequested) {
              throw new TypeError("stream is closed or draining");
            }
            const state = this._controlledReadableByteStream._state;
            if (state !== "readable") {
              throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
            }
            ReadableByteStreamControllerEnqueue(this, chunk);
          }
          error(e = void 0) {
            if (!IsReadableByteStreamController(this)) {
              throw byteStreamControllerBrandCheckException("error");
            }
            ReadableByteStreamControllerError(this, e);
          }
          [CancelSteps](reason) {
            ReadableByteStreamControllerClearPendingPullIntos(this);
            ResetQueue(this);
            const result = this._cancelAlgorithm(reason);
            ReadableByteStreamControllerClearAlgorithms(this);
            return result;
          }
          [PullSteps](readRequest) {
            const stream = this._controlledReadableByteStream;
            if (this._queueTotalSize > 0) {
              const entry = this._queue.shift();
              this._queueTotalSize -= entry.byteLength;
              ReadableByteStreamControllerHandleQueueDrain(this);
              const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
              readRequest._chunkSteps(view);
              return;
            }
            const autoAllocateChunkSize = this._autoAllocateChunkSize;
            if (autoAllocateChunkSize !== void 0) {
              let buffer;
              try {
                buffer = new ArrayBuffer(autoAllocateChunkSize);
              } catch (bufferE) {
                readRequest._errorSteps(bufferE);
                return;
              }
              const pullIntoDescriptor = {
                buffer,
                bufferByteLength: autoAllocateChunkSize,
                byteOffset: 0,
                byteLength: autoAllocateChunkSize,
                bytesFilled: 0,
                elementSize: 1,
                viewConstructor: Uint8Array,
                readerType: "default"
              };
              this._pendingPullIntos.push(pullIntoDescriptor);
            }
            ReadableStreamAddReadRequest(stream, readRequest);
            ReadableByteStreamControllerCallPullIfNeeded(this);
          }
        }
        Object.defineProperties(ReadableByteStreamController.prototype, {
          close: { enumerable: true },
          enqueue: { enumerable: true },
          error: { enumerable: true },
          byobRequest: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableByteStreamController",
            configurable: true
          });
        }
        function IsReadableByteStreamController(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableByteStream")) {
            return false;
          }
          return x instanceof ReadableByteStreamController;
        }
        function IsReadableStreamBYOBRequest(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_associatedReadableByteStreamController")) {
            return false;
          }
          return x instanceof ReadableStreamBYOBRequest;
        }
        function ReadableByteStreamControllerCallPullIfNeeded(controller) {
          const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
          if (!shouldPull) {
            return;
          }
          if (controller._pulling) {
            controller._pullAgain = true;
            return;
          }
          controller._pulling = true;
          const pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, () => {
            controller._pulling = false;
            if (controller._pullAgain) {
              controller._pullAgain = false;
              ReadableByteStreamControllerCallPullIfNeeded(controller);
            }
          }, (e) => {
            ReadableByteStreamControllerError(controller, e);
          });
        }
        function ReadableByteStreamControllerClearPendingPullIntos(controller) {
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          controller._pendingPullIntos = new SimpleQueue();
        }
        function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
          let done = false;
          if (stream._state === "closed") {
            done = true;
          }
          const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
          if (pullIntoDescriptor.readerType === "default") {
            ReadableStreamFulfillReadRequest(stream, filledView, done);
          } else {
            ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
          }
        }
        function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
          const bytesFilled = pullIntoDescriptor.bytesFilled;
          const elementSize = pullIntoDescriptor.elementSize;
          return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
        }
        function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
          controller._queue.push({ buffer, byteOffset, byteLength });
          controller._queueTotalSize += byteLength;
        }
        function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
          const elementSize = pullIntoDescriptor.elementSize;
          const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
          const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
          const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
          const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
          let totalBytesToCopyRemaining = maxBytesToCopy;
          let ready = false;
          if (maxAlignedBytes > currentAlignedBytes) {
            totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
            ready = true;
          }
          const queue = controller._queue;
          while (totalBytesToCopyRemaining > 0) {
            const headOfQueue = queue.peek();
            const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
            const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
            if (headOfQueue.byteLength === bytesToCopy) {
              queue.shift();
            } else {
              headOfQueue.byteOffset += bytesToCopy;
              headOfQueue.byteLength -= bytesToCopy;
            }
            controller._queueTotalSize -= bytesToCopy;
            ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
            totalBytesToCopyRemaining -= bytesToCopy;
          }
          return ready;
        }
        function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
          pullIntoDescriptor.bytesFilled += size;
        }
        function ReadableByteStreamControllerHandleQueueDrain(controller) {
          if (controller._queueTotalSize === 0 && controller._closeRequested) {
            ReadableByteStreamControllerClearAlgorithms(controller);
            ReadableStreamClose(controller._controlledReadableByteStream);
          } else {
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }
        }
        function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
          if (controller._byobRequest === null) {
            return;
          }
          controller._byobRequest._associatedReadableByteStreamController = void 0;
          controller._byobRequest._view = null;
          controller._byobRequest = null;
        }
        function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
          while (controller._pendingPullIntos.length > 0) {
            if (controller._queueTotalSize === 0) {
              return;
            }
            const pullIntoDescriptor = controller._pendingPullIntos.peek();
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
              ReadableByteStreamControllerShiftPendingPullInto(controller);
              ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
            }
          }
        }
        function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
          const stream = controller._controlledReadableByteStream;
          let elementSize = 1;
          if (view.constructor !== DataView) {
            elementSize = view.constructor.BYTES_PER_ELEMENT;
          }
          const ctor = view.constructor;
          const buffer = TransferArrayBuffer(view.buffer);
          const pullIntoDescriptor = {
            buffer,
            bufferByteLength: buffer.byteLength,
            byteOffset: view.byteOffset,
            byteLength: view.byteLength,
            bytesFilled: 0,
            elementSize,
            viewConstructor: ctor,
            readerType: "byob"
          };
          if (controller._pendingPullIntos.length > 0) {
            controller._pendingPullIntos.push(pullIntoDescriptor);
            ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
            return;
          }
          if (stream._state === "closed") {
            const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
            readIntoRequest._closeSteps(emptyView);
            return;
          }
          if (controller._queueTotalSize > 0) {
            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
              const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
              ReadableByteStreamControllerHandleQueueDrain(controller);
              readIntoRequest._chunkSteps(filledView);
              return;
            }
            if (controller._closeRequested) {
              const e = new TypeError("Insufficient bytes to fill elements in the given buffer");
              ReadableByteStreamControllerError(controller, e);
              readIntoRequest._errorSteps(e);
              return;
            }
          }
          controller._pendingPullIntos.push(pullIntoDescriptor);
          ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
          const stream = controller._controlledReadableByteStream;
          if (ReadableStreamHasBYOBReader(stream)) {
            while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
              const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
              ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
            }
          }
        }
        function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
          ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
          if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
            return;
          }
          ReadableByteStreamControllerShiftPendingPullInto(controller);
          const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
          if (remainderSize > 0) {
            const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
            const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
          }
          pullIntoDescriptor.bytesFilled -= remainderSize;
          ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
          ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        }
        function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            ReadableByteStreamControllerRespondInClosedState(controller);
          } else {
            ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
          }
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerShiftPendingPullInto(controller) {
          const descriptor = controller._pendingPullIntos.shift();
          return descriptor;
        }
        function ReadableByteStreamControllerShouldCallPull(controller) {
          const stream = controller._controlledReadableByteStream;
          if (stream._state !== "readable") {
            return false;
          }
          if (controller._closeRequested) {
            return false;
          }
          if (!controller._started) {
            return false;
          }
          if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
          }
          if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
            return true;
          }
          const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
          if (desiredSize > 0) {
            return true;
          }
          return false;
        }
        function ReadableByteStreamControllerClearAlgorithms(controller) {
          controller._pullAlgorithm = void 0;
          controller._cancelAlgorithm = void 0;
        }
        function ReadableByteStreamControllerClose(controller) {
          const stream = controller._controlledReadableByteStream;
          if (controller._closeRequested || stream._state !== "readable") {
            return;
          }
          if (controller._queueTotalSize > 0) {
            controller._closeRequested = true;
            return;
          }
          if (controller._pendingPullIntos.length > 0) {
            const firstPendingPullInto = controller._pendingPullIntos.peek();
            if (firstPendingPullInto.bytesFilled > 0) {
              const e = new TypeError("Insufficient bytes to fill elements in the given buffer");
              ReadableByteStreamControllerError(controller, e);
              throw e;
            }
          }
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamClose(stream);
        }
        function ReadableByteStreamControllerEnqueue(controller, chunk) {
          const stream = controller._controlledReadableByteStream;
          if (controller._closeRequested || stream._state !== "readable") {
            return;
          }
          const buffer = chunk.buffer;
          const byteOffset = chunk.byteOffset;
          const byteLength = chunk.byteLength;
          const transferredBuffer = TransferArrayBuffer(buffer);
          if (controller._pendingPullIntos.length > 0) {
            const firstPendingPullInto = controller._pendingPullIntos.peek();
            if (IsDetachedBuffer(firstPendingPullInto.buffer))
              ;
            firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
          }
          ReadableByteStreamControllerInvalidateBYOBRequest(controller);
          if (ReadableStreamHasDefaultReader(stream)) {
            if (ReadableStreamGetNumReadRequests(stream) === 0) {
              ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            } else {
              const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
              ReadableStreamFulfillReadRequest(stream, transferredView, false);
            }
          } else if (ReadableStreamHasBYOBReader(stream)) {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
            ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
          } else {
            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
          }
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        function ReadableByteStreamControllerError(controller, e) {
          const stream = controller._controlledReadableByteStream;
          if (stream._state !== "readable") {
            return;
          }
          ReadableByteStreamControllerClearPendingPullIntos(controller);
          ResetQueue(controller);
          ReadableByteStreamControllerClearAlgorithms(controller);
          ReadableStreamError(stream, e);
        }
        function ReadableByteStreamControllerGetBYOBRequest(controller) {
          if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
            const firstDescriptor = controller._pendingPullIntos.peek();
            const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
            const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
            SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
            controller._byobRequest = byobRequest;
          }
          return controller._byobRequest;
        }
        function ReadableByteStreamControllerGetDesiredSize(controller) {
          const state = controller._controlledReadableByteStream._state;
          if (state === "errored") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function ReadableByteStreamControllerRespond(controller, bytesWritten) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            if (bytesWritten !== 0) {
              throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
            }
          } else {
            if (bytesWritten === 0) {
              throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
            }
            if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
              throw new RangeError("bytesWritten out of range");
            }
          }
          firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
          ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
        }
        function ReadableByteStreamControllerRespondWithNewView(controller, view) {
          const firstDescriptor = controller._pendingPullIntos.peek();
          const state = controller._controlledReadableByteStream._state;
          if (state === "closed") {
            if (view.byteLength !== 0) {
              throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
            }
          } else {
            if (view.byteLength === 0) {
              throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
            }
          }
          if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
            throw new RangeError("The region specified by view does not match byobRequest");
          }
          if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
            throw new RangeError("The buffer of view has different capacity than byobRequest");
          }
          if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
            throw new RangeError("The region specified by view is larger than byobRequest");
          }
          firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
          ReadableByteStreamControllerRespondInternal(controller, view.byteLength);
        }
        function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
          controller._controlledReadableByteStream = stream;
          controller._pullAgain = false;
          controller._pulling = false;
          controller._byobRequest = null;
          controller._queue = controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._closeRequested = false;
          controller._started = false;
          controller._strategyHWM = highWaterMark;
          controller._pullAlgorithm = pullAlgorithm;
          controller._cancelAlgorithm = cancelAlgorithm;
          controller._autoAllocateChunkSize = autoAllocateChunkSize;
          controller._pendingPullIntos = new SimpleQueue();
          stream._readableStreamController = controller;
          const startResult = startAlgorithm();
          uponPromise(promiseResolvedWith(startResult), () => {
            controller._started = true;
            ReadableByteStreamControllerCallPullIfNeeded(controller);
          }, (r) => {
            ReadableByteStreamControllerError(controller, r);
          });
        }
        function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
          const controller = Object.create(ReadableByteStreamController.prototype);
          let startAlgorithm = () => void 0;
          let pullAlgorithm = () => promiseResolvedWith(void 0);
          let cancelAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingByteSource.start !== void 0) {
            startAlgorithm = () => underlyingByteSource.start(controller);
          }
          if (underlyingByteSource.pull !== void 0) {
            pullAlgorithm = () => underlyingByteSource.pull(controller);
          }
          if (underlyingByteSource.cancel !== void 0) {
            cancelAlgorithm = (reason) => underlyingByteSource.cancel(reason);
          }
          const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
          if (autoAllocateChunkSize === 0) {
            throw new TypeError("autoAllocateChunkSize must be greater than 0");
          }
          SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
        }
        function SetUpReadableStreamBYOBRequest(request, controller, view) {
          request._associatedReadableByteStreamController = controller;
          request._view = view;
        }
        function byobRequestBrandCheckException(name2) {
          return new TypeError(`ReadableStreamBYOBRequest.prototype.${name2} can only be used on a ReadableStreamBYOBRequest`);
        }
        function byteStreamControllerBrandCheckException(name2) {
          return new TypeError(`ReadableByteStreamController.prototype.${name2} can only be used on a ReadableByteStreamController`);
        }
        function AcquireReadableStreamBYOBReader(stream) {
          return new ReadableStreamBYOBReader(stream);
        }
        function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
          stream._reader._readIntoRequests.push(readIntoRequest);
        }
        function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
          const reader = stream._reader;
          const readIntoRequest = reader._readIntoRequests.shift();
          if (done) {
            readIntoRequest._closeSteps(chunk);
          } else {
            readIntoRequest._chunkSteps(chunk);
          }
        }
        function ReadableStreamGetNumReadIntoRequests(stream) {
          return stream._reader._readIntoRequests.length;
        }
        function ReadableStreamHasBYOBReader(stream) {
          const reader = stream._reader;
          if (reader === void 0) {
            return false;
          }
          if (!IsReadableStreamBYOBReader(reader)) {
            return false;
          }
          return true;
        }
        class ReadableStreamBYOBReader {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
            assertReadableStream(stream, "First parameter");
            if (IsReadableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive reading by another reader");
            }
            if (!IsReadableByteStreamController(stream._readableStreamController)) {
              throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
            }
            ReadableStreamReaderGenericInitialize(this, stream);
            this._readIntoRequests = new SimpleQueue();
          }
          get closed() {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          cancel(reason = void 0) {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
            }
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("cancel"));
            }
            return ReadableStreamReaderGenericCancel(this, reason);
          }
          read(view) {
            if (!IsReadableStreamBYOBReader(this)) {
              return promiseRejectedWith(byobReaderBrandCheckException("read"));
            }
            if (!ArrayBuffer.isView(view)) {
              return promiseRejectedWith(new TypeError("view must be an array buffer view"));
            }
            if (view.byteLength === 0) {
              return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
            }
            if (view.buffer.byteLength === 0) {
              return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));
            }
            if (IsDetachedBuffer(view.buffer))
              ;
            if (this._ownerReadableStream === void 0) {
              return promiseRejectedWith(readerLockException("read from"));
            }
            let resolvePromise;
            let rejectPromise;
            const promise = newPromise((resolve2, reject) => {
              resolvePromise = resolve2;
              rejectPromise = reject;
            });
            const readIntoRequest = {
              _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
              _closeSteps: (chunk) => resolvePromise({ value: chunk, done: true }),
              _errorSteps: (e) => rejectPromise(e)
            };
            ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
            return promise;
          }
          releaseLock() {
            if (!IsReadableStreamBYOBReader(this)) {
              throw byobReaderBrandCheckException("releaseLock");
            }
            if (this._ownerReadableStream === void 0) {
              return;
            }
            if (this._readIntoRequests.length > 0) {
              throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
            }
            ReadableStreamReaderGenericRelease(this);
          }
        }
        Object.defineProperties(ReadableStreamBYOBReader.prototype, {
          cancel: { enumerable: true },
          read: { enumerable: true },
          releaseLock: { enumerable: true },
          closed: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamBYOBReader",
            configurable: true
          });
        }
        function IsReadableStreamBYOBReader(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_readIntoRequests")) {
            return false;
          }
          return x instanceof ReadableStreamBYOBReader;
        }
        function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
          const stream = reader._ownerReadableStream;
          stream._disturbed = true;
          if (stream._state === "errored") {
            readIntoRequest._errorSteps(stream._storedError);
          } else {
            ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
          }
        }
        function byobReaderBrandCheckException(name2) {
          return new TypeError(`ReadableStreamBYOBReader.prototype.${name2} can only be used on a ReadableStreamBYOBReader`);
        }
        function ExtractHighWaterMark(strategy, defaultHWM) {
          const { highWaterMark } = strategy;
          if (highWaterMark === void 0) {
            return defaultHWM;
          }
          if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
            throw new RangeError("Invalid highWaterMark");
          }
          return highWaterMark;
        }
        function ExtractSizeAlgorithm(strategy) {
          const { size } = strategy;
          if (!size) {
            return () => 1;
          }
          return size;
        }
        function convertQueuingStrategy(init2, context) {
          assertDictionary(init2, context);
          const highWaterMark = init2 === null || init2 === void 0 ? void 0 : init2.highWaterMark;
          const size = init2 === null || init2 === void 0 ? void 0 : init2.size;
          return {
            highWaterMark: highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
            size: size === void 0 ? void 0 : convertQueuingStrategySize(size, `${context} has member 'size' that`)
          };
        }
        function convertQueuingStrategySize(fn, context) {
          assertFunction(fn, context);
          return (chunk) => convertUnrestrictedDouble(fn(chunk));
        }
        function convertUnderlyingSink(original, context) {
          assertDictionary(original, context);
          const abort = original === null || original === void 0 ? void 0 : original.abort;
          const close = original === null || original === void 0 ? void 0 : original.close;
          const start2 = original === null || original === void 0 ? void 0 : original.start;
          const type = original === null || original === void 0 ? void 0 : original.type;
          const write = original === null || original === void 0 ? void 0 : original.write;
          return {
            abort: abort === void 0 ? void 0 : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),
            close: close === void 0 ? void 0 : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),
            start: start2 === void 0 ? void 0 : convertUnderlyingSinkStartCallback(start2, original, `${context} has member 'start' that`),
            write: write === void 0 ? void 0 : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),
            type
          };
        }
        function convertUnderlyingSinkAbortCallback(fn, original, context) {
          assertFunction(fn, context);
          return (reason) => promiseCall(fn, original, [reason]);
        }
        function convertUnderlyingSinkCloseCallback(fn, original, context) {
          assertFunction(fn, context);
          return () => promiseCall(fn, original, []);
        }
        function convertUnderlyingSinkStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => reflectCall(fn, original, [controller]);
        }
        function convertUnderlyingSinkWriteCallback(fn, original, context) {
          assertFunction(fn, context);
          return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
        }
        function assertWritableStream(x, context) {
          if (!IsWritableStream(x)) {
            throw new TypeError(`${context} is not a WritableStream.`);
          }
        }
        function isAbortSignal2(value) {
          if (typeof value !== "object" || value === null) {
            return false;
          }
          try {
            return typeof value.aborted === "boolean";
          } catch (_a) {
            return false;
          }
        }
        const supportsAbortController = typeof AbortController === "function";
        function createAbortController() {
          if (supportsAbortController) {
            return new AbortController();
          }
          return void 0;
        }
        class WritableStream {
          constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
            if (rawUnderlyingSink === void 0) {
              rawUnderlyingSink = null;
            } else {
              assertObject(rawUnderlyingSink, "First parameter");
            }
            const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
            const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
            InitializeWritableStream(this);
            const type = underlyingSink.type;
            if (type !== void 0) {
              throw new RangeError("Invalid type is specified");
            }
            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
            const highWaterMark = ExtractHighWaterMark(strategy, 1);
            SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
          }
          get locked() {
            if (!IsWritableStream(this)) {
              throw streamBrandCheckException$2("locked");
            }
            return IsWritableStreamLocked(this);
          }
          abort(reason = void 0) {
            if (!IsWritableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$2("abort"));
            }
            if (IsWritableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
            }
            return WritableStreamAbort(this, reason);
          }
          close() {
            if (!IsWritableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$2("close"));
            }
            if (IsWritableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
            }
            if (WritableStreamCloseQueuedOrInFlight(this)) {
              return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
            }
            return WritableStreamClose(this);
          }
          getWriter() {
            if (!IsWritableStream(this)) {
              throw streamBrandCheckException$2("getWriter");
            }
            return AcquireWritableStreamDefaultWriter(this);
          }
        }
        Object.defineProperties(WritableStream.prototype, {
          abort: { enumerable: true },
          close: { enumerable: true },
          getWriter: { enumerable: true },
          locked: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStream",
            configurable: true
          });
        }
        function AcquireWritableStreamDefaultWriter(stream) {
          return new WritableStreamDefaultWriter(stream);
        }
        function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
          const stream = Object.create(WritableStream.prototype);
          InitializeWritableStream(stream);
          const controller = Object.create(WritableStreamDefaultController.prototype);
          SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
          return stream;
        }
        function InitializeWritableStream(stream) {
          stream._state = "writable";
          stream._storedError = void 0;
          stream._writer = void 0;
          stream._writableStreamController = void 0;
          stream._writeRequests = new SimpleQueue();
          stream._inFlightWriteRequest = void 0;
          stream._closeRequest = void 0;
          stream._inFlightCloseRequest = void 0;
          stream._pendingAbortRequest = void 0;
          stream._backpressure = false;
        }
        function IsWritableStream(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_writableStreamController")) {
            return false;
          }
          return x instanceof WritableStream;
        }
        function IsWritableStreamLocked(stream) {
          if (stream._writer === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamAbort(stream, reason) {
          var _a;
          if (stream._state === "closed" || stream._state === "errored") {
            return promiseResolvedWith(void 0);
          }
          stream._writableStreamController._abortReason = reason;
          (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort();
          const state = stream._state;
          if (state === "closed" || state === "errored") {
            return promiseResolvedWith(void 0);
          }
          if (stream._pendingAbortRequest !== void 0) {
            return stream._pendingAbortRequest._promise;
          }
          let wasAlreadyErroring = false;
          if (state === "erroring") {
            wasAlreadyErroring = true;
            reason = void 0;
          }
          const promise = newPromise((resolve2, reject) => {
            stream._pendingAbortRequest = {
              _promise: void 0,
              _resolve: resolve2,
              _reject: reject,
              _reason: reason,
              _wasAlreadyErroring: wasAlreadyErroring
            };
          });
          stream._pendingAbortRequest._promise = promise;
          if (!wasAlreadyErroring) {
            WritableStreamStartErroring(stream, reason);
          }
          return promise;
        }
        function WritableStreamClose(stream) {
          const state = stream._state;
          if (state === "closed" || state === "errored") {
            return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
          }
          const promise = newPromise((resolve2, reject) => {
            const closeRequest = {
              _resolve: resolve2,
              _reject: reject
            };
            stream._closeRequest = closeRequest;
          });
          const writer = stream._writer;
          if (writer !== void 0 && stream._backpressure && state === "writable") {
            defaultWriterReadyPromiseResolve(writer);
          }
          WritableStreamDefaultControllerClose(stream._writableStreamController);
          return promise;
        }
        function WritableStreamAddWriteRequest(stream) {
          const promise = newPromise((resolve2, reject) => {
            const writeRequest = {
              _resolve: resolve2,
              _reject: reject
            };
            stream._writeRequests.push(writeRequest);
          });
          return promise;
        }
        function WritableStreamDealWithRejection(stream, error2) {
          const state = stream._state;
          if (state === "writable") {
            WritableStreamStartErroring(stream, error2);
            return;
          }
          WritableStreamFinishErroring(stream);
        }
        function WritableStreamStartErroring(stream, reason) {
          const controller = stream._writableStreamController;
          stream._state = "erroring";
          stream._storedError = reason;
          const writer = stream._writer;
          if (writer !== void 0) {
            WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
          }
          if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
            WritableStreamFinishErroring(stream);
          }
        }
        function WritableStreamFinishErroring(stream) {
          stream._state = "errored";
          stream._writableStreamController[ErrorSteps]();
          const storedError = stream._storedError;
          stream._writeRequests.forEach((writeRequest) => {
            writeRequest._reject(storedError);
          });
          stream._writeRequests = new SimpleQueue();
          if (stream._pendingAbortRequest === void 0) {
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
          }
          const abortRequest = stream._pendingAbortRequest;
          stream._pendingAbortRequest = void 0;
          if (abortRequest._wasAlreadyErroring) {
            abortRequest._reject(storedError);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
            return;
          }
          const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
          uponPromise(promise, () => {
            abortRequest._resolve();
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          }, (reason) => {
            abortRequest._reject(reason);
            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
          });
        }
        function WritableStreamFinishInFlightWrite(stream) {
          stream._inFlightWriteRequest._resolve(void 0);
          stream._inFlightWriteRequest = void 0;
        }
        function WritableStreamFinishInFlightWriteWithError(stream, error2) {
          stream._inFlightWriteRequest._reject(error2);
          stream._inFlightWriteRequest = void 0;
          WritableStreamDealWithRejection(stream, error2);
        }
        function WritableStreamFinishInFlightClose(stream) {
          stream._inFlightCloseRequest._resolve(void 0);
          stream._inFlightCloseRequest = void 0;
          const state = stream._state;
          if (state === "erroring") {
            stream._storedError = void 0;
            if (stream._pendingAbortRequest !== void 0) {
              stream._pendingAbortRequest._resolve();
              stream._pendingAbortRequest = void 0;
            }
          }
          stream._state = "closed";
          const writer = stream._writer;
          if (writer !== void 0) {
            defaultWriterClosedPromiseResolve(writer);
          }
        }
        function WritableStreamFinishInFlightCloseWithError(stream, error2) {
          stream._inFlightCloseRequest._reject(error2);
          stream._inFlightCloseRequest = void 0;
          if (stream._pendingAbortRequest !== void 0) {
            stream._pendingAbortRequest._reject(error2);
            stream._pendingAbortRequest = void 0;
          }
          WritableStreamDealWithRejection(stream, error2);
        }
        function WritableStreamCloseQueuedOrInFlight(stream) {
          if (stream._closeRequest === void 0 && stream._inFlightCloseRequest === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamHasOperationMarkedInFlight(stream) {
          if (stream._inFlightWriteRequest === void 0 && stream._inFlightCloseRequest === void 0) {
            return false;
          }
          return true;
        }
        function WritableStreamMarkCloseRequestInFlight(stream) {
          stream._inFlightCloseRequest = stream._closeRequest;
          stream._closeRequest = void 0;
        }
        function WritableStreamMarkFirstWriteRequestInFlight(stream) {
          stream._inFlightWriteRequest = stream._writeRequests.shift();
        }
        function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
          if (stream._closeRequest !== void 0) {
            stream._closeRequest._reject(stream._storedError);
            stream._closeRequest = void 0;
          }
          const writer = stream._writer;
          if (writer !== void 0) {
            defaultWriterClosedPromiseReject(writer, stream._storedError);
          }
        }
        function WritableStreamUpdateBackpressure(stream, backpressure) {
          const writer = stream._writer;
          if (writer !== void 0 && backpressure !== stream._backpressure) {
            if (backpressure) {
              defaultWriterReadyPromiseReset(writer);
            } else {
              defaultWriterReadyPromiseResolve(writer);
            }
          }
          stream._backpressure = backpressure;
        }
        class WritableStreamDefaultWriter {
          constructor(stream) {
            assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
            assertWritableStream(stream, "First parameter");
            if (IsWritableStreamLocked(stream)) {
              throw new TypeError("This stream has already been locked for exclusive writing by another writer");
            }
            this._ownerWritableStream = stream;
            stream._writer = this;
            const state = stream._state;
            if (state === "writable") {
              if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
                defaultWriterReadyPromiseInitialize(this);
              } else {
                defaultWriterReadyPromiseInitializeAsResolved(this);
              }
              defaultWriterClosedPromiseInitialize(this);
            } else if (state === "erroring") {
              defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
              defaultWriterClosedPromiseInitialize(this);
            } else if (state === "closed") {
              defaultWriterReadyPromiseInitializeAsResolved(this);
              defaultWriterClosedPromiseInitializeAsResolved(this);
            } else {
              const storedError = stream._storedError;
              defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
              defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
            }
          }
          get closed() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
            }
            return this._closedPromise;
          }
          get desiredSize() {
            if (!IsWritableStreamDefaultWriter(this)) {
              throw defaultWriterBrandCheckException("desiredSize");
            }
            if (this._ownerWritableStream === void 0) {
              throw defaultWriterLockException("desiredSize");
            }
            return WritableStreamDefaultWriterGetDesiredSize(this);
          }
          get ready() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
            }
            return this._readyPromise;
          }
          abort(reason = void 0) {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
            }
            if (this._ownerWritableStream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("abort"));
            }
            return WritableStreamDefaultWriterAbort(this, reason);
          }
          close() {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("close"));
            }
            const stream = this._ownerWritableStream;
            if (stream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("close"));
            }
            if (WritableStreamCloseQueuedOrInFlight(stream)) {
              return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
            }
            return WritableStreamDefaultWriterClose(this);
          }
          releaseLock() {
            if (!IsWritableStreamDefaultWriter(this)) {
              throw defaultWriterBrandCheckException("releaseLock");
            }
            const stream = this._ownerWritableStream;
            if (stream === void 0) {
              return;
            }
            WritableStreamDefaultWriterRelease(this);
          }
          write(chunk = void 0) {
            if (!IsWritableStreamDefaultWriter(this)) {
              return promiseRejectedWith(defaultWriterBrandCheckException("write"));
            }
            if (this._ownerWritableStream === void 0) {
              return promiseRejectedWith(defaultWriterLockException("write to"));
            }
            return WritableStreamDefaultWriterWrite(this, chunk);
          }
        }
        Object.defineProperties(WritableStreamDefaultWriter.prototype, {
          abort: { enumerable: true },
          close: { enumerable: true },
          releaseLock: { enumerable: true },
          write: { enumerable: true },
          closed: { enumerable: true },
          desiredSize: { enumerable: true },
          ready: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStreamDefaultWriter",
            configurable: true
          });
        }
        function IsWritableStreamDefaultWriter(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_ownerWritableStream")) {
            return false;
          }
          return x instanceof WritableStreamDefaultWriter;
        }
        function WritableStreamDefaultWriterAbort(writer, reason) {
          const stream = writer._ownerWritableStream;
          return WritableStreamAbort(stream, reason);
        }
        function WritableStreamDefaultWriterClose(writer) {
          const stream = writer._ownerWritableStream;
          return WritableStreamClose(stream);
        }
        function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
          const stream = writer._ownerWritableStream;
          const state = stream._state;
          if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
            return promiseResolvedWith(void 0);
          }
          if (state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          return WritableStreamDefaultWriterClose(writer);
        }
        function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error2) {
          if (writer._closedPromiseState === "pending") {
            defaultWriterClosedPromiseReject(writer, error2);
          } else {
            defaultWriterClosedPromiseResetToRejected(writer, error2);
          }
        }
        function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error2) {
          if (writer._readyPromiseState === "pending") {
            defaultWriterReadyPromiseReject(writer, error2);
          } else {
            defaultWriterReadyPromiseResetToRejected(writer, error2);
          }
        }
        function WritableStreamDefaultWriterGetDesiredSize(writer) {
          const stream = writer._ownerWritableStream;
          const state = stream._state;
          if (state === "errored" || state === "erroring") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
        }
        function WritableStreamDefaultWriterRelease(writer) {
          const stream = writer._ownerWritableStream;
          const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);
          WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
          WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
          stream._writer = void 0;
          writer._ownerWritableStream = void 0;
        }
        function WritableStreamDefaultWriterWrite(writer, chunk) {
          const stream = writer._ownerWritableStream;
          const controller = stream._writableStreamController;
          const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
          if (stream !== writer._ownerWritableStream) {
            return promiseRejectedWith(defaultWriterLockException("write to"));
          }
          const state = stream._state;
          if (state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
            return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
          }
          if (state === "erroring") {
            return promiseRejectedWith(stream._storedError);
          }
          const promise = WritableStreamAddWriteRequest(stream);
          WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
          return promise;
        }
        const closeSentinel = {};
        class WritableStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get abortReason() {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("abortReason");
            }
            return this._abortReason;
          }
          get signal() {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("signal");
            }
            if (this._abortController === void 0) {
              throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
            }
            return this._abortController.signal;
          }
          error(e = void 0) {
            if (!IsWritableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$2("error");
            }
            const state = this._controlledWritableStream._state;
            if (state !== "writable") {
              return;
            }
            WritableStreamDefaultControllerError(this, e);
          }
          [AbortSteps](reason) {
            const result = this._abortAlgorithm(reason);
            WritableStreamDefaultControllerClearAlgorithms(this);
            return result;
          }
          [ErrorSteps]() {
            ResetQueue(this);
          }
        }
        Object.defineProperties(WritableStreamDefaultController.prototype, {
          error: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "WritableStreamDefaultController",
            configurable: true
          });
        }
        function IsWritableStreamDefaultController(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_controlledWritableStream")) {
            return false;
          }
          return x instanceof WritableStreamDefaultController;
        }
        function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
          controller._controlledWritableStream = stream;
          stream._writableStreamController = controller;
          controller._queue = void 0;
          controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._abortReason = void 0;
          controller._abortController = createAbortController();
          controller._started = false;
          controller._strategySizeAlgorithm = sizeAlgorithm;
          controller._strategyHWM = highWaterMark;
          controller._writeAlgorithm = writeAlgorithm;
          controller._closeAlgorithm = closeAlgorithm;
          controller._abortAlgorithm = abortAlgorithm;
          const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
          const startResult = startAlgorithm();
          const startPromise = promiseResolvedWith(startResult);
          uponPromise(startPromise, () => {
            controller._started = true;
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          }, (r) => {
            controller._started = true;
            WritableStreamDealWithRejection(stream, r);
          });
        }
        function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
          const controller = Object.create(WritableStreamDefaultController.prototype);
          let startAlgorithm = () => void 0;
          let writeAlgorithm = () => promiseResolvedWith(void 0);
          let closeAlgorithm = () => promiseResolvedWith(void 0);
          let abortAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingSink.start !== void 0) {
            startAlgorithm = () => underlyingSink.start(controller);
          }
          if (underlyingSink.write !== void 0) {
            writeAlgorithm = (chunk) => underlyingSink.write(chunk, controller);
          }
          if (underlyingSink.close !== void 0) {
            closeAlgorithm = () => underlyingSink.close();
          }
          if (underlyingSink.abort !== void 0) {
            abortAlgorithm = (reason) => underlyingSink.abort(reason);
          }
          SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
        }
        function WritableStreamDefaultControllerClearAlgorithms(controller) {
          controller._writeAlgorithm = void 0;
          controller._closeAlgorithm = void 0;
          controller._abortAlgorithm = void 0;
          controller._strategySizeAlgorithm = void 0;
        }
        function WritableStreamDefaultControllerClose(controller) {
          EnqueueValueWithSize(controller, closeSentinel, 0);
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }
        function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
          try {
            return controller._strategySizeAlgorithm(chunk);
          } catch (chunkSizeE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
            return 1;
          }
        }
        function WritableStreamDefaultControllerGetDesiredSize(controller) {
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
          try {
            EnqueueValueWithSize(controller, chunk, chunkSize);
          } catch (enqueueE) {
            WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
            return;
          }
          const stream = controller._controlledWritableStream;
          if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
            WritableStreamUpdateBackpressure(stream, backpressure);
          }
          WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        }
        function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
          const stream = controller._controlledWritableStream;
          if (!controller._started) {
            return;
          }
          if (stream._inFlightWriteRequest !== void 0) {
            return;
          }
          const state = stream._state;
          if (state === "erroring") {
            WritableStreamFinishErroring(stream);
            return;
          }
          if (controller._queue.length === 0) {
            return;
          }
          const value = PeekQueueValue(controller);
          if (value === closeSentinel) {
            WritableStreamDefaultControllerProcessClose(controller);
          } else {
            WritableStreamDefaultControllerProcessWrite(controller, value);
          }
        }
        function WritableStreamDefaultControllerErrorIfNeeded(controller, error2) {
          if (controller._controlledWritableStream._state === "writable") {
            WritableStreamDefaultControllerError(controller, error2);
          }
        }
        function WritableStreamDefaultControllerProcessClose(controller) {
          const stream = controller._controlledWritableStream;
          WritableStreamMarkCloseRequestInFlight(stream);
          DequeueValue(controller);
          const sinkClosePromise = controller._closeAlgorithm();
          WritableStreamDefaultControllerClearAlgorithms(controller);
          uponPromise(sinkClosePromise, () => {
            WritableStreamFinishInFlightClose(stream);
          }, (reason) => {
            WritableStreamFinishInFlightCloseWithError(stream, reason);
          });
        }
        function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
          const stream = controller._controlledWritableStream;
          WritableStreamMarkFirstWriteRequestInFlight(stream);
          const sinkWritePromise = controller._writeAlgorithm(chunk);
          uponPromise(sinkWritePromise, () => {
            WritableStreamFinishInFlightWrite(stream);
            const state = stream._state;
            DequeueValue(controller);
            if (!WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
              const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
              WritableStreamUpdateBackpressure(stream, backpressure);
            }
            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
          }, (reason) => {
            if (stream._state === "writable") {
              WritableStreamDefaultControllerClearAlgorithms(controller);
            }
            WritableStreamFinishInFlightWriteWithError(stream, reason);
          });
        }
        function WritableStreamDefaultControllerGetBackpressure(controller) {
          const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
          return desiredSize <= 0;
        }
        function WritableStreamDefaultControllerError(controller, error2) {
          const stream = controller._controlledWritableStream;
          WritableStreamDefaultControllerClearAlgorithms(controller);
          WritableStreamStartErroring(stream, error2);
        }
        function streamBrandCheckException$2(name2) {
          return new TypeError(`WritableStream.prototype.${name2} can only be used on a WritableStream`);
        }
        function defaultControllerBrandCheckException$2(name2) {
          return new TypeError(`WritableStreamDefaultController.prototype.${name2} can only be used on a WritableStreamDefaultController`);
        }
        function defaultWriterBrandCheckException(name2) {
          return new TypeError(`WritableStreamDefaultWriter.prototype.${name2} can only be used on a WritableStreamDefaultWriter`);
        }
        function defaultWriterLockException(name2) {
          return new TypeError("Cannot " + name2 + " a stream using a released writer");
        }
        function defaultWriterClosedPromiseInitialize(writer) {
          writer._closedPromise = newPromise((resolve2, reject) => {
            writer._closedPromise_resolve = resolve2;
            writer._closedPromise_reject = reject;
            writer._closedPromiseState = "pending";
          });
        }
        function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
          defaultWriterClosedPromiseInitialize(writer);
          defaultWriterClosedPromiseReject(writer, reason);
        }
        function defaultWriterClosedPromiseInitializeAsResolved(writer) {
          defaultWriterClosedPromiseInitialize(writer);
          defaultWriterClosedPromiseResolve(writer);
        }
        function defaultWriterClosedPromiseReject(writer, reason) {
          if (writer._closedPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(writer._closedPromise);
          writer._closedPromise_reject(reason);
          writer._closedPromise_resolve = void 0;
          writer._closedPromise_reject = void 0;
          writer._closedPromiseState = "rejected";
        }
        function defaultWriterClosedPromiseResetToRejected(writer, reason) {
          defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
        }
        function defaultWriterClosedPromiseResolve(writer) {
          if (writer._closedPromise_resolve === void 0) {
            return;
          }
          writer._closedPromise_resolve(void 0);
          writer._closedPromise_resolve = void 0;
          writer._closedPromise_reject = void 0;
          writer._closedPromiseState = "resolved";
        }
        function defaultWriterReadyPromiseInitialize(writer) {
          writer._readyPromise = newPromise((resolve2, reject) => {
            writer._readyPromise_resolve = resolve2;
            writer._readyPromise_reject = reject;
          });
          writer._readyPromiseState = "pending";
        }
        function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
          defaultWriterReadyPromiseInitialize(writer);
          defaultWriterReadyPromiseReject(writer, reason);
        }
        function defaultWriterReadyPromiseInitializeAsResolved(writer) {
          defaultWriterReadyPromiseInitialize(writer);
          defaultWriterReadyPromiseResolve(writer);
        }
        function defaultWriterReadyPromiseReject(writer, reason) {
          if (writer._readyPromise_reject === void 0) {
            return;
          }
          setPromiseIsHandledToTrue(writer._readyPromise);
          writer._readyPromise_reject(reason);
          writer._readyPromise_resolve = void 0;
          writer._readyPromise_reject = void 0;
          writer._readyPromiseState = "rejected";
        }
        function defaultWriterReadyPromiseReset(writer) {
          defaultWriterReadyPromiseInitialize(writer);
        }
        function defaultWriterReadyPromiseResetToRejected(writer, reason) {
          defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
        }
        function defaultWriterReadyPromiseResolve(writer) {
          if (writer._readyPromise_resolve === void 0) {
            return;
          }
          writer._readyPromise_resolve(void 0);
          writer._readyPromise_resolve = void 0;
          writer._readyPromise_reject = void 0;
          writer._readyPromiseState = "fulfilled";
        }
        const NativeDOMException = typeof DOMException !== "undefined" ? DOMException : void 0;
        function isDOMExceptionConstructor(ctor) {
          if (!(typeof ctor === "function" || typeof ctor === "object")) {
            return false;
          }
          try {
            new ctor();
            return true;
          } catch (_a) {
            return false;
          }
        }
        function createDOMExceptionPolyfill() {
          const ctor = function DOMException2(message, name2) {
            this.message = message || "";
            this.name = name2 || "Error";
            if (Error.captureStackTrace) {
              Error.captureStackTrace(this, this.constructor);
            }
          };
          ctor.prototype = Object.create(Error.prototype);
          Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
          return ctor;
        }
        const DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();
        function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
          const reader = AcquireReadableStreamDefaultReader(source);
          const writer = AcquireWritableStreamDefaultWriter(dest);
          source._disturbed = true;
          let shuttingDown = false;
          let currentWrite = promiseResolvedWith(void 0);
          return newPromise((resolve2, reject) => {
            let abortAlgorithm;
            if (signal !== void 0) {
              abortAlgorithm = () => {
                const error2 = new DOMException$1("Aborted", "AbortError");
                const actions = [];
                if (!preventAbort) {
                  actions.push(() => {
                    if (dest._state === "writable") {
                      return WritableStreamAbort(dest, error2);
                    }
                    return promiseResolvedWith(void 0);
                  });
                }
                if (!preventCancel) {
                  actions.push(() => {
                    if (source._state === "readable") {
                      return ReadableStreamCancel(source, error2);
                    }
                    return promiseResolvedWith(void 0);
                  });
                }
                shutdownWithAction(() => Promise.all(actions.map((action) => action())), true, error2);
              };
              if (signal.aborted) {
                abortAlgorithm();
                return;
              }
              signal.addEventListener("abort", abortAlgorithm);
            }
            function pipeLoop() {
              return newPromise((resolveLoop, rejectLoop) => {
                function next(done) {
                  if (done) {
                    resolveLoop();
                  } else {
                    PerformPromiseThen(pipeStep(), next, rejectLoop);
                  }
                }
                next(false);
              });
            }
            function pipeStep() {
              if (shuttingDown) {
                return promiseResolvedWith(true);
              }
              return PerformPromiseThen(writer._readyPromise, () => {
                return newPromise((resolveRead, rejectRead) => {
                  ReadableStreamDefaultReaderRead(reader, {
                    _chunkSteps: (chunk) => {
                      currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), void 0, noop2);
                      resolveRead(false);
                    },
                    _closeSteps: () => resolveRead(true),
                    _errorSteps: rejectRead
                  });
                });
              });
            }
            isOrBecomesErrored(source, reader._closedPromise, (storedError) => {
              if (!preventAbort) {
                shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
              } else {
                shutdown(true, storedError);
              }
            });
            isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {
              if (!preventCancel) {
                shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);
              } else {
                shutdown(true, storedError);
              }
            });
            isOrBecomesClosed(source, reader._closedPromise, () => {
              if (!preventClose) {
                shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
              } else {
                shutdown();
              }
            });
            if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
              const destClosed = new TypeError("the destination writable stream closed before all data could be piped to it");
              if (!preventCancel) {
                shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);
              } else {
                shutdown(true, destClosed);
              }
            }
            setPromiseIsHandledToTrue(pipeLoop());
            function waitForWritesToFinish() {
              const oldCurrentWrite = currentWrite;
              return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0);
            }
            function isOrBecomesErrored(stream, promise, action) {
              if (stream._state === "errored") {
                action(stream._storedError);
              } else {
                uponRejection(promise, action);
              }
            }
            function isOrBecomesClosed(stream, promise, action) {
              if (stream._state === "closed") {
                action();
              } else {
                uponFulfillment(promise, action);
              }
            }
            function shutdownWithAction(action, originalIsError, originalError) {
              if (shuttingDown) {
                return;
              }
              shuttingDown = true;
              if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                uponFulfillment(waitForWritesToFinish(), doTheRest);
              } else {
                doTheRest();
              }
              function doTheRest() {
                uponPromise(action(), () => finalize(originalIsError, originalError), (newError) => finalize(true, newError));
              }
            }
            function shutdown(isError, error2) {
              if (shuttingDown) {
                return;
              }
              shuttingDown = true;
              if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
                uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error2));
              } else {
                finalize(isError, error2);
              }
            }
            function finalize(isError, error2) {
              WritableStreamDefaultWriterRelease(writer);
              ReadableStreamReaderGenericRelease(reader);
              if (signal !== void 0) {
                signal.removeEventListener("abort", abortAlgorithm);
              }
              if (isError) {
                reject(error2);
              } else {
                resolve2(void 0);
              }
            }
          });
        }
        class ReadableStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get desiredSize() {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("desiredSize");
            }
            return ReadableStreamDefaultControllerGetDesiredSize(this);
          }
          close() {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("close");
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
              throw new TypeError("The stream is not in a state that permits close");
            }
            ReadableStreamDefaultControllerClose(this);
          }
          enqueue(chunk = void 0) {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("enqueue");
            }
            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
              throw new TypeError("The stream is not in a state that permits enqueue");
            }
            return ReadableStreamDefaultControllerEnqueue(this, chunk);
          }
          error(e = void 0) {
            if (!IsReadableStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException$1("error");
            }
            ReadableStreamDefaultControllerError(this, e);
          }
          [CancelSteps](reason) {
            ResetQueue(this);
            const result = this._cancelAlgorithm(reason);
            ReadableStreamDefaultControllerClearAlgorithms(this);
            return result;
          }
          [PullSteps](readRequest) {
            const stream = this._controlledReadableStream;
            if (this._queue.length > 0) {
              const chunk = DequeueValue(this);
              if (this._closeRequested && this._queue.length === 0) {
                ReadableStreamDefaultControllerClearAlgorithms(this);
                ReadableStreamClose(stream);
              } else {
                ReadableStreamDefaultControllerCallPullIfNeeded(this);
              }
              readRequest._chunkSteps(chunk);
            } else {
              ReadableStreamAddReadRequest(stream, readRequest);
              ReadableStreamDefaultControllerCallPullIfNeeded(this);
            }
          }
        }
        Object.defineProperties(ReadableStreamDefaultController.prototype, {
          close: { enumerable: true },
          enqueue: { enumerable: true },
          error: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStreamDefaultController",
            configurable: true
          });
        }
        function IsReadableStreamDefaultController(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableStream")) {
            return false;
          }
          return x instanceof ReadableStreamDefaultController;
        }
        function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
          const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
          if (!shouldPull) {
            return;
          }
          if (controller._pulling) {
            controller._pullAgain = true;
            return;
          }
          controller._pulling = true;
          const pullPromise = controller._pullAlgorithm();
          uponPromise(pullPromise, () => {
            controller._pulling = false;
            if (controller._pullAgain) {
              controller._pullAgain = false;
              ReadableStreamDefaultControllerCallPullIfNeeded(controller);
            }
          }, (e) => {
            ReadableStreamDefaultControllerError(controller, e);
          });
        }
        function ReadableStreamDefaultControllerShouldCallPull(controller) {
          const stream = controller._controlledReadableStream;
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return false;
          }
          if (!controller._started) {
            return false;
          }
          if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            return true;
          }
          const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
          if (desiredSize > 0) {
            return true;
          }
          return false;
        }
        function ReadableStreamDefaultControllerClearAlgorithms(controller) {
          controller._pullAlgorithm = void 0;
          controller._cancelAlgorithm = void 0;
          controller._strategySizeAlgorithm = void 0;
        }
        function ReadableStreamDefaultControllerClose(controller) {
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
          }
          const stream = controller._controlledReadableStream;
          controller._closeRequested = true;
          if (controller._queue.length === 0) {
            ReadableStreamDefaultControllerClearAlgorithms(controller);
            ReadableStreamClose(stream);
          }
        }
        function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
            return;
          }
          const stream = controller._controlledReadableStream;
          if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
            ReadableStreamFulfillReadRequest(stream, chunk, false);
          } else {
            let chunkSize;
            try {
              chunkSize = controller._strategySizeAlgorithm(chunk);
            } catch (chunkSizeE) {
              ReadableStreamDefaultControllerError(controller, chunkSizeE);
              throw chunkSizeE;
            }
            try {
              EnqueueValueWithSize(controller, chunk, chunkSize);
            } catch (enqueueE) {
              ReadableStreamDefaultControllerError(controller, enqueueE);
              throw enqueueE;
            }
          }
          ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }
        function ReadableStreamDefaultControllerError(controller, e) {
          const stream = controller._controlledReadableStream;
          if (stream._state !== "readable") {
            return;
          }
          ResetQueue(controller);
          ReadableStreamDefaultControllerClearAlgorithms(controller);
          ReadableStreamError(stream, e);
        }
        function ReadableStreamDefaultControllerGetDesiredSize(controller) {
          const state = controller._controlledReadableStream._state;
          if (state === "errored") {
            return null;
          }
          if (state === "closed") {
            return 0;
          }
          return controller._strategyHWM - controller._queueTotalSize;
        }
        function ReadableStreamDefaultControllerHasBackpressure(controller) {
          if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
            return false;
          }
          return true;
        }
        function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
          const state = controller._controlledReadableStream._state;
          if (!controller._closeRequested && state === "readable") {
            return true;
          }
          return false;
        }
        function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
          controller._controlledReadableStream = stream;
          controller._queue = void 0;
          controller._queueTotalSize = void 0;
          ResetQueue(controller);
          controller._started = false;
          controller._closeRequested = false;
          controller._pullAgain = false;
          controller._pulling = false;
          controller._strategySizeAlgorithm = sizeAlgorithm;
          controller._strategyHWM = highWaterMark;
          controller._pullAlgorithm = pullAlgorithm;
          controller._cancelAlgorithm = cancelAlgorithm;
          stream._readableStreamController = controller;
          const startResult = startAlgorithm();
          uponPromise(promiseResolvedWith(startResult), () => {
            controller._started = true;
            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
          }, (r) => {
            ReadableStreamDefaultControllerError(controller, r);
          });
        }
        function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
          const controller = Object.create(ReadableStreamDefaultController.prototype);
          let startAlgorithm = () => void 0;
          let pullAlgorithm = () => promiseResolvedWith(void 0);
          let cancelAlgorithm = () => promiseResolvedWith(void 0);
          if (underlyingSource.start !== void 0) {
            startAlgorithm = () => underlyingSource.start(controller);
          }
          if (underlyingSource.pull !== void 0) {
            pullAlgorithm = () => underlyingSource.pull(controller);
          }
          if (underlyingSource.cancel !== void 0) {
            cancelAlgorithm = (reason) => underlyingSource.cancel(reason);
          }
          SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
        }
        function defaultControllerBrandCheckException$1(name2) {
          return new TypeError(`ReadableStreamDefaultController.prototype.${name2} can only be used on a ReadableStreamDefaultController`);
        }
        function ReadableStreamTee(stream, cloneForBranch2) {
          if (IsReadableByteStreamController(stream._readableStreamController)) {
            return ReadableByteStreamTee(stream);
          }
          return ReadableStreamDefaultTee(stream);
        }
        function ReadableStreamDefaultTee(stream, cloneForBranch2) {
          const reader = AcquireReadableStreamDefaultReader(stream);
          let reading = false;
          let canceled1 = false;
          let canceled2 = false;
          let reason1;
          let reason2;
          let branch1;
          let branch2;
          let resolveCancelPromise;
          const cancelPromise = newPromise((resolve2) => {
            resolveCancelPromise = resolve2;
          });
          function pullAlgorithm() {
            if (reading) {
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const readRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  reading = false;
                  const chunk1 = chunk;
                  const chunk2 = chunk;
                  if (!canceled1) {
                    ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
                  }
                  if (!canceled2) {
                    ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
                  }
                });
              },
              _closeSteps: () => {
                reading = false;
                if (!canceled1) {
                  ReadableStreamDefaultControllerClose(branch1._readableStreamController);
                }
                if (!canceled2) {
                  ReadableStreamDefaultControllerClose(branch2._readableStreamController);
                }
                if (!canceled1 || !canceled2) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
            return promiseResolvedWith(void 0);
          }
          function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function startAlgorithm() {
          }
          branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
          branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
          uponRejection(reader._closedPromise, (r) => {
            ReadableStreamDefaultControllerError(branch1._readableStreamController, r);
            ReadableStreamDefaultControllerError(branch2._readableStreamController, r);
            if (!canceled1 || !canceled2) {
              resolveCancelPromise(void 0);
            }
          });
          return [branch1, branch2];
        }
        function ReadableByteStreamTee(stream) {
          let reader = AcquireReadableStreamDefaultReader(stream);
          let reading = false;
          let canceled1 = false;
          let canceled2 = false;
          let reason1;
          let reason2;
          let branch1;
          let branch2;
          let resolveCancelPromise;
          const cancelPromise = newPromise((resolve2) => {
            resolveCancelPromise = resolve2;
          });
          function forwardReaderError(thisReader) {
            uponRejection(thisReader._closedPromise, (r) => {
              if (thisReader !== reader) {
                return;
              }
              ReadableByteStreamControllerError(branch1._readableStreamController, r);
              ReadableByteStreamControllerError(branch2._readableStreamController, r);
              if (!canceled1 || !canceled2) {
                resolveCancelPromise(void 0);
              }
            });
          }
          function pullWithDefaultReader() {
            if (IsReadableStreamBYOBReader(reader)) {
              ReadableStreamReaderGenericRelease(reader);
              reader = AcquireReadableStreamDefaultReader(stream);
              forwardReaderError(reader);
            }
            const readRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  reading = false;
                  const chunk1 = chunk;
                  let chunk2 = chunk;
                  if (!canceled1 && !canceled2) {
                    try {
                      chunk2 = CloneAsUint8Array(chunk);
                    } catch (cloneE) {
                      ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                      ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                      resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                      return;
                    }
                  }
                  if (!canceled1) {
                    ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
                  }
                  if (!canceled2) {
                    ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
                  }
                });
              },
              _closeSteps: () => {
                reading = false;
                if (!canceled1) {
                  ReadableByteStreamControllerClose(branch1._readableStreamController);
                }
                if (!canceled2) {
                  ReadableByteStreamControllerClose(branch2._readableStreamController);
                }
                if (branch1._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
                }
                if (branch2._readableStreamController._pendingPullIntos.length > 0) {
                  ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
                }
                if (!canceled1 || !canceled2) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamDefaultReaderRead(reader, readRequest);
          }
          function pullWithBYOBReader(view, forBranch2) {
            if (IsReadableStreamDefaultReader(reader)) {
              ReadableStreamReaderGenericRelease(reader);
              reader = AcquireReadableStreamBYOBReader(stream);
              forwardReaderError(reader);
            }
            const byobBranch = forBranch2 ? branch2 : branch1;
            const otherBranch = forBranch2 ? branch1 : branch2;
            const readIntoRequest = {
              _chunkSteps: (chunk) => {
                queueMicrotask(() => {
                  reading = false;
                  const byobCanceled = forBranch2 ? canceled2 : canceled1;
                  const otherCanceled = forBranch2 ? canceled1 : canceled2;
                  if (!otherCanceled) {
                    let clonedChunk;
                    try {
                      clonedChunk = CloneAsUint8Array(chunk);
                    } catch (cloneE) {
                      ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                      ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                      resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                      return;
                    }
                    if (!byobCanceled) {
                      ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                    }
                    ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
                  } else if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                });
              },
              _closeSteps: (chunk) => {
                reading = false;
                const byobCanceled = forBranch2 ? canceled2 : canceled1;
                const otherCanceled = forBranch2 ? canceled1 : canceled2;
                if (!byobCanceled) {
                  ReadableByteStreamControllerClose(byobBranch._readableStreamController);
                }
                if (!otherCanceled) {
                  ReadableByteStreamControllerClose(otherBranch._readableStreamController);
                }
                if (chunk !== void 0) {
                  if (!byobCanceled) {
                    ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                  }
                  if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                    ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
                  }
                }
                if (!byobCanceled || !otherCanceled) {
                  resolveCancelPromise(void 0);
                }
              },
              _errorSteps: () => {
                reading = false;
              }
            };
            ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
          }
          function pull1Algorithm() {
            if (reading) {
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
            if (byobRequest === null) {
              pullWithDefaultReader();
            } else {
              pullWithBYOBReader(byobRequest._view, false);
            }
            return promiseResolvedWith(void 0);
          }
          function pull2Algorithm() {
            if (reading) {
              return promiseResolvedWith(void 0);
            }
            reading = true;
            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
            if (byobRequest === null) {
              pullWithDefaultReader();
            } else {
              pullWithBYOBReader(byobRequest._view, true);
            }
            return promiseResolvedWith(void 0);
          }
          function cancel1Algorithm(reason) {
            canceled1 = true;
            reason1 = reason;
            if (canceled2) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function cancel2Algorithm(reason) {
            canceled2 = true;
            reason2 = reason;
            if (canceled1) {
              const compositeReason = CreateArrayFromList([reason1, reason2]);
              const cancelResult = ReadableStreamCancel(stream, compositeReason);
              resolveCancelPromise(cancelResult);
            }
            return cancelPromise;
          }
          function startAlgorithm() {
            return;
          }
          branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
          branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
          forwardReaderError(reader);
          return [branch1, branch2];
        }
        function convertUnderlyingDefaultOrByteSource(source, context) {
          assertDictionary(source, context);
          const original = source;
          const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
          const cancel = original === null || original === void 0 ? void 0 : original.cancel;
          const pull = original === null || original === void 0 ? void 0 : original.pull;
          const start2 = original === null || original === void 0 ? void 0 : original.start;
          const type = original === null || original === void 0 ? void 0 : original.type;
          return {
            autoAllocateChunkSize: autoAllocateChunkSize === void 0 ? void 0 : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),
            cancel: cancel === void 0 ? void 0 : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),
            pull: pull === void 0 ? void 0 : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),
            start: start2 === void 0 ? void 0 : convertUnderlyingSourceStartCallback(start2, original, `${context} has member 'start' that`),
            type: type === void 0 ? void 0 : convertReadableStreamType(type, `${context} has member 'type' that`)
          };
        }
        function convertUnderlyingSourceCancelCallback(fn, original, context) {
          assertFunction(fn, context);
          return (reason) => promiseCall(fn, original, [reason]);
        }
        function convertUnderlyingSourcePullCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => promiseCall(fn, original, [controller]);
        }
        function convertUnderlyingSourceStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => reflectCall(fn, original, [controller]);
        }
        function convertReadableStreamType(type, context) {
          type = `${type}`;
          if (type !== "bytes") {
            throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);
          }
          return type;
        }
        function convertReaderOptions(options2, context) {
          assertDictionary(options2, context);
          const mode = options2 === null || options2 === void 0 ? void 0 : options2.mode;
          return {
            mode: mode === void 0 ? void 0 : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)
          };
        }
        function convertReadableStreamReaderMode(mode, context) {
          mode = `${mode}`;
          if (mode !== "byob") {
            throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
          }
          return mode;
        }
        function convertIteratorOptions(options2, context) {
          assertDictionary(options2, context);
          const preventCancel = options2 === null || options2 === void 0 ? void 0 : options2.preventCancel;
          return { preventCancel: Boolean(preventCancel) };
        }
        function convertPipeOptions(options2, context) {
          assertDictionary(options2, context);
          const preventAbort = options2 === null || options2 === void 0 ? void 0 : options2.preventAbort;
          const preventCancel = options2 === null || options2 === void 0 ? void 0 : options2.preventCancel;
          const preventClose = options2 === null || options2 === void 0 ? void 0 : options2.preventClose;
          const signal = options2 === null || options2 === void 0 ? void 0 : options2.signal;
          if (signal !== void 0) {
            assertAbortSignal(signal, `${context} has member 'signal' that`);
          }
          return {
            preventAbort: Boolean(preventAbort),
            preventCancel: Boolean(preventCancel),
            preventClose: Boolean(preventClose),
            signal
          };
        }
        function assertAbortSignal(signal, context) {
          if (!isAbortSignal2(signal)) {
            throw new TypeError(`${context} is not an AbortSignal.`);
          }
        }
        function convertReadableWritablePair(pair, context) {
          assertDictionary(pair, context);
          const readable = pair === null || pair === void 0 ? void 0 : pair.readable;
          assertRequiredField(readable, "readable", "ReadableWritablePair");
          assertReadableStream(readable, `${context} has member 'readable' that`);
          const writable2 = pair === null || pair === void 0 ? void 0 : pair.writable;
          assertRequiredField(writable2, "writable", "ReadableWritablePair");
          assertWritableStream(writable2, `${context} has member 'writable' that`);
          return { readable, writable: writable2 };
        }
        class ReadableStream2 {
          constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
            if (rawUnderlyingSource === void 0) {
              rawUnderlyingSource = null;
            } else {
              assertObject(rawUnderlyingSource, "First parameter");
            }
            const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
            const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
            InitializeReadableStream(this);
            if (underlyingSource.type === "bytes") {
              if (strategy.size !== void 0) {
                throw new RangeError("The strategy for a byte stream cannot have a size function");
              }
              const highWaterMark = ExtractHighWaterMark(strategy, 0);
              SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
            } else {
              const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
              const highWaterMark = ExtractHighWaterMark(strategy, 1);
              SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
            }
          }
          get locked() {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("locked");
            }
            return IsReadableStreamLocked(this);
          }
          cancel(reason = void 0) {
            if (!IsReadableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$1("cancel"));
            }
            if (IsReadableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
            }
            return ReadableStreamCancel(this, reason);
          }
          getReader(rawOptions = void 0) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("getReader");
            }
            const options2 = convertReaderOptions(rawOptions, "First parameter");
            if (options2.mode === void 0) {
              return AcquireReadableStreamDefaultReader(this);
            }
            return AcquireReadableStreamBYOBReader(this);
          }
          pipeThrough(rawTransform, rawOptions = {}) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("pipeThrough");
            }
            assertRequiredArgument(rawTransform, 1, "pipeThrough");
            const transform = convertReadableWritablePair(rawTransform, "First parameter");
            const options2 = convertPipeOptions(rawOptions, "Second parameter");
            if (IsReadableStreamLocked(this)) {
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
            }
            if (IsWritableStreamLocked(transform.writable)) {
              throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
            }
            const promise = ReadableStreamPipeTo(this, transform.writable, options2.preventClose, options2.preventAbort, options2.preventCancel, options2.signal);
            setPromiseIsHandledToTrue(promise);
            return transform.readable;
          }
          pipeTo(destination, rawOptions = {}) {
            if (!IsReadableStream(this)) {
              return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
            }
            if (destination === void 0) {
              return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
            }
            if (!IsWritableStream(destination)) {
              return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));
            }
            let options2;
            try {
              options2 = convertPipeOptions(rawOptions, "Second parameter");
            } catch (e) {
              return promiseRejectedWith(e);
            }
            if (IsReadableStreamLocked(this)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
            }
            if (IsWritableStreamLocked(destination)) {
              return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
            }
            return ReadableStreamPipeTo(this, destination, options2.preventClose, options2.preventAbort, options2.preventCancel, options2.signal);
          }
          tee() {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("tee");
            }
            const branches = ReadableStreamTee(this);
            return CreateArrayFromList(branches);
          }
          values(rawOptions = void 0) {
            if (!IsReadableStream(this)) {
              throw streamBrandCheckException$1("values");
            }
            const options2 = convertIteratorOptions(rawOptions, "First parameter");
            return AcquireReadableStreamAsyncIterator(this, options2.preventCancel);
          }
        }
        Object.defineProperties(ReadableStream2.prototype, {
          cancel: { enumerable: true },
          getReader: { enumerable: true },
          pipeThrough: { enumerable: true },
          pipeTo: { enumerable: true },
          tee: { enumerable: true },
          values: { enumerable: true },
          locked: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.toStringTag, {
            value: "ReadableStream",
            configurable: true
          });
        }
        if (typeof SymbolPolyfill.asyncIterator === "symbol") {
          Object.defineProperty(ReadableStream2.prototype, SymbolPolyfill.asyncIterator, {
            value: ReadableStream2.prototype.values,
            writable: true,
            configurable: true
          });
        }
        function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
          const stream = Object.create(ReadableStream2.prototype);
          InitializeReadableStream(stream);
          const controller = Object.create(ReadableStreamDefaultController.prototype);
          SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
          return stream;
        }
        function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
          const stream = Object.create(ReadableStream2.prototype);
          InitializeReadableStream(stream);
          const controller = Object.create(ReadableByteStreamController.prototype);
          SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, void 0);
          return stream;
        }
        function InitializeReadableStream(stream) {
          stream._state = "readable";
          stream._reader = void 0;
          stream._storedError = void 0;
          stream._disturbed = false;
        }
        function IsReadableStream(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_readableStreamController")) {
            return false;
          }
          return x instanceof ReadableStream2;
        }
        function IsReadableStreamLocked(stream) {
          if (stream._reader === void 0) {
            return false;
          }
          return true;
        }
        function ReadableStreamCancel(stream, reason) {
          stream._disturbed = true;
          if (stream._state === "closed") {
            return promiseResolvedWith(void 0);
          }
          if (stream._state === "errored") {
            return promiseRejectedWith(stream._storedError);
          }
          ReadableStreamClose(stream);
          const reader = stream._reader;
          if (reader !== void 0 && IsReadableStreamBYOBReader(reader)) {
            reader._readIntoRequests.forEach((readIntoRequest) => {
              readIntoRequest._closeSteps(void 0);
            });
            reader._readIntoRequests = new SimpleQueue();
          }
          const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
          return transformPromiseWith(sourceCancelPromise, noop2);
        }
        function ReadableStreamClose(stream) {
          stream._state = "closed";
          const reader = stream._reader;
          if (reader === void 0) {
            return;
          }
          defaultReaderClosedPromiseResolve(reader);
          if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach((readRequest) => {
              readRequest._closeSteps();
            });
            reader._readRequests = new SimpleQueue();
          }
        }
        function ReadableStreamError(stream, e) {
          stream._state = "errored";
          stream._storedError = e;
          const reader = stream._reader;
          if (reader === void 0) {
            return;
          }
          defaultReaderClosedPromiseReject(reader, e);
          if (IsReadableStreamDefaultReader(reader)) {
            reader._readRequests.forEach((readRequest) => {
              readRequest._errorSteps(e);
            });
            reader._readRequests = new SimpleQueue();
          } else {
            reader._readIntoRequests.forEach((readIntoRequest) => {
              readIntoRequest._errorSteps(e);
            });
            reader._readIntoRequests = new SimpleQueue();
          }
        }
        function streamBrandCheckException$1(name2) {
          return new TypeError(`ReadableStream.prototype.${name2} can only be used on a ReadableStream`);
        }
        function convertQueuingStrategyInit(init2, context) {
          assertDictionary(init2, context);
          const highWaterMark = init2 === null || init2 === void 0 ? void 0 : init2.highWaterMark;
          assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
          return {
            highWaterMark: convertUnrestrictedDouble(highWaterMark)
          };
        }
        const byteLengthSizeFunction = (chunk) => {
          return chunk.byteLength;
        };
        Object.defineProperty(byteLengthSizeFunction, "name", {
          value: "size",
          configurable: true
        });
        class ByteLengthQueuingStrategy {
          constructor(options2) {
            assertRequiredArgument(options2, 1, "ByteLengthQueuingStrategy");
            options2 = convertQueuingStrategyInit(options2, "First parameter");
            this._byteLengthQueuingStrategyHighWaterMark = options2.highWaterMark;
          }
          get highWaterMark() {
            if (!IsByteLengthQueuingStrategy(this)) {
              throw byteLengthBrandCheckException("highWaterMark");
            }
            return this._byteLengthQueuingStrategyHighWaterMark;
          }
          get size() {
            if (!IsByteLengthQueuingStrategy(this)) {
              throw byteLengthBrandCheckException("size");
            }
            return byteLengthSizeFunction;
          }
        }
        Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
          highWaterMark: { enumerable: true },
          size: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: "ByteLengthQueuingStrategy",
            configurable: true
          });
        }
        function byteLengthBrandCheckException(name2) {
          return new TypeError(`ByteLengthQueuingStrategy.prototype.${name2} can only be used on a ByteLengthQueuingStrategy`);
        }
        function IsByteLengthQueuingStrategy(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_byteLengthQueuingStrategyHighWaterMark")) {
            return false;
          }
          return x instanceof ByteLengthQueuingStrategy;
        }
        const countSizeFunction = () => {
          return 1;
        };
        Object.defineProperty(countSizeFunction, "name", {
          value: "size",
          configurable: true
        });
        class CountQueuingStrategy {
          constructor(options2) {
            assertRequiredArgument(options2, 1, "CountQueuingStrategy");
            options2 = convertQueuingStrategyInit(options2, "First parameter");
            this._countQueuingStrategyHighWaterMark = options2.highWaterMark;
          }
          get highWaterMark() {
            if (!IsCountQueuingStrategy(this)) {
              throw countBrandCheckException("highWaterMark");
            }
            return this._countQueuingStrategyHighWaterMark;
          }
          get size() {
            if (!IsCountQueuingStrategy(this)) {
              throw countBrandCheckException("size");
            }
            return countSizeFunction;
          }
        }
        Object.defineProperties(CountQueuingStrategy.prototype, {
          highWaterMark: { enumerable: true },
          size: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
            value: "CountQueuingStrategy",
            configurable: true
          });
        }
        function countBrandCheckException(name2) {
          return new TypeError(`CountQueuingStrategy.prototype.${name2} can only be used on a CountQueuingStrategy`);
        }
        function IsCountQueuingStrategy(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_countQueuingStrategyHighWaterMark")) {
            return false;
          }
          return x instanceof CountQueuingStrategy;
        }
        function convertTransformer(original, context) {
          assertDictionary(original, context);
          const flush = original === null || original === void 0 ? void 0 : original.flush;
          const readableType = original === null || original === void 0 ? void 0 : original.readableType;
          const start2 = original === null || original === void 0 ? void 0 : original.start;
          const transform = original === null || original === void 0 ? void 0 : original.transform;
          const writableType = original === null || original === void 0 ? void 0 : original.writableType;
          return {
            flush: flush === void 0 ? void 0 : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),
            readableType,
            start: start2 === void 0 ? void 0 : convertTransformerStartCallback(start2, original, `${context} has member 'start' that`),
            transform: transform === void 0 ? void 0 : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),
            writableType
          };
        }
        function convertTransformerFlushCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => promiseCall(fn, original, [controller]);
        }
        function convertTransformerStartCallback(fn, original, context) {
          assertFunction(fn, context);
          return (controller) => reflectCall(fn, original, [controller]);
        }
        function convertTransformerTransformCallback(fn, original, context) {
          assertFunction(fn, context);
          return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
        }
        class TransformStream {
          constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
            if (rawTransformer === void 0) {
              rawTransformer = null;
            }
            const writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
            const readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
            const transformer = convertTransformer(rawTransformer, "First parameter");
            if (transformer.readableType !== void 0) {
              throw new RangeError("Invalid readableType specified");
            }
            if (transformer.writableType !== void 0) {
              throw new RangeError("Invalid writableType specified");
            }
            const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
            const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
            const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
            const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
            let startPromise_resolve;
            const startPromise = newPromise((resolve2) => {
              startPromise_resolve = resolve2;
            });
            InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
            SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
            if (transformer.start !== void 0) {
              startPromise_resolve(transformer.start(this._transformStreamController));
            } else {
              startPromise_resolve(void 0);
            }
          }
          get readable() {
            if (!IsTransformStream(this)) {
              throw streamBrandCheckException("readable");
            }
            return this._readable;
          }
          get writable() {
            if (!IsTransformStream(this)) {
              throw streamBrandCheckException("writable");
            }
            return this._writable;
          }
        }
        Object.defineProperties(TransformStream.prototype, {
          readable: { enumerable: true },
          writable: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
            value: "TransformStream",
            configurable: true
          });
        }
        function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
          function startAlgorithm() {
            return startPromise;
          }
          function writeAlgorithm(chunk) {
            return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
          }
          function abortAlgorithm(reason) {
            return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
          }
          function closeAlgorithm() {
            return TransformStreamDefaultSinkCloseAlgorithm(stream);
          }
          stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
          function pullAlgorithm() {
            return TransformStreamDefaultSourcePullAlgorithm(stream);
          }
          function cancelAlgorithm(reason) {
            TransformStreamErrorWritableAndUnblockWrite(stream, reason);
            return promiseResolvedWith(void 0);
          }
          stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
          stream._backpressure = void 0;
          stream._backpressureChangePromise = void 0;
          stream._backpressureChangePromise_resolve = void 0;
          TransformStreamSetBackpressure(stream, true);
          stream._transformStreamController = void 0;
        }
        function IsTransformStream(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_transformStreamController")) {
            return false;
          }
          return x instanceof TransformStream;
        }
        function TransformStreamError(stream, e) {
          ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);
          TransformStreamErrorWritableAndUnblockWrite(stream, e);
        }
        function TransformStreamErrorWritableAndUnblockWrite(stream, e) {
          TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
          WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);
          if (stream._backpressure) {
            TransformStreamSetBackpressure(stream, false);
          }
        }
        function TransformStreamSetBackpressure(stream, backpressure) {
          if (stream._backpressureChangePromise !== void 0) {
            stream._backpressureChangePromise_resolve();
          }
          stream._backpressureChangePromise = newPromise((resolve2) => {
            stream._backpressureChangePromise_resolve = resolve2;
          });
          stream._backpressure = backpressure;
        }
        class TransformStreamDefaultController {
          constructor() {
            throw new TypeError("Illegal constructor");
          }
          get desiredSize() {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("desiredSize");
            }
            const readableController = this._controlledTransformStream._readable._readableStreamController;
            return ReadableStreamDefaultControllerGetDesiredSize(readableController);
          }
          enqueue(chunk = void 0) {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("enqueue");
            }
            TransformStreamDefaultControllerEnqueue(this, chunk);
          }
          error(reason = void 0) {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("error");
            }
            TransformStreamDefaultControllerError(this, reason);
          }
          terminate() {
            if (!IsTransformStreamDefaultController(this)) {
              throw defaultControllerBrandCheckException("terminate");
            }
            TransformStreamDefaultControllerTerminate(this);
          }
        }
        Object.defineProperties(TransformStreamDefaultController.prototype, {
          enqueue: { enumerable: true },
          error: { enumerable: true },
          terminate: { enumerable: true },
          desiredSize: { enumerable: true }
        });
        if (typeof SymbolPolyfill.toStringTag === "symbol") {
          Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
            value: "TransformStreamDefaultController",
            configurable: true
          });
        }
        function IsTransformStreamDefaultController(x) {
          if (!typeIsObject(x)) {
            return false;
          }
          if (!Object.prototype.hasOwnProperty.call(x, "_controlledTransformStream")) {
            return false;
          }
          return x instanceof TransformStreamDefaultController;
        }
        function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
          controller._controlledTransformStream = stream;
          stream._transformStreamController = controller;
          controller._transformAlgorithm = transformAlgorithm;
          controller._flushAlgorithm = flushAlgorithm;
        }
        function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
          const controller = Object.create(TransformStreamDefaultController.prototype);
          let transformAlgorithm = (chunk) => {
            try {
              TransformStreamDefaultControllerEnqueue(controller, chunk);
              return promiseResolvedWith(void 0);
            } catch (transformResultE) {
              return promiseRejectedWith(transformResultE);
            }
          };
          let flushAlgorithm = () => promiseResolvedWith(void 0);
          if (transformer.transform !== void 0) {
            transformAlgorithm = (chunk) => transformer.transform(chunk, controller);
          }
          if (transformer.flush !== void 0) {
            flushAlgorithm = () => transformer.flush(controller);
          }
          SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
        }
        function TransformStreamDefaultControllerClearAlgorithms(controller) {
          controller._transformAlgorithm = void 0;
          controller._flushAlgorithm = void 0;
        }
        function TransformStreamDefaultControllerEnqueue(controller, chunk) {
          const stream = controller._controlledTransformStream;
          const readableController = stream._readable._readableStreamController;
          if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
            throw new TypeError("Readable side is not in a state that permits enqueue");
          }
          try {
            ReadableStreamDefaultControllerEnqueue(readableController, chunk);
          } catch (e) {
            TransformStreamErrorWritableAndUnblockWrite(stream, e);
            throw stream._readable._storedError;
          }
          const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
          if (backpressure !== stream._backpressure) {
            TransformStreamSetBackpressure(stream, true);
          }
        }
        function TransformStreamDefaultControllerError(controller, e) {
          TransformStreamError(controller._controlledTransformStream, e);
        }
        function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
          const transformPromise = controller._transformAlgorithm(chunk);
          return transformPromiseWith(transformPromise, void 0, (r) => {
            TransformStreamError(controller._controlledTransformStream, r);
            throw r;
          });
        }
        function TransformStreamDefaultControllerTerminate(controller) {
          const stream = controller._controlledTransformStream;
          const readableController = stream._readable._readableStreamController;
          ReadableStreamDefaultControllerClose(readableController);
          const error2 = new TypeError("TransformStream terminated");
          TransformStreamErrorWritableAndUnblockWrite(stream, error2);
        }
        function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
          const controller = stream._transformStreamController;
          if (stream._backpressure) {
            const backpressureChangePromise = stream._backpressureChangePromise;
            return transformPromiseWith(backpressureChangePromise, () => {
              const writable2 = stream._writable;
              const state = writable2._state;
              if (state === "erroring") {
                throw writable2._storedError;
              }
              return TransformStreamDefaultControllerPerformTransform(controller, chunk);
            });
          }
          return TransformStreamDefaultControllerPerformTransform(controller, chunk);
        }
        function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
          TransformStreamError(stream, reason);
          return promiseResolvedWith(void 0);
        }
        function TransformStreamDefaultSinkCloseAlgorithm(stream) {
          const readable = stream._readable;
          const controller = stream._transformStreamController;
          const flushPromise = controller._flushAlgorithm();
          TransformStreamDefaultControllerClearAlgorithms(controller);
          return transformPromiseWith(flushPromise, () => {
            if (readable._state === "errored") {
              throw readable._storedError;
            }
            ReadableStreamDefaultControllerClose(readable._readableStreamController);
          }, (r) => {
            TransformStreamError(stream, r);
            throw readable._storedError;
          });
        }
        function TransformStreamDefaultSourcePullAlgorithm(stream) {
          TransformStreamSetBackpressure(stream, false);
          return stream._backpressureChangePromise;
        }
        function defaultControllerBrandCheckException(name2) {
          return new TypeError(`TransformStreamDefaultController.prototype.${name2} can only be used on a TransformStreamDefaultController`);
        }
        function streamBrandCheckException(name2) {
          return new TypeError(`TransformStream.prototype.${name2} can only be used on a TransformStream`);
        }
        exports3.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
        exports3.CountQueuingStrategy = CountQueuingStrategy;
        exports3.ReadableByteStreamController = ReadableByteStreamController;
        exports3.ReadableStream = ReadableStream2;
        exports3.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
        exports3.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
        exports3.ReadableStreamDefaultController = ReadableStreamDefaultController;
        exports3.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
        exports3.TransformStream = TransformStream;
        exports3.TransformStreamDefaultController = TransformStreamDefaultController;
        exports3.WritableStream = WritableStream;
        exports3.WritableStreamDefaultController = WritableStreamDefaultController;
        exports3.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
        Object.defineProperty(exports3, "__esModule", { value: true });
      });
    })(ponyfill_es2018, ponyfill_es2018.exports);
    POOL_SIZE$1 = 65536;
    if (!globalThis.ReadableStream) {
      try {
        Object.assign(globalThis, require("stream/web"));
      } catch (error2) {
        Object.assign(globalThis, ponyfill_es2018.exports);
      }
    }
    try {
      const { Blob: Blob3 } = require("buffer");
      if (Blob3 && !Blob3.prototype.stream) {
        Blob3.prototype.stream = function name2(params) {
          let position = 0;
          const blob = this;
          return new ReadableStream({
            type: "bytes",
            async pull(ctrl) {
              const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE$1));
              const buffer = await chunk.arrayBuffer();
              position += buffer.byteLength;
              ctrl.enqueue(new Uint8Array(buffer));
              if (position === blob.size) {
                ctrl.close();
              }
            }
          });
        };
      }
    } catch (error2) {
    }
    POOL_SIZE = 65536;
    _Blob = class Blob {
      #parts = [];
      #type = "";
      #size = 0;
      constructor(blobParts = [], options2 = {}) {
        let size = 0;
        const parts = blobParts.map((element) => {
          let part;
          if (ArrayBuffer.isView(element)) {
            part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));
          } else if (element instanceof ArrayBuffer) {
            part = new Uint8Array(element.slice(0));
          } else if (element instanceof Blob) {
            part = element;
          } else {
            part = new TextEncoder().encode(element);
          }
          size += ArrayBuffer.isView(part) ? part.byteLength : part.size;
          return part;
        });
        const type = options2.type === void 0 ? "" : String(options2.type);
        this.#type = /[^\u0020-\u007E]/.test(type) ? "" : type;
        this.#size = size;
        this.#parts = parts;
      }
      get size() {
        return this.#size;
      }
      get type() {
        return this.#type;
      }
      async text() {
        const decoder = new TextDecoder();
        let str = "";
        for await (let part of toIterator(this.#parts, false)) {
          str += decoder.decode(part, { stream: true });
        }
        str += decoder.decode();
        return str;
      }
      async arrayBuffer() {
        const data = new Uint8Array(this.size);
        let offset = 0;
        for await (const chunk of toIterator(this.#parts, false)) {
          data.set(chunk, offset);
          offset += chunk.length;
        }
        return data.buffer;
      }
      stream() {
        const it = toIterator(this.#parts, true);
        return new ReadableStream({
          type: "bytes",
          async pull(ctrl) {
            const chunk = await it.next();
            chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);
          }
        });
      }
      slice(start2 = 0, end = this.size, type = "") {
        const { size } = this;
        let relativeStart = start2 < 0 ? Math.max(size + start2, 0) : Math.min(start2, size);
        let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
        const span = Math.max(relativeEnd - relativeStart, 0);
        const parts = this.#parts;
        const blobParts = [];
        let added = 0;
        for (const part of parts) {
          if (added >= span) {
            break;
          }
          const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
          if (relativeStart && size2 <= relativeStart) {
            relativeStart -= size2;
            relativeEnd -= size2;
          } else {
            let chunk;
            if (ArrayBuffer.isView(part)) {
              chunk = part.subarray(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.byteLength;
            } else {
              chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
              added += chunk.size;
            }
            blobParts.push(chunk);
            relativeStart = 0;
          }
        }
        const blob = new Blob([], { type: String(type).toLowerCase() });
        blob.#size = span;
        blob.#parts = blobParts;
        return blob;
      }
      get [Symbol.toStringTag]() {
        return "Blob";
      }
      static [Symbol.hasInstance](object) {
        return object && typeof object === "object" && typeof object.constructor === "function" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
      }
    };
    Object.defineProperties(_Blob.prototype, {
      size: { enumerable: true },
      type: { enumerable: true },
      slice: { enumerable: true }
    });
    Blob2 = _Blob;
    Blob$1 = Blob2;
    FetchBaseError = class extends Error {
      constructor(message, type) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.type = type;
      }
      get name() {
        return this.constructor.name;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
    FetchError = class extends FetchBaseError {
      constructor(message, type, systemError) {
        super(message, type);
        if (systemError) {
          this.code = this.errno = systemError.code;
          this.erroredSysCall = systemError.syscall;
        }
      }
    };
    NAME = Symbol.toStringTag;
    isURLSearchParameters = (object) => {
      return typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && typeof object.sort === "function" && object[NAME] === "URLSearchParams";
    };
    isBlob = (object) => {
      return typeof object === "object" && typeof object.arrayBuffer === "function" && typeof object.type === "string" && typeof object.stream === "function" && typeof object.constructor === "function" && /^(Blob|File)$/.test(object[NAME]);
    };
    isAbortSignal = (object) => {
      return typeof object === "object" && (object[NAME] === "AbortSignal" || object[NAME] === "EventTarget");
    };
    carriage = "\r\n";
    dashes = "-".repeat(2);
    carriageLength = Buffer.byteLength(carriage);
    getFooter = (boundary) => `${dashes}${boundary}${dashes}${carriage.repeat(2)}`;
    getBoundary = () => (0, import_crypto.randomBytes)(8).toString("hex");
    INTERNALS$2 = Symbol("Body internals");
    Body = class {
      constructor(body, {
        size = 0
      } = {}) {
        let boundary = null;
        if (body === null) {
          body = null;
        } else if (isURLSearchParameters(body)) {
          body = Buffer.from(body.toString());
        } else if (isBlob(body))
          ;
        else if (Buffer.isBuffer(body))
          ;
        else if (import_util.types.isAnyArrayBuffer(body)) {
          body = Buffer.from(body);
        } else if (ArrayBuffer.isView(body)) {
          body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
        } else if (body instanceof import_stream.default)
          ;
        else if (isFormData(body)) {
          boundary = `NodeFetchFormDataBoundary${getBoundary()}`;
          body = import_stream.default.Readable.from(formDataIterator(body, boundary));
        } else {
          body = Buffer.from(String(body));
        }
        this[INTERNALS$2] = {
          body,
          boundary,
          disturbed: false,
          error: null
        };
        this.size = size;
        if (body instanceof import_stream.default) {
          body.on("error", (error_) => {
            const error2 = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, "system", error_);
            this[INTERNALS$2].error = error2;
          });
        }
      }
      get body() {
        return this[INTERNALS$2].body;
      }
      get bodyUsed() {
        return this[INTERNALS$2].disturbed;
      }
      async arrayBuffer() {
        const { buffer, byteOffset, byteLength } = await consumeBody(this);
        return buffer.slice(byteOffset, byteOffset + byteLength);
      }
      async blob() {
        const ct = this.headers && this.headers.get("content-type") || this[INTERNALS$2].body && this[INTERNALS$2].body.type || "";
        const buf = await this.buffer();
        return new Blob$1([buf], {
          type: ct
        });
      }
      async json() {
        const buffer = await consumeBody(this);
        return JSON.parse(buffer.toString());
      }
      async text() {
        const buffer = await consumeBody(this);
        return buffer.toString();
      }
      buffer() {
        return consumeBody(this);
      }
    };
    Object.defineProperties(Body.prototype, {
      body: { enumerable: true },
      bodyUsed: { enumerable: true },
      arrayBuffer: { enumerable: true },
      blob: { enumerable: true },
      json: { enumerable: true },
      text: { enumerable: true }
    });
    clone = (instance, highWaterMark) => {
      let p1;
      let p2;
      let { body } = instance;
      if (instance.bodyUsed) {
        throw new Error("cannot clone body after it is used");
      }
      if (body instanceof import_stream.default && typeof body.getBoundary !== "function") {
        p1 = new import_stream.PassThrough({ highWaterMark });
        p2 = new import_stream.PassThrough({ highWaterMark });
        body.pipe(p1);
        body.pipe(p2);
        instance[INTERNALS$2].body = p1;
        body = p2;
      }
      return body;
    };
    extractContentType = (body, request) => {
      if (body === null) {
        return null;
      }
      if (typeof body === "string") {
        return "text/plain;charset=UTF-8";
      }
      if (isURLSearchParameters(body)) {
        return "application/x-www-form-urlencoded;charset=UTF-8";
      }
      if (isBlob(body)) {
        return body.type || null;
      }
      if (Buffer.isBuffer(body) || import_util.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
        return null;
      }
      if (body && typeof body.getBoundary === "function") {
        return `multipart/form-data;boundary=${body.getBoundary()}`;
      }
      if (isFormData(body)) {
        return `multipart/form-data; boundary=${request[INTERNALS$2].boundary}`;
      }
      if (body instanceof import_stream.default) {
        return null;
      }
      return "text/plain;charset=UTF-8";
    };
    getTotalBytes = (request) => {
      const { body } = request;
      if (body === null) {
        return 0;
      }
      if (isBlob(body)) {
        return body.size;
      }
      if (Buffer.isBuffer(body)) {
        return body.length;
      }
      if (body && typeof body.getLengthSync === "function") {
        return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
      }
      if (isFormData(body)) {
        return getFormDataLength(request[INTERNALS$2].boundary);
      }
      return null;
    };
    writeToStream = (dest, { body }) => {
      if (body === null) {
        dest.end();
      } else if (isBlob(body)) {
        import_stream.default.Readable.from(body.stream()).pipe(dest);
      } else if (Buffer.isBuffer(body)) {
        dest.write(body);
        dest.end();
      } else {
        body.pipe(dest);
      }
    };
    validateHeaderName = typeof import_http.default.validateHeaderName === "function" ? import_http.default.validateHeaderName : (name2) => {
      if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name2)) {
        const error2 = new TypeError(`Header name must be a valid HTTP token [${name2}]`);
        Object.defineProperty(error2, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
        throw error2;
      }
    };
    validateHeaderValue = typeof import_http.default.validateHeaderValue === "function" ? import_http.default.validateHeaderValue : (name2, value) => {
      if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
        const error2 = new TypeError(`Invalid character in header content ["${name2}"]`);
        Object.defineProperty(error2, "code", { value: "ERR_INVALID_CHAR" });
        throw error2;
      }
    };
    Headers = class extends URLSearchParams {
      constructor(init2) {
        let result = [];
        if (init2 instanceof Headers) {
          const raw = init2.raw();
          for (const [name2, values] of Object.entries(raw)) {
            result.push(...values.map((value) => [name2, value]));
          }
        } else if (init2 == null)
          ;
        else if (typeof init2 === "object" && !import_util.types.isBoxedPrimitive(init2)) {
          const method = init2[Symbol.iterator];
          if (method == null) {
            result.push(...Object.entries(init2));
          } else {
            if (typeof method !== "function") {
              throw new TypeError("Header pairs must be iterable");
            }
            result = [...init2].map((pair) => {
              if (typeof pair !== "object" || import_util.types.isBoxedPrimitive(pair)) {
                throw new TypeError("Each header pair must be an iterable object");
              }
              return [...pair];
            }).map((pair) => {
              if (pair.length !== 2) {
                throw new TypeError("Each header pair must be a name/value tuple");
              }
              return [...pair];
            });
          }
        } else {
          throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
        }
        result = result.length > 0 ? result.map(([name2, value]) => {
          validateHeaderName(name2);
          validateHeaderValue(name2, String(value));
          return [String(name2).toLowerCase(), String(value)];
        }) : void 0;
        super(result);
        return new Proxy(this, {
          get(target, p, receiver) {
            switch (p) {
              case "append":
              case "set":
                return (name2, value) => {
                  validateHeaderName(name2);
                  validateHeaderValue(name2, String(value));
                  return URLSearchParams.prototype[p].call(target, String(name2).toLowerCase(), String(value));
                };
              case "delete":
              case "has":
              case "getAll":
                return (name2) => {
                  validateHeaderName(name2);
                  return URLSearchParams.prototype[p].call(target, String(name2).toLowerCase());
                };
              case "keys":
                return () => {
                  target.sort();
                  return new Set(URLSearchParams.prototype.keys.call(target)).keys();
                };
              default:
                return Reflect.get(target, p, receiver);
            }
          }
        });
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      toString() {
        return Object.prototype.toString.call(this);
      }
      get(name2) {
        const values = this.getAll(name2);
        if (values.length === 0) {
          return null;
        }
        let value = values.join(", ");
        if (/^content-encoding$/i.test(name2)) {
          value = value.toLowerCase();
        }
        return value;
      }
      forEach(callback, thisArg = void 0) {
        for (const name2 of this.keys()) {
          Reflect.apply(callback, thisArg, [this.get(name2), name2, this]);
        }
      }
      *values() {
        for (const name2 of this.keys()) {
          yield this.get(name2);
        }
      }
      *entries() {
        for (const name2 of this.keys()) {
          yield [name2, this.get(name2)];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      raw() {
        return [...this.keys()].reduce((result, key) => {
          result[key] = this.getAll(key);
          return result;
        }, {});
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return [...this.keys()].reduce((result, key) => {
          const values = this.getAll(key);
          if (key === "host") {
            result[key] = values[0];
          } else {
            result[key] = values.length > 1 ? values : values[0];
          }
          return result;
        }, {});
      }
    };
    Object.defineProperties(Headers.prototype, ["get", "entries", "forEach", "values"].reduce((result, property) => {
      result[property] = { enumerable: true };
      return result;
    }, {}));
    redirectStatus = new Set([301, 302, 303, 307, 308]);
    isRedirect = (code) => {
      return redirectStatus.has(code);
    };
    INTERNALS$1 = Symbol("Response internals");
    Response = class extends Body {
      constructor(body = null, options2 = {}) {
        super(body, options2);
        const status = options2.status != null ? options2.status : 200;
        const headers = new Headers(options2.headers);
        if (body !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(body);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        this[INTERNALS$1] = {
          type: "default",
          url: options2.url,
          status,
          statusText: options2.statusText || "",
          headers,
          counter: options2.counter,
          highWaterMark: options2.highWaterMark
        };
      }
      get type() {
        return this[INTERNALS$1].type;
      }
      get url() {
        return this[INTERNALS$1].url || "";
      }
      get status() {
        return this[INTERNALS$1].status;
      }
      get ok() {
        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
      }
      get redirected() {
        return this[INTERNALS$1].counter > 0;
      }
      get statusText() {
        return this[INTERNALS$1].statusText;
      }
      get headers() {
        return this[INTERNALS$1].headers;
      }
      get highWaterMark() {
        return this[INTERNALS$1].highWaterMark;
      }
      clone() {
        return new Response(clone(this, this.highWaterMark), {
          type: this.type,
          url: this.url,
          status: this.status,
          statusText: this.statusText,
          headers: this.headers,
          ok: this.ok,
          redirected: this.redirected,
          size: this.size
        });
      }
      static redirect(url, status = 302) {
        if (!isRedirect(status)) {
          throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
        }
        return new Response(null, {
          headers: {
            location: new URL(url).toString()
          },
          status
        });
      }
      static error() {
        const response = new Response(null, { status: 0, statusText: "" });
        response[INTERNALS$1].type = "error";
        return response;
      }
      get [Symbol.toStringTag]() {
        return "Response";
      }
    };
    Object.defineProperties(Response.prototype, {
      type: { enumerable: true },
      url: { enumerable: true },
      status: { enumerable: true },
      ok: { enumerable: true },
      redirected: { enumerable: true },
      statusText: { enumerable: true },
      headers: { enumerable: true },
      clone: { enumerable: true }
    });
    getSearch = (parsedURL) => {
      if (parsedURL.search) {
        return parsedURL.search;
      }
      const lastOffset = parsedURL.href.length - 1;
      const hash2 = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
      return parsedURL.href[lastOffset - hash2.length] === "?" ? "?" : "";
    };
    INTERNALS = Symbol("Request internals");
    isRequest = (object) => {
      return typeof object === "object" && typeof object[INTERNALS] === "object";
    };
    Request = class extends Body {
      constructor(input, init2 = {}) {
        let parsedURL;
        if (isRequest(input)) {
          parsedURL = new URL(input.url);
        } else {
          parsedURL = new URL(input);
          input = {};
        }
        let method = init2.method || input.method || "GET";
        method = method.toUpperCase();
        if ((init2.body != null || isRequest(input)) && input.body !== null && (method === "GET" || method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body");
        }
        const inputBody = init2.body ? init2.body : isRequest(input) && input.body !== null ? clone(input) : null;
        super(inputBody, {
          size: init2.size || input.size || 0
        });
        const headers = new Headers(init2.headers || input.headers || {});
        if (inputBody !== null && !headers.has("Content-Type")) {
          const contentType = extractContentType(inputBody, this);
          if (contentType) {
            headers.append("Content-Type", contentType);
          }
        }
        let signal = isRequest(input) ? input.signal : null;
        if ("signal" in init2) {
          signal = init2.signal;
        }
        if (signal != null && !isAbortSignal(signal)) {
          throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
        }
        this[INTERNALS] = {
          method,
          redirect: init2.redirect || input.redirect || "follow",
          headers,
          parsedURL,
          signal
        };
        this.follow = init2.follow === void 0 ? input.follow === void 0 ? 20 : input.follow : init2.follow;
        this.compress = init2.compress === void 0 ? input.compress === void 0 ? true : input.compress : init2.compress;
        this.counter = init2.counter || input.counter || 0;
        this.agent = init2.agent || input.agent;
        this.highWaterMark = init2.highWaterMark || input.highWaterMark || 16384;
        this.insecureHTTPParser = init2.insecureHTTPParser || input.insecureHTTPParser || false;
      }
      get method() {
        return this[INTERNALS].method;
      }
      get url() {
        return (0, import_url.format)(this[INTERNALS].parsedURL);
      }
      get headers() {
        return this[INTERNALS].headers;
      }
      get redirect() {
        return this[INTERNALS].redirect;
      }
      get signal() {
        return this[INTERNALS].signal;
      }
      clone() {
        return new Request(this);
      }
      get [Symbol.toStringTag]() {
        return "Request";
      }
    };
    Object.defineProperties(Request.prototype, {
      method: { enumerable: true },
      url: { enumerable: true },
      headers: { enumerable: true },
      redirect: { enumerable: true },
      clone: { enumerable: true },
      signal: { enumerable: true }
    });
    getNodeRequestOptions = (request) => {
      const { parsedURL } = request[INTERNALS];
      const headers = new Headers(request[INTERNALS].headers);
      if (!headers.has("Accept")) {
        headers.set("Accept", "*/*");
      }
      let contentLengthValue = null;
      if (request.body === null && /^(post|put)$/i.test(request.method)) {
        contentLengthValue = "0";
      }
      if (request.body !== null) {
        const totalBytes = getTotalBytes(request);
        if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
          contentLengthValue = String(totalBytes);
        }
      }
      if (contentLengthValue) {
        headers.set("Content-Length", contentLengthValue);
      }
      if (!headers.has("User-Agent")) {
        headers.set("User-Agent", "node-fetch");
      }
      if (request.compress && !headers.has("Accept-Encoding")) {
        headers.set("Accept-Encoding", "gzip,deflate,br");
      }
      let { agent } = request;
      if (typeof agent === "function") {
        agent = agent(parsedURL);
      }
      if (!headers.has("Connection") && !agent) {
        headers.set("Connection", "close");
      }
      const search = getSearch(parsedURL);
      const requestOptions = {
        path: parsedURL.pathname + search,
        pathname: parsedURL.pathname,
        hostname: parsedURL.hostname,
        protocol: parsedURL.protocol,
        port: parsedURL.port,
        hash: parsedURL.hash,
        search: parsedURL.search,
        query: parsedURL.query,
        href: parsedURL.href,
        method: request.method,
        headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
        insecureHTTPParser: request.insecureHTTPParser,
        agent
      };
      return requestOptions;
    };
    AbortError = class extends FetchBaseError {
      constructor(message, type = "aborted") {
        super(message, type);
      }
    };
    supportedSchemas = new Set(["data:", "http:", "https:"]);
  }
});

// node_modules/@sveltejs/adapter-netlify/files/shims.js
var init_shims = __esm({
  "node_modules/@sveltejs/adapter-netlify/files/shims.js"() {
    init_install_fetch();
  }
});

// node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/tslib/tslib.js"(exports2, module2) {
    init_shims();
    var __extends2;
    var __assign2;
    var __rest2;
    var __decorate2;
    var __param2;
    var __metadata2;
    var __awaiter2;
    var __generator2;
    var __exportStar2;
    var __values2;
    var __read2;
    var __spread2;
    var __spreadArrays2;
    var __spreadArray2;
    var __await2;
    var __asyncGenerator2;
    var __asyncDelegator2;
    var __asyncValues2;
    var __makeTemplateObject2;
    var __importStar2;
    var __importDefault2;
    var __classPrivateFieldGet2;
    var __classPrivateFieldSet2;
    var __createBinding2;
    (function(factory2) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports3) {
          factory2(createExporter(root, createExporter(exports3)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory2(createExporter(root, createExporter(module2.exports)));
      } else {
        factory2(createExporter(root));
      }
      function createExporter(exports3, previous) {
        if (exports3 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports3, "__esModule", { value: true });
          } else {
            exports3.__esModule = true;
          }
        }
        return function(id, v) {
          return exports3[id] = previous ? previous(id, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b) {
        d2.__proto__ = b;
      } || function(d2, b) {
        for (var p in b)
          if (Object.prototype.hasOwnProperty.call(b, p))
            d2[p] = b[p];
      };
      __extends2 = function(d2, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d2, b);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      __assign2 = Object.assign || function(t) {
        for (var s2, i = 1, n = arguments.length; i < n; i++) {
          s2 = arguments[i];
          for (var p in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p))
              t[p] = s2[p];
        }
        return t;
      };
      __rest2 = function(s2, e) {
        var t = {};
        for (var p in s2)
          if (Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0)
            t[p] = s2[p];
        if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s2); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]))
              t[p[i]] = s2[p[i]];
          }
        return t;
      };
      __decorate2 = function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d2 = decorators[i])
              r = (c < 3 ? d2(r) : c > 3 ? d2(target, key, r) : d2(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      __param2 = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata2 = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter2 = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve2) {
            resolve2(value);
          });
        }
        return new (P || (P = Promise))(function(resolve2, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator2 = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar2 = function(m, o) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
            __createBinding2(o, m, p);
      };
      __createBinding2 = Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      };
      __values2 = function(o) {
        var s2 = typeof Symbol === "function" && Symbol.iterator, m = s2 && o[s2], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
        throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read2 = function(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
          return o;
        var i = m.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
            ar.push(r.value);
        } catch (error2) {
          e = { error: error2 };
        } finally {
          try {
            if (r && !r.done && (m = i["return"]))
              m.call(i);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      };
      __spread2 = function() {
        for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read2(arguments[i]));
        return ar;
      };
      __spreadArrays2 = function() {
        for (var s2 = 0, i = 0, il = arguments.length; i < il; i++)
          s2 += arguments[i].length;
        for (var r = Array(s2), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
        return r;
      };
      __spreadArray2 = function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      __await2 = function(v) {
        return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
      };
      __asyncGenerator2 = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i;
        function verb(n) {
          if (g[n])
            i[n] = function(v) {
              return new Promise(function(a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
              });
            };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      };
      __asyncDelegator2 = function(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function(e) {
          throw e;
        }), verb("return"), i[Symbol.iterator] = function() {
          return this;
        }, i;
        function verb(n, f) {
          i[n] = o[n] ? function(v) {
            return (p = !p) ? { value: __await2(o[n](v)), done: n === "return" } : f ? f(v) : v;
          } : f;
        }
      };
      __asyncValues2 = function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function(v) {
            return new Promise(function(resolve2, reject) {
              v = o[n](v), settle(resolve2, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve2, reject, d2, v) {
          Promise.resolve(v).then(function(v2) {
            resolve2({ value: v2, done: d2 });
          }, reject);
        }
      };
      __makeTemplateObject2 = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      };
      __importStar2 = function(mod2) {
        if (mod2 && mod2.__esModule)
          return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k in mod2)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
              __createBinding2(result, mod2, k);
        }
        __setModuleDefault(result, mod2);
        return result;
      };
      __importDefault2 = function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      __classPrivateFieldGet2 = function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      exporter("__extends", __extends2);
      exporter("__assign", __assign2);
      exporter("__rest", __rest2);
      exporter("__decorate", __decorate2);
      exporter("__param", __param2);
      exporter("__metadata", __metadata2);
      exporter("__awaiter", __awaiter2);
      exporter("__generator", __generator2);
      exporter("__exportStar", __exportStar2);
      exporter("__createBinding", __createBinding2);
      exporter("__values", __values2);
      exporter("__read", __read2);
      exporter("__spread", __spread2);
      exporter("__spreadArrays", __spreadArrays2);
      exporter("__spreadArray", __spreadArray2);
      exporter("__await", __await2);
      exporter("__asyncGenerator", __asyncGenerator2);
      exporter("__asyncDelegator", __asyncDelegator2);
      exporter("__asyncValues", __asyncValues2);
      exporter("__makeTemplateObject", __makeTemplateObject2);
      exporter("__importStar", __importStar2);
      exporter("__importDefault", __importDefault2);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
    });
  }
});

// node_modules/@firebase/util/dist/index.node.cjs.js
var require_index_node_cjs = __commonJS({
  "node_modules/@firebase/util/dist/index.node.cjs.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib2 = require_tslib();
    var CONSTANTS = {
      NODE_CLIENT: false,
      NODE_ADMIN: false,
      SDK_VERSION: "${JSCORE_VERSION}"
    };
    var assert = function(assertion, message) {
      if (!assertion) {
        throw assertionError(message);
      }
    };
    var assertionError = function(message) {
      return new Error("Firebase Database (" + CONSTANTS.SDK_VERSION + ") INTERNAL ASSERT FAILED: " + message);
    };
    var stringToByteArray$12 = function(str) {
      var out = [];
      var p = 0;
      for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        if (c < 128) {
          out[p++] = c;
        } else if (c < 2048) {
          out[p++] = c >> 6 | 192;
          out[p++] = c & 63 | 128;
        } else if ((c & 64512) === 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) === 56320) {
          c = 65536 + ((c & 1023) << 10) + (str.charCodeAt(++i) & 1023);
          out[p++] = c >> 18 | 240;
          out[p++] = c >> 12 & 63 | 128;
          out[p++] = c >> 6 & 63 | 128;
          out[p++] = c & 63 | 128;
        } else {
          out[p++] = c >> 12 | 224;
          out[p++] = c >> 6 & 63 | 128;
          out[p++] = c & 63 | 128;
        }
      }
      return out;
    };
    var byteArrayToString2 = function(bytes) {
      var out = [];
      var pos = 0, c = 0;
      while (pos < bytes.length) {
        var c1 = bytes[pos++];
        if (c1 < 128) {
          out[c++] = String.fromCharCode(c1);
        } else if (c1 > 191 && c1 < 224) {
          var c2 = bytes[pos++];
          out[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);
        } else if (c1 > 239 && c1 < 365) {
          var c2 = bytes[pos++];
          var c3 = bytes[pos++];
          var c4 = bytes[pos++];
          var u = ((c1 & 7) << 18 | (c2 & 63) << 12 | (c3 & 63) << 6 | c4 & 63) - 65536;
          out[c++] = String.fromCharCode(55296 + (u >> 10));
          out[c++] = String.fromCharCode(56320 + (u & 1023));
        } else {
          var c2 = bytes[pos++];
          var c3 = bytes[pos++];
          out[c++] = String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
        }
      }
      return out.join("");
    };
    var base642 = {
      byteToCharMap_: null,
      charToByteMap_: null,
      byteToCharMapWebSafe_: null,
      charToByteMapWebSafe_: null,
      ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
      get ENCODED_VALS() {
        return this.ENCODED_VALS_BASE + "+/=";
      },
      get ENCODED_VALS_WEBSAFE() {
        return this.ENCODED_VALS_BASE + "-_.";
      },
      HAS_NATIVE_SUPPORT: typeof atob === "function",
      encodeByteArray: function(input, webSafe) {
        if (!Array.isArray(input)) {
          throw Error("encodeByteArray takes an array as a parameter");
        }
        this.init_();
        var byteToCharMap = webSafe ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;
        var output = [];
        for (var i = 0; i < input.length; i += 3) {
          var byte1 = input[i];
          var haveByte2 = i + 1 < input.length;
          var byte2 = haveByte2 ? input[i + 1] : 0;
          var haveByte3 = i + 2 < input.length;
          var byte3 = haveByte3 ? input[i + 2] : 0;
          var outByte1 = byte1 >> 2;
          var outByte2 = (byte1 & 3) << 4 | byte2 >> 4;
          var outByte3 = (byte2 & 15) << 2 | byte3 >> 6;
          var outByte4 = byte3 & 63;
          if (!haveByte3) {
            outByte4 = 64;
            if (!haveByte2) {
              outByte3 = 64;
            }
          }
          output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);
        }
        return output.join("");
      },
      encodeString: function(input, webSafe) {
        if (this.HAS_NATIVE_SUPPORT && !webSafe) {
          return btoa(input);
        }
        return this.encodeByteArray(stringToByteArray$12(input), webSafe);
      },
      decodeString: function(input, webSafe) {
        if (this.HAS_NATIVE_SUPPORT && !webSafe) {
          return atob(input);
        }
        return byteArrayToString2(this.decodeStringToByteArray(input, webSafe));
      },
      decodeStringToByteArray: function(input, webSafe) {
        this.init_();
        var charToByteMap = webSafe ? this.charToByteMapWebSafe_ : this.charToByteMap_;
        var output = [];
        for (var i = 0; i < input.length; ) {
          var byte1 = charToByteMap[input.charAt(i++)];
          var haveByte2 = i < input.length;
          var byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;
          ++i;
          var haveByte3 = i < input.length;
          var byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;
          ++i;
          var haveByte4 = i < input.length;
          var byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;
          ++i;
          if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {
            throw Error();
          }
          var outByte1 = byte1 << 2 | byte2 >> 4;
          output.push(outByte1);
          if (byte3 !== 64) {
            var outByte2 = byte2 << 4 & 240 | byte3 >> 2;
            output.push(outByte2);
            if (byte4 !== 64) {
              var outByte3 = byte3 << 6 & 192 | byte4;
              output.push(outByte3);
            }
          }
        }
        return output;
      },
      init_: function() {
        if (!this.byteToCharMap_) {
          this.byteToCharMap_ = {};
          this.charToByteMap_ = {};
          this.byteToCharMapWebSafe_ = {};
          this.charToByteMapWebSafe_ = {};
          for (var i = 0; i < this.ENCODED_VALS.length; i++) {
            this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);
            this.charToByteMap_[this.byteToCharMap_[i]] = i;
            this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);
            this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;
            if (i >= this.ENCODED_VALS_BASE.length) {
              this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;
              this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;
            }
          }
        }
      }
    };
    var base64Encode = function(str) {
      var utf8Bytes = stringToByteArray$12(str);
      return base642.encodeByteArray(utf8Bytes, true);
    };
    var base64urlEncodeWithoutPadding = function(str) {
      return base64Encode(str).replace(/\./g, "");
    };
    var base64Decode2 = function(str) {
      try {
        return base642.decodeString(str, true);
      } catch (e) {
        console.error("base64Decode failed: ", e);
      }
      return null;
    };
    function deepCopy(value) {
      return deepExtend(void 0, value);
    }
    function deepExtend(target, source) {
      if (!(source instanceof Object)) {
        return source;
      }
      switch (source.constructor) {
        case Date:
          var dateValue = source;
          return new Date(dateValue.getTime());
        case Object:
          if (target === void 0) {
            target = {};
          }
          break;
        case Array:
          target = [];
          break;
        default:
          return source;
      }
      for (var prop in source) {
        if (!source.hasOwnProperty(prop) || !isValidKey(prop)) {
          continue;
        }
        target[prop] = deepExtend(target[prop], source[prop]);
      }
      return target;
    }
    function isValidKey(key) {
      return key !== "__proto__";
    }
    var Deferred2 = function() {
      function Deferred3() {
        var _this = this;
        this.reject = function() {
        };
        this.resolve = function() {
        };
        this.promise = new Promise(function(resolve2, reject) {
          _this.resolve = resolve2;
          _this.reject = reject;
        });
      }
      Deferred3.prototype.wrapCallback = function(callback) {
        var _this = this;
        return function(error2, value) {
          if (error2) {
            _this.reject(error2);
          } else {
            _this.resolve(value);
          }
          if (typeof callback === "function") {
            _this.promise.catch(function() {
            });
            if (callback.length === 1) {
              callback(error2);
            } else {
              callback(error2, value);
            }
          }
        };
      };
      return Deferred3;
    }();
    function createMockUserToken(token, projectId) {
      if (token.uid) {
        throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');
      }
      var header = {
        alg: "none",
        type: "JWT"
      };
      var project = projectId || "demo-project";
      var iat = token.iat || 0;
      var sub = token.sub || token.user_id;
      if (!sub) {
        throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");
      }
      var payload = tslib2.__assign({
        iss: "https://securetoken.google.com/" + project,
        aud: project,
        iat,
        exp: iat + 3600,
        auth_time: iat,
        sub,
        user_id: sub,
        firebase: {
          sign_in_provider: "custom",
          identities: {}
        }
      }, token);
      var signature = "";
      return [
        base64urlEncodeWithoutPadding(JSON.stringify(header)),
        base64urlEncodeWithoutPadding(JSON.stringify(payload)),
        signature
      ].join(".");
    }
    function getUA2() {
      if (typeof navigator !== "undefined" && typeof navigator["userAgent"] === "string") {
        return navigator["userAgent"];
      } else {
        return "";
      }
    }
    function isMobileCordova2() {
      return typeof window !== "undefined" && !!(window["cordova"] || window["phonegap"] || window["PhoneGap"]) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA2());
    }
    function isNode() {
      try {
        return Object.prototype.toString.call(global.process) === "[object process]";
      } catch (e) {
        return false;
      }
    }
    function isBrowser() {
      return typeof self === "object" && self.self === self;
    }
    function isBrowserExtension2() {
      var runtime = typeof chrome === "object" ? chrome.runtime : typeof browser === "object" ? browser.runtime : void 0;
      return typeof runtime === "object" && runtime.id !== void 0;
    }
    function isReactNative2() {
      return typeof navigator === "object" && navigator["product"] === "ReactNative";
    }
    function isElectron() {
      return getUA2().indexOf("Electron/") >= 0;
    }
    function isIE2() {
      var ua = getUA2();
      return ua.indexOf("MSIE ") >= 0 || ua.indexOf("Trident/") >= 0;
    }
    function isUWP() {
      return getUA2().indexOf("MSAppHost/") >= 0;
    }
    function isNodeSdk() {
      return CONSTANTS.NODE_CLIENT === true || CONSTANTS.NODE_ADMIN === true;
    }
    function isSafari() {
      return !isNode() && navigator.userAgent.includes("Safari") && !navigator.userAgent.includes("Chrome");
    }
    function isIndexedDBAvailable2() {
      return typeof indexedDB === "object";
    }
    function validateIndexedDBOpenable2() {
      return new Promise(function(resolve2, reject) {
        try {
          var preExist_1 = true;
          var DB_CHECK_NAME_1 = "validate-browser-context-for-indexeddb-analytics-module";
          var request_1 = self.indexedDB.open(DB_CHECK_NAME_1);
          request_1.onsuccess = function() {
            request_1.result.close();
            if (!preExist_1) {
              self.indexedDB.deleteDatabase(DB_CHECK_NAME_1);
            }
            resolve2(true);
          };
          request_1.onupgradeneeded = function() {
            preExist_1 = false;
          };
          request_1.onerror = function() {
            var _a;
            reject(((_a = request_1.error) === null || _a === void 0 ? void 0 : _a.message) || "");
          };
        } catch (error2) {
          reject(error2);
        }
      });
    }
    function areCookiesEnabled2() {
      if (typeof navigator === "undefined" || !navigator.cookieEnabled) {
        return false;
      }
      return true;
    }
    function getGlobal() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw new Error("Unable to locate global object.");
    }
    var ERROR_NAME2 = "FirebaseError";
    var FirebaseError2 = function(_super) {
      tslib2.__extends(FirebaseError3, _super);
      function FirebaseError3(code, message, customData) {
        var _this = _super.call(this, message) || this;
        _this.code = code;
        _this.customData = customData;
        _this.name = ERROR_NAME2;
        Object.setPrototypeOf(_this, FirebaseError3.prototype);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(_this, ErrorFactory2.prototype.create);
        }
        return _this;
      }
      return FirebaseError3;
    }(Error);
    var ErrorFactory2 = function() {
      function ErrorFactory3(service, serviceName, errors) {
        this.service = service;
        this.serviceName = serviceName;
        this.errors = errors;
      }
      ErrorFactory3.prototype.create = function(code) {
        var data = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          data[_i - 1] = arguments[_i];
        }
        var customData = data[0] || {};
        var fullCode = this.service + "/" + code;
        var template2 = this.errors[code];
        var message = template2 ? replaceTemplate2(template2, customData) : "Error";
        var fullMessage = this.serviceName + ": " + message + " (" + fullCode + ").";
        var error2 = new FirebaseError2(fullCode, fullMessage, customData);
        return error2;
      };
      return ErrorFactory3;
    }();
    function replaceTemplate2(template2, data) {
      return template2.replace(PATTERN2, function(_, key) {
        var value = data[key];
        return value != null ? String(value) : "<" + key + "?>";
      });
    }
    var PATTERN2 = /\{\$([^}]+)}/g;
    function jsonEval(str) {
      return JSON.parse(str);
    }
    function stringify(data) {
      return JSON.stringify(data);
    }
    var decode = function(token) {
      var header = {}, claims = {}, data = {}, signature = "";
      try {
        var parts = token.split(".");
        header = jsonEval(base64Decode2(parts[0]) || "");
        claims = jsonEval(base64Decode2(parts[1]) || "");
        signature = parts[2];
        data = claims["d"] || {};
        delete claims["d"];
      } catch (e) {
      }
      return {
        header,
        claims,
        data,
        signature
      };
    };
    var isValidTimestamp = function(token) {
      var claims = decode(token).claims;
      var now = Math.floor(new Date().getTime() / 1e3);
      var validSince = 0, validUntil = 0;
      if (typeof claims === "object") {
        if (claims.hasOwnProperty("nbf")) {
          validSince = claims["nbf"];
        } else if (claims.hasOwnProperty("iat")) {
          validSince = claims["iat"];
        }
        if (claims.hasOwnProperty("exp")) {
          validUntil = claims["exp"];
        } else {
          validUntil = validSince + 86400;
        }
      }
      return !!now && !!validSince && !!validUntil && now >= validSince && now <= validUntil;
    };
    var issuedAtTime = function(token) {
      var claims = decode(token).claims;
      if (typeof claims === "object" && claims.hasOwnProperty("iat")) {
        return claims["iat"];
      }
      return null;
    };
    var isValidFormat = function(token) {
      var decoded = decode(token), claims = decoded.claims;
      return !!claims && typeof claims === "object" && claims.hasOwnProperty("iat");
    };
    var isAdmin = function(token) {
      var claims = decode(token).claims;
      return typeof claims === "object" && claims["admin"] === true;
    };
    function contains(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    function safeGet(obj, key) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        return obj[key];
      } else {
        return void 0;
      }
    }
    function isEmpty2(obj) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          return false;
        }
      }
      return true;
    }
    function map(obj, fn, contextObj) {
      var res = {};
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          res[key] = fn.call(contextObj, obj[key], key, obj);
        }
      }
      return res;
    }
    function deepEqual2(a, b) {
      if (a === b) {
        return true;
      }
      var aKeys = Object.keys(a);
      var bKeys = Object.keys(b);
      for (var _i = 0, aKeys_1 = aKeys; _i < aKeys_1.length; _i++) {
        var k = aKeys_1[_i];
        if (!bKeys.includes(k)) {
          return false;
        }
        var aProp = a[k];
        var bProp = b[k];
        if (isObject2(aProp) && isObject2(bProp)) {
          if (!deepEqual2(aProp, bProp)) {
            return false;
          }
        } else if (aProp !== bProp) {
          return false;
        }
      }
      for (var _a = 0, bKeys_1 = bKeys; _a < bKeys_1.length; _a++) {
        var k = bKeys_1[_a];
        if (!aKeys.includes(k)) {
          return false;
        }
      }
      return true;
    }
    function isObject2(thing) {
      return thing !== null && typeof thing === "object";
    }
    function querystring2(querystringParams) {
      var params = [];
      var _loop_1 = function(key2, value2) {
        if (Array.isArray(value2)) {
          value2.forEach(function(arrayVal) {
            params.push(encodeURIComponent(key2) + "=" + encodeURIComponent(arrayVal));
          });
        } else {
          params.push(encodeURIComponent(key2) + "=" + encodeURIComponent(value2));
        }
      };
      for (var _i = 0, _a = Object.entries(querystringParams); _i < _a.length; _i++) {
        var _b = _a[_i], key = _b[0], value = _b[1];
        _loop_1(key, value);
      }
      return params.length ? "&" + params.join("&") : "";
    }
    function querystringDecode(querystring3) {
      var obj = {};
      var tokens = querystring3.replace(/^\?/, "").split("&");
      tokens.forEach(function(token) {
        if (token) {
          var _a = token.split("="), key = _a[0], value = _a[1];
          obj[decodeURIComponent(key)] = decodeURIComponent(value);
        }
      });
      return obj;
    }
    function extractQuerystring(url) {
      var queryStart = url.indexOf("?");
      if (!queryStart) {
        return "";
      }
      var fragmentStart = url.indexOf("#", queryStart);
      return url.substring(queryStart, fragmentStart > 0 ? fragmentStart : void 0);
    }
    var Sha1 = function() {
      function Sha12() {
        this.chain_ = [];
        this.buf_ = [];
        this.W_ = [];
        this.pad_ = [];
        this.inbuf_ = 0;
        this.total_ = 0;
        this.blockSize = 512 / 8;
        this.pad_[0] = 128;
        for (var i = 1; i < this.blockSize; ++i) {
          this.pad_[i] = 0;
        }
        this.reset();
      }
      Sha12.prototype.reset = function() {
        this.chain_[0] = 1732584193;
        this.chain_[1] = 4023233417;
        this.chain_[2] = 2562383102;
        this.chain_[3] = 271733878;
        this.chain_[4] = 3285377520;
        this.inbuf_ = 0;
        this.total_ = 0;
      };
      Sha12.prototype.compress_ = function(buf, offset) {
        if (!offset) {
          offset = 0;
        }
        var W = this.W_;
        if (typeof buf === "string") {
          for (var i = 0; i < 16; i++) {
            W[i] = buf.charCodeAt(offset) << 24 | buf.charCodeAt(offset + 1) << 16 | buf.charCodeAt(offset + 2) << 8 | buf.charCodeAt(offset + 3);
            offset += 4;
          }
        } else {
          for (var i = 0; i < 16; i++) {
            W[i] = buf[offset] << 24 | buf[offset + 1] << 16 | buf[offset + 2] << 8 | buf[offset + 3];
            offset += 4;
          }
        }
        for (var i = 16; i < 80; i++) {
          var t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
          W[i] = (t << 1 | t >>> 31) & 4294967295;
        }
        var a = this.chain_[0];
        var b = this.chain_[1];
        var c = this.chain_[2];
        var d2 = this.chain_[3];
        var e = this.chain_[4];
        var f, k;
        for (var i = 0; i < 80; i++) {
          if (i < 40) {
            if (i < 20) {
              f = d2 ^ b & (c ^ d2);
              k = 1518500249;
            } else {
              f = b ^ c ^ d2;
              k = 1859775393;
            }
          } else {
            if (i < 60) {
              f = b & c | d2 & (b | c);
              k = 2400959708;
            } else {
              f = b ^ c ^ d2;
              k = 3395469782;
            }
          }
          var t = (a << 5 | a >>> 27) + f + e + k + W[i] & 4294967295;
          e = d2;
          d2 = c;
          c = (b << 30 | b >>> 2) & 4294967295;
          b = a;
          a = t;
        }
        this.chain_[0] = this.chain_[0] + a & 4294967295;
        this.chain_[1] = this.chain_[1] + b & 4294967295;
        this.chain_[2] = this.chain_[2] + c & 4294967295;
        this.chain_[3] = this.chain_[3] + d2 & 4294967295;
        this.chain_[4] = this.chain_[4] + e & 4294967295;
      };
      Sha12.prototype.update = function(bytes, length) {
        if (bytes == null) {
          return;
        }
        if (length === void 0) {
          length = bytes.length;
        }
        var lengthMinusBlock = length - this.blockSize;
        var n = 0;
        var buf = this.buf_;
        var inbuf = this.inbuf_;
        while (n < length) {
          if (inbuf === 0) {
            while (n <= lengthMinusBlock) {
              this.compress_(bytes, n);
              n += this.blockSize;
            }
          }
          if (typeof bytes === "string") {
            while (n < length) {
              buf[inbuf] = bytes.charCodeAt(n);
              ++inbuf;
              ++n;
              if (inbuf === this.blockSize) {
                this.compress_(buf);
                inbuf = 0;
                break;
              }
            }
          } else {
            while (n < length) {
              buf[inbuf] = bytes[n];
              ++inbuf;
              ++n;
              if (inbuf === this.blockSize) {
                this.compress_(buf);
                inbuf = 0;
                break;
              }
            }
          }
        }
        this.inbuf_ = inbuf;
        this.total_ += length;
      };
      Sha12.prototype.digest = function() {
        var digest = [];
        var totalBits = this.total_ * 8;
        if (this.inbuf_ < 56) {
          this.update(this.pad_, 56 - this.inbuf_);
        } else {
          this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));
        }
        for (var i = this.blockSize - 1; i >= 56; i--) {
          this.buf_[i] = totalBits & 255;
          totalBits /= 256;
        }
        this.compress_(this.buf_);
        var n = 0;
        for (var i = 0; i < 5; i++) {
          for (var j = 24; j >= 0; j -= 8) {
            digest[n] = this.chain_[i] >> j & 255;
            ++n;
          }
        }
        return digest;
      };
      return Sha12;
    }();
    function createSubscribe2(executor, onNoObservers) {
      var proxy = new ObserverProxy2(executor, onNoObservers);
      return proxy.subscribe.bind(proxy);
    }
    var ObserverProxy2 = function() {
      function ObserverProxy3(executor, onNoObservers) {
        var _this = this;
        this.observers = [];
        this.unsubscribes = [];
        this.observerCount = 0;
        this.task = Promise.resolve();
        this.finalized = false;
        this.onNoObservers = onNoObservers;
        this.task.then(function() {
          executor(_this);
        }).catch(function(e) {
          _this.error(e);
        });
      }
      ObserverProxy3.prototype.next = function(value) {
        this.forEachObserver(function(observer) {
          observer.next(value);
        });
      };
      ObserverProxy3.prototype.error = function(error2) {
        this.forEachObserver(function(observer) {
          observer.error(error2);
        });
        this.close(error2);
      };
      ObserverProxy3.prototype.complete = function() {
        this.forEachObserver(function(observer) {
          observer.complete();
        });
        this.close();
      };
      ObserverProxy3.prototype.subscribe = function(nextOrObserver, error2, complete) {
        var _this = this;
        var observer;
        if (nextOrObserver === void 0 && error2 === void 0 && complete === void 0) {
          throw new Error("Missing Observer.");
        }
        if (implementsAnyMethods2(nextOrObserver, [
          "next",
          "error",
          "complete"
        ])) {
          observer = nextOrObserver;
        } else {
          observer = {
            next: nextOrObserver,
            error: error2,
            complete
          };
        }
        if (observer.next === void 0) {
          observer.next = noop2;
        }
        if (observer.error === void 0) {
          observer.error = noop2;
        }
        if (observer.complete === void 0) {
          observer.complete = noop2;
        }
        var unsub = this.unsubscribeOne.bind(this, this.observers.length);
        if (this.finalized) {
          this.task.then(function() {
            try {
              if (_this.finalError) {
                observer.error(_this.finalError);
              } else {
                observer.complete();
              }
            } catch (e) {
            }
            return;
          });
        }
        this.observers.push(observer);
        return unsub;
      };
      ObserverProxy3.prototype.unsubscribeOne = function(i) {
        if (this.observers === void 0 || this.observers[i] === void 0) {
          return;
        }
        delete this.observers[i];
        this.observerCount -= 1;
        if (this.observerCount === 0 && this.onNoObservers !== void 0) {
          this.onNoObservers(this);
        }
      };
      ObserverProxy3.prototype.forEachObserver = function(fn) {
        if (this.finalized) {
          return;
        }
        for (var i = 0; i < this.observers.length; i++) {
          this.sendOne(i, fn);
        }
      };
      ObserverProxy3.prototype.sendOne = function(i, fn) {
        var _this = this;
        this.task.then(function() {
          if (_this.observers !== void 0 && _this.observers[i] !== void 0) {
            try {
              fn(_this.observers[i]);
            } catch (e) {
              if (typeof console !== "undefined" && console.error) {
                console.error(e);
              }
            }
          }
        });
      };
      ObserverProxy3.prototype.close = function(err) {
        var _this = this;
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        if (err !== void 0) {
          this.finalError = err;
        }
        this.task.then(function() {
          _this.observers = void 0;
          _this.onNoObservers = void 0;
        });
      };
      return ObserverProxy3;
    }();
    function async(fn, onError) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        Promise.resolve(true).then(function() {
          fn.apply(void 0, args);
        }).catch(function(error2) {
          if (onError) {
            onError(error2);
          }
        });
      };
    }
    function implementsAnyMethods2(obj, methods) {
      if (typeof obj !== "object" || obj === null) {
        return false;
      }
      for (var _i = 0, methods_1 = methods; _i < methods_1.length; _i++) {
        var method = methods_1[_i];
        if (method in obj && typeof obj[method] === "function") {
          return true;
        }
      }
      return false;
    }
    function noop2() {
    }
    var validateArgCount = function(fnName, minCount, maxCount, argCount) {
      var argError;
      if (argCount < minCount) {
        argError = "at least " + minCount;
      } else if (argCount > maxCount) {
        argError = maxCount === 0 ? "none" : "no more than " + maxCount;
      }
      if (argError) {
        var error2 = fnName + " failed: Was called with " + argCount + (argCount === 1 ? " argument." : " arguments.") + " Expects " + argError + ".";
        throw new Error(error2);
      }
    };
    function errorPrefix(fnName, argName) {
      return fnName + " failed: " + argName + " argument ";
    }
    function validateNamespace(fnName, namespace, optional) {
      if (optional && !namespace) {
        return;
      }
      if (typeof namespace !== "string") {
        throw new Error(errorPrefix(fnName, "namespace") + "must be a valid firebase namespace.");
      }
    }
    function validateCallback(fnName, argumentName, callback, optional) {
      if (optional && !callback) {
        return;
      }
      if (typeof callback !== "function") {
        throw new Error(errorPrefix(fnName, argumentName) + "must be a valid function.");
      }
    }
    function validateContextObject(fnName, argumentName, context, optional) {
      if (optional && !context) {
        return;
      }
      if (typeof context !== "object" || context === null) {
        throw new Error(errorPrefix(fnName, argumentName) + "must be a valid context object.");
      }
    }
    var stringToByteArray = function(str) {
      var out = [];
      var p = 0;
      for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        if (c >= 55296 && c <= 56319) {
          var high = c - 55296;
          i++;
          assert(i < str.length, "Surrogate pair missing trail surrogate.");
          var low = str.charCodeAt(i) - 56320;
          c = 65536 + (high << 10) + low;
        }
        if (c < 128) {
          out[p++] = c;
        } else if (c < 2048) {
          out[p++] = c >> 6 | 192;
          out[p++] = c & 63 | 128;
        } else if (c < 65536) {
          out[p++] = c >> 12 | 224;
          out[p++] = c >> 6 & 63 | 128;
          out[p++] = c & 63 | 128;
        } else {
          out[p++] = c >> 18 | 240;
          out[p++] = c >> 12 & 63 | 128;
          out[p++] = c >> 6 & 63 | 128;
          out[p++] = c & 63 | 128;
        }
      }
      return out;
    };
    var stringLength = function(str) {
      var p = 0;
      for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        if (c < 128) {
          p++;
        } else if (c < 2048) {
          p += 2;
        } else if (c >= 55296 && c <= 56319) {
          p += 4;
          i++;
        } else {
          p += 3;
        }
      }
      return p;
    };
    var DEFAULT_INTERVAL_MILLIS2 = 1e3;
    var DEFAULT_BACKOFF_FACTOR2 = 2;
    var MAX_VALUE_MILLIS2 = 4 * 60 * 60 * 1e3;
    var RANDOM_FACTOR2 = 0.5;
    function calculateBackoffMillis2(backoffCount, intervalMillis, backoffFactor) {
      if (intervalMillis === void 0) {
        intervalMillis = DEFAULT_INTERVAL_MILLIS2;
      }
      if (backoffFactor === void 0) {
        backoffFactor = DEFAULT_BACKOFF_FACTOR2;
      }
      var currBaseValue = intervalMillis * Math.pow(backoffFactor, backoffCount);
      var randomWait = Math.round(RANDOM_FACTOR2 * currBaseValue * (Math.random() - 0.5) * 2);
      return Math.min(MAX_VALUE_MILLIS2, currBaseValue + randomWait);
    }
    function ordinal(i) {
      if (!Number.isFinite(i)) {
        return "" + i;
      }
      return i + indicator(i);
    }
    function indicator(i) {
      i = Math.abs(i);
      var cent = i % 100;
      if (cent >= 10 && cent <= 20) {
        return "th";
      }
      var dec = i % 10;
      if (dec === 1) {
        return "st";
      }
      if (dec === 2) {
        return "nd";
      }
      if (dec === 3) {
        return "rd";
      }
      return "th";
    }
    function getModularInstance2(service) {
      if (service && service._delegate) {
        return service._delegate;
      } else {
        return service;
      }
    }
    CONSTANTS.NODE_CLIENT = true;
    exports2.CONSTANTS = CONSTANTS;
    exports2.Deferred = Deferred2;
    exports2.ErrorFactory = ErrorFactory2;
    exports2.FirebaseError = FirebaseError2;
    exports2.MAX_VALUE_MILLIS = MAX_VALUE_MILLIS2;
    exports2.RANDOM_FACTOR = RANDOM_FACTOR2;
    exports2.Sha1 = Sha1;
    exports2.areCookiesEnabled = areCookiesEnabled2;
    exports2.assert = assert;
    exports2.assertionError = assertionError;
    exports2.async = async;
    exports2.base64 = base642;
    exports2.base64Decode = base64Decode2;
    exports2.base64Encode = base64Encode;
    exports2.base64urlEncodeWithoutPadding = base64urlEncodeWithoutPadding;
    exports2.calculateBackoffMillis = calculateBackoffMillis2;
    exports2.contains = contains;
    exports2.createMockUserToken = createMockUserToken;
    exports2.createSubscribe = createSubscribe2;
    exports2.decode = decode;
    exports2.deepCopy = deepCopy;
    exports2.deepEqual = deepEqual2;
    exports2.deepExtend = deepExtend;
    exports2.errorPrefix = errorPrefix;
    exports2.extractQuerystring = extractQuerystring;
    exports2.getGlobal = getGlobal;
    exports2.getModularInstance = getModularInstance2;
    exports2.getUA = getUA2;
    exports2.isAdmin = isAdmin;
    exports2.isBrowser = isBrowser;
    exports2.isBrowserExtension = isBrowserExtension2;
    exports2.isElectron = isElectron;
    exports2.isEmpty = isEmpty2;
    exports2.isIE = isIE2;
    exports2.isIndexedDBAvailable = isIndexedDBAvailable2;
    exports2.isMobileCordova = isMobileCordova2;
    exports2.isNode = isNode;
    exports2.isNodeSdk = isNodeSdk;
    exports2.isReactNative = isReactNative2;
    exports2.isSafari = isSafari;
    exports2.isUWP = isUWP;
    exports2.isValidFormat = isValidFormat;
    exports2.isValidTimestamp = isValidTimestamp;
    exports2.issuedAtTime = issuedAtTime;
    exports2.jsonEval = jsonEval;
    exports2.map = map;
    exports2.ordinal = ordinal;
    exports2.querystring = querystring2;
    exports2.querystringDecode = querystringDecode;
    exports2.safeGet = safeGet;
    exports2.stringLength = stringLength;
    exports2.stringToByteArray = stringToByteArray;
    exports2.stringify = stringify;
    exports2.validateArgCount = validateArgCount;
    exports2.validateCallback = validateCallback;
    exports2.validateContextObject = validateContextObject;
    exports2.validateIndexedDBOpenable = validateIndexedDBOpenable2;
    exports2.validateNamespace = validateNamespace;
  }
});

// node_modules/@firebase/component/dist/index.cjs.js
var require_index_cjs = __commonJS({
  "node_modules/@firebase/component/dist/index.cjs.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib2 = require_tslib();
    var util = require_index_node_cjs();
    var Component2 = function() {
      function Component3(name2, instanceFactory, type) {
        this.name = name2;
        this.instanceFactory = instanceFactory;
        this.type = type;
        this.multipleInstances = false;
        this.serviceProps = {};
        this.instantiationMode = "LAZY";
        this.onInstanceCreated = null;
      }
      Component3.prototype.setInstantiationMode = function(mode) {
        this.instantiationMode = mode;
        return this;
      };
      Component3.prototype.setMultipleInstances = function(multipleInstances) {
        this.multipleInstances = multipleInstances;
        return this;
      };
      Component3.prototype.setServiceProps = function(props) {
        this.serviceProps = props;
        return this;
      };
      Component3.prototype.setInstanceCreatedCallback = function(callback) {
        this.onInstanceCreated = callback;
        return this;
      };
      return Component3;
    }();
    var DEFAULT_ENTRY_NAME2 = "[DEFAULT]";
    var Provider2 = function() {
      function Provider3(name2, container) {
        this.name = name2;
        this.container = container;
        this.component = null;
        this.instances = new Map();
        this.instancesDeferred = new Map();
        this.instancesOptions = new Map();
        this.onInitCallbacks = new Map();
      }
      Provider3.prototype.get = function(identifier) {
        var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
        if (!this.instancesDeferred.has(normalizedIdentifier)) {
          var deferred = new util.Deferred();
          this.instancesDeferred.set(normalizedIdentifier, deferred);
          if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {
            try {
              var instance = this.getOrInitializeService({
                instanceIdentifier: normalizedIdentifier
              });
              if (instance) {
                deferred.resolve(instance);
              }
            } catch (e) {
            }
          }
        }
        return this.instancesDeferred.get(normalizedIdentifier).promise;
      };
      Provider3.prototype.getImmediate = function(options2) {
        var _a;
        var normalizedIdentifier = this.normalizeInstanceIdentifier(options2 === null || options2 === void 0 ? void 0 : options2.identifier);
        var optional = (_a = options2 === null || options2 === void 0 ? void 0 : options2.optional) !== null && _a !== void 0 ? _a : false;
        if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {
          try {
            return this.getOrInitializeService({
              instanceIdentifier: normalizedIdentifier
            });
          } catch (e) {
            if (optional) {
              return null;
            } else {
              throw e;
            }
          }
        } else {
          if (optional) {
            return null;
          } else {
            throw Error("Service " + this.name + " is not available");
          }
        }
      };
      Provider3.prototype.getComponent = function() {
        return this.component;
      };
      Provider3.prototype.setComponent = function(component) {
        var e_1, _a;
        if (component.name !== this.name) {
          throw Error("Mismatching Component " + component.name + " for Provider " + this.name + ".");
        }
        if (this.component) {
          throw Error("Component for " + this.name + " has already been provided");
        }
        this.component = component;
        if (!this.shouldAutoInitialize()) {
          return;
        }
        if (isComponentEager2(component)) {
          try {
            this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME2 });
          } catch (e) {
          }
        }
        try {
          for (var _b = tslib2.__values(this.instancesDeferred.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var _d = tslib2.__read(_c.value, 2), instanceIdentifier = _d[0], instanceDeferred = _d[1];
            var normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
            try {
              var instance = this.getOrInitializeService({
                instanceIdentifier: normalizedIdentifier
              });
              instanceDeferred.resolve(instance);
            } catch (e) {
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      };
      Provider3.prototype.clearInstance = function(identifier) {
        if (identifier === void 0) {
          identifier = DEFAULT_ENTRY_NAME2;
        }
        this.instancesDeferred.delete(identifier);
        this.instancesOptions.delete(identifier);
        this.instances.delete(identifier);
      };
      Provider3.prototype.delete = function() {
        return tslib2.__awaiter(this, void 0, void 0, function() {
          var services;
          return tslib2.__generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                services = Array.from(this.instances.values());
                return [4, Promise.all(tslib2.__spreadArray(tslib2.__spreadArray([], tslib2.__read(services.filter(function(service) {
                  return "INTERNAL" in service;
                }).map(function(service) {
                  return service.INTERNAL.delete();
                }))), tslib2.__read(services.filter(function(service) {
                  return "_delete" in service;
                }).map(function(service) {
                  return service._delete();
                }))))];
              case 1:
                _a.sent();
                return [2];
            }
          });
        });
      };
      Provider3.prototype.isComponentSet = function() {
        return this.component != null;
      };
      Provider3.prototype.isInitialized = function(identifier) {
        if (identifier === void 0) {
          identifier = DEFAULT_ENTRY_NAME2;
        }
        return this.instances.has(identifier);
      };
      Provider3.prototype.getOptions = function(identifier) {
        if (identifier === void 0) {
          identifier = DEFAULT_ENTRY_NAME2;
        }
        return this.instancesOptions.get(identifier) || {};
      };
      Provider3.prototype.initialize = function(opts) {
        var e_2, _a;
        if (opts === void 0) {
          opts = {};
        }
        var _b = opts.options, options2 = _b === void 0 ? {} : _b;
        var normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);
        if (this.isInitialized(normalizedIdentifier)) {
          throw Error(this.name + "(" + normalizedIdentifier + ") has already been initialized");
        }
        if (!this.isComponentSet()) {
          throw Error("Component " + this.name + " has not been registered yet");
        }
        var instance = this.getOrInitializeService({
          instanceIdentifier: normalizedIdentifier,
          options: options2
        });
        try {
          for (var _c = tslib2.__values(this.instancesDeferred.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {
            var _e = tslib2.__read(_d.value, 2), instanceIdentifier = _e[0], instanceDeferred = _e[1];
            var normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
            if (normalizedIdentifier === normalizedDeferredIdentifier) {
              instanceDeferred.resolve(instance);
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_d && !_d.done && (_a = _c.return))
              _a.call(_c);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
        return instance;
      };
      Provider3.prototype.onInit = function(callback, identifier) {
        var _a;
        var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
        var existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();
        existingCallbacks.add(callback);
        this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);
        var existingInstance = this.instances.get(normalizedIdentifier);
        if (existingInstance) {
          callback(existingInstance, normalizedIdentifier);
        }
        return function() {
          existingCallbacks.delete(callback);
        };
      };
      Provider3.prototype.invokeOnInitCallbacks = function(instance, identifier) {
        var e_3, _a;
        var callbacks = this.onInitCallbacks.get(identifier);
        if (!callbacks) {
          return;
        }
        try {
          for (var callbacks_1 = tslib2.__values(callbacks), callbacks_1_1 = callbacks_1.next(); !callbacks_1_1.done; callbacks_1_1 = callbacks_1.next()) {
            var callback = callbacks_1_1.value;
            try {
              callback(instance, identifier);
            } catch (_b) {
            }
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (callbacks_1_1 && !callbacks_1_1.done && (_a = callbacks_1.return))
              _a.call(callbacks_1);
          } finally {
            if (e_3)
              throw e_3.error;
          }
        }
      };
      Provider3.prototype.getOrInitializeService = function(_a) {
        var instanceIdentifier = _a.instanceIdentifier, _b = _a.options, options2 = _b === void 0 ? {} : _b;
        var instance = this.instances.get(instanceIdentifier);
        if (!instance && this.component) {
          instance = this.component.instanceFactory(this.container, {
            instanceIdentifier: normalizeIdentifierForFactory2(instanceIdentifier),
            options: options2
          });
          this.instances.set(instanceIdentifier, instance);
          this.instancesOptions.set(instanceIdentifier, options2);
          this.invokeOnInitCallbacks(instance, instanceIdentifier);
          if (this.component.onInstanceCreated) {
            try {
              this.component.onInstanceCreated(this.container, instanceIdentifier, instance);
            } catch (_c) {
            }
          }
        }
        return instance || null;
      };
      Provider3.prototype.normalizeInstanceIdentifier = function(identifier) {
        if (identifier === void 0) {
          identifier = DEFAULT_ENTRY_NAME2;
        }
        if (this.component) {
          return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME2;
        } else {
          return identifier;
        }
      };
      Provider3.prototype.shouldAutoInitialize = function() {
        return !!this.component && this.component.instantiationMode !== "EXPLICIT";
      };
      return Provider3;
    }();
    function normalizeIdentifierForFactory2(identifier) {
      return identifier === DEFAULT_ENTRY_NAME2 ? void 0 : identifier;
    }
    function isComponentEager2(component) {
      return component.instantiationMode === "EAGER";
    }
    var ComponentContainer2 = function() {
      function ComponentContainer3(name2) {
        this.name = name2;
        this.providers = new Map();
      }
      ComponentContainer3.prototype.addComponent = function(component) {
        var provider = this.getProvider(component.name);
        if (provider.isComponentSet()) {
          throw new Error("Component " + component.name + " has already been registered with " + this.name);
        }
        provider.setComponent(component);
      };
      ComponentContainer3.prototype.addOrOverwriteComponent = function(component) {
        var provider = this.getProvider(component.name);
        if (provider.isComponentSet()) {
          this.providers.delete(component.name);
        }
        this.addComponent(component);
      };
      ComponentContainer3.prototype.getProvider = function(name2) {
        if (this.providers.has(name2)) {
          return this.providers.get(name2);
        }
        var provider = new Provider2(name2, this);
        this.providers.set(name2, provider);
        return provider;
      };
      ComponentContainer3.prototype.getProviders = function() {
        return Array.from(this.providers.values());
      };
      return ComponentContainer3;
    }();
    exports2.Component = Component2;
    exports2.ComponentContainer = ComponentContainer2;
    exports2.Provider = Provider2;
  }
});

// node_modules/@firebase/logger/dist/index.cjs.js
var require_index_cjs2 = __commonJS({
  "node_modules/@firebase/logger/dist/index.cjs.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib2 = require_tslib();
    var _a;
    var instances = [];
    exports2.LogLevel = void 0;
    (function(LogLevel2) {
      LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
      LogLevel2[LogLevel2["VERBOSE"] = 1] = "VERBOSE";
      LogLevel2[LogLevel2["INFO"] = 2] = "INFO";
      LogLevel2[LogLevel2["WARN"] = 3] = "WARN";
      LogLevel2[LogLevel2["ERROR"] = 4] = "ERROR";
      LogLevel2[LogLevel2["SILENT"] = 5] = "SILENT";
    })(exports2.LogLevel || (exports2.LogLevel = {}));
    var levelStringToEnum2 = {
      "debug": exports2.LogLevel.DEBUG,
      "verbose": exports2.LogLevel.VERBOSE,
      "info": exports2.LogLevel.INFO,
      "warn": exports2.LogLevel.WARN,
      "error": exports2.LogLevel.ERROR,
      "silent": exports2.LogLevel.SILENT
    };
    var defaultLogLevel2 = exports2.LogLevel.INFO;
    var ConsoleMethod2 = (_a = {}, _a[exports2.LogLevel.DEBUG] = "log", _a[exports2.LogLevel.VERBOSE] = "log", _a[exports2.LogLevel.INFO] = "info", _a[exports2.LogLevel.WARN] = "warn", _a[exports2.LogLevel.ERROR] = "error", _a);
    var defaultLogHandler2 = function(instance, logType) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      if (logType < instance.logLevel) {
        return;
      }
      var now = new Date().toISOString();
      var method = ConsoleMethod2[logType];
      if (method) {
        console[method].apply(console, tslib2.__spreadArray(["[" + now + "]  " + instance.name + ":"], args));
      } else {
        throw new Error("Attempted to log a message with an invalid logType (value: " + logType + ")");
      }
    };
    var Logger2 = function() {
      function Logger3(name2) {
        this.name = name2;
        this._logLevel = defaultLogLevel2;
        this._logHandler = defaultLogHandler2;
        this._userLogHandler = null;
        instances.push(this);
      }
      Object.defineProperty(Logger3.prototype, "logLevel", {
        get: function() {
          return this._logLevel;
        },
        set: function(val) {
          if (!(val in exports2.LogLevel)) {
            throw new TypeError('Invalid value "' + val + '" assigned to `logLevel`');
          }
          this._logLevel = val;
        },
        enumerable: false,
        configurable: true
      });
      Logger3.prototype.setLogLevel = function(val) {
        this._logLevel = typeof val === "string" ? levelStringToEnum2[val] : val;
      };
      Object.defineProperty(Logger3.prototype, "logHandler", {
        get: function() {
          return this._logHandler;
        },
        set: function(val) {
          if (typeof val !== "function") {
            throw new TypeError("Value assigned to `logHandler` must be a function");
          }
          this._logHandler = val;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Logger3.prototype, "userLogHandler", {
        get: function() {
          return this._userLogHandler;
        },
        set: function(val) {
          this._userLogHandler = val;
        },
        enumerable: false,
        configurable: true
      });
      Logger3.prototype.debug = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        this._userLogHandler && this._userLogHandler.apply(this, tslib2.__spreadArray([this, exports2.LogLevel.DEBUG], args));
        this._logHandler.apply(this, tslib2.__spreadArray([this, exports2.LogLevel.DEBUG], args));
      };
      Logger3.prototype.log = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        this._userLogHandler && this._userLogHandler.apply(this, tslib2.__spreadArray([this, exports2.LogLevel.VERBOSE], args));
        this._logHandler.apply(this, tslib2.__spreadArray([this, exports2.LogLevel.VERBOSE], args));
      };
      Logger3.prototype.info = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        this._userLogHandler && this._userLogHandler.apply(this, tslib2.__spreadArray([this, exports2.LogLevel.INFO], args));
        this._logHandler.apply(this, tslib2.__spreadArray([this, exports2.LogLevel.INFO], args));
      };
      Logger3.prototype.warn = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        this._userLogHandler && this._userLogHandler.apply(this, tslib2.__spreadArray([this, exports2.LogLevel.WARN], args));
        this._logHandler.apply(this, tslib2.__spreadArray([this, exports2.LogLevel.WARN], args));
      };
      Logger3.prototype.error = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        this._userLogHandler && this._userLogHandler.apply(this, tslib2.__spreadArray([this, exports2.LogLevel.ERROR], args));
        this._logHandler.apply(this, tslib2.__spreadArray([this, exports2.LogLevel.ERROR], args));
      };
      return Logger3;
    }();
    function setLogLevel(level) {
      instances.forEach(function(inst) {
        inst.setLogLevel(level);
      });
    }
    function setUserLogHandler(logCallback, options2) {
      var _loop_1 = function(instance2) {
        var customLogLevel = null;
        if (options2 && options2.level) {
          customLogLevel = levelStringToEnum2[options2.level];
        }
        if (logCallback === null) {
          instance2.userLogHandler = null;
        } else {
          instance2.userLogHandler = function(instance3, level) {
            var args = [];
            for (var _i2 = 2; _i2 < arguments.length; _i2++) {
              args[_i2 - 2] = arguments[_i2];
            }
            var message = args.map(function(arg) {
              if (arg == null) {
                return null;
              } else if (typeof arg === "string") {
                return arg;
              } else if (typeof arg === "number" || typeof arg === "boolean") {
                return arg.toString();
              } else if (arg instanceof Error) {
                return arg.message;
              } else {
                try {
                  return JSON.stringify(arg);
                } catch (ignored) {
                  return null;
                }
              }
            }).filter(function(arg) {
              return arg;
            }).join(" ");
            if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance3.logLevel)) {
              logCallback({
                level: exports2.LogLevel[level].toLowerCase(),
                message,
                args,
                type: instance3.name
              });
            }
          };
        }
      };
      for (var _i = 0, instances_1 = instances; _i < instances_1.length; _i++) {
        var instance = instances_1[_i];
        _loop_1(instance);
      }
    }
    exports2.Logger = Logger2;
    exports2.setLogLevel = setLogLevel;
    exports2.setUserLogHandler = setUserLogHandler;
  }
});

// node_modules/@firebase/app/dist/index.cjs.js
var require_index_cjs3 = __commonJS({
  "node_modules/@firebase/app/dist/index.cjs.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var component = require_index_cjs();
    var tslib2 = require_tslib();
    var logger$12 = require_index_cjs2();
    var util = require_index_node_cjs();
    var PlatformLoggerServiceImpl2 = function() {
      function PlatformLoggerServiceImpl3(container) {
        this.container = container;
      }
      PlatformLoggerServiceImpl3.prototype.getPlatformInfoString = function() {
        var providers = this.container.getProviders();
        return providers.map(function(provider) {
          if (isVersionServiceProvider2(provider)) {
            var service = provider.getImmediate();
            return service.library + "/" + service.version;
          } else {
            return null;
          }
        }).filter(function(logString) {
          return logString;
        }).join(" ");
      };
      return PlatformLoggerServiceImpl3;
    }();
    function isVersionServiceProvider2(provider) {
      var component2 = provider.getComponent();
      return (component2 === null || component2 === void 0 ? void 0 : component2.type) === "VERSION";
    }
    var name$o2 = "@firebase/app";
    var version$12 = "0.7.3";
    var logger2 = new logger$12.Logger("@firebase/app");
    var name$n2 = "@firebase/app-compat";
    var name$m2 = "@firebase/analytics-compat";
    var name$l2 = "@firebase/analytics";
    var name$k2 = "@firebase/app-check-compat";
    var name$j2 = "@firebase/app-check";
    var name$i2 = "@firebase/auth";
    var name$h2 = "@firebase/auth-compat";
    var name$g2 = "@firebase/database";
    var name$f2 = "@firebase/database-compat";
    var name$e2 = "@firebase/functions";
    var name$d2 = "@firebase/functions-compat";
    var name$c2 = "@firebase/installations";
    var name$b2 = "@firebase/installations-compat";
    var name$a2 = "@firebase/messaging";
    var name$92 = "@firebase/messaging-compat";
    var name$82 = "@firebase/performance";
    var name$72 = "@firebase/performance-compat";
    var name$62 = "@firebase/remote-config";
    var name$52 = "@firebase/remote-config-compat";
    var name$42 = "@firebase/storage";
    var name$32 = "@firebase/storage-compat";
    var name$22 = "@firebase/firestore";
    var name$12 = "@firebase/firestore-compat";
    var name2 = "firebase";
    var version2 = "9.1.2";
    var _a$1;
    var DEFAULT_ENTRY_NAME2 = "[DEFAULT]";
    var PLATFORM_LOG_STRING2 = (_a$1 = {}, _a$1[name$o2] = "fire-core", _a$1[name$n2] = "fire-core-compat", _a$1[name$l2] = "fire-analytics", _a$1[name$m2] = "fire-analytics-compat", _a$1[name$j2] = "fire-app-check", _a$1[name$k2] = "fire-app-check-compat", _a$1[name$i2] = "fire-auth", _a$1[name$h2] = "fire-auth-compat", _a$1[name$g2] = "fire-rtdb", _a$1[name$f2] = "fire-rtdb-compat", _a$1[name$e2] = "fire-fn", _a$1[name$d2] = "fire-fn-compat", _a$1[name$c2] = "fire-iid", _a$1[name$b2] = "fire-iid-compat", _a$1[name$a2] = "fire-fcm", _a$1[name$92] = "fire-fcm-compat", _a$1[name$82] = "fire-perf", _a$1[name$72] = "fire-perf-compat", _a$1[name$62] = "fire-rc", _a$1[name$52] = "fire-rc-compat", _a$1[name$42] = "fire-gcs", _a$1[name$32] = "fire-gcs-compat", _a$1[name$22] = "fire-fst", _a$1[name$12] = "fire-fst-compat", _a$1["fire-js"] = "fire-js", _a$1[name2] = "fire-js-all", _a$1);
    var _apps2 = new Map();
    var _components2 = new Map();
    function _addComponent2(app, component2) {
      try {
        app.container.addComponent(component2);
      } catch (e) {
        logger2.debug("Component " + component2.name + " failed to register with FirebaseApp " + app.name, e);
      }
    }
    function _addOrOverwriteComponent(app, component2) {
      app.container.addOrOverwriteComponent(component2);
    }
    function _registerComponent2(component2) {
      var e_1, _a2;
      var componentName = component2.name;
      if (_components2.has(componentName)) {
        logger2.debug("There were multiple attempts to register component " + componentName + ".");
        return false;
      }
      _components2.set(componentName, component2);
      try {
        for (var _b = tslib2.__values(_apps2.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
          var app = _c.value;
          _addComponent2(app, component2);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b.return))
            _a2.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return true;
    }
    function _getProvider2(app, name3) {
      return app.container.getProvider(name3);
    }
    function _removeServiceInstance(app, name3, instanceIdentifier) {
      if (instanceIdentifier === void 0) {
        instanceIdentifier = DEFAULT_ENTRY_NAME2;
      }
      _getProvider2(app, name3).clearInstance(instanceIdentifier);
    }
    function _clearComponents() {
      _components2.clear();
    }
    var _a;
    var ERRORS2 = (_a = {}, _a["no-app"] = "No Firebase App '{$appName}' has been created - call Firebase App.initializeApp()", _a["bad-app-name"] = "Illegal App name: '{$appName}", _a["duplicate-app"] = "Firebase App named '{$appName}' already exists with different options or config", _a["app-deleted"] = "Firebase App named '{$appName}' already deleted", _a["invalid-app-argument"] = "firebase.{$appName}() takes either no argument or a Firebase App instance.", _a["invalid-log-argument"] = "First argument to `onLog` must be null or a function.", _a);
    var ERROR_FACTORY2 = new util.ErrorFactory("app", "Firebase", ERRORS2);
    var FirebaseAppImpl2 = function() {
      function FirebaseAppImpl3(options2, config2, container) {
        var _this = this;
        this._isDeleted = false;
        this._options = tslib2.__assign({}, options2);
        this._config = tslib2.__assign({}, config2);
        this._name = config2.name;
        this._automaticDataCollectionEnabled = config2.automaticDataCollectionEnabled;
        this._container = container;
        this.container.addComponent(new component.Component("app", function() {
          return _this;
        }, "PUBLIC"));
      }
      Object.defineProperty(FirebaseAppImpl3.prototype, "automaticDataCollectionEnabled", {
        get: function() {
          this.checkDestroyed();
          return this._automaticDataCollectionEnabled;
        },
        set: function(val) {
          this.checkDestroyed();
          this._automaticDataCollectionEnabled = val;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FirebaseAppImpl3.prototype, "name", {
        get: function() {
          this.checkDestroyed();
          return this._name;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FirebaseAppImpl3.prototype, "options", {
        get: function() {
          this.checkDestroyed();
          return this._options;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FirebaseAppImpl3.prototype, "config", {
        get: function() {
          this.checkDestroyed();
          return this._config;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FirebaseAppImpl3.prototype, "container", {
        get: function() {
          return this._container;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FirebaseAppImpl3.prototype, "isDeleted", {
        get: function() {
          return this._isDeleted;
        },
        set: function(val) {
          this._isDeleted = val;
        },
        enumerable: false,
        configurable: true
      });
      FirebaseAppImpl3.prototype.checkDestroyed = function() {
        if (this.isDeleted) {
          throw ERROR_FACTORY2.create("app-deleted", { appName: this._name });
        }
      };
      return FirebaseAppImpl3;
    }();
    var SDK_VERSION2 = version2;
    function initializeApp2(options2, rawConfig) {
      var e_1, _a2;
      if (rawConfig === void 0) {
        rawConfig = {};
      }
      if (typeof rawConfig !== "object") {
        var name_1 = rawConfig;
        rawConfig = { name: name_1 };
      }
      var config2 = tslib2.__assign({ name: DEFAULT_ENTRY_NAME2, automaticDataCollectionEnabled: false }, rawConfig);
      var name3 = config2.name;
      if (typeof name3 !== "string" || !name3) {
        throw ERROR_FACTORY2.create("bad-app-name", {
          appName: String(name3)
        });
      }
      var existingApp = _apps2.get(name3);
      if (existingApp) {
        if (util.deepEqual(options2, existingApp.options) && util.deepEqual(config2, existingApp.config)) {
          return existingApp;
        } else {
          throw ERROR_FACTORY2.create("duplicate-app", { appName: name3 });
        }
      }
      var container = new component.ComponentContainer(name3);
      try {
        for (var _b = tslib2.__values(_components2.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
          var component$1 = _c.value;
          container.addComponent(component$1);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b.return))
            _a2.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      var newApp = new FirebaseAppImpl2(options2, config2, container);
      _apps2.set(name3, newApp);
      return newApp;
    }
    function getApp2(name3) {
      if (name3 === void 0) {
        name3 = DEFAULT_ENTRY_NAME2;
      }
      var app = _apps2.get(name3);
      if (!app) {
        throw ERROR_FACTORY2.create("no-app", { appName: name3 });
      }
      return app;
    }
    function getApps() {
      return Array.from(_apps2.values());
    }
    function deleteApp(app) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var name3;
        return tslib2.__generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              name3 = app.name;
              if (!_apps2.has(name3))
                return [3, 2];
              _apps2.delete(name3);
              return [4, Promise.all(app.container.getProviders().map(function(provider) {
                return provider.delete();
              }))];
            case 1:
              _a2.sent();
              app.isDeleted = true;
              _a2.label = 2;
            case 2:
              return [2];
          }
        });
      });
    }
    function registerVersion2(libraryKeyOrName, version3, variant) {
      var _a2;
      var library = (_a2 = PLATFORM_LOG_STRING2[libraryKeyOrName]) !== null && _a2 !== void 0 ? _a2 : libraryKeyOrName;
      if (variant) {
        library += "-" + variant;
      }
      var libraryMismatch = library.match(/\s|\//);
      var versionMismatch = version3.match(/\s|\//);
      if (libraryMismatch || versionMismatch) {
        var warning = [
          'Unable to register library "' + library + '" with version "' + version3 + '":'
        ];
        if (libraryMismatch) {
          warning.push('library name "' + library + '" contains illegal characters (whitespace or "/")');
        }
        if (libraryMismatch && versionMismatch) {
          warning.push("and");
        }
        if (versionMismatch) {
          warning.push('version name "' + version3 + '" contains illegal characters (whitespace or "/")');
        }
        logger2.warn(warning.join(" "));
        return;
      }
      _registerComponent2(new component.Component(library + "-version", function() {
        return { library, version: version3 };
      }, "VERSION"));
    }
    function onLog(logCallback, options2) {
      if (logCallback !== null && typeof logCallback !== "function") {
        throw ERROR_FACTORY2.create("invalid-log-argument");
      }
      logger$12.setUserLogHandler(logCallback, options2);
    }
    function setLogLevel(logLevel) {
      logger$12.setLogLevel(logLevel);
    }
    function registerCoreComponents2(variant) {
      _registerComponent2(new component.Component("platform-logger", function(container) {
        return new PlatformLoggerServiceImpl2(container);
      }, "PRIVATE"));
      registerVersion2(name$o2, version$12, variant);
      registerVersion2("fire-js", "");
    }
    registerCoreComponents2();
    Object.defineProperty(exports2, "FirebaseError", {
      enumerable: true,
      get: function() {
        return util.FirebaseError;
      }
    });
    exports2.SDK_VERSION = SDK_VERSION2;
    exports2._DEFAULT_ENTRY_NAME = DEFAULT_ENTRY_NAME2;
    exports2._addComponent = _addComponent2;
    exports2._addOrOverwriteComponent = _addOrOverwriteComponent;
    exports2._apps = _apps2;
    exports2._clearComponents = _clearComponents;
    exports2._components = _components2;
    exports2._getProvider = _getProvider2;
    exports2._registerComponent = _registerComponent2;
    exports2._removeServiceInstance = _removeServiceInstance;
    exports2.deleteApp = deleteApp;
    exports2.getApp = getApp2;
    exports2.getApps = getApps;
    exports2.initializeApp = initializeApp2;
    exports2.onLog = onLog;
    exports2.registerVersion = registerVersion2;
    exports2.setLogLevel = setLogLevel;
  }
});

// node_modules/@grpc/grpc-js/build/src/constants.js
var require_constants = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/constants.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = exports2.DEFAULT_MAX_SEND_MESSAGE_LENGTH = exports2.Propagate = exports2.LogVerbosity = exports2.Status = void 0;
    var Status;
    (function(Status2) {
      Status2[Status2["OK"] = 0] = "OK";
      Status2[Status2["CANCELLED"] = 1] = "CANCELLED";
      Status2[Status2["UNKNOWN"] = 2] = "UNKNOWN";
      Status2[Status2["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
      Status2[Status2["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
      Status2[Status2["NOT_FOUND"] = 5] = "NOT_FOUND";
      Status2[Status2["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
      Status2[Status2["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
      Status2[Status2["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
      Status2[Status2["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
      Status2[Status2["ABORTED"] = 10] = "ABORTED";
      Status2[Status2["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
      Status2[Status2["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
      Status2[Status2["INTERNAL"] = 13] = "INTERNAL";
      Status2[Status2["UNAVAILABLE"] = 14] = "UNAVAILABLE";
      Status2[Status2["DATA_LOSS"] = 15] = "DATA_LOSS";
      Status2[Status2["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
    })(Status = exports2.Status || (exports2.Status = {}));
    var LogVerbosity;
    (function(LogVerbosity2) {
      LogVerbosity2[LogVerbosity2["DEBUG"] = 0] = "DEBUG";
      LogVerbosity2[LogVerbosity2["INFO"] = 1] = "INFO";
      LogVerbosity2[LogVerbosity2["ERROR"] = 2] = "ERROR";
      LogVerbosity2[LogVerbosity2["NONE"] = 3] = "NONE";
    })(LogVerbosity = exports2.LogVerbosity || (exports2.LogVerbosity = {}));
    var Propagate;
    (function(Propagate2) {
      Propagate2[Propagate2["DEADLINE"] = 1] = "DEADLINE";
      Propagate2[Propagate2["CENSUS_STATS_CONTEXT"] = 2] = "CENSUS_STATS_CONTEXT";
      Propagate2[Propagate2["CENSUS_TRACING_CONTEXT"] = 4] = "CENSUS_TRACING_CONTEXT";
      Propagate2[Propagate2["CANCELLATION"] = 8] = "CANCELLATION";
      Propagate2[Propagate2["DEFAULTS"] = 65535] = "DEFAULTS";
    })(Propagate = exports2.Propagate || (exports2.Propagate = {}));
    exports2.DEFAULT_MAX_SEND_MESSAGE_LENGTH = -1;
    exports2.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = 4 * 1024 * 1024;
  }
});

// node_modules/@grpc/grpc-js/build/src/logging.js
var require_logging = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/logging.js"(exports2) {
    init_shims();
    "use strict";
    var _a;
    var _b;
    var _c;
    var _d;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.trace = exports2.log = exports2.setLoggerVerbosity = exports2.setLogger = exports2.getLogger = void 0;
    var constants_1 = require_constants();
    var _logger = console;
    var _logVerbosity = constants_1.LogVerbosity.ERROR;
    var verbosityString = (_b = (_a = process.env.GRPC_NODE_VERBOSITY) !== null && _a !== void 0 ? _a : process.env.GRPC_VERBOSITY) !== null && _b !== void 0 ? _b : "";
    switch (verbosityString.toUpperCase()) {
      case "DEBUG":
        _logVerbosity = constants_1.LogVerbosity.DEBUG;
        break;
      case "INFO":
        _logVerbosity = constants_1.LogVerbosity.INFO;
        break;
      case "ERROR":
        _logVerbosity = constants_1.LogVerbosity.ERROR;
        break;
      case "NONE":
        _logVerbosity = constants_1.LogVerbosity.NONE;
        break;
      default:
    }
    exports2.getLogger = () => {
      return _logger;
    };
    exports2.setLogger = (logger2) => {
      _logger = logger2;
    };
    exports2.setLoggerVerbosity = (verbosity) => {
      _logVerbosity = verbosity;
    };
    exports2.log = (severity, ...args) => {
      if (severity >= _logVerbosity && typeof _logger.error === "function") {
        _logger.error(...args);
      }
    };
    var tracersString = (_d = (_c = process.env.GRPC_NODE_TRACE) !== null && _c !== void 0 ? _c : process.env.GRPC_TRACE) !== null && _d !== void 0 ? _d : "";
    var enabledTracers = new Set();
    var disabledTracers = new Set();
    for (const tracerName of tracersString.split(",")) {
      if (tracerName.startsWith("-")) {
        disabledTracers.add(tracerName.substring(1));
      } else {
        enabledTracers.add(tracerName);
      }
    }
    var allEnabled = enabledTracers.has("all");
    function trace(severity, tracer, text) {
      if (!disabledTracers.has(tracer) && (allEnabled || enabledTracers.has(tracer))) {
        exports2.log(severity, new Date().toISOString() + " | " + tracer + " | " + text);
      }
    }
    exports2.trace = trace;
  }
});

// node_modules/@grpc/grpc-js/build/src/metadata.js
var require_metadata = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/metadata.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Metadata = void 0;
    var logging_1 = require_logging();
    var constants_1 = require_constants();
    var LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;
    var LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;
    function isLegalKey(key) {
      return LEGAL_KEY_REGEX.test(key);
    }
    function isLegalNonBinaryValue(value) {
      return LEGAL_NON_BINARY_VALUE_REGEX.test(value);
    }
    function isBinaryKey(key) {
      return key.endsWith("-bin");
    }
    function isCustomMetadata(key) {
      return !key.startsWith("grpc-");
    }
    function normalizeKey(key) {
      return key.toLowerCase();
    }
    function validate(key, value) {
      if (!isLegalKey(key)) {
        throw new Error('Metadata key "' + key + '" contains illegal characters');
      }
      if (value !== null && value !== void 0) {
        if (isBinaryKey(key)) {
          if (!(value instanceof Buffer)) {
            throw new Error("keys that end with '-bin' must have Buffer values");
          }
        } else {
          if (value instanceof Buffer) {
            throw new Error("keys that don't end with '-bin' must have String values");
          }
          if (!isLegalNonBinaryValue(value)) {
            throw new Error('Metadata string value "' + value + '" contains illegal characters');
          }
        }
      }
    }
    var Metadata = class {
      constructor(options2) {
        this.internalRepr = new Map();
        if (options2 === void 0) {
          this.options = {};
        } else {
          this.options = options2;
        }
      }
      set(key, value) {
        key = normalizeKey(key);
        validate(key, value);
        this.internalRepr.set(key, [value]);
      }
      add(key, value) {
        key = normalizeKey(key);
        validate(key, value);
        const existingValue = this.internalRepr.get(key);
        if (existingValue === void 0) {
          this.internalRepr.set(key, [value]);
        } else {
          existingValue.push(value);
        }
      }
      remove(key) {
        key = normalizeKey(key);
        validate(key);
        this.internalRepr.delete(key);
      }
      get(key) {
        key = normalizeKey(key);
        validate(key);
        return this.internalRepr.get(key) || [];
      }
      getMap() {
        const result = {};
        this.internalRepr.forEach((values, key) => {
          if (values.length > 0) {
            const v = values[0];
            result[key] = v instanceof Buffer ? v.slice() : v;
          }
        });
        return result;
      }
      clone() {
        const newMetadata = new Metadata(this.options);
        const newInternalRepr = newMetadata.internalRepr;
        this.internalRepr.forEach((value, key) => {
          const clonedValue = value.map((v) => {
            if (v instanceof Buffer) {
              return Buffer.from(v);
            } else {
              return v;
            }
          });
          newInternalRepr.set(key, clonedValue);
        });
        return newMetadata;
      }
      merge(other) {
        other.internalRepr.forEach((values, key) => {
          const mergedValue = (this.internalRepr.get(key) || []).concat(values);
          this.internalRepr.set(key, mergedValue);
        });
      }
      setOptions(options2) {
        this.options = options2;
      }
      getOptions() {
        return this.options;
      }
      toHttp2Headers() {
        const result = {};
        this.internalRepr.forEach((values, key) => {
          result[key] = values.map((value) => {
            if (value instanceof Buffer) {
              return value.toString("base64");
            } else {
              return value;
            }
          });
        });
        return result;
      }
      _getCoreRepresentation() {
        return this.internalRepr;
      }
      static fromHttp2Headers(headers) {
        const result = new Metadata();
        Object.keys(headers).forEach((key) => {
          if (key.charAt(0) === ":") {
            return;
          }
          const values = headers[key];
          try {
            if (isBinaryKey(key)) {
              if (Array.isArray(values)) {
                values.forEach((value) => {
                  result.add(key, Buffer.from(value, "base64"));
                });
              } else if (values !== void 0) {
                if (isCustomMetadata(key)) {
                  values.split(",").forEach((v) => {
                    result.add(key, Buffer.from(v.trim(), "base64"));
                  });
                } else {
                  result.add(key, Buffer.from(values, "base64"));
                }
              }
            } else {
              if (Array.isArray(values)) {
                values.forEach((value) => {
                  result.add(key, value);
                });
              } else if (values !== void 0) {
                result.add(key, values);
              }
            }
          } catch (error2) {
            const message = `Failed to add metadata entry ${key}: ${values}. ${error2.message}. For more information see https://github.com/grpc/grpc-node/issues/1173`;
            logging_1.log(constants_1.LogVerbosity.ERROR, message);
          }
        });
        return result;
      }
    };
    exports2.Metadata = Metadata;
  }
});

// node_modules/@grpc/grpc-js/build/src/call-credentials.js
var require_call_credentials = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/call-credentials.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallCredentials = void 0;
    var metadata_1 = require_metadata();
    function isCurrentOauth2Client(client) {
      return "getRequestHeaders" in client && typeof client.getRequestHeaders === "function";
    }
    var CallCredentials = class {
      static createFromMetadataGenerator(metadataGenerator) {
        return new SingleCallCredentials(metadataGenerator);
      }
      static createFromGoogleCredential(googleCredentials) {
        return CallCredentials.createFromMetadataGenerator((options2, callback) => {
          let getHeaders2;
          if (isCurrentOauth2Client(googleCredentials)) {
            getHeaders2 = googleCredentials.getRequestHeaders(options2.service_url);
          } else {
            getHeaders2 = new Promise((resolve2, reject) => {
              googleCredentials.getRequestMetadata(options2.service_url, (err, headers) => {
                if (err) {
                  reject(err);
                  return;
                }
                resolve2(headers);
              });
            });
          }
          getHeaders2.then((headers) => {
            const metadata = new metadata_1.Metadata();
            for (const key of Object.keys(headers)) {
              metadata.add(key, headers[key]);
            }
            callback(null, metadata);
          }, (err) => {
            callback(err);
          });
        });
      }
      static createEmpty() {
        return new EmptyCallCredentials();
      }
    };
    exports2.CallCredentials = CallCredentials;
    var ComposedCallCredentials = class extends CallCredentials {
      constructor(creds) {
        super();
        this.creds = creds;
      }
      async generateMetadata(options2) {
        const base2 = new metadata_1.Metadata();
        const generated = await Promise.all(this.creds.map((cred) => cred.generateMetadata(options2)));
        for (const gen of generated) {
          base2.merge(gen);
        }
        return base2;
      }
      compose(other) {
        return new ComposedCallCredentials(this.creds.concat([other]));
      }
      _equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof ComposedCallCredentials) {
          return this.creds.every((value, index2) => value._equals(other.creds[index2]));
        } else {
          return false;
        }
      }
    };
    var SingleCallCredentials = class extends CallCredentials {
      constructor(metadataGenerator) {
        super();
        this.metadataGenerator = metadataGenerator;
      }
      generateMetadata(options2) {
        return new Promise((resolve2, reject) => {
          this.metadataGenerator(options2, (err, metadata) => {
            if (metadata !== void 0) {
              resolve2(metadata);
            } else {
              reject(err);
            }
          });
        });
      }
      compose(other) {
        return new ComposedCallCredentials([this, other]);
      }
      _equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof SingleCallCredentials) {
          return this.metadataGenerator === other.metadataGenerator;
        } else {
          return false;
        }
      }
    };
    var EmptyCallCredentials = class extends CallCredentials {
      generateMetadata(options2) {
        return Promise.resolve(new metadata_1.Metadata());
      }
      compose(other) {
        return other;
      }
      _equals(other) {
        return other instanceof EmptyCallCredentials;
      }
    };
  }
});

// node_modules/@grpc/grpc-js/build/src/filter-stack.js
var require_filter_stack = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/filter-stack.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FilterStackFactory = exports2.FilterStack = void 0;
    var FilterStack = class {
      constructor(filters) {
        this.filters = filters;
      }
      sendMetadata(metadata) {
        let result = metadata;
        for (let i = 0; i < this.filters.length; i++) {
          result = this.filters[i].sendMetadata(result);
        }
        return result;
      }
      receiveMetadata(metadata) {
        let result = metadata;
        for (let i = this.filters.length - 1; i >= 0; i--) {
          result = this.filters[i].receiveMetadata(result);
        }
        return result;
      }
      sendMessage(message) {
        let result = message;
        for (let i = 0; i < this.filters.length; i++) {
          result = this.filters[i].sendMessage(result);
        }
        return result;
      }
      receiveMessage(message) {
        let result = message;
        for (let i = this.filters.length - 1; i >= 0; i--) {
          result = this.filters[i].receiveMessage(result);
        }
        return result;
      }
      receiveTrailers(status) {
        let result = status;
        for (let i = this.filters.length - 1; i >= 0; i--) {
          result = this.filters[i].receiveTrailers(result);
        }
        return result;
      }
    };
    exports2.FilterStack = FilterStack;
    var FilterStackFactory = class {
      constructor(factories) {
        this.factories = factories;
      }
      createFilter(callStream) {
        return new FilterStack(this.factories.map((factory2) => factory2.createFilter(callStream)));
      }
    };
    exports2.FilterStackFactory = FilterStackFactory;
  }
});

// node_modules/@grpc/grpc-js/build/src/stream-decoder.js
var require_stream_decoder = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/stream-decoder.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StreamDecoder = void 0;
    var ReadState;
    (function(ReadState2) {
      ReadState2[ReadState2["NO_DATA"] = 0] = "NO_DATA";
      ReadState2[ReadState2["READING_SIZE"] = 1] = "READING_SIZE";
      ReadState2[ReadState2["READING_MESSAGE"] = 2] = "READING_MESSAGE";
    })(ReadState || (ReadState = {}));
    var StreamDecoder = class {
      constructor() {
        this.readState = ReadState.NO_DATA;
        this.readCompressFlag = Buffer.alloc(1);
        this.readPartialSize = Buffer.alloc(4);
        this.readSizeRemaining = 4;
        this.readMessageSize = 0;
        this.readPartialMessage = [];
        this.readMessageRemaining = 0;
      }
      write(data) {
        let readHead = 0;
        let toRead;
        const result = [];
        while (readHead < data.length) {
          switch (this.readState) {
            case ReadState.NO_DATA:
              this.readCompressFlag = data.slice(readHead, readHead + 1);
              readHead += 1;
              this.readState = ReadState.READING_SIZE;
              this.readPartialSize.fill(0);
              this.readSizeRemaining = 4;
              this.readMessageSize = 0;
              this.readMessageRemaining = 0;
              this.readPartialMessage = [];
              break;
            case ReadState.READING_SIZE:
              toRead = Math.min(data.length - readHead, this.readSizeRemaining);
              data.copy(this.readPartialSize, 4 - this.readSizeRemaining, readHead, readHead + toRead);
              this.readSizeRemaining -= toRead;
              readHead += toRead;
              if (this.readSizeRemaining === 0) {
                this.readMessageSize = this.readPartialSize.readUInt32BE(0);
                this.readMessageRemaining = this.readMessageSize;
                if (this.readMessageRemaining > 0) {
                  this.readState = ReadState.READING_MESSAGE;
                } else {
                  const message = Buffer.concat([this.readCompressFlag, this.readPartialSize], 5);
                  this.readState = ReadState.NO_DATA;
                  result.push(message);
                }
              }
              break;
            case ReadState.READING_MESSAGE:
              toRead = Math.min(data.length - readHead, this.readMessageRemaining);
              this.readPartialMessage.push(data.slice(readHead, readHead + toRead));
              this.readMessageRemaining -= toRead;
              readHead += toRead;
              if (this.readMessageRemaining === 0) {
                const framedMessageBuffers = [
                  this.readCompressFlag,
                  this.readPartialSize
                ].concat(this.readPartialMessage);
                const framedMessage = Buffer.concat(framedMessageBuffers, this.readMessageSize + 5);
                this.readState = ReadState.NO_DATA;
                result.push(framedMessage);
              }
              break;
            default:
              throw new Error("Unexpected read state");
          }
        }
        return result;
      }
    };
    exports2.StreamDecoder = StreamDecoder;
  }
});

// node_modules/@grpc/grpc-js/build/src/call-stream.js
var require_call_stream = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/call-stream.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Http2CallStream = exports2.InterceptingListenerImpl = exports2.isInterceptingListener = void 0;
    var http2 = require("http2");
    var os = require("os");
    var constants_1 = require_constants();
    var filter_stack_1 = require_filter_stack();
    var metadata_1 = require_metadata();
    var stream_decoder_1 = require_stream_decoder();
    var logging = require_logging();
    var constants_2 = require_constants();
    var TRACER_NAME = "call_stream";
    var { HTTP2_HEADER_STATUS, HTTP2_HEADER_CONTENT_TYPE, NGHTTP2_CANCEL } = http2.constants;
    function getSystemErrorName(errno) {
      for (const [name2, num] of Object.entries(os.constants.errno)) {
        if (num === errno) {
          return name2;
        }
      }
      return "Unknown system error " + errno;
    }
    function isInterceptingListener(listener) {
      return listener.onReceiveMetadata !== void 0 && listener.onReceiveMetadata.length === 1;
    }
    exports2.isInterceptingListener = isInterceptingListener;
    var InterceptingListenerImpl = class {
      constructor(listener, nextListener) {
        this.listener = listener;
        this.nextListener = nextListener;
        this.processingMessage = false;
        this.pendingStatus = null;
      }
      onReceiveMetadata(metadata) {
        this.listener.onReceiveMetadata(metadata, (metadata2) => {
          this.nextListener.onReceiveMetadata(metadata2);
        });
      }
      onReceiveMessage(message) {
        this.processingMessage = true;
        this.listener.onReceiveMessage(message, (msg) => {
          this.processingMessage = false;
          this.nextListener.onReceiveMessage(msg);
          if (this.pendingStatus) {
            this.nextListener.onReceiveStatus(this.pendingStatus);
          }
        });
      }
      onReceiveStatus(status) {
        this.listener.onReceiveStatus(status, (processedStatus) => {
          if (this.processingMessage) {
            this.pendingStatus = processedStatus;
          } else {
            this.nextListener.onReceiveStatus(processedStatus);
          }
        });
      }
    };
    exports2.InterceptingListenerImpl = InterceptingListenerImpl;
    var Http2CallStream = class {
      constructor(methodName, channel, options2, filterStackFactory, channelCallCredentials, callNumber) {
        this.methodName = methodName;
        this.channel = channel;
        this.options = options2;
        this.channelCallCredentials = channelCallCredentials;
        this.callNumber = callNumber;
        this.http2Stream = null;
        this.pendingRead = false;
        this.isWriteFilterPending = false;
        this.pendingWrite = null;
        this.pendingWriteCallback = null;
        this.writesClosed = false;
        this.decoder = new stream_decoder_1.StreamDecoder();
        this.isReadFilterPending = false;
        this.canPush = false;
        this.readsClosed = false;
        this.statusOutput = false;
        this.unpushedReadMessages = [];
        this.unfilteredReadMessages = [];
        this.mappedStatusCode = constants_1.Status.UNKNOWN;
        this.finalStatus = null;
        this.subchannel = null;
        this.listener = null;
        this.internalError = null;
        this.filterStack = filterStackFactory.createFilter(this);
        this.credentials = channelCallCredentials;
        this.disconnectListener = () => {
          this.endCall({
            code: constants_1.Status.UNAVAILABLE,
            details: "Connection dropped",
            metadata: new metadata_1.Metadata()
          });
        };
        if (this.options.parentCall && this.options.flags & constants_1.Propagate.CANCELLATION) {
          this.options.parentCall.on("cancelled", () => {
            this.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled by parent call");
          });
        }
      }
      outputStatus() {
        if (!this.statusOutput) {
          this.statusOutput = true;
          const filteredStatus = this.filterStack.receiveTrailers(this.finalStatus);
          process.nextTick(() => {
            var _a;
            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(filteredStatus);
          });
          if (this.subchannel) {
            this.subchannel.callUnref();
            this.subchannel.removeDisconnectListener(this.disconnectListener);
          }
        }
      }
      trace(text) {
        logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, "[" + this.callNumber + "] " + text);
      }
      endCall(status) {
        if (this.finalStatus === null || this.finalStatus.code === constants_1.Status.OK) {
          this.trace("ended with status: code=" + status.code + ' details="' + status.details + '"');
          this.finalStatus = status;
          this.maybeOutputStatus();
        }
        this.destroyHttp2Stream();
      }
      maybeOutputStatus() {
        if (this.finalStatus !== null) {
          if (this.finalStatus.code !== constants_1.Status.OK || this.readsClosed && this.unpushedReadMessages.length === 0 && this.unfilteredReadMessages.length === 0 && !this.isReadFilterPending) {
            this.outputStatus();
          }
        }
      }
      push(message) {
        this.trace("pushing to reader message of length " + (message instanceof Buffer ? message.length : null));
        this.canPush = false;
        process.nextTick(() => {
          var _a;
          if (this.statusOutput) {
            return;
          }
          (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveMessage(message);
          this.maybeOutputStatus();
        });
      }
      handleFilterError(error2) {
        this.cancelWithStatus(constants_1.Status.INTERNAL, error2.message);
      }
      handleFilteredRead(message) {
        if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {
          this.maybeOutputStatus();
          return;
        }
        this.isReadFilterPending = false;
        if (this.canPush) {
          this.http2Stream.pause();
          this.push(message);
        } else {
          this.trace("unpushedReadMessages.push message of length " + message.length);
          this.unpushedReadMessages.push(message);
        }
        if (this.unfilteredReadMessages.length > 0) {
          const nextMessage = this.unfilteredReadMessages.shift();
          this.filterReceivedMessage(nextMessage);
        }
      }
      filterReceivedMessage(framedMessage) {
        if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {
          this.maybeOutputStatus();
          return;
        }
        this.trace("filterReceivedMessage of length " + framedMessage.length);
        this.isReadFilterPending = true;
        this.filterStack.receiveMessage(Promise.resolve(framedMessage)).then(this.handleFilteredRead.bind(this), this.handleFilterError.bind(this));
      }
      tryPush(messageBytes) {
        if (this.isReadFilterPending) {
          this.trace("unfilteredReadMessages.push message of length " + (messageBytes && messageBytes.length));
          this.unfilteredReadMessages.push(messageBytes);
        } else {
          this.filterReceivedMessage(messageBytes);
        }
      }
      handleTrailers(headers) {
        let headersString = "";
        for (const header of Object.keys(headers)) {
          headersString += "		" + header + ": " + headers[header] + "\n";
        }
        this.trace("Received server trailers:\n" + headersString);
        let metadata;
        try {
          metadata = metadata_1.Metadata.fromHttp2Headers(headers);
        } catch (e) {
          metadata = new metadata_1.Metadata();
        }
        const metadataMap = metadata.getMap();
        let code = this.mappedStatusCode;
        if (code === constants_1.Status.UNKNOWN && typeof metadataMap["grpc-status"] === "string") {
          const receivedStatus = Number(metadataMap["grpc-status"]);
          if (receivedStatus in constants_1.Status) {
            code = receivedStatus;
            this.trace("received status code " + receivedStatus + " from server");
          }
          metadata.remove("grpc-status");
        }
        let details = "";
        if (typeof metadataMap["grpc-message"] === "string") {
          details = decodeURI(metadataMap["grpc-message"]);
          metadata.remove("grpc-message");
          this.trace('received status details string "' + details + '" from server');
        }
        const status = { code, details, metadata };
        this.endCall(status);
      }
      attachHttp2Stream(stream, subchannel, extraFilterFactory) {
        if (extraFilterFactory !== void 0) {
          this.filterStack = new filter_stack_1.FilterStack([
            this.filterStack,
            extraFilterFactory.createFilter(this)
          ]);
        }
        if (this.finalStatus !== null) {
          stream.close(NGHTTP2_CANCEL);
        } else {
          this.trace("attachHttp2Stream from subchannel " + subchannel.getAddress());
          this.http2Stream = stream;
          this.subchannel = subchannel;
          subchannel.addDisconnectListener(this.disconnectListener);
          subchannel.callRef();
          stream.on("response", (headers, flags) => {
            var _a;
            let headersString = "";
            for (const header of Object.keys(headers)) {
              headersString += "		" + header + ": " + headers[header] + "\n";
            }
            this.trace("Received server headers:\n" + headersString);
            switch (headers[":status"]) {
              case 400:
                this.mappedStatusCode = constants_1.Status.INTERNAL;
                break;
              case 401:
                this.mappedStatusCode = constants_1.Status.UNAUTHENTICATED;
                break;
              case 403:
                this.mappedStatusCode = constants_1.Status.PERMISSION_DENIED;
                break;
              case 404:
                this.mappedStatusCode = constants_1.Status.UNIMPLEMENTED;
                break;
              case 429:
              case 502:
              case 503:
              case 504:
                this.mappedStatusCode = constants_1.Status.UNAVAILABLE;
                break;
              default:
                this.mappedStatusCode = constants_1.Status.UNKNOWN;
            }
            if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {
              this.handleTrailers(headers);
            } else {
              let metadata;
              try {
                metadata = metadata_1.Metadata.fromHttp2Headers(headers);
              } catch (error2) {
                this.endCall({
                  code: constants_1.Status.UNKNOWN,
                  details: error2.message,
                  metadata: new metadata_1.Metadata()
                });
                return;
              }
              try {
                const finalMetadata = this.filterStack.receiveMetadata(metadata);
                (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveMetadata(finalMetadata);
              } catch (error2) {
                this.endCall({
                  code: constants_1.Status.UNKNOWN,
                  details: error2.message,
                  metadata: new metadata_1.Metadata()
                });
              }
            }
          });
          stream.on("trailers", this.handleTrailers.bind(this));
          stream.on("data", (data) => {
            this.trace("receive HTTP/2 data frame of length " + data.length);
            const messages = this.decoder.write(data);
            for (const message of messages) {
              this.trace("parsed message of length " + message.length);
              this.tryPush(message);
            }
          });
          stream.on("end", () => {
            this.readsClosed = true;
            this.maybeOutputStatus();
          });
          stream.on("close", () => {
            process.nextTick(() => {
              var _a;
              this.trace("HTTP/2 stream closed with code " + stream.rstCode);
              if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {
                return;
              }
              let code;
              let details = "";
              switch (stream.rstCode) {
                case http2.constants.NGHTTP2_NO_ERROR:
                  if (this.finalStatus !== null) {
                    return;
                  }
                  code = constants_1.Status.INTERNAL;
                  details = `Received RST_STREAM with code ${stream.rstCode}`;
                  break;
                case http2.constants.NGHTTP2_REFUSED_STREAM:
                  code = constants_1.Status.UNAVAILABLE;
                  details = "Stream refused by server";
                  break;
                case http2.constants.NGHTTP2_CANCEL:
                  code = constants_1.Status.CANCELLED;
                  details = "Call cancelled";
                  break;
                case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:
                  code = constants_1.Status.RESOURCE_EXHAUSTED;
                  details = "Bandwidth exhausted";
                  break;
                case http2.constants.NGHTTP2_INADEQUATE_SECURITY:
                  code = constants_1.Status.PERMISSION_DENIED;
                  details = "Protocol not secure enough";
                  break;
                case http2.constants.NGHTTP2_INTERNAL_ERROR:
                  code = constants_1.Status.INTERNAL;
                  if (this.internalError === null) {
                    details = `Received RST_STREAM with code ${stream.rstCode} (Internal server error)`;
                  } else {
                    if (this.internalError.code === "ECONNRESET") {
                      code = constants_1.Status.UNAVAILABLE;
                      details = this.internalError.message;
                    } else {
                      details = `Received RST_STREAM with code ${stream.rstCode} triggered by internal client error: ${this.internalError.message}`;
                    }
                  }
                  break;
                default:
                  code = constants_1.Status.INTERNAL;
                  details = `Received RST_STREAM with code ${stream.rstCode}`;
              }
              this.endCall({ code, details, metadata: new metadata_1.Metadata() });
            });
          });
          stream.on("error", (err) => {
            if (err.code !== "ERR_HTTP2_STREAM_ERROR") {
              this.trace("Node error event: message=" + err.message + " code=" + err.code + " errno=" + getSystemErrorName(err.errno) + " syscall=" + err.syscall);
              this.internalError = err;
            }
          });
          if (!this.pendingRead) {
            stream.pause();
          }
          if (this.pendingWrite) {
            if (!this.pendingWriteCallback) {
              throw new Error("Invalid state in write handling code");
            }
            this.trace("sending data chunk of length " + this.pendingWrite.length + " (deferred)");
            try {
              stream.write(this.pendingWrite, this.pendingWriteCallback);
            } catch (error2) {
              this.endCall({
                code: constants_1.Status.UNAVAILABLE,
                details: `Write failed with error ${error2.message}`,
                metadata: new metadata_1.Metadata()
              });
            }
          }
          this.maybeCloseWrites();
        }
      }
      start(metadata, listener) {
        this.trace("Sending metadata");
        this.listener = listener;
        this.channel._startCallStream(this, metadata);
      }
      destroyHttp2Stream() {
        var _a;
        if (this.http2Stream !== null && !this.http2Stream.destroyed) {
          let code;
          if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {
            code = http2.constants.NGHTTP2_NO_ERROR;
          } else {
            code = http2.constants.NGHTTP2_CANCEL;
          }
          this.trace("close http2 stream with code " + code);
          this.http2Stream.close(code);
        }
      }
      cancelWithStatus(status, details) {
        this.trace("cancelWithStatus code: " + status + ' details: "' + details + '"');
        this.endCall({ code: status, details, metadata: new metadata_1.Metadata() });
      }
      getDeadline() {
        if (this.options.parentCall && this.options.flags & constants_1.Propagate.DEADLINE) {
          const parentDeadline = this.options.parentCall.getDeadline();
          const selfDeadline = this.options.deadline;
          const parentDeadlineMsecs = parentDeadline instanceof Date ? parentDeadline.getTime() : parentDeadline;
          const selfDeadlineMsecs = selfDeadline instanceof Date ? selfDeadline.getTime() : selfDeadline;
          return Math.min(parentDeadlineMsecs, selfDeadlineMsecs);
        } else {
          return this.options.deadline;
        }
      }
      getCredentials() {
        return this.credentials;
      }
      setCredentials(credentials) {
        this.credentials = this.channelCallCredentials.compose(credentials);
      }
      getStatus() {
        return this.finalStatus;
      }
      getPeer() {
        var _a, _b;
        return (_b = (_a = this.subchannel) === null || _a === void 0 ? void 0 : _a.getAddress()) !== null && _b !== void 0 ? _b : this.channel.getTarget();
      }
      getMethod() {
        return this.methodName;
      }
      getHost() {
        return this.options.host;
      }
      startRead() {
        if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {
          this.readsClosed = true;
          this.maybeOutputStatus();
          return;
        }
        this.canPush = true;
        if (this.http2Stream === null) {
          this.pendingRead = true;
        } else {
          if (this.unpushedReadMessages.length > 0) {
            const nextMessage = this.unpushedReadMessages.shift();
            this.push(nextMessage);
            return;
          }
          this.http2Stream.resume();
        }
      }
      maybeCloseWrites() {
        if (this.writesClosed && !this.isWriteFilterPending && this.http2Stream !== null) {
          this.trace("calling end() on HTTP/2 stream");
          this.http2Stream.end();
        }
      }
      sendMessageWithContext(context, message) {
        var _a;
        this.trace("write() called with message of length " + message.length);
        const writeObj = {
          message,
          flags: context.flags
        };
        const cb = (_a = context.callback) !== null && _a !== void 0 ? _a : () => {
        };
        this.isWriteFilterPending = true;
        this.filterStack.sendMessage(Promise.resolve(writeObj)).then((message2) => {
          this.isWriteFilterPending = false;
          if (this.http2Stream === null) {
            this.trace("deferring writing data chunk of length " + message2.message.length);
            this.pendingWrite = message2.message;
            this.pendingWriteCallback = cb;
          } else {
            this.trace("sending data chunk of length " + message2.message.length);
            try {
              this.http2Stream.write(message2.message, cb);
            } catch (error2) {
              this.endCall({
                code: constants_1.Status.UNAVAILABLE,
                details: `Write failed with error ${error2.message}`,
                metadata: new metadata_1.Metadata()
              });
            }
            this.maybeCloseWrites();
          }
        }, this.handleFilterError.bind(this));
      }
      halfClose() {
        this.trace("end() called");
        this.writesClosed = true;
        this.maybeCloseWrites();
      }
    };
    exports2.Http2CallStream = Http2CallStream;
  }
});

// node_modules/@grpc/grpc-js/build/src/tls-helpers.js
var require_tls_helpers = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/tls-helpers.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDefaultRootsData = exports2.CIPHER_SUITES = void 0;
    var fs = require("fs");
    exports2.CIPHER_SUITES = process.env.GRPC_SSL_CIPHER_SUITES;
    var DEFAULT_ROOTS_FILE_PATH = process.env.GRPC_DEFAULT_SSL_ROOTS_FILE_PATH;
    var defaultRootsData = null;
    function getDefaultRootsData() {
      if (DEFAULT_ROOTS_FILE_PATH) {
        if (defaultRootsData === null) {
          defaultRootsData = fs.readFileSync(DEFAULT_ROOTS_FILE_PATH);
        }
        return defaultRootsData;
      }
      return null;
    }
    exports2.getDefaultRootsData = getDefaultRootsData;
  }
});

// node_modules/@grpc/grpc-js/build/src/channel-credentials.js
var require_channel_credentials = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/channel-credentials.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ChannelCredentials = void 0;
    var tls_1 = require("tls");
    var call_credentials_1 = require_call_credentials();
    var tls_helpers_1 = require_tls_helpers();
    function verifyIsBufferOrNull(obj, friendlyName) {
      if (obj && !(obj instanceof Buffer)) {
        throw new TypeError(`${friendlyName}, if provided, must be a Buffer.`);
      }
    }
    function bufferOrNullEqual(buf1, buf2) {
      if (buf1 === null && buf2 === null) {
        return true;
      } else {
        return buf1 !== null && buf2 !== null && buf1.equals(buf2);
      }
    }
    var ChannelCredentials = class {
      constructor(callCredentials) {
        this.callCredentials = callCredentials || call_credentials_1.CallCredentials.createEmpty();
      }
      _getCallCredentials() {
        return this.callCredentials;
      }
      static createSsl(rootCerts, privateKey, certChain, verifyOptions) {
        verifyIsBufferOrNull(rootCerts, "Root certificate");
        verifyIsBufferOrNull(privateKey, "Private key");
        verifyIsBufferOrNull(certChain, "Certificate chain");
        if (privateKey && !certChain) {
          throw new Error("Private key must be given with accompanying certificate chain");
        }
        if (!privateKey && certChain) {
          throw new Error("Certificate chain must be given with accompanying private key");
        }
        return new SecureChannelCredentialsImpl(rootCerts || tls_helpers_1.getDefaultRootsData(), privateKey || null, certChain || null, verifyOptions || {});
      }
      static createInsecure() {
        return new InsecureChannelCredentialsImpl();
      }
    };
    exports2.ChannelCredentials = ChannelCredentials;
    var InsecureChannelCredentialsImpl = class extends ChannelCredentials {
      constructor(callCredentials) {
        super(callCredentials);
      }
      compose(callCredentials) {
        throw new Error("Cannot compose insecure credentials");
      }
      _getConnectionOptions() {
        return null;
      }
      _isSecure() {
        return false;
      }
      _equals(other) {
        return other instanceof InsecureChannelCredentialsImpl;
      }
    };
    var SecureChannelCredentialsImpl = class extends ChannelCredentials {
      constructor(rootCerts, privateKey, certChain, verifyOptions) {
        super();
        this.rootCerts = rootCerts;
        this.privateKey = privateKey;
        this.certChain = certChain;
        this.verifyOptions = verifyOptions;
        const secureContext = tls_1.createSecureContext({
          ca: rootCerts || void 0,
          key: privateKey || void 0,
          cert: certChain || void 0,
          ciphers: tls_helpers_1.CIPHER_SUITES
        });
        this.connectionOptions = { secureContext };
        if (verifyOptions && verifyOptions.checkServerIdentity) {
          this.connectionOptions.checkServerIdentity = (host, cert) => {
            return verifyOptions.checkServerIdentity(host, { raw: cert.raw });
          };
        }
      }
      compose(callCredentials) {
        const combinedCallCredentials = this.callCredentials.compose(callCredentials);
        return new ComposedChannelCredentialsImpl(this, combinedCallCredentials);
      }
      _getConnectionOptions() {
        return Object.assign({}, this.connectionOptions);
      }
      _isSecure() {
        return true;
      }
      _equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof SecureChannelCredentialsImpl) {
          if (!bufferOrNullEqual(this.rootCerts, other.rootCerts)) {
            return false;
          }
          if (!bufferOrNullEqual(this.privateKey, other.privateKey)) {
            return false;
          }
          if (!bufferOrNullEqual(this.certChain, other.certChain)) {
            return false;
          }
          return this.verifyOptions.checkServerIdentity === other.verifyOptions.checkServerIdentity;
        } else {
          return false;
        }
      }
    };
    var ComposedChannelCredentialsImpl = class extends ChannelCredentials {
      constructor(channelCredentials, callCreds) {
        super(callCreds);
        this.channelCredentials = channelCredentials;
      }
      compose(callCredentials) {
        const combinedCallCredentials = this.callCredentials.compose(callCredentials);
        return new ComposedChannelCredentialsImpl(this.channelCredentials, combinedCallCredentials);
      }
      _getConnectionOptions() {
        return this.channelCredentials._getConnectionOptions();
      }
      _isSecure() {
        return true;
      }
      _equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof ComposedChannelCredentialsImpl) {
          return this.channelCredentials._equals(other.channelCredentials) && this.callCredentials._equals(other.callCredentials);
        } else {
          return false;
        }
      }
    };
  }
});

// node_modules/@grpc/grpc-js/build/src/picker.js
var require_picker = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/picker.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueuePicker = exports2.UnavailablePicker = exports2.PickResultType = void 0;
    var metadata_1 = require_metadata();
    var constants_1 = require_constants();
    var PickResultType;
    (function(PickResultType2) {
      PickResultType2[PickResultType2["COMPLETE"] = 0] = "COMPLETE";
      PickResultType2[PickResultType2["QUEUE"] = 1] = "QUEUE";
      PickResultType2[PickResultType2["TRANSIENT_FAILURE"] = 2] = "TRANSIENT_FAILURE";
      PickResultType2[PickResultType2["DROP"] = 3] = "DROP";
    })(PickResultType = exports2.PickResultType || (exports2.PickResultType = {}));
    var UnavailablePicker = class {
      constructor(status) {
        if (status !== void 0) {
          this.status = status;
        } else {
          this.status = {
            code: constants_1.Status.UNAVAILABLE,
            details: "No connection established",
            metadata: new metadata_1.Metadata()
          };
        }
      }
      pick(pickArgs) {
        return {
          pickResultType: PickResultType.TRANSIENT_FAILURE,
          subchannel: null,
          status: this.status,
          extraFilterFactory: null,
          onCallStarted: null
        };
      }
    };
    exports2.UnavailablePicker = UnavailablePicker;
    var QueuePicker = class {
      constructor(loadBalancer) {
        this.loadBalancer = loadBalancer;
        this.calledExitIdle = false;
      }
      pick(pickArgs) {
        if (!this.calledExitIdle) {
          process.nextTick(() => {
            this.loadBalancer.exitIdle();
          });
          this.calledExitIdle = true;
        }
        return {
          pickResultType: PickResultType.QUEUE,
          subchannel: null,
          status: null,
          extraFilterFactory: null,
          onCallStarted: null
        };
      }
    };
    exports2.QueuePicker = QueuePicker;
  }
});

// node_modules/@grpc/grpc-js/build/src/backoff-timeout.js
var require_backoff_timeout = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/backoff-timeout.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BackoffTimeout = void 0;
    var INITIAL_BACKOFF_MS = 1e3;
    var BACKOFF_MULTIPLIER = 1.6;
    var MAX_BACKOFF_MS = 12e4;
    var BACKOFF_JITTER = 0.2;
    function uniformRandom(min, max) {
      return Math.random() * (max - min) + min;
    }
    var BackoffTimeout = class {
      constructor(callback, options2) {
        this.callback = callback;
        this.initialDelay = INITIAL_BACKOFF_MS;
        this.multiplier = BACKOFF_MULTIPLIER;
        this.maxDelay = MAX_BACKOFF_MS;
        this.jitter = BACKOFF_JITTER;
        this.running = false;
        this.hasRef = true;
        if (options2) {
          if (options2.initialDelay) {
            this.initialDelay = options2.initialDelay;
          }
          if (options2.multiplier) {
            this.multiplier = options2.multiplier;
          }
          if (options2.jitter) {
            this.jitter = options2.jitter;
          }
          if (options2.maxDelay) {
            this.maxDelay = options2.maxDelay;
          }
        }
        this.nextDelay = this.initialDelay;
        this.timerId = setTimeout(() => {
        }, 0);
        clearTimeout(this.timerId);
      }
      runOnce() {
        var _a, _b;
        this.running = true;
        this.timerId = setTimeout(() => {
          this.callback();
          this.running = false;
        }, this.nextDelay);
        if (!this.hasRef) {
          (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
        const nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);
        const jitterMagnitude = nextBackoff * this.jitter;
        this.nextDelay = nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);
      }
      stop() {
        clearTimeout(this.timerId);
        this.running = false;
      }
      reset() {
        this.nextDelay = this.initialDelay;
      }
      isRunning() {
        return this.running;
      }
      ref() {
        var _a, _b;
        this.hasRef = true;
        (_b = (_a = this.timerId).ref) === null || _b === void 0 ? void 0 : _b.call(_a);
      }
      unref() {
        var _a, _b;
        this.hasRef = false;
        (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
      }
    };
    exports2.BackoffTimeout = BackoffTimeout;
  }
});

// node_modules/@grpc/grpc-js/build/src/service-config.js
var require_service_config = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/service-config.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extractAndSelectServiceConfig = exports2.validateServiceConfig = void 0;
    var os = require("os");
    var load_balancer_1 = require_load_balancer();
    var TIMEOUT_REGEX = /^\d+(\.\d{1,9})?s$/;
    var CLIENT_LANGUAGE_STRING = "node";
    function validateName(obj) {
      if (!("service" in obj) || typeof obj.service !== "string") {
        throw new Error("Invalid method config name: invalid service");
      }
      const result = {
        service: obj.service
      };
      if ("method" in obj) {
        if (typeof obj.method === "string") {
          result.method = obj.method;
        } else {
          throw new Error("Invalid method config name: invalid method");
        }
      }
      return result;
    }
    function validateMethodConfig(obj) {
      const result = {
        name: []
      };
      if (!("name" in obj) || !Array.isArray(obj.name)) {
        throw new Error("Invalid method config: invalid name array");
      }
      for (const name2 of obj.name) {
        result.name.push(validateName(name2));
      }
      if ("waitForReady" in obj) {
        if (typeof obj.waitForReady !== "boolean") {
          throw new Error("Invalid method config: invalid waitForReady");
        }
        result.waitForReady = obj.waitForReady;
      }
      if ("timeout" in obj) {
        if (!(typeof obj.timeout === "string") || !TIMEOUT_REGEX.test(obj.timeout)) {
          throw new Error("Invalid method config: invalid timeout");
        }
        result.timeout = obj.timeout;
      }
      if ("maxRequestBytes" in obj) {
        if (typeof obj.maxRequestBytes !== "number") {
          throw new Error("Invalid method config: invalid maxRequestBytes");
        }
        result.maxRequestBytes = obj.maxRequestBytes;
      }
      if ("maxResponseBytes" in obj) {
        if (typeof obj.maxResponseBytes !== "number") {
          throw new Error("Invalid method config: invalid maxRequestBytes");
        }
        result.maxResponseBytes = obj.maxResponseBytes;
      }
      return result;
    }
    function validateServiceConfig(obj) {
      const result = {
        loadBalancingConfig: [],
        methodConfig: []
      };
      if ("loadBalancingPolicy" in obj) {
        if (typeof obj.loadBalancingPolicy === "string") {
          result.loadBalancingPolicy = obj.loadBalancingPolicy;
        } else {
          throw new Error("Invalid service config: invalid loadBalancingPolicy");
        }
      }
      if ("loadBalancingConfig" in obj) {
        if (Array.isArray(obj.loadBalancingConfig)) {
          for (const config2 of obj.loadBalancingConfig) {
            result.loadBalancingConfig.push(load_balancer_1.validateLoadBalancingConfig(config2));
          }
        } else {
          throw new Error("Invalid service config: invalid loadBalancingConfig");
        }
      }
      if ("methodConfig" in obj) {
        if (Array.isArray(obj.methodConfig)) {
          for (const methodConfig of obj.methodConfig) {
            result.methodConfig.push(validateMethodConfig(methodConfig));
          }
        }
      }
      const seenMethodNames = [];
      for (const methodConfig of result.methodConfig) {
        for (const name2 of methodConfig.name) {
          for (const seenName of seenMethodNames) {
            if (name2.service === seenName.service && name2.method === seenName.method) {
              throw new Error(`Invalid service config: duplicate name ${name2.service}/${name2.method}`);
            }
          }
          seenMethodNames.push(name2);
        }
      }
      return result;
    }
    exports2.validateServiceConfig = validateServiceConfig;
    function validateCanaryConfig(obj) {
      if (!("serviceConfig" in obj)) {
        throw new Error("Invalid service config choice: missing service config");
      }
      const result = {
        serviceConfig: validateServiceConfig(obj.serviceConfig)
      };
      if ("clientLanguage" in obj) {
        if (Array.isArray(obj.clientLanguage)) {
          result.clientLanguage = [];
          for (const lang of obj.clientLanguage) {
            if (typeof lang === "string") {
              result.clientLanguage.push(lang);
            } else {
              throw new Error("Invalid service config choice: invalid clientLanguage");
            }
          }
        } else {
          throw new Error("Invalid service config choice: invalid clientLanguage");
        }
      }
      if ("clientHostname" in obj) {
        if (Array.isArray(obj.clientHostname)) {
          result.clientHostname = [];
          for (const lang of obj.clientHostname) {
            if (typeof lang === "string") {
              result.clientHostname.push(lang);
            } else {
              throw new Error("Invalid service config choice: invalid clientHostname");
            }
          }
        } else {
          throw new Error("Invalid service config choice: invalid clientHostname");
        }
      }
      if ("percentage" in obj) {
        if (typeof obj.percentage === "number" && 0 <= obj.percentage && obj.percentage <= 100) {
          result.percentage = obj.percentage;
        } else {
          throw new Error("Invalid service config choice: invalid percentage");
        }
      }
      const allowedFields = [
        "clientLanguage",
        "percentage",
        "clientHostname",
        "serviceConfig"
      ];
      for (const field in obj) {
        if (!allowedFields.includes(field)) {
          throw new Error(`Invalid service config choice: unexpected field ${field}`);
        }
      }
      return result;
    }
    function validateAndSelectCanaryConfig(obj, percentage) {
      if (!Array.isArray(obj)) {
        throw new Error("Invalid service config list");
      }
      for (const config2 of obj) {
        const validatedConfig = validateCanaryConfig(config2);
        if (typeof validatedConfig.percentage === "number" && percentage > validatedConfig.percentage) {
          continue;
        }
        if (Array.isArray(validatedConfig.clientHostname)) {
          let hostnameMatched = false;
          for (const hostname of validatedConfig.clientHostname) {
            if (hostname === os.hostname()) {
              hostnameMatched = true;
            }
          }
          if (!hostnameMatched) {
            continue;
          }
        }
        if (Array.isArray(validatedConfig.clientLanguage)) {
          let languageMatched = false;
          for (const language of validatedConfig.clientLanguage) {
            if (language === CLIENT_LANGUAGE_STRING) {
              languageMatched = true;
            }
          }
          if (!languageMatched) {
            continue;
          }
        }
        return validatedConfig.serviceConfig;
      }
      throw new Error("No matching service config found");
    }
    function extractAndSelectServiceConfig(txtRecord, percentage) {
      for (const record of txtRecord) {
        if (record.length > 0 && record[0].startsWith("grpc_config=")) {
          const recordString = record.join("").substring("grpc_config=".length);
          const recordJson = JSON.parse(recordString);
          return validateAndSelectCanaryConfig(recordJson, percentage);
        }
      }
      return null;
    }
    exports2.extractAndSelectServiceConfig = extractAndSelectServiceConfig;
  }
});

// node_modules/@grpc/grpc-js/build/src/uri-parser.js
var require_uri_parser = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/uri-parser.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.uriToString = exports2.splitHostPort = exports2.parseUri = void 0;
    var URI_REGEX = /^(?:([A-Za-z0-9+.-]+):)?(?:\/\/([^/]*)\/)?(.+)$/;
    function parseUri(uriString) {
      const parsedUri = URI_REGEX.exec(uriString);
      if (parsedUri === null) {
        return null;
      }
      return {
        scheme: parsedUri[1],
        authority: parsedUri[2],
        path: parsedUri[3]
      };
    }
    exports2.parseUri = parseUri;
    var NUMBER_REGEX = /^\d+$/;
    function splitHostPort(path) {
      if (path.startsWith("[")) {
        const hostEnd = path.indexOf("]");
        if (hostEnd === -1) {
          return null;
        }
        const host = path.substring(1, hostEnd);
        if (host.indexOf(":") === -1) {
          return null;
        }
        if (path.length > hostEnd + 1) {
          if (path[hostEnd + 1] === ":") {
            const portString = path.substring(hostEnd + 2);
            if (NUMBER_REGEX.test(portString)) {
              return {
                host,
                port: +portString
              };
            } else {
              return null;
            }
          } else {
            return null;
          }
        } else {
          return {
            host
          };
        }
      } else {
        const splitPath = path.split(":");
        if (splitPath.length === 2) {
          if (NUMBER_REGEX.test(splitPath[1])) {
            return {
              host: splitPath[0],
              port: +splitPath[1]
            };
          } else {
            return null;
          }
        } else {
          return {
            host: path
          };
        }
      }
    }
    exports2.splitHostPort = splitHostPort;
    function uriToString(uri) {
      let result = "";
      if (uri.scheme !== void 0) {
        result += uri.scheme + ":";
      }
      if (uri.authority !== void 0) {
        result += "//" + uri.authority + "/";
      }
      result += uri.path;
      return result;
    }
    exports2.uriToString = uriToString;
  }
});

// node_modules/@grpc/grpc-js/build/src/resolver-dns.js
var require_resolver_dns = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/resolver-dns.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setup = void 0;
    var resolver_1 = require_resolver();
    var dns = require("dns");
    var util = require("util");
    var service_config_1 = require_service_config();
    var constants_1 = require_constants();
    var metadata_1 = require_metadata();
    var logging = require_logging();
    var constants_2 = require_constants();
    var uri_parser_1 = require_uri_parser();
    var net_1 = require("net");
    var TRACER_NAME = "dns_resolver";
    function trace(text) {
      logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    var DEFAULT_PORT = 443;
    var resolveTxtPromise = util.promisify(dns.resolveTxt);
    var dnsLookupPromise = util.promisify(dns.lookup);
    function mergeArrays(...arrays) {
      const result = [];
      for (let i = 0; i < Math.max.apply(null, arrays.map((array) => array.length)); i++) {
        for (const array of arrays) {
          if (i < array.length) {
            result.push(array[i]);
          }
        }
      }
      return result;
    }
    var DnsResolver = class {
      constructor(target, listener, channelOptions) {
        var _a, _b;
        this.target = target;
        this.listener = listener;
        this.pendingLookupPromise = null;
        this.pendingTxtPromise = null;
        this.latestLookupResult = null;
        this.latestServiceConfig = null;
        this.latestServiceConfigError = null;
        trace("Resolver constructed for target " + uri_parser_1.uriToString(target));
        const hostPort = uri_parser_1.splitHostPort(target.path);
        if (hostPort === null) {
          this.ipResult = null;
          this.dnsHostname = null;
          this.port = null;
        } else {
          if (net_1.isIPv4(hostPort.host) || net_1.isIPv6(hostPort.host)) {
            this.ipResult = [
              {
                host: hostPort.host,
                port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : DEFAULT_PORT
              }
            ];
            this.dnsHostname = null;
            this.port = null;
          } else {
            this.ipResult = null;
            this.dnsHostname = hostPort.host;
            this.port = (_b = hostPort.port) !== null && _b !== void 0 ? _b : DEFAULT_PORT;
          }
        }
        this.percentage = Math.random() * 100;
        this.defaultResolutionError = {
          code: constants_1.Status.UNAVAILABLE,
          details: `Name resolution failed for target ${uri_parser_1.uriToString(this.target)}`,
          metadata: new metadata_1.Metadata()
        };
      }
      startResolution() {
        if (this.ipResult !== null) {
          trace("Returning IP address for target " + uri_parser_1.uriToString(this.target));
          setImmediate(() => {
            this.listener.onSuccessfulResolution(this.ipResult, null, null, null, {});
          });
          return;
        }
        if (this.dnsHostname === null) {
          setImmediate(() => {
            this.listener.onError({
              code: constants_1.Status.UNAVAILABLE,
              details: `Failed to parse DNS address ${uri_parser_1.uriToString(this.target)}`,
              metadata: new metadata_1.Metadata()
            });
          });
        } else {
          this.latestLookupResult = null;
          const hostname = this.dnsHostname;
          this.pendingLookupPromise = dnsLookupPromise(hostname, { all: true });
          this.pendingLookupPromise.then((addressList) => {
            this.pendingLookupPromise = null;
            const ip4Addresses = addressList.filter((addr) => addr.family === 4);
            const ip6Addresses = addressList.filter((addr) => addr.family === 6);
            this.latestLookupResult = mergeArrays(ip6Addresses, ip4Addresses).map((addr) => ({ host: addr.address, port: +this.port }));
            const allAddressesString = "[" + this.latestLookupResult.map((addr) => addr.host + ":" + addr.port).join(",") + "]";
            trace("Resolved addresses for target " + uri_parser_1.uriToString(this.target) + ": " + allAddressesString);
            if (this.latestLookupResult.length === 0) {
              this.listener.onError(this.defaultResolutionError);
              return;
            }
            this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});
          }, (err) => {
            trace("Resolution error for target " + uri_parser_1.uriToString(this.target) + ": " + err.message);
            this.pendingLookupPromise = null;
            this.listener.onError(this.defaultResolutionError);
          });
          if (this.pendingTxtPromise === null) {
            this.pendingTxtPromise = resolveTxtPromise(hostname);
            this.pendingTxtPromise.then((txtRecord) => {
              this.pendingTxtPromise = null;
              try {
                this.latestServiceConfig = service_config_1.extractAndSelectServiceConfig(txtRecord, this.percentage);
              } catch (err) {
                this.latestServiceConfigError = {
                  code: constants_1.Status.UNAVAILABLE,
                  details: "Parsing service config failed",
                  metadata: new metadata_1.Metadata()
                };
              }
              if (this.latestLookupResult !== null) {
                this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});
              }
            }, (err) => {
            });
          }
        }
      }
      updateResolution() {
        trace("Resolution update requested for target " + uri_parser_1.uriToString(this.target));
        if (this.pendingLookupPromise === null) {
          this.startResolution();
        }
      }
      destroy() {
      }
      static getDefaultAuthority(target) {
        return target.path;
      }
    };
    function setup() {
      resolver_1.registerResolver("dns", DnsResolver);
      resolver_1.registerDefaultScheme("dns");
    }
    exports2.setup = setup;
  }
});

// node_modules/@grpc/grpc-js/build/src/resolver-uds.js
var require_resolver_uds = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/resolver-uds.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setup = void 0;
    var resolver_1 = require_resolver();
    var UdsResolver = class {
      constructor(target, listener, channelOptions) {
        this.listener = listener;
        this.addresses = [];
        let path;
        if (target.authority === "") {
          path = "/" + target.path;
        } else {
          path = target.path;
        }
        this.addresses = [{ path }];
      }
      updateResolution() {
        process.nextTick(this.listener.onSuccessfulResolution, this.addresses, null, null, null, {});
      }
      destroy() {
      }
      static getDefaultAuthority(target) {
        return "localhost";
      }
    };
    function setup() {
      resolver_1.registerResolver("unix", UdsResolver);
    }
    exports2.setup = setup;
  }
});

// node_modules/@grpc/grpc-js/build/src/resolver-ip.js
var require_resolver_ip = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/resolver-ip.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setup = void 0;
    var net_1 = require("net");
    var constants_1 = require_constants();
    var metadata_1 = require_metadata();
    var resolver_1 = require_resolver();
    var uri_parser_1 = require_uri_parser();
    var logging = require_logging();
    var TRACER_NAME = "ip_resolver";
    function trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    var IPV4_SCHEME = "ipv4";
    var IPV6_SCHEME = "ipv6";
    var DEFAULT_PORT = 443;
    var IpResolver = class {
      constructor(target, listener, channelOptions) {
        var _a;
        this.target = target;
        this.listener = listener;
        this.addresses = [];
        this.error = null;
        trace("Resolver constructed for target " + uri_parser_1.uriToString(target));
        const addresses = [];
        if (!(target.scheme === IPV4_SCHEME || target.scheme === IPV6_SCHEME)) {
          this.error = {
            code: constants_1.Status.UNAVAILABLE,
            details: `Unrecognized scheme ${target.scheme} in IP resolver`,
            metadata: new metadata_1.Metadata()
          };
          return;
        }
        const pathList = target.path.split(",");
        for (const path of pathList) {
          const hostPort = uri_parser_1.splitHostPort(path);
          if (hostPort === null) {
            this.error = {
              code: constants_1.Status.UNAVAILABLE,
              details: `Failed to parse ${target.scheme} address ${path}`,
              metadata: new metadata_1.Metadata()
            };
            return;
          }
          if (target.scheme === IPV4_SCHEME && !net_1.isIPv4(hostPort.host) || target.scheme === IPV6_SCHEME && !net_1.isIPv6(hostPort.host)) {
            this.error = {
              code: constants_1.Status.UNAVAILABLE,
              details: `Failed to parse ${target.scheme} address ${path}`,
              metadata: new metadata_1.Metadata()
            };
            return;
          }
          addresses.push({
            host: hostPort.host,
            port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : DEFAULT_PORT
          });
        }
        this.addresses = addresses;
        trace("Parsed " + target.scheme + " address list " + this.addresses);
      }
      updateResolution() {
        process.nextTick(() => {
          if (this.error) {
            this.listener.onError(this.error);
          } else {
            this.listener.onSuccessfulResolution(this.addresses, null, null, null, {});
          }
        });
      }
      destroy() {
      }
      static getDefaultAuthority(target) {
        return target.path.split(",")[0];
      }
    };
    function setup() {
      resolver_1.registerResolver(IPV4_SCHEME, IpResolver);
      resolver_1.registerResolver(IPV6_SCHEME, IpResolver);
    }
    exports2.setup = setup;
  }
});

// node_modules/@grpc/grpc-js/build/src/resolver.js
var require_resolver = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/resolver.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.registerAll = exports2.mapUriDefaultScheme = exports2.getDefaultAuthority = exports2.createResolver = exports2.registerDefaultScheme = exports2.registerResolver = void 0;
    var resolver_dns = require_resolver_dns();
    var resolver_uds = require_resolver_uds();
    var resolver_ip = require_resolver_ip();
    var uri_parser_1 = require_uri_parser();
    var registeredResolvers = {};
    var defaultScheme = null;
    function registerResolver(scheme, resolverClass) {
      registeredResolvers[scheme] = resolverClass;
    }
    exports2.registerResolver = registerResolver;
    function registerDefaultScheme(scheme) {
      defaultScheme = scheme;
    }
    exports2.registerDefaultScheme = registerDefaultScheme;
    function createResolver(target, listener, options2) {
      if (target.scheme !== void 0 && target.scheme in registeredResolvers) {
        return new registeredResolvers[target.scheme](target, listener, options2);
      } else {
        throw new Error(`No resolver could be created for target ${uri_parser_1.uriToString(target)}`);
      }
    }
    exports2.createResolver = createResolver;
    function getDefaultAuthority(target) {
      if (target.scheme !== void 0 && target.scheme in registeredResolvers) {
        return registeredResolvers[target.scheme].getDefaultAuthority(target);
      } else {
        throw new Error(`Invalid target ${uri_parser_1.uriToString(target)}`);
      }
    }
    exports2.getDefaultAuthority = getDefaultAuthority;
    function mapUriDefaultScheme(target) {
      if (target.scheme === void 0 || !(target.scheme in registeredResolvers)) {
        if (defaultScheme !== null) {
          return {
            scheme: defaultScheme,
            authority: void 0,
            path: uri_parser_1.uriToString(target)
          };
        } else {
          return null;
        }
      }
      return target;
    }
    exports2.mapUriDefaultScheme = mapUriDefaultScheme;
    function registerAll() {
      resolver_dns.setup();
      resolver_uds.setup();
      resolver_ip.setup();
    }
    exports2.registerAll = registerAll;
  }
});

// node_modules/@grpc/grpc-js/build/src/http_proxy.js
var require_http_proxy = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/http_proxy.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getProxiedConnection = exports2.mapProxyName = void 0;
    var logging_1 = require_logging();
    var constants_1 = require_constants();
    var resolver_1 = require_resolver();
    var http2 = require("http");
    var tls = require("tls");
    var logging = require_logging();
    var subchannel_1 = require_subchannel();
    var uri_parser_1 = require_uri_parser();
    var url_1 = require("url");
    var TRACER_NAME = "proxy";
    function trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    function getProxyInfo() {
      let proxyEnv = "";
      let envVar = "";
      if (process.env.grpc_proxy) {
        envVar = "grpc_proxy";
        proxyEnv = process.env.grpc_proxy;
      } else if (process.env.https_proxy) {
        envVar = "https_proxy";
        proxyEnv = process.env.https_proxy;
      } else if (process.env.http_proxy) {
        envVar = "http_proxy";
        proxyEnv = process.env.http_proxy;
      } else {
        return {};
      }
      let proxyUrl;
      try {
        proxyUrl = new url_1.URL(proxyEnv);
      } catch (e) {
        logging_1.log(constants_1.LogVerbosity.ERROR, `cannot parse value of "${envVar}" env var`);
        return {};
      }
      if (proxyUrl.protocol !== "http:") {
        logging_1.log(constants_1.LogVerbosity.ERROR, `"${proxyUrl.protocol}" scheme not supported in proxy URI`);
        return {};
      }
      let userCred = null;
      if (proxyUrl.username) {
        if (proxyUrl.password) {
          logging_1.log(constants_1.LogVerbosity.INFO, "userinfo found in proxy URI");
          userCred = `${proxyUrl.username}:${proxyUrl.password}`;
        } else {
          userCred = proxyUrl.username;
        }
      }
      const hostname = proxyUrl.hostname;
      let port = proxyUrl.port;
      if (port === "") {
        port = "80";
      }
      const result = {
        address: `${hostname}:${port}`
      };
      if (userCred) {
        result.creds = userCred;
      }
      trace("Proxy server " + result.address + " set by environment variable " + envVar);
      return result;
    }
    function getNoProxyHostList() {
      let noProxyStr = process.env.no_grpc_proxy;
      let envVar = "no_grpc_proxy";
      if (!noProxyStr) {
        noProxyStr = process.env.no_proxy;
        envVar = "no_proxy";
      }
      if (noProxyStr) {
        trace("No proxy server list set by environment variable " + envVar);
        return noProxyStr.split(",");
      } else {
        return [];
      }
    }
    function mapProxyName(target, options2) {
      var _a;
      const noProxyResult = {
        target,
        extraOptions: {}
      };
      if (((_a = options2["grpc.enable_http_proxy"]) !== null && _a !== void 0 ? _a : 1) === 0) {
        return noProxyResult;
      }
      const proxyInfo = getProxyInfo();
      if (!proxyInfo.address) {
        return noProxyResult;
      }
      const hostPort = uri_parser_1.splitHostPort(target.path);
      if (!hostPort) {
        return noProxyResult;
      }
      const serverHost = hostPort.host;
      for (const host of getNoProxyHostList()) {
        if (host === serverHost) {
          trace("Not using proxy for target in no_proxy list: " + uri_parser_1.uriToString(target));
          return noProxyResult;
        }
      }
      const extraOptions = {
        "grpc.http_connect_target": uri_parser_1.uriToString(target)
      };
      if (proxyInfo.creds) {
        extraOptions["grpc.http_connect_creds"] = proxyInfo.creds;
      }
      return {
        target: {
          scheme: "dns",
          path: proxyInfo.address
        },
        extraOptions
      };
    }
    exports2.mapProxyName = mapProxyName;
    function getProxiedConnection(address, channelOptions, connectionOptions) {
      if (!("grpc.http_connect_target" in channelOptions)) {
        return Promise.resolve({});
      }
      const realTarget = channelOptions["grpc.http_connect_target"];
      const parsedTarget = uri_parser_1.parseUri(realTarget);
      if (parsedTarget === null) {
        return Promise.resolve({});
      }
      const options2 = {
        method: "CONNECT",
        path: parsedTarget.path
      };
      if (subchannel_1.isTcpSubchannelAddress(address)) {
        options2.host = address.host;
        options2.port = address.port;
      } else {
        options2.socketPath = address.path;
      }
      if ("grpc.http_connect_creds" in channelOptions) {
        options2.headers = {
          "Proxy-Authorization": "Basic " + Buffer.from(channelOptions["grpc.http_connect_creds"]).toString("base64")
        };
      }
      const proxyAddressString = subchannel_1.subchannelAddressToString(address);
      trace("Using proxy " + proxyAddressString + " to connect to " + options2.path);
      return new Promise((resolve2, reject) => {
        const request = http2.request(options2);
        request.once("connect", (res, socket, head) => {
          var _a;
          request.removeAllListeners();
          socket.removeAllListeners();
          if (res.statusCode === 200) {
            trace("Successfully connected to " + options2.path + " through proxy " + proxyAddressString);
            if ("secureContext" in connectionOptions) {
              const targetPath = resolver_1.getDefaultAuthority(parsedTarget);
              const hostPort = uri_parser_1.splitHostPort(targetPath);
              const remoteHost = (_a = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _a !== void 0 ? _a : targetPath;
              const cts = tls.connect(Object.assign({ host: remoteHost, servername: remoteHost, socket }, connectionOptions), () => {
                trace("Successfully established a TLS connection to " + options2.path + " through proxy " + proxyAddressString);
                resolve2({ socket: cts, realTarget: parsedTarget });
              });
              cts.on("error", (error2) => {
                trace("Failed to establish a TLS connection to " + options2.path + " through proxy " + proxyAddressString + " with error " + error2.message);
                reject();
              });
            } else {
              trace("Successfully established a plaintext connection to " + options2.path + " through proxy " + proxyAddressString);
              resolve2({
                socket,
                realTarget: parsedTarget
              });
            }
          } else {
            logging_1.log(constants_1.LogVerbosity.ERROR, "Failed to connect to " + options2.path + " through proxy " + proxyAddressString + " with status " + res.statusCode);
            reject();
          }
        });
        request.once("error", (err) => {
          request.removeAllListeners();
          logging_1.log(constants_1.LogVerbosity.ERROR, "Failed to connect to proxy " + proxyAddressString + " with error " + err.message);
          reject();
        });
        request.end();
      });
    }
    exports2.getProxiedConnection = getProxiedConnection;
  }
});

// node_modules/@grpc/grpc-js/package.json
var require_package = __commonJS({
  "node_modules/@grpc/grpc-js/package.json"(exports2, module2) {
    module2.exports = {
      name: "@grpc/grpc-js",
      version: "1.3.7",
      description: "gRPC Library for Node - pure JS implementation",
      homepage: "https://grpc.io/",
      repository: "https://github.com/grpc/grpc-node/tree/master/packages/grpc-js",
      main: "build/src/index.js",
      engines: {
        node: "^8.13.0 || >=10.10.0"
      },
      keywords: [],
      author: {
        name: "Google Inc."
      },
      types: "build/src/index.d.ts",
      license: "Apache-2.0",
      devDependencies: {
        "@grpc/proto-loader": "^0.5.5",
        "@types/gulp": "^4.0.6",
        "@types/gulp-mocha": "0.0.32",
        "@types/lodash": "^4.14.108",
        "@types/mocha": "^5.2.6",
        "@types/ncp": "^2.0.1",
        "@types/pify": "^3.0.2",
        "@types/yargs": "^15.0.5",
        "clang-format": "^1.0.55",
        execa: "^2.0.3",
        gts: "^2.0.0",
        gulp: "^4.0.2",
        "gulp-mocha": "^6.0.0",
        lodash: "^4.17.4",
        "mocha-jenkins-reporter": "^0.4.1",
        ncp: "^2.0.0",
        pify: "^4.0.1",
        rimraf: "^3.0.2",
        "ts-node": "^8.3.0",
        typescript: "^3.7.2",
        yargs: "^15.4.1"
      },
      contributors: [
        {
          name: "Google Inc."
        }
      ],
      scripts: {
        build: "npm run compile",
        clean: `node -e 'require("rimraf")("./build", () => {})'`,
        compile: "tsc -p .",
        format: 'clang-format -i -style="{Language: JavaScript, BasedOnStyle: Google, ColumnLimit: 80}" src/*.ts test/*.ts',
        lint: "npm run check",
        prepare: "npm run compile",
        test: "gulp test",
        check: "gts check src/**/*.ts",
        fix: "gts fix src/*.ts",
        pretest: "npm run compile",
        posttest: "npm run check"
      },
      dependencies: {
        "@types/node": ">=12.12.47"
      },
      files: [
        "src/**/*.ts",
        "build/src/*.{js,d.ts,js.map}",
        "LICENSE",
        "deps/envoy-api/envoy/api/v2/**/*.proto",
        "deps/envoy-api/envoy/config/**/*.proto",
        "deps/envoy-api/envoy/service/**/*.proto",
        "deps/envoy-api/envoy/type/**/*.proto",
        "deps/udpa/udpa/**/*.proto",
        "deps/googleapis/google/api/*.proto",
        "deps/googleapis/google/rpc/*.proto",
        "deps/protoc-gen-validate/validate/**/*.proto"
      ]
    };
  }
});

// node_modules/@grpc/grpc-js/build/src/subchannel.js
var require_subchannel = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/subchannel.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Subchannel = exports2.subchannelAddressToString = exports2.subchannelAddressEqual = exports2.isTcpSubchannelAddress = void 0;
    var http2 = require("http2");
    var tls_1 = require("tls");
    var channel_1 = require_channel();
    var backoff_timeout_1 = require_backoff_timeout();
    var resolver_1 = require_resolver();
    var logging = require_logging();
    var constants_1 = require_constants();
    var http_proxy_1 = require_http_proxy();
    var net = require("net");
    var uri_parser_1 = require_uri_parser();
    var clientVersion = require_package().version;
    var TRACER_NAME = "subchannel";
    function trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    function refTrace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, "subchannel_refcount", text);
    }
    var KEEPALIVE_MAX_TIME_MS = ~(1 << 31);
    var KEEPALIVE_TIMEOUT_MS = 2e4;
    var { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_TE, HTTP2_HEADER_USER_AGENT } = http2.constants;
    var tooManyPingsData = Buffer.from("too_many_pings", "ascii");
    function isTcpSubchannelAddress(address) {
      return "port" in address;
    }
    exports2.isTcpSubchannelAddress = isTcpSubchannelAddress;
    function subchannelAddressEqual(address1, address2) {
      if (isTcpSubchannelAddress(address1)) {
        return isTcpSubchannelAddress(address2) && address1.host === address2.host && address1.port === address2.port;
      } else {
        return !isTcpSubchannelAddress(address2) && address1.path === address2.path;
      }
    }
    exports2.subchannelAddressEqual = subchannelAddressEqual;
    function subchannelAddressToString(address) {
      if (isTcpSubchannelAddress(address)) {
        return address.host + ":" + address.port;
      } else {
        return address.path;
      }
    }
    exports2.subchannelAddressToString = subchannelAddressToString;
    var Subchannel = class {
      constructor(channelTarget, subchannelAddress, options2, credentials) {
        this.channelTarget = channelTarget;
        this.subchannelAddress = subchannelAddress;
        this.options = options2;
        this.credentials = credentials;
        this.connectivityState = channel_1.ConnectivityState.IDLE;
        this.session = null;
        this.continueConnecting = false;
        this.stateListeners = [];
        this.disconnectListeners = [];
        this.keepaliveTimeMs = KEEPALIVE_MAX_TIME_MS;
        this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;
        this.keepaliveWithoutCalls = false;
        this.callRefcount = 0;
        this.refcount = 0;
        this.userAgent = [
          options2["grpc.primary_user_agent"],
          `grpc-node-js/${clientVersion}`,
          options2["grpc.secondary_user_agent"]
        ].filter((e) => e).join(" ");
        if ("grpc.keepalive_time_ms" in options2) {
          this.keepaliveTimeMs = options2["grpc.keepalive_time_ms"];
        }
        if ("grpc.keepalive_timeout_ms" in options2) {
          this.keepaliveTimeoutMs = options2["grpc.keepalive_timeout_ms"];
        }
        if ("grpc.keepalive_permit_without_calls" in options2) {
          this.keepaliveWithoutCalls = options2["grpc.keepalive_permit_without_calls"] === 1;
        } else {
          this.keepaliveWithoutCalls = false;
        }
        this.keepaliveIntervalId = setTimeout(() => {
        }, 0);
        clearTimeout(this.keepaliveIntervalId);
        this.keepaliveTimeoutId = setTimeout(() => {
        }, 0);
        clearTimeout(this.keepaliveTimeoutId);
        const backoffOptions = {
          initialDelay: options2["grpc.initial_reconnect_backoff_ms"],
          maxDelay: options2["grpc.max_reconnect_backoff_ms"]
        };
        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {
          this.handleBackoffTimer();
        }, backoffOptions);
        this.subchannelAddressString = subchannelAddressToString(subchannelAddress);
      }
      handleBackoffTimer() {
        if (this.continueConnecting) {
          this.transitionToState([channel_1.ConnectivityState.TRANSIENT_FAILURE], channel_1.ConnectivityState.CONNECTING);
        } else {
          this.transitionToState([channel_1.ConnectivityState.TRANSIENT_FAILURE], channel_1.ConnectivityState.IDLE);
        }
      }
      startBackoff() {
        this.backoffTimeout.runOnce();
      }
      stopBackoff() {
        this.backoffTimeout.stop();
        this.backoffTimeout.reset();
      }
      sendPing() {
        var _a, _b;
        logging.trace(constants_1.LogVerbosity.DEBUG, "keepalive", "Sending ping to " + this.subchannelAddressString);
        this.keepaliveTimeoutId = setTimeout(() => {
          this.transitionToState([channel_1.ConnectivityState.READY], channel_1.ConnectivityState.IDLE);
        }, this.keepaliveTimeoutMs);
        (_b = (_a = this.keepaliveTimeoutId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        this.session.ping((err, duration, payload) => {
          clearTimeout(this.keepaliveTimeoutId);
        });
      }
      startKeepalivePings() {
        var _a, _b;
        this.keepaliveIntervalId = setInterval(() => {
          this.sendPing();
        }, this.keepaliveTimeMs);
        (_b = (_a = this.keepaliveIntervalId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
      }
      stopKeepalivePings() {
        clearInterval(this.keepaliveIntervalId);
        clearTimeout(this.keepaliveTimeoutId);
      }
      createSession(proxyConnectionResult) {
        var _a, _b, _c;
        if (proxyConnectionResult.realTarget) {
          trace(this.subchannelAddressString + " creating HTTP/2 session through proxy to " + proxyConnectionResult.realTarget);
        } else {
          trace(this.subchannelAddressString + " creating HTTP/2 session");
        }
        const targetAuthority = resolver_1.getDefaultAuthority((_a = proxyConnectionResult.realTarget) !== null && _a !== void 0 ? _a : this.channelTarget);
        let connectionOptions = this.credentials._getConnectionOptions() || {};
        connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;
        if ("grpc-node.max_session_memory" in this.options) {
          connectionOptions.maxSessionMemory = this.options["grpc-node.max_session_memory"];
        }
        let addressScheme = "http://";
        if ("secureContext" in connectionOptions) {
          addressScheme = "https://";
          if (this.options["grpc.ssl_target_name_override"]) {
            const sslTargetNameOverride = this.options["grpc.ssl_target_name_override"];
            connectionOptions.checkServerIdentity = (host, cert) => {
              return tls_1.checkServerIdentity(sslTargetNameOverride, cert);
            };
            connectionOptions.servername = sslTargetNameOverride;
          } else {
            const authorityHostname = (_c = (_b = uri_parser_1.splitHostPort(targetAuthority)) === null || _b === void 0 ? void 0 : _b.host) !== null && _c !== void 0 ? _c : "localhost";
            connectionOptions.servername = authorityHostname;
          }
          if (proxyConnectionResult.socket) {
            connectionOptions.createConnection = (authority, option) => {
              return proxyConnectionResult.socket;
            };
          }
        } else {
          connectionOptions.createConnection = (authority, option) => {
            if (proxyConnectionResult.socket) {
              return proxyConnectionResult.socket;
            } else {
              return net.connect(this.subchannelAddress);
            }
          };
        }
        connectionOptions = Object.assign(Object.assign({}, connectionOptions), this.subchannelAddress);
        const session = http2.connect(addressScheme + targetAuthority, connectionOptions);
        this.session = session;
        session.unref();
        session.once("connect", () => {
          if (this.session === session) {
            this.transitionToState([channel_1.ConnectivityState.CONNECTING], channel_1.ConnectivityState.READY);
          }
        });
        session.once("close", () => {
          if (this.session === session) {
            trace(this.subchannelAddressString + " connection closed");
            this.transitionToState([channel_1.ConnectivityState.CONNECTING], channel_1.ConnectivityState.TRANSIENT_FAILURE);
            this.transitionToState([channel_1.ConnectivityState.READY], channel_1.ConnectivityState.IDLE);
          }
        });
        session.once("goaway", (errorCode, lastStreamID, opaqueData) => {
          if (this.session === session) {
            if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM && opaqueData.equals(tooManyPingsData)) {
              this.keepaliveTimeMs = Math.min(2 * this.keepaliveTimeMs, KEEPALIVE_MAX_TIME_MS);
              logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${uri_parser_1.uriToString(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to ${this.keepaliveTimeMs} ms`);
            }
            trace(this.subchannelAddressString + " connection closed by GOAWAY with code " + errorCode);
            this.transitionToState([channel_1.ConnectivityState.CONNECTING, channel_1.ConnectivityState.READY], channel_1.ConnectivityState.IDLE);
          }
        });
        session.once("error", (error2) => {
          trace(this.subchannelAddressString + " connection closed with error " + error2.message);
        });
      }
      startConnectingInternal() {
        var _a, _b;
        const connectionOptions = this.credentials._getConnectionOptions() || {};
        if ("secureContext" in connectionOptions) {
          connectionOptions.ALPNProtocols = ["h2"];
          if (this.options["grpc.ssl_target_name_override"]) {
            const sslTargetNameOverride = this.options["grpc.ssl_target_name_override"];
            connectionOptions.checkServerIdentity = (host, cert) => {
              return tls_1.checkServerIdentity(sslTargetNameOverride, cert);
            };
            connectionOptions.servername = sslTargetNameOverride;
          } else {
            if ("grpc.http_connect_target" in this.options) {
              const targetPath = resolver_1.getDefaultAuthority((_a = uri_parser_1.parseUri(this.options["grpc.http_connect_target"])) !== null && _a !== void 0 ? _a : {
                path: "localhost"
              });
              const hostPort = uri_parser_1.splitHostPort(targetPath);
              connectionOptions.servername = (_b = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _b !== void 0 ? _b : targetPath;
            }
          }
        }
        http_proxy_1.getProxiedConnection(this.subchannelAddress, this.options, connectionOptions).then((result) => {
          this.createSession(result);
        }, (reason) => {
          this.transitionToState([channel_1.ConnectivityState.CONNECTING], channel_1.ConnectivityState.TRANSIENT_FAILURE);
        });
      }
      transitionToState(oldStates, newState) {
        if (oldStates.indexOf(this.connectivityState) === -1) {
          return false;
        }
        trace(this.subchannelAddressString + " " + channel_1.ConnectivityState[this.connectivityState] + " -> " + channel_1.ConnectivityState[newState]);
        const previousState = this.connectivityState;
        this.connectivityState = newState;
        switch (newState) {
          case channel_1.ConnectivityState.READY:
            this.stopBackoff();
            this.session.socket.once("close", () => {
              for (const listener of this.disconnectListeners) {
                listener();
              }
            });
            if (this.keepaliveWithoutCalls) {
              this.startKeepalivePings();
            }
            break;
          case channel_1.ConnectivityState.CONNECTING:
            this.startBackoff();
            this.startConnectingInternal();
            this.continueConnecting = false;
            break;
          case channel_1.ConnectivityState.TRANSIENT_FAILURE:
            if (this.session) {
              this.session.close();
            }
            this.session = null;
            this.stopKeepalivePings();
            if (!this.backoffTimeout.isRunning()) {
              process.nextTick(() => {
                this.handleBackoffTimer();
              });
            }
            break;
          case channel_1.ConnectivityState.IDLE:
            if (this.session) {
              this.session.close();
            }
            this.session = null;
            this.stopKeepalivePings();
            break;
          default:
            throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);
        }
        for (const listener of [...this.stateListeners]) {
          listener(this, previousState, newState);
        }
        return true;
      }
      checkBothRefcounts() {
        if (this.callRefcount === 0 && this.refcount === 0) {
          this.transitionToState([
            channel_1.ConnectivityState.CONNECTING,
            channel_1.ConnectivityState.READY
          ], channel_1.ConnectivityState.TRANSIENT_FAILURE);
        }
      }
      callRef() {
        refTrace(this.subchannelAddressString + " callRefcount " + this.callRefcount + " -> " + (this.callRefcount + 1));
        if (this.callRefcount === 0) {
          if (this.session) {
            this.session.ref();
          }
          this.backoffTimeout.ref();
          if (!this.keepaliveWithoutCalls) {
            this.startKeepalivePings();
          }
        }
        this.callRefcount += 1;
      }
      callUnref() {
        refTrace(this.subchannelAddressString + " callRefcount " + this.callRefcount + " -> " + (this.callRefcount - 1));
        this.callRefcount -= 1;
        if (this.callRefcount === 0) {
          if (this.session) {
            this.session.unref();
          }
          this.backoffTimeout.unref();
          if (!this.keepaliveWithoutCalls) {
            this.stopKeepalivePings();
          }
          this.checkBothRefcounts();
        }
      }
      ref() {
        refTrace(this.subchannelAddressString + " refcount " + this.refcount + " -> " + (this.refcount + 1));
        this.refcount += 1;
      }
      unref() {
        refTrace(this.subchannelAddressString + " refcount " + this.refcount + " -> " + (this.refcount - 1));
        this.refcount -= 1;
        this.checkBothRefcounts();
      }
      unrefIfOneRef() {
        if (this.refcount === 1) {
          this.unref();
          return true;
        }
        return false;
      }
      startCallStream(metadata, callStream, extraFilterFactory) {
        const headers = metadata.toHttp2Headers();
        headers[HTTP2_HEADER_AUTHORITY] = callStream.getHost();
        headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;
        headers[HTTP2_HEADER_CONTENT_TYPE] = "application/grpc";
        headers[HTTP2_HEADER_METHOD] = "POST";
        headers[HTTP2_HEADER_PATH] = callStream.getMethod();
        headers[HTTP2_HEADER_TE] = "trailers";
        let http2Stream;
        try {
          http2Stream = this.session.request(headers);
        } catch (e) {
          this.transitionToState([channel_1.ConnectivityState.READY], channel_1.ConnectivityState.TRANSIENT_FAILURE);
          throw e;
        }
        let headersString = "";
        for (const header of Object.keys(headers)) {
          headersString += "		" + header + ": " + headers[header] + "\n";
        }
        logging.trace(constants_1.LogVerbosity.DEBUG, "call_stream", "Starting stream on subchannel " + this.subchannelAddressString + " with headers\n" + headersString);
        callStream.attachHttp2Stream(http2Stream, this, extraFilterFactory);
      }
      startConnecting() {
        if (!this.transitionToState([channel_1.ConnectivityState.IDLE], channel_1.ConnectivityState.CONNECTING)) {
          if (this.connectivityState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {
            this.continueConnecting = true;
          }
        }
      }
      getConnectivityState() {
        return this.connectivityState;
      }
      addConnectivityStateListener(listener) {
        this.stateListeners.push(listener);
      }
      removeConnectivityStateListener(listener) {
        const listenerIndex = this.stateListeners.indexOf(listener);
        if (listenerIndex > -1) {
          this.stateListeners.splice(listenerIndex, 1);
        }
      }
      addDisconnectListener(listener) {
        this.disconnectListeners.push(listener);
      }
      removeDisconnectListener(listener) {
        const listenerIndex = this.disconnectListeners.indexOf(listener);
        if (listenerIndex > -1) {
          this.disconnectListeners.splice(listenerIndex, 1);
        }
      }
      resetBackoff() {
        this.backoffTimeout.reset();
        this.transitionToState([channel_1.ConnectivityState.TRANSIENT_FAILURE], channel_1.ConnectivityState.CONNECTING);
      }
      getAddress() {
        return this.subchannelAddressString;
      }
    };
    exports2.Subchannel = Subchannel;
  }
});

// node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js
var require_load_balancer_pick_first = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setup = exports2.PickFirstLoadBalancer = exports2.PickFirstLoadBalancingConfig = void 0;
    var load_balancer_1 = require_load_balancer();
    var channel_1 = require_channel();
    var picker_1 = require_picker();
    var subchannel_1 = require_subchannel();
    var logging = require_logging();
    var constants_1 = require_constants();
    var TRACER_NAME = "pick_first";
    function trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    var TYPE_NAME = "pick_first";
    var CONNECTION_DELAY_INTERVAL_MS = 250;
    var PickFirstLoadBalancingConfig = class {
      getLoadBalancerName() {
        return TYPE_NAME;
      }
      constructor() {
      }
      toJsonObject() {
        return {
          [TYPE_NAME]: {}
        };
      }
      static createFromJson(obj) {
        return new PickFirstLoadBalancingConfig();
      }
    };
    exports2.PickFirstLoadBalancingConfig = PickFirstLoadBalancingConfig;
    var PickFirstPicker = class {
      constructor(subchannel) {
        this.subchannel = subchannel;
      }
      pick(pickArgs) {
        return {
          pickResultType: picker_1.PickResultType.COMPLETE,
          subchannel: this.subchannel,
          status: null,
          extraFilterFactory: null,
          onCallStarted: null
        };
      }
    };
    var PickFirstLoadBalancer = class {
      constructor(channelControlHelper) {
        this.channelControlHelper = channelControlHelper;
        this.latestAddressList = [];
        this.subchannels = [];
        this.currentState = channel_1.ConnectivityState.IDLE;
        this.currentSubchannelIndex = 0;
        this.currentPick = null;
        this.triedAllSubchannels = false;
        this.subchannelStateCounts = {
          [channel_1.ConnectivityState.CONNECTING]: 0,
          [channel_1.ConnectivityState.IDLE]: 0,
          [channel_1.ConnectivityState.READY]: 0,
          [channel_1.ConnectivityState.SHUTDOWN]: 0,
          [channel_1.ConnectivityState.TRANSIENT_FAILURE]: 0
        };
        this.subchannelStateListener = (subchannel, previousState, newState) => {
          this.subchannelStateCounts[previousState] -= 1;
          this.subchannelStateCounts[newState] += 1;
          if (subchannel === this.subchannels[this.currentSubchannelIndex] && newState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {
            this.startNextSubchannelConnecting();
          }
          if (newState === channel_1.ConnectivityState.READY) {
            this.pickSubchannel(subchannel);
            return;
          } else {
            if (this.triedAllSubchannels && this.subchannelStateCounts[channel_1.ConnectivityState.IDLE] === this.subchannels.length) {
              this.resetSubchannelList();
              this.updateState(channel_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
              return;
            }
            if (this.currentPick === null) {
              if (this.triedAllSubchannels) {
                let newLBState;
                if (this.subchannelStateCounts[channel_1.ConnectivityState.CONNECTING] > 0) {
                  newLBState = channel_1.ConnectivityState.CONNECTING;
                } else if (this.subchannelStateCounts[channel_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {
                  newLBState = channel_1.ConnectivityState.TRANSIENT_FAILURE;
                } else {
                  newLBState = channel_1.ConnectivityState.IDLE;
                }
                if (newLBState !== this.currentState) {
                  if (newLBState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {
                    this.updateState(newLBState, new picker_1.UnavailablePicker());
                  } else {
                    this.updateState(newLBState, new picker_1.QueuePicker(this));
                  }
                }
              } else {
                this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
              }
            }
          }
        };
        this.pickedSubchannelStateListener = (subchannel, previousState, newState) => {
          if (newState !== channel_1.ConnectivityState.READY) {
            this.currentPick = null;
            subchannel.unref();
            subchannel.removeConnectivityStateListener(this.pickedSubchannelStateListener);
            if (this.subchannels.length > 0) {
              if (this.triedAllSubchannels) {
                let newLBState;
                if (this.subchannelStateCounts[channel_1.ConnectivityState.CONNECTING] > 0) {
                  newLBState = channel_1.ConnectivityState.CONNECTING;
                } else if (this.subchannelStateCounts[channel_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {
                  newLBState = channel_1.ConnectivityState.TRANSIENT_FAILURE;
                } else {
                  newLBState = channel_1.ConnectivityState.IDLE;
                }
                if (newLBState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {
                  this.updateState(newLBState, new picker_1.UnavailablePicker());
                } else {
                  this.updateState(newLBState, new picker_1.QueuePicker(this));
                }
              } else {
                this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
              }
            } else {
              this.updateState(channel_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
            }
          }
        };
        this.connectionDelayTimeout = setTimeout(() => {
        }, 0);
        clearTimeout(this.connectionDelayTimeout);
      }
      startNextSubchannelConnecting() {
        if (this.triedAllSubchannels) {
          return;
        }
        for (const [index2, subchannel] of this.subchannels.entries()) {
          if (index2 > this.currentSubchannelIndex) {
            const subchannelState = subchannel.getConnectivityState();
            if (subchannelState === channel_1.ConnectivityState.IDLE || subchannelState === channel_1.ConnectivityState.CONNECTING) {
              this.startConnecting(index2);
              return;
            }
          }
        }
        this.triedAllSubchannels = true;
      }
      startConnecting(subchannelIndex) {
        clearTimeout(this.connectionDelayTimeout);
        this.currentSubchannelIndex = subchannelIndex;
        if (this.subchannels[subchannelIndex].getConnectivityState() === channel_1.ConnectivityState.IDLE) {
          trace("Start connecting to subchannel with address " + this.subchannels[subchannelIndex].getAddress());
          process.nextTick(() => {
            this.subchannels[subchannelIndex].startConnecting();
          });
        }
        this.connectionDelayTimeout = setTimeout(() => {
          this.startNextSubchannelConnecting();
        }, CONNECTION_DELAY_INTERVAL_MS);
      }
      pickSubchannel(subchannel) {
        trace("Pick subchannel with address " + subchannel.getAddress());
        if (this.currentPick !== null) {
          this.currentPick.unref();
          this.currentPick.removeConnectivityStateListener(this.pickedSubchannelStateListener);
        }
        this.currentPick = subchannel;
        this.updateState(channel_1.ConnectivityState.READY, new PickFirstPicker(subchannel));
        subchannel.addConnectivityStateListener(this.pickedSubchannelStateListener);
        subchannel.ref();
        this.resetSubchannelList();
        clearTimeout(this.connectionDelayTimeout);
      }
      updateState(newState, picker) {
        trace(channel_1.ConnectivityState[this.currentState] + " -> " + channel_1.ConnectivityState[newState]);
        this.currentState = newState;
        this.channelControlHelper.updateState(newState, picker);
      }
      resetSubchannelList() {
        for (const subchannel of this.subchannels) {
          subchannel.removeConnectivityStateListener(this.subchannelStateListener);
          subchannel.unref();
        }
        this.currentSubchannelIndex = 0;
        this.subchannelStateCounts = {
          [channel_1.ConnectivityState.CONNECTING]: 0,
          [channel_1.ConnectivityState.IDLE]: 0,
          [channel_1.ConnectivityState.READY]: 0,
          [channel_1.ConnectivityState.SHUTDOWN]: 0,
          [channel_1.ConnectivityState.TRANSIENT_FAILURE]: 0
        };
        this.subchannels = [];
        this.triedAllSubchannels = false;
      }
      connectToAddressList() {
        this.resetSubchannelList();
        trace("Connect to address list " + this.latestAddressList.map((address) => subchannel_1.subchannelAddressToString(address)));
        this.subchannels = this.latestAddressList.map((address) => this.channelControlHelper.createSubchannel(address, {}));
        for (const subchannel of this.subchannels) {
          subchannel.ref();
        }
        for (const subchannel of this.subchannels) {
          subchannel.addConnectivityStateListener(this.subchannelStateListener);
          this.subchannelStateCounts[subchannel.getConnectivityState()] += 1;
          if (subchannel.getConnectivityState() === channel_1.ConnectivityState.READY) {
            this.pickSubchannel(subchannel);
            this.resetSubchannelList();
            return;
          }
        }
        for (const [index2, subchannel] of this.subchannels.entries()) {
          const subchannelState = subchannel.getConnectivityState();
          if (subchannelState === channel_1.ConnectivityState.IDLE || subchannelState === channel_1.ConnectivityState.CONNECTING) {
            this.startConnecting(index2);
            if (this.currentPick === null) {
              this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
            }
            return;
          }
        }
        if (this.currentPick === null) {
          this.updateState(channel_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker());
        }
      }
      updateAddressList(addressList, lbConfig) {
        if (this.subchannels.length === 0 || !this.latestAddressList.every((value, index2) => addressList[index2] === value)) {
          this.latestAddressList = addressList;
          this.connectToAddressList();
        }
      }
      exitIdle() {
        for (const subchannel of this.subchannels) {
          subchannel.startConnecting();
        }
        if (this.currentState === channel_1.ConnectivityState.IDLE) {
          if (this.latestAddressList.length > 0) {
            this.connectToAddressList();
          }
        }
        if (this.currentState === channel_1.ConnectivityState.IDLE || this.triedAllSubchannels) {
          this.channelControlHelper.requestReresolution();
        }
      }
      resetBackoff() {
      }
      destroy() {
        this.resetSubchannelList();
        if (this.currentPick !== null) {
          this.currentPick.unref();
          this.currentPick.removeConnectivityStateListener(this.pickedSubchannelStateListener);
        }
      }
      getTypeName() {
        return TYPE_NAME;
      }
    };
    exports2.PickFirstLoadBalancer = PickFirstLoadBalancer;
    function setup() {
      load_balancer_1.registerLoadBalancerType(TYPE_NAME, PickFirstLoadBalancer, PickFirstLoadBalancingConfig);
    }
    exports2.setup = setup;
  }
});

// node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js
var require_load_balancer_round_robin = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setup = exports2.RoundRobinLoadBalancer = void 0;
    var load_balancer_1 = require_load_balancer();
    var channel_1 = require_channel();
    var picker_1 = require_picker();
    var subchannel_1 = require_subchannel();
    var logging = require_logging();
    var constants_1 = require_constants();
    var TRACER_NAME = "round_robin";
    function trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    var TYPE_NAME = "round_robin";
    var RoundRobinLoadBalancingConfig = class {
      getLoadBalancerName() {
        return TYPE_NAME;
      }
      constructor() {
      }
      toJsonObject() {
        return {
          [TYPE_NAME]: {}
        };
      }
      static createFromJson(obj) {
        return new RoundRobinLoadBalancingConfig();
      }
    };
    var RoundRobinPicker = class {
      constructor(subchannelList, nextIndex = 0) {
        this.subchannelList = subchannelList;
        this.nextIndex = nextIndex;
      }
      pick(pickArgs) {
        const pickedSubchannel = this.subchannelList[this.nextIndex];
        this.nextIndex = (this.nextIndex + 1) % this.subchannelList.length;
        return {
          pickResultType: picker_1.PickResultType.COMPLETE,
          subchannel: pickedSubchannel,
          status: null,
          extraFilterFactory: null,
          onCallStarted: null
        };
      }
      peekNextSubchannel() {
        return this.subchannelList[this.nextIndex];
      }
    };
    var RoundRobinLoadBalancer = class {
      constructor(channelControlHelper) {
        this.channelControlHelper = channelControlHelper;
        this.subchannels = [];
        this.currentState = channel_1.ConnectivityState.IDLE;
        this.currentReadyPicker = null;
        this.subchannelStateCounts = {
          [channel_1.ConnectivityState.CONNECTING]: 0,
          [channel_1.ConnectivityState.IDLE]: 0,
          [channel_1.ConnectivityState.READY]: 0,
          [channel_1.ConnectivityState.SHUTDOWN]: 0,
          [channel_1.ConnectivityState.TRANSIENT_FAILURE]: 0
        };
        this.subchannelStateListener = (subchannel, previousState, newState) => {
          this.subchannelStateCounts[previousState] -= 1;
          this.subchannelStateCounts[newState] += 1;
          this.calculateAndUpdateState();
          if (newState === channel_1.ConnectivityState.TRANSIENT_FAILURE || newState === channel_1.ConnectivityState.IDLE) {
            this.channelControlHelper.requestReresolution();
            subchannel.startConnecting();
          }
        };
      }
      calculateAndUpdateState() {
        if (this.subchannelStateCounts[channel_1.ConnectivityState.READY] > 0) {
          const readySubchannels = this.subchannels.filter((subchannel) => subchannel.getConnectivityState() === channel_1.ConnectivityState.READY);
          let index2 = 0;
          if (this.currentReadyPicker !== null) {
            index2 = readySubchannels.indexOf(this.currentReadyPicker.peekNextSubchannel());
            if (index2 < 0) {
              index2 = 0;
            }
          }
          this.updateState(channel_1.ConnectivityState.READY, new RoundRobinPicker(readySubchannels, index2));
        } else if (this.subchannelStateCounts[channel_1.ConnectivityState.CONNECTING] > 0) {
          this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
        } else if (this.subchannelStateCounts[channel_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {
          this.updateState(channel_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker());
        } else {
          this.updateState(channel_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
        }
      }
      updateState(newState, picker) {
        trace(channel_1.ConnectivityState[this.currentState] + " -> " + channel_1.ConnectivityState[newState]);
        if (newState === channel_1.ConnectivityState.READY) {
          this.currentReadyPicker = picker;
        } else {
          this.currentReadyPicker = null;
        }
        this.currentState = newState;
        this.channelControlHelper.updateState(newState, picker);
      }
      resetSubchannelList() {
        for (const subchannel of this.subchannels) {
          subchannel.removeConnectivityStateListener(this.subchannelStateListener);
          subchannel.unref();
        }
        this.subchannelStateCounts = {
          [channel_1.ConnectivityState.CONNECTING]: 0,
          [channel_1.ConnectivityState.IDLE]: 0,
          [channel_1.ConnectivityState.READY]: 0,
          [channel_1.ConnectivityState.SHUTDOWN]: 0,
          [channel_1.ConnectivityState.TRANSIENT_FAILURE]: 0
        };
        this.subchannels = [];
      }
      updateAddressList(addressList, lbConfig) {
        this.resetSubchannelList();
        trace("Connect to address list " + addressList.map((address) => subchannel_1.subchannelAddressToString(address)));
        this.subchannels = addressList.map((address) => this.channelControlHelper.createSubchannel(address, {}));
        for (const subchannel of this.subchannels) {
          subchannel.ref();
          subchannel.addConnectivityStateListener(this.subchannelStateListener);
          const subchannelState = subchannel.getConnectivityState();
          this.subchannelStateCounts[subchannelState] += 1;
          if (subchannelState === channel_1.ConnectivityState.IDLE || subchannelState === channel_1.ConnectivityState.TRANSIENT_FAILURE) {
            subchannel.startConnecting();
          }
        }
        this.calculateAndUpdateState();
      }
      exitIdle() {
        for (const subchannel of this.subchannels) {
          subchannel.startConnecting();
        }
      }
      resetBackoff() {
      }
      destroy() {
        this.resetSubchannelList();
      }
      getTypeName() {
        return TYPE_NAME;
      }
    };
    exports2.RoundRobinLoadBalancer = RoundRobinLoadBalancer;
    function setup() {
      load_balancer_1.registerLoadBalancerType(TYPE_NAME, RoundRobinLoadBalancer, RoundRobinLoadBalancingConfig);
    }
    exports2.setup = setup;
  }
});

// node_modules/@grpc/grpc-js/build/src/load-balancer.js
var require_load_balancer = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/load-balancer.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.registerAll = exports2.validateLoadBalancingConfig = exports2.getFirstUsableConfig = exports2.isLoadBalancerNameRegistered = exports2.createLoadBalancer = exports2.registerLoadBalancerType = void 0;
    var load_balancer_pick_first = require_load_balancer_pick_first();
    var load_balancer_round_robin = require_load_balancer_round_robin();
    var registeredLoadBalancerTypes = {};
    function registerLoadBalancerType(typeName, loadBalancerType, loadBalancingConfigType) {
      registeredLoadBalancerTypes[typeName] = {
        LoadBalancer: loadBalancerType,
        LoadBalancingConfig: loadBalancingConfigType
      };
    }
    exports2.registerLoadBalancerType = registerLoadBalancerType;
    function createLoadBalancer(config2, channelControlHelper) {
      const typeName = config2.getLoadBalancerName();
      if (typeName in registeredLoadBalancerTypes) {
        return new registeredLoadBalancerTypes[typeName].LoadBalancer(channelControlHelper);
      } else {
        return null;
      }
    }
    exports2.createLoadBalancer = createLoadBalancer;
    function isLoadBalancerNameRegistered(typeName) {
      return typeName in registeredLoadBalancerTypes;
    }
    exports2.isLoadBalancerNameRegistered = isLoadBalancerNameRegistered;
    function getFirstUsableConfig(configs, defaultPickFirst = false) {
      for (const config2 of configs) {
        if (config2.getLoadBalancerName() in registeredLoadBalancerTypes) {
          return config2;
        }
      }
      if (defaultPickFirst) {
        return new load_balancer_pick_first.PickFirstLoadBalancingConfig();
      } else {
        return null;
      }
    }
    exports2.getFirstUsableConfig = getFirstUsableConfig;
    function validateLoadBalancingConfig(obj) {
      if (!(obj !== null && typeof obj === "object")) {
        throw new Error("Load balancing config must be an object");
      }
      const keys = Object.keys(obj);
      if (keys.length !== 1) {
        throw new Error("Provided load balancing config has multiple conflicting entries");
      }
      const typeName = keys[0];
      if (typeName in registeredLoadBalancerTypes) {
        return registeredLoadBalancerTypes[typeName].LoadBalancingConfig.createFromJson(obj[typeName]);
      } else {
        throw new Error(`Unrecognized load balancing config name ${typeName}`);
      }
    }
    exports2.validateLoadBalancingConfig = validateLoadBalancingConfig;
    function registerAll() {
      load_balancer_pick_first.setup();
      load_balancer_round_robin.setup();
    }
    exports2.registerAll = registerAll;
  }
});

// node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js
var require_load_balancer_child_handler = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ChildLoadBalancerHandler = void 0;
    var load_balancer_1 = require_load_balancer();
    var channel_1 = require_channel();
    var TYPE_NAME = "child_load_balancer_helper";
    var ChildLoadBalancerHandler = class {
      constructor(channelControlHelper) {
        this.channelControlHelper = channelControlHelper;
        this.currentChild = null;
        this.pendingChild = null;
        this.ChildPolicyHelper = class {
          constructor(parent2) {
            this.parent = parent2;
            this.child = null;
          }
          createSubchannel(subchannelAddress, subchannelArgs) {
            return this.parent.channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);
          }
          updateState(connectivityState, picker) {
            var _a;
            if (this.calledByPendingChild()) {
              if (connectivityState !== channel_1.ConnectivityState.READY) {
                return;
              }
              (_a = this.parent.currentChild) === null || _a === void 0 ? void 0 : _a.destroy();
              this.parent.currentChild = this.parent.pendingChild;
              this.parent.pendingChild = null;
            } else if (!this.calledByCurrentChild()) {
              return;
            }
            this.parent.channelControlHelper.updateState(connectivityState, picker);
          }
          requestReresolution() {
            var _a;
            const latestChild = (_a = this.parent.pendingChild) !== null && _a !== void 0 ? _a : this.parent.currentChild;
            if (this.child === latestChild) {
              this.parent.channelControlHelper.requestReresolution();
            }
          }
          setChild(newChild) {
            this.child = newChild;
          }
          calledByPendingChild() {
            return this.child === this.parent.pendingChild;
          }
          calledByCurrentChild() {
            return this.child === this.parent.currentChild;
          }
        };
      }
      updateAddressList(addressList, lbConfig, attributes) {
        let childToUpdate;
        if (this.currentChild === null || this.currentChild.getTypeName() !== lbConfig.getLoadBalancerName()) {
          const newHelper = new this.ChildPolicyHelper(this);
          const newChild = load_balancer_1.createLoadBalancer(lbConfig, newHelper);
          newHelper.setChild(newChild);
          if (this.currentChild === null) {
            this.currentChild = newChild;
            childToUpdate = this.currentChild;
          } else {
            if (this.pendingChild) {
              this.pendingChild.destroy();
            }
            this.pendingChild = newChild;
            childToUpdate = this.pendingChild;
          }
        } else {
          if (this.pendingChild === null) {
            childToUpdate = this.currentChild;
          } else {
            childToUpdate = this.pendingChild;
          }
        }
        childToUpdate.updateAddressList(addressList, lbConfig, attributes);
      }
      exitIdle() {
        if (this.currentChild) {
          this.currentChild.resetBackoff();
          if (this.pendingChild) {
            this.pendingChild.resetBackoff();
          }
        }
      }
      resetBackoff() {
        if (this.currentChild) {
          this.currentChild.resetBackoff();
          if (this.pendingChild) {
            this.pendingChild.resetBackoff();
          }
        }
      }
      destroy() {
        if (this.currentChild) {
          this.currentChild.destroy();
          this.currentChild = null;
        }
        if (this.pendingChild) {
          this.pendingChild.destroy();
          this.pendingChild = null;
        }
      }
      getTypeName() {
        return TYPE_NAME;
      }
    };
    exports2.ChildLoadBalancerHandler = ChildLoadBalancerHandler;
  }
});

// node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js
var require_resolving_load_balancer = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ResolvingLoadBalancer = void 0;
    var load_balancer_1 = require_load_balancer();
    var service_config_1 = require_service_config();
    var channel_1 = require_channel();
    var resolver_1 = require_resolver();
    var picker_1 = require_picker();
    var backoff_timeout_1 = require_backoff_timeout();
    var constants_1 = require_constants();
    var metadata_1 = require_metadata();
    var logging = require_logging();
    var constants_2 = require_constants();
    var uri_parser_1 = require_uri_parser();
    var load_balancer_child_handler_1 = require_load_balancer_child_handler();
    var TRACER_NAME = "resolving_load_balancer";
    function trace(text) {
      logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    function getDefaultConfigSelector(serviceConfig) {
      return function defaultConfigSelector(methodName, metadata) {
        var _a, _b;
        const splitName = methodName.split("/").filter((x) => x.length > 0);
        const service = (_a = splitName[0]) !== null && _a !== void 0 ? _a : "";
        const method = (_b = splitName[1]) !== null && _b !== void 0 ? _b : "";
        if (serviceConfig && serviceConfig.methodConfig) {
          for (const methodConfig of serviceConfig.methodConfig) {
            for (const name2 of methodConfig.name) {
              if (name2.service === service && (name2.method === void 0 || name2.method === method)) {
                return {
                  methodConfig,
                  pickInformation: {},
                  status: constants_1.Status.OK
                };
              }
            }
          }
        }
        return {
          methodConfig: { name: [] },
          pickInformation: {},
          status: constants_1.Status.OK
        };
      };
    }
    var ResolvingLoadBalancer = class {
      constructor(target, channelControlHelper, channelOptions, onSuccessfulResolution, onFailedResolution) {
        this.target = target;
        this.channelControlHelper = channelControlHelper;
        this.channelOptions = channelOptions;
        this.onSuccessfulResolution = onSuccessfulResolution;
        this.onFailedResolution = onFailedResolution;
        this.latestChildState = channel_1.ConnectivityState.IDLE;
        this.latestChildPicker = new picker_1.QueuePicker(this);
        this.currentState = channel_1.ConnectivityState.IDLE;
        this.previousServiceConfig = null;
        this.continueResolving = false;
        if (channelOptions["grpc.service_config"]) {
          this.defaultServiceConfig = service_config_1.validateServiceConfig(JSON.parse(channelOptions["grpc.service_config"]));
        } else {
          this.defaultServiceConfig = {
            loadBalancingConfig: [],
            methodConfig: []
          };
        }
        this.updateState(channel_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
        this.childLoadBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler({
          createSubchannel: channelControlHelper.createSubchannel.bind(channelControlHelper),
          requestReresolution: () => {
            if (this.backoffTimeout.isRunning()) {
              this.continueResolving = true;
            } else {
              this.updateResolution();
            }
          },
          updateState: (newState, picker) => {
            this.latestChildState = newState;
            this.latestChildPicker = picker;
            this.updateState(newState, picker);
          }
        });
        this.innerResolver = resolver_1.createResolver(target, {
          onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError, configSelector, attributes) => {
            var _a;
            let workingServiceConfig = null;
            if (serviceConfig === null) {
              if (serviceConfigError === null) {
                this.previousServiceConfig = null;
                workingServiceConfig = this.defaultServiceConfig;
              } else {
                if (this.previousServiceConfig === null) {
                  this.handleResolutionFailure(serviceConfigError);
                } else {
                  workingServiceConfig = this.previousServiceConfig;
                }
              }
            } else {
              workingServiceConfig = serviceConfig;
              this.previousServiceConfig = serviceConfig;
            }
            const workingConfigList = (_a = workingServiceConfig === null || workingServiceConfig === void 0 ? void 0 : workingServiceConfig.loadBalancingConfig) !== null && _a !== void 0 ? _a : [];
            const loadBalancingConfig = load_balancer_1.getFirstUsableConfig(workingConfigList, true);
            if (loadBalancingConfig === null) {
              this.handleResolutionFailure({
                code: constants_1.Status.UNAVAILABLE,
                details: "All load balancer options in service config are not compatible",
                metadata: new metadata_1.Metadata()
              });
              return;
            }
            this.childLoadBalancer.updateAddressList(addressList, loadBalancingConfig, attributes);
            const finalServiceConfig = workingServiceConfig !== null && workingServiceConfig !== void 0 ? workingServiceConfig : this.defaultServiceConfig;
            this.onSuccessfulResolution(configSelector !== null && configSelector !== void 0 ? configSelector : getDefaultConfigSelector(finalServiceConfig));
          },
          onError: (error2) => {
            this.handleResolutionFailure(error2);
          }
        }, channelOptions);
        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {
          if (this.continueResolving) {
            this.updateResolution();
            this.continueResolving = false;
          } else {
            this.updateState(this.latestChildState, this.latestChildPicker);
          }
        });
        this.backoffTimeout.unref();
      }
      updateResolution() {
        this.innerResolver.updateResolution();
        if (this.currentState === channel_1.ConnectivityState.IDLE) {
          this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
        }
      }
      updateState(connectivityState, picker) {
        trace(uri_parser_1.uriToString(this.target) + " " + channel_1.ConnectivityState[this.currentState] + " -> " + channel_1.ConnectivityState[connectivityState]);
        if (connectivityState === channel_1.ConnectivityState.IDLE) {
          picker = new picker_1.QueuePicker(this);
        }
        this.currentState = connectivityState;
        this.channelControlHelper.updateState(connectivityState, picker);
      }
      handleResolutionFailure(error2) {
        if (this.latestChildState === channel_1.ConnectivityState.IDLE) {
          this.updateState(channel_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker(error2));
          this.onFailedResolution(error2);
        }
        this.backoffTimeout.runOnce();
      }
      exitIdle() {
        this.childLoadBalancer.exitIdle();
        if (this.currentState === channel_1.ConnectivityState.IDLE) {
          if (this.backoffTimeout.isRunning()) {
            this.continueResolving = true;
          } else {
            this.updateResolution();
          }
          this.updateState(channel_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
        }
      }
      updateAddressList(addressList, lbConfig) {
        throw new Error("updateAddressList not supported on ResolvingLoadBalancer");
      }
      resetBackoff() {
        this.backoffTimeout.reset();
        this.childLoadBalancer.resetBackoff();
      }
      destroy() {
        this.childLoadBalancer.destroy();
        this.innerResolver.destroy();
        this.updateState(channel_1.ConnectivityState.SHUTDOWN, new picker_1.UnavailablePicker());
      }
      getTypeName() {
        return "resolving_load_balancer";
      }
    };
    exports2.ResolvingLoadBalancer = ResolvingLoadBalancer;
  }
});

// node_modules/@grpc/grpc-js/build/src/channel-options.js
var require_channel_options = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/channel-options.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.channelOptionsEqual = exports2.recognizedOptions = void 0;
    exports2.recognizedOptions = {
      "grpc.ssl_target_name_override": true,
      "grpc.primary_user_agent": true,
      "grpc.secondary_user_agent": true,
      "grpc.default_authority": true,
      "grpc.keepalive_time_ms": true,
      "grpc.keepalive_timeout_ms": true,
      "grpc.keepalive_permit_without_calls": true,
      "grpc.service_config": true,
      "grpc.max_concurrent_streams": true,
      "grpc.initial_reconnect_backoff_ms": true,
      "grpc.max_reconnect_backoff_ms": true,
      "grpc.use_local_subchannel_pool": true,
      "grpc.max_send_message_length": true,
      "grpc.max_receive_message_length": true,
      "grpc.enable_http_proxy": true,
      "grpc-node.max_session_memory": true
    };
    function channelOptionsEqual(options1, options2) {
      const keys1 = Object.keys(options1).sort();
      const keys2 = Object.keys(options2).sort();
      if (keys1.length !== keys2.length) {
        return false;
      }
      for (let i = 0; i < keys1.length; i += 1) {
        if (keys1[i] !== keys2[i]) {
          return false;
        }
        if (options1[keys1[i]] !== options2[keys2[i]]) {
          return false;
        }
      }
      return true;
    }
    exports2.channelOptionsEqual = channelOptionsEqual;
  }
});

// node_modules/@grpc/grpc-js/build/src/subchannel-pool.js
var require_subchannel_pool = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/subchannel-pool.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSubchannelPool = exports2.SubchannelPool = void 0;
    var channel_options_1 = require_channel_options();
    var subchannel_1 = require_subchannel();
    var uri_parser_1 = require_uri_parser();
    var REF_CHECK_INTERVAL = 1e4;
    var SubchannelPool = class {
      constructor(global2) {
        this.global = global2;
        this.pool = Object.create(null);
        this.cleanupTimer = null;
      }
      unrefUnusedSubchannels() {
        let allSubchannelsUnrefed = true;
        for (const channelTarget in this.pool) {
          const subchannelObjArray = this.pool[channelTarget];
          const refedSubchannels = subchannelObjArray.filter((value) => !value.subchannel.unrefIfOneRef());
          if (refedSubchannels.length > 0) {
            allSubchannelsUnrefed = false;
          }
          this.pool[channelTarget] = refedSubchannels;
        }
        if (allSubchannelsUnrefed && this.cleanupTimer !== null) {
          clearInterval(this.cleanupTimer);
          this.cleanupTimer = null;
        }
      }
      ensureCleanupTask() {
        var _a, _b;
        if (this.global && this.cleanupTimer === null) {
          this.cleanupTimer = setInterval(() => {
            this.unrefUnusedSubchannels();
          }, REF_CHECK_INTERVAL);
          (_b = (_a = this.cleanupTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
      }
      getOrCreateSubchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials) {
        this.ensureCleanupTask();
        const channelTarget = uri_parser_1.uriToString(channelTargetUri);
        if (channelTarget in this.pool) {
          const subchannelObjArray = this.pool[channelTarget];
          for (const subchannelObj of subchannelObjArray) {
            if (subchannel_1.subchannelAddressEqual(subchannelTarget, subchannelObj.subchannelAddress) && channel_options_1.channelOptionsEqual(channelArguments, subchannelObj.channelArguments) && channelCredentials._equals(subchannelObj.channelCredentials)) {
              return subchannelObj.subchannel;
            }
          }
        }
        const subchannel = new subchannel_1.Subchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials);
        if (!(channelTarget in this.pool)) {
          this.pool[channelTarget] = [];
        }
        this.pool[channelTarget].push({
          subchannelAddress: subchannelTarget,
          channelArguments,
          channelCredentials,
          subchannel
        });
        if (this.global) {
          subchannel.ref();
        }
        return subchannel;
      }
    };
    exports2.SubchannelPool = SubchannelPool;
    var globalSubchannelPool = new SubchannelPool(true);
    function getSubchannelPool(global2) {
      if (global2) {
        return globalSubchannelPool;
      } else {
        return new SubchannelPool(false);
      }
    }
    exports2.getSubchannelPool = getSubchannelPool;
  }
});

// node_modules/@grpc/grpc-js/build/src/filter.js
var require_filter = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/filter.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BaseFilter = void 0;
    var BaseFilter = class {
      async sendMetadata(metadata) {
        return metadata;
      }
      receiveMetadata(metadata) {
        return metadata;
      }
      async sendMessage(message) {
        return message;
      }
      async receiveMessage(message) {
        return message;
      }
      receiveTrailers(status) {
        return status;
      }
    };
    exports2.BaseFilter = BaseFilter;
  }
});

// node_modules/@grpc/grpc-js/build/src/call-credentials-filter.js
var require_call_credentials_filter = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/call-credentials-filter.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallCredentialsFilterFactory = exports2.CallCredentialsFilter = void 0;
    var filter_1 = require_filter();
    var constants_1 = require_constants();
    var uri_parser_1 = require_uri_parser();
    var CallCredentialsFilter = class extends filter_1.BaseFilter {
      constructor(channel, stream) {
        var _a, _b;
        super();
        this.channel = channel;
        this.stream = stream;
        this.channel = channel;
        this.stream = stream;
        const splitPath = stream.getMethod().split("/");
        let serviceName = "";
        if (splitPath.length >= 2) {
          serviceName = splitPath[1];
        }
        const hostname = (_b = (_a = uri_parser_1.splitHostPort(stream.getHost())) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : "localhost";
        this.serviceUrl = `https://${hostname}/${serviceName}`;
      }
      async sendMetadata(metadata) {
        const credentials = this.stream.getCredentials();
        const credsMetadata = credentials.generateMetadata({
          service_url: this.serviceUrl
        });
        const resultMetadata = await metadata;
        try {
          resultMetadata.merge(await credsMetadata);
        } catch (error2) {
          this.stream.cancelWithStatus(constants_1.Status.UNAUTHENTICATED, `Failed to retrieve auth metadata with error: ${error2.message}`);
          return Promise.reject("Failed to retrieve auth metadata");
        }
        if (resultMetadata.get("authorization").length > 1) {
          this.stream.cancelWithStatus(constants_1.Status.INTERNAL, '"authorization" metadata cannot have multiple values');
          return Promise.reject('"authorization" metadata cannot have multiple values');
        }
        return resultMetadata;
      }
    };
    exports2.CallCredentialsFilter = CallCredentialsFilter;
    var CallCredentialsFilterFactory = class {
      constructor(channel) {
        this.channel = channel;
        this.channel = channel;
      }
      createFilter(callStream) {
        return new CallCredentialsFilter(this.channel, callStream);
      }
    };
    exports2.CallCredentialsFilterFactory = CallCredentialsFilterFactory;
  }
});

// node_modules/@grpc/grpc-js/build/src/deadline-filter.js
var require_deadline_filter = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/deadline-filter.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeadlineFilterFactory = exports2.DeadlineFilter = void 0;
    var constants_1 = require_constants();
    var filter_1 = require_filter();
    var units = [
      ["m", 1],
      ["S", 1e3],
      ["M", 60 * 1e3],
      ["H", 60 * 60 * 1e3]
    ];
    function getDeadline(deadline) {
      const now = new Date().getTime();
      const timeoutMs = Math.max(deadline - now, 0);
      for (const [unit, factor] of units) {
        const amount = timeoutMs / factor;
        if (amount < 1e8) {
          return String(Math.ceil(amount)) + unit;
        }
      }
      throw new Error("Deadline is too far in the future");
    }
    var DeadlineFilter = class extends filter_1.BaseFilter {
      constructor(channel, callStream) {
        var _a, _b;
        super();
        this.channel = channel;
        this.callStream = callStream;
        this.timer = null;
        const callDeadline = callStream.getDeadline();
        if (callDeadline instanceof Date) {
          this.deadline = callDeadline.getTime();
        } else {
          this.deadline = callDeadline;
        }
        const now = new Date().getTime();
        let timeout = this.deadline - now;
        if (timeout <= 0) {
          process.nextTick(() => {
            callStream.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, "Deadline exceeded");
          });
        } else if (this.deadline !== Infinity) {
          this.timer = setTimeout(() => {
            callStream.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, "Deadline exceeded");
          }, timeout);
          (_b = (_a = this.timer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
      }
      async sendMetadata(metadata) {
        if (this.deadline === Infinity) {
          return metadata;
        }
        const finalMetadata = await metadata;
        const timeoutString = getDeadline(this.deadline);
        finalMetadata.set("grpc-timeout", timeoutString);
        return finalMetadata;
      }
      receiveTrailers(status) {
        if (this.timer) {
          clearTimeout(this.timer);
        }
        return status;
      }
    };
    exports2.DeadlineFilter = DeadlineFilter;
    var DeadlineFilterFactory = class {
      constructor(channel) {
        this.channel = channel;
      }
      createFilter(callStream) {
        return new DeadlineFilter(this.channel, callStream);
      }
    };
    exports2.DeadlineFilterFactory = DeadlineFilterFactory;
  }
});

// node_modules/@grpc/grpc-js/build/src/compression-filter.js
var require_compression_filter = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/compression-filter.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CompressionFilterFactory = exports2.CompressionFilter = void 0;
    var zlib2 = require("zlib");
    var filter_1 = require_filter();
    var CompressionHandler = class {
      async writeMessage(message, compress) {
        let messageBuffer = message;
        if (compress) {
          messageBuffer = await this.compressMessage(messageBuffer);
        }
        const output = Buffer.allocUnsafe(messageBuffer.length + 5);
        output.writeUInt8(compress ? 1 : 0, 0);
        output.writeUInt32BE(messageBuffer.length, 1);
        messageBuffer.copy(output, 5);
        return output;
      }
      async readMessage(data) {
        const compressed = data.readUInt8(0) === 1;
        let messageBuffer = data.slice(5);
        if (compressed) {
          messageBuffer = await this.decompressMessage(messageBuffer);
        }
        return messageBuffer;
      }
    };
    var IdentityHandler = class extends CompressionHandler {
      async compressMessage(message) {
        return message;
      }
      async writeMessage(message, compress) {
        const output = Buffer.allocUnsafe(message.length + 5);
        output.writeUInt8(0, 0);
        output.writeUInt32BE(message.length, 1);
        message.copy(output, 5);
        return output;
      }
      decompressMessage(message) {
        return Promise.reject(new Error('Received compressed message but "grpc-encoding" header was identity'));
      }
    };
    var DeflateHandler = class extends CompressionHandler {
      compressMessage(message) {
        return new Promise((resolve2, reject) => {
          zlib2.deflate(message, (err, output) => {
            if (err) {
              reject(err);
            } else {
              resolve2(output);
            }
          });
        });
      }
      decompressMessage(message) {
        return new Promise((resolve2, reject) => {
          zlib2.inflate(message, (err, output) => {
            if (err) {
              reject(err);
            } else {
              resolve2(output);
            }
          });
        });
      }
    };
    var GzipHandler = class extends CompressionHandler {
      compressMessage(message) {
        return new Promise((resolve2, reject) => {
          zlib2.gzip(message, (err, output) => {
            if (err) {
              reject(err);
            } else {
              resolve2(output);
            }
          });
        });
      }
      decompressMessage(message) {
        return new Promise((resolve2, reject) => {
          zlib2.unzip(message, (err, output) => {
            if (err) {
              reject(err);
            } else {
              resolve2(output);
            }
          });
        });
      }
    };
    var UnknownHandler = class extends CompressionHandler {
      constructor(compressionName) {
        super();
        this.compressionName = compressionName;
      }
      compressMessage(message) {
        return Promise.reject(new Error(`Received message compressed with unsupported compression method ${this.compressionName}`));
      }
      decompressMessage(message) {
        return Promise.reject(new Error(`Compression method not supported: ${this.compressionName}`));
      }
    };
    function getCompressionHandler(compressionName) {
      switch (compressionName) {
        case "identity":
          return new IdentityHandler();
        case "deflate":
          return new DeflateHandler();
        case "gzip":
          return new GzipHandler();
        default:
          return new UnknownHandler(compressionName);
      }
    }
    var CompressionFilter = class extends filter_1.BaseFilter {
      constructor() {
        super(...arguments);
        this.sendCompression = new IdentityHandler();
        this.receiveCompression = new IdentityHandler();
      }
      async sendMetadata(metadata) {
        const headers = await metadata;
        headers.set("grpc-accept-encoding", "identity,deflate,gzip");
        headers.set("accept-encoding", "identity");
        return headers;
      }
      receiveMetadata(metadata) {
        const receiveEncoding = metadata.get("grpc-encoding");
        if (receiveEncoding.length > 0) {
          const encoding = receiveEncoding[0];
          if (typeof encoding === "string") {
            this.receiveCompression = getCompressionHandler(encoding);
          }
        }
        metadata.remove("grpc-encoding");
        metadata.remove("grpc-accept-encoding");
        return metadata;
      }
      async sendMessage(message) {
        const resolvedMessage = await message;
        const compress = resolvedMessage.flags === void 0 ? false : (resolvedMessage.flags & 2) === 0;
        return {
          message: await this.sendCompression.writeMessage(resolvedMessage.message, compress),
          flags: resolvedMessage.flags
        };
      }
      async receiveMessage(message) {
        return this.receiveCompression.readMessage(await message);
      }
    };
    exports2.CompressionFilter = CompressionFilter;
    var CompressionFilterFactory = class {
      constructor(channel) {
        this.channel = channel;
      }
      createFilter(callStream) {
        return new CompressionFilter();
      }
    };
    exports2.CompressionFilterFactory = CompressionFilterFactory;
  }
});

// node_modules/@grpc/grpc-js/build/src/max-message-size-filter.js
var require_max_message_size_filter = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/max-message-size-filter.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MaxMessageSizeFilterFactory = exports2.MaxMessageSizeFilter = void 0;
    var filter_1 = require_filter();
    var constants_1 = require_constants();
    var MaxMessageSizeFilter = class extends filter_1.BaseFilter {
      constructor(options2, callStream) {
        super();
        this.options = options2;
        this.callStream = callStream;
        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;
        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
        if ("grpc.max_send_message_length" in options2) {
          this.maxSendMessageSize = options2["grpc.max_send_message_length"];
        }
        if ("grpc.max_receive_message_length" in options2) {
          this.maxReceiveMessageSize = options2["grpc.max_receive_message_length"];
        }
      }
      async sendMessage(message) {
        if (this.maxSendMessageSize === -1) {
          return message;
        } else {
          const concreteMessage = await message;
          if (concreteMessage.message.length > this.maxSendMessageSize) {
            this.callStream.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, `Sent message larger than max (${concreteMessage.message.length} vs. ${this.maxSendMessageSize})`);
            return Promise.reject("Message too large");
          } else {
            return concreteMessage;
          }
        }
      }
      async receiveMessage(message) {
        if (this.maxReceiveMessageSize === -1) {
          return message;
        } else {
          const concreteMessage = await message;
          if (concreteMessage.length > this.maxReceiveMessageSize) {
            this.callStream.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, `Received message larger than max (${concreteMessage.length} vs. ${this.maxReceiveMessageSize})`);
            return Promise.reject("Message too large");
          } else {
            return concreteMessage;
          }
        }
      }
    };
    exports2.MaxMessageSizeFilter = MaxMessageSizeFilter;
    var MaxMessageSizeFilterFactory = class {
      constructor(options2) {
        this.options = options2;
      }
      createFilter(callStream) {
        return new MaxMessageSizeFilter(this.options, callStream);
      }
    };
    exports2.MaxMessageSizeFilterFactory = MaxMessageSizeFilterFactory;
  }
});

// node_modules/@grpc/grpc-js/build/src/channel.js
var require_channel = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/channel.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ChannelImplementation = exports2.ConnectivityState = void 0;
    var call_stream_1 = require_call_stream();
    var channel_credentials_1 = require_channel_credentials();
    var resolving_load_balancer_1 = require_resolving_load_balancer();
    var subchannel_pool_1 = require_subchannel_pool();
    var picker_1 = require_picker();
    var constants_1 = require_constants();
    var filter_stack_1 = require_filter_stack();
    var call_credentials_filter_1 = require_call_credentials_filter();
    var deadline_filter_1 = require_deadline_filter();
    var compression_filter_1 = require_compression_filter();
    var resolver_1 = require_resolver();
    var logging_1 = require_logging();
    var max_message_size_filter_1 = require_max_message_size_filter();
    var http_proxy_1 = require_http_proxy();
    var uri_parser_1 = require_uri_parser();
    var ConnectivityState;
    (function(ConnectivityState2) {
      ConnectivityState2[ConnectivityState2["IDLE"] = 0] = "IDLE";
      ConnectivityState2[ConnectivityState2["CONNECTING"] = 1] = "CONNECTING";
      ConnectivityState2[ConnectivityState2["READY"] = 2] = "READY";
      ConnectivityState2[ConnectivityState2["TRANSIENT_FAILURE"] = 3] = "TRANSIENT_FAILURE";
      ConnectivityState2[ConnectivityState2["SHUTDOWN"] = 4] = "SHUTDOWN";
    })(ConnectivityState = exports2.ConnectivityState || (exports2.ConnectivityState = {}));
    var MAX_TIMEOUT_TIME = 2147483647;
    var nextCallNumber = 0;
    function getNewCallNumber() {
      const callNumber = nextCallNumber;
      nextCallNumber += 1;
      if (nextCallNumber >= Number.MAX_SAFE_INTEGER) {
        nextCallNumber = 0;
      }
      return callNumber;
    }
    var ChannelImplementation = class {
      constructor(target, credentials, options2) {
        var _a, _b, _c;
        this.credentials = credentials;
        this.options = options2;
        this.connectivityState = ConnectivityState.IDLE;
        this.currentPicker = new picker_1.UnavailablePicker();
        this.configSelectionQueue = [];
        this.pickQueue = [];
        this.connectivityStateWatchers = [];
        this.configSelector = null;
        if (typeof target !== "string") {
          throw new TypeError("Channel target must be a string");
        }
        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {
          throw new TypeError("Channel credentials must be a ChannelCredentials object");
        }
        if (options2) {
          if (typeof options2 !== "object" || !Object.values(options2).every((value) => typeof value === "string" || typeof value === "number" || typeof value === "undefined")) {
            throw new TypeError("Channel options must be an object with string or number values");
          }
        }
        const originalTargetUri = uri_parser_1.parseUri(target);
        if (originalTargetUri === null) {
          throw new Error(`Could not parse target name "${target}"`);
        }
        const defaultSchemeMapResult = resolver_1.mapUriDefaultScheme(originalTargetUri);
        if (defaultSchemeMapResult === null) {
          throw new Error(`Could not find a default scheme for target name "${target}"`);
        }
        this.callRefTimer = setInterval(() => {
        }, MAX_TIMEOUT_TIME);
        (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        if (this.options["grpc.default_authority"]) {
          this.defaultAuthority = this.options["grpc.default_authority"];
        } else {
          this.defaultAuthority = resolver_1.getDefaultAuthority(defaultSchemeMapResult);
        }
        const proxyMapResult = http_proxy_1.mapProxyName(defaultSchemeMapResult, options2);
        this.target = proxyMapResult.target;
        this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);
        this.subchannelPool = subchannel_pool_1.getSubchannelPool(((_c = options2["grpc.use_local_subchannel_pool"]) !== null && _c !== void 0 ? _c : 0) === 0);
        const channelControlHelper = {
          createSubchannel: (subchannelAddress, subchannelArgs) => {
            return this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, Object.assign({}, this.options, subchannelArgs), this.credentials);
          },
          updateState: (connectivityState, picker) => {
            this.currentPicker = picker;
            const queueCopy = this.pickQueue.slice();
            this.pickQueue = [];
            this.callRefTimerUnref();
            for (const { callStream, callMetadata, callConfig } of queueCopy) {
              this.tryPick(callStream, callMetadata, callConfig);
            }
            this.updateState(connectivityState);
          },
          requestReresolution: () => {
            throw new Error("Resolving load balancer should never call requestReresolution");
          }
        };
        this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, options2, (configSelector) => {
          this.configSelector = configSelector;
          process.nextTick(() => {
            const localQueue = this.configSelectionQueue;
            this.configSelectionQueue = [];
            this.callRefTimerUnref();
            for (const { callStream, callMetadata } of localQueue) {
              this.tryGetConfig(callStream, callMetadata);
            }
            this.configSelectionQueue = [];
          });
        }, (status) => {
          if (this.configSelectionQueue.length > 0) {
            logging_1.trace(constants_1.LogVerbosity.DEBUG, "channel", "Name resolution failed for target " + uri_parser_1.uriToString(this.target) + " with calls queued for config selection");
          }
          const localQueue = this.configSelectionQueue;
          this.configSelectionQueue = [];
          this.callRefTimerUnref();
          for (const { callStream, callMetadata } of localQueue) {
            if (callMetadata.getOptions().waitForReady) {
              this.callRefTimerRef();
              this.configSelectionQueue.push({ callStream, callMetadata });
            } else {
              callStream.cancelWithStatus(status.code, status.details);
            }
          }
        });
        this.filterStackFactory = new filter_stack_1.FilterStackFactory([
          new call_credentials_filter_1.CallCredentialsFilterFactory(this),
          new deadline_filter_1.DeadlineFilterFactory(this),
          new max_message_size_filter_1.MaxMessageSizeFilterFactory(this.options),
          new compression_filter_1.CompressionFilterFactory(this)
        ]);
      }
      callRefTimerRef() {
        var _a, _b, _c, _d;
        if (!((_b = (_a = this.callRefTimer).hasRef) === null || _b === void 0 ? void 0 : _b.call(_a))) {
          logging_1.trace(constants_1.LogVerbosity.DEBUG, "channel", "callRefTimer.ref | configSelectionQueue.length=" + this.configSelectionQueue.length + " pickQueue.length=" + this.pickQueue.length);
          (_d = (_c = this.callRefTimer).ref) === null || _d === void 0 ? void 0 : _d.call(_c);
        }
      }
      callRefTimerUnref() {
        var _a, _b;
        if (!this.callRefTimer.hasRef || this.callRefTimer.hasRef()) {
          logging_1.trace(constants_1.LogVerbosity.DEBUG, "channel", "callRefTimer.unref | configSelectionQueue.length=" + this.configSelectionQueue.length + " pickQueue.length=" + this.pickQueue.length);
          (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
      }
      pushPick(callStream, callMetadata, callConfig) {
        this.pickQueue.push({ callStream, callMetadata, callConfig });
        this.callRefTimerRef();
      }
      tryPick(callStream, callMetadata, callConfig) {
        var _a, _b, _c;
        const pickResult = this.currentPicker.pick({ metadata: callMetadata, extraPickInfo: callConfig.pickInformation });
        logging_1.trace(constants_1.LogVerbosity.DEBUG, "channel", "Pick result: " + picker_1.PickResultType[pickResult.pickResultType] + " subchannel: " + ((_a = pickResult.subchannel) === null || _a === void 0 ? void 0 : _a.getAddress()) + " status: " + ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.code) + " " + ((_c = pickResult.status) === null || _c === void 0 ? void 0 : _c.details));
        switch (pickResult.pickResultType) {
          case picker_1.PickResultType.COMPLETE:
            if (pickResult.subchannel === null) {
              callStream.cancelWithStatus(constants_1.Status.UNAVAILABLE, "Request dropped by load balancing policy");
            } else {
              if (pickResult.subchannel.getConnectivityState() !== ConnectivityState.READY) {
                logging_1.log(constants_1.LogVerbosity.ERROR, "Error: COMPLETE pick result subchannel " + pickResult.subchannel.getAddress() + " has state " + ConnectivityState[pickResult.subchannel.getConnectivityState()]);
                this.pushPick(callStream, callMetadata, callConfig);
                break;
              }
              callStream.filterStack.sendMetadata(Promise.resolve(callMetadata.clone())).then((finalMetadata) => {
                var _a2, _b2, _c2;
                const subchannelState = pickResult.subchannel.getConnectivityState();
                if (subchannelState === ConnectivityState.READY) {
                  try {
                    pickResult.subchannel.startCallStream(finalMetadata, callStream, (_a2 = pickResult.extraFilterFactory) !== null && _a2 !== void 0 ? _a2 : void 0);
                    (_b2 = callConfig.onCommitted) === null || _b2 === void 0 ? void 0 : _b2.call(callConfig);
                    (_c2 = pickResult.onCallStarted) === null || _c2 === void 0 ? void 0 : _c2.call(pickResult);
                  } catch (error2) {
                    if (error2.code === "ERR_HTTP2_GOAWAY_SESSION") {
                      logging_1.trace(constants_1.LogVerbosity.INFO, "channel", "Failed to start call on picked subchannel " + pickResult.subchannel.getAddress() + " with error " + error2.message + ". Retrying pick");
                      this.tryPick(callStream, callMetadata, callConfig);
                    } else {
                      logging_1.trace(constants_1.LogVerbosity.INFO, "channel", "Failed to start call on picked subchanel " + pickResult.subchannel.getAddress() + " with error " + error2.message + ". Ending call");
                      callStream.cancelWithStatus(constants_1.Status.INTERNAL, `Failed to start HTTP/2 stream with error: ${error2.message}`);
                    }
                  }
                } else {
                  logging_1.trace(constants_1.LogVerbosity.INFO, "channel", "Picked subchannel " + pickResult.subchannel.getAddress() + " has state " + ConnectivityState[subchannelState] + " after metadata filters. Retrying pick");
                  this.tryPick(callStream, callMetadata, callConfig);
                }
              }, (error2) => {
                callStream.cancelWithStatus(typeof error2.code === "number" ? error2.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error2.message}`);
              });
            }
            break;
          case picker_1.PickResultType.QUEUE:
            this.pushPick(callStream, callMetadata, callConfig);
            break;
          case picker_1.PickResultType.TRANSIENT_FAILURE:
            if (callMetadata.getOptions().waitForReady) {
              this.pushPick(callStream, callMetadata, callConfig);
            } else {
              callStream.cancelWithStatus(pickResult.status.code, pickResult.status.details);
            }
            break;
          case picker_1.PickResultType.DROP:
            callStream.cancelWithStatus(pickResult.status.code, pickResult.status.details);
            break;
          default:
            throw new Error(`Invalid state: unknown pickResultType ${pickResult.pickResultType}`);
        }
      }
      removeConnectivityStateWatcher(watcherObject) {
        const watcherIndex = this.connectivityStateWatchers.findIndex((value) => value === watcherObject);
        if (watcherIndex >= 0) {
          this.connectivityStateWatchers.splice(watcherIndex, 1);
        }
      }
      updateState(newState) {
        logging_1.trace(constants_1.LogVerbosity.DEBUG, "connectivity_state", uri_parser_1.uriToString(this.target) + " " + ConnectivityState[this.connectivityState] + " -> " + ConnectivityState[newState]);
        this.connectivityState = newState;
        const watchersCopy = this.connectivityStateWatchers.slice();
        for (const watcherObject of watchersCopy) {
          if (newState !== watcherObject.currentState) {
            if (watcherObject.timer) {
              clearTimeout(watcherObject.timer);
            }
            this.removeConnectivityStateWatcher(watcherObject);
            watcherObject.callback();
          }
        }
      }
      tryGetConfig(stream, metadata) {
        if (this.configSelector === null) {
          this.resolvingLoadBalancer.exitIdle();
          this.configSelectionQueue.push({
            callStream: stream,
            callMetadata: metadata
          });
          this.callRefTimerRef();
        } else {
          const callConfig = this.configSelector(stream.getMethod(), metadata);
          if (callConfig.status === constants_1.Status.OK) {
            this.tryPick(stream, metadata, callConfig);
          } else {
            stream.cancelWithStatus(callConfig.status, "Failed to route call to method " + stream.getMethod());
          }
        }
      }
      _startCallStream(stream, metadata) {
        this.tryGetConfig(stream, metadata.clone());
      }
      close() {
        this.resolvingLoadBalancer.destroy();
        this.updateState(ConnectivityState.SHUTDOWN);
        clearInterval(this.callRefTimer);
        this.subchannelPool.unrefUnusedSubchannels();
      }
      getTarget() {
        return uri_parser_1.uriToString(this.target);
      }
      getConnectivityState(tryToConnect) {
        const connectivityState = this.connectivityState;
        if (tryToConnect) {
          this.resolvingLoadBalancer.exitIdle();
        }
        return connectivityState;
      }
      watchConnectivityState(currentState, deadline, callback) {
        if (this.connectivityState === ConnectivityState.SHUTDOWN) {
          throw new Error("Channel has been shut down");
        }
        let timer = null;
        if (deadline !== Infinity) {
          const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);
          const now = new Date();
          if (deadline === -Infinity || deadlineDate <= now) {
            process.nextTick(callback, new Error("Deadline passed without connectivity state change"));
            return;
          }
          timer = setTimeout(() => {
            this.removeConnectivityStateWatcher(watcherObject);
            callback(new Error("Deadline passed without connectivity state change"));
          }, deadlineDate.getTime() - now.getTime());
        }
        const watcherObject = {
          currentState,
          callback,
          timer
        };
        this.connectivityStateWatchers.push(watcherObject);
      }
      createCall(method, deadline, host, parentCall, propagateFlags) {
        if (typeof method !== "string") {
          throw new TypeError("Channel#createCall: method must be a string");
        }
        if (!(typeof deadline === "number" || deadline instanceof Date)) {
          throw new TypeError("Channel#createCall: deadline must be a number or Date");
        }
        if (this.connectivityState === ConnectivityState.SHUTDOWN) {
          throw new Error("Channel has been shut down");
        }
        const callNumber = getNewCallNumber();
        logging_1.trace(constants_1.LogVerbosity.DEBUG, "channel", uri_parser_1.uriToString(this.target) + " createCall [" + callNumber + '] method="' + method + '", deadline=' + deadline);
        const finalOptions = {
          deadline,
          flags: propagateFlags !== null && propagateFlags !== void 0 ? propagateFlags : constants_1.Propagate.DEFAULTS,
          host: host !== null && host !== void 0 ? host : this.defaultAuthority,
          parentCall
        };
        const stream = new call_stream_1.Http2CallStream(method, this, finalOptions, this.filterStackFactory, this.credentials._getCallCredentials(), callNumber);
        return stream;
      }
    };
    exports2.ChannelImplementation = ChannelImplementation;
  }
});

// node_modules/@grpc/grpc-js/build/src/call.js
var require_call = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/call.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ClientDuplexStreamImpl = exports2.ClientWritableStreamImpl = exports2.ClientReadableStreamImpl = exports2.ClientUnaryCallImpl = exports2.callErrorFromStatus = void 0;
    var events_1 = require("events");
    var stream_1 = require("stream");
    var constants_1 = require_constants();
    function callErrorFromStatus(status) {
      const message = `${status.code} ${constants_1.Status[status.code]}: ${status.details}`;
      return Object.assign(new Error(message), status);
    }
    exports2.callErrorFromStatus = callErrorFromStatus;
    var ClientUnaryCallImpl = class extends events_1.EventEmitter {
      constructor() {
        super();
      }
      cancel() {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled on client");
      }
      getPeer() {
        var _a, _b;
        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : "unknown";
      }
    };
    exports2.ClientUnaryCallImpl = ClientUnaryCallImpl;
    var ClientReadableStreamImpl = class extends stream_1.Readable {
      constructor(deserialize) {
        super({ objectMode: true });
        this.deserialize = deserialize;
      }
      cancel() {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled on client");
      }
      getPeer() {
        var _a, _b;
        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : "unknown";
      }
      _read(_size) {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();
      }
    };
    exports2.ClientReadableStreamImpl = ClientReadableStreamImpl;
    var ClientWritableStreamImpl = class extends stream_1.Writable {
      constructor(serialize) {
        super({ objectMode: true });
        this.serialize = serialize;
      }
      cancel() {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled on client");
      }
      getPeer() {
        var _a, _b;
        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : "unknown";
      }
      _write(chunk, encoding, cb) {
        var _a;
        const context = {
          callback: cb
        };
        const flags = Number(encoding);
        if (!Number.isNaN(flags)) {
          context.flags = flags;
        }
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);
      }
      _final(cb) {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();
        cb();
      }
    };
    exports2.ClientWritableStreamImpl = ClientWritableStreamImpl;
    var ClientDuplexStreamImpl = class extends stream_1.Duplex {
      constructor(serialize, deserialize) {
        super({ objectMode: true });
        this.serialize = serialize;
        this.deserialize = deserialize;
      }
      cancel() {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled on client");
      }
      getPeer() {
        var _a, _b;
        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : "unknown";
      }
      _read(_size) {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();
      }
      _write(chunk, encoding, cb) {
        var _a;
        const context = {
          callback: cb
        };
        const flags = Number(encoding);
        if (!Number.isNaN(flags)) {
          context.flags = flags;
        }
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);
      }
      _final(cb) {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();
        cb();
      }
    };
    exports2.ClientDuplexStreamImpl = ClientDuplexStreamImpl;
  }
});

// node_modules/@grpc/grpc-js/build/src/client-interceptors.js
var require_client_interceptors = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/client-interceptors.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getInterceptingCall = exports2.InterceptingCall = exports2.RequesterBuilder = exports2.ListenerBuilder = exports2.InterceptorConfigurationError = void 0;
    var metadata_1 = require_metadata();
    var call_stream_1 = require_call_stream();
    var constants_1 = require_constants();
    var InterceptorConfigurationError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "InterceptorConfigurationError";
        Error.captureStackTrace(this, InterceptorConfigurationError);
      }
    };
    exports2.InterceptorConfigurationError = InterceptorConfigurationError;
    var ListenerBuilder = class {
      constructor() {
        this.metadata = void 0;
        this.message = void 0;
        this.status = void 0;
      }
      withOnReceiveMetadata(onReceiveMetadata) {
        this.metadata = onReceiveMetadata;
        return this;
      }
      withOnReceiveMessage(onReceiveMessage) {
        this.message = onReceiveMessage;
        return this;
      }
      withOnReceiveStatus(onReceiveStatus) {
        this.status = onReceiveStatus;
        return this;
      }
      build() {
        return {
          onReceiveMetadata: this.metadata,
          onReceiveMessage: this.message,
          onReceiveStatus: this.status
        };
      }
    };
    exports2.ListenerBuilder = ListenerBuilder;
    var RequesterBuilder = class {
      constructor() {
        this.start = void 0;
        this.message = void 0;
        this.halfClose = void 0;
        this.cancel = void 0;
      }
      withStart(start2) {
        this.start = start2;
        return this;
      }
      withSendMessage(sendMessage) {
        this.message = sendMessage;
        return this;
      }
      withHalfClose(halfClose) {
        this.halfClose = halfClose;
        return this;
      }
      withCancel(cancel) {
        this.cancel = cancel;
        return this;
      }
      build() {
        return {
          start: this.start,
          sendMessage: this.message,
          halfClose: this.halfClose,
          cancel: this.cancel
        };
      }
    };
    exports2.RequesterBuilder = RequesterBuilder;
    var defaultListener = {
      onReceiveMetadata: (metadata, next) => {
        next(metadata);
      },
      onReceiveMessage: (message, next) => {
        next(message);
      },
      onReceiveStatus: (status, next) => {
        next(status);
      }
    };
    var defaultRequester = {
      start: (metadata, listener, next) => {
        next(metadata, listener);
      },
      sendMessage: (message, next) => {
        next(message);
      },
      halfClose: (next) => {
        next();
      },
      cancel: (next) => {
        next();
      }
    };
    var InterceptingCall = class {
      constructor(nextCall, requester) {
        var _a, _b, _c, _d;
        this.nextCall = nextCall;
        this.processingMessage = false;
        this.pendingHalfClose = false;
        if (requester) {
          this.requester = {
            start: (_a = requester.start) !== null && _a !== void 0 ? _a : defaultRequester.start,
            sendMessage: (_b = requester.sendMessage) !== null && _b !== void 0 ? _b : defaultRequester.sendMessage,
            halfClose: (_c = requester.halfClose) !== null && _c !== void 0 ? _c : defaultRequester.halfClose,
            cancel: (_d = requester.cancel) !== null && _d !== void 0 ? _d : defaultRequester.cancel
          };
        } else {
          this.requester = defaultRequester;
        }
      }
      cancelWithStatus(status, details) {
        this.requester.cancel(() => {
          this.nextCall.cancelWithStatus(status, details);
        });
      }
      getPeer() {
        return this.nextCall.getPeer();
      }
      start(metadata, interceptingListener) {
        var _a, _b, _c, _d, _e, _f;
        const fullInterceptingListener = {
          onReceiveMetadata: (_b = (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(interceptingListener)) !== null && _b !== void 0 ? _b : (metadata2) => {
          },
          onReceiveMessage: (_d = (_c = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _c === void 0 ? void 0 : _c.bind(interceptingListener)) !== null && _d !== void 0 ? _d : (message) => {
          },
          onReceiveStatus: (_f = (_e = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _e === void 0 ? void 0 : _e.bind(interceptingListener)) !== null && _f !== void 0 ? _f : (status) => {
          }
        };
        this.requester.start(metadata, fullInterceptingListener, (md, listener) => {
          var _a2, _b2, _c2;
          let finalInterceptingListener;
          if (call_stream_1.isInterceptingListener(listener)) {
            finalInterceptingListener = listener;
          } else {
            const fullListener = {
              onReceiveMetadata: (_a2 = listener.onReceiveMetadata) !== null && _a2 !== void 0 ? _a2 : defaultListener.onReceiveMetadata,
              onReceiveMessage: (_b2 = listener.onReceiveMessage) !== null && _b2 !== void 0 ? _b2 : defaultListener.onReceiveMessage,
              onReceiveStatus: (_c2 = listener.onReceiveStatus) !== null && _c2 !== void 0 ? _c2 : defaultListener.onReceiveStatus
            };
            finalInterceptingListener = new call_stream_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);
          }
          this.nextCall.start(md, finalInterceptingListener);
        });
      }
      sendMessageWithContext(context, message) {
        this.processingMessage = true;
        this.requester.sendMessage(message, (finalMessage) => {
          this.processingMessage = false;
          this.nextCall.sendMessageWithContext(context, finalMessage);
          if (this.pendingHalfClose) {
            this.nextCall.halfClose();
          }
        });
      }
      sendMessage(message) {
        this.sendMessageWithContext({}, message);
      }
      startRead() {
        this.nextCall.startRead();
      }
      halfClose() {
        this.requester.halfClose(() => {
          if (this.processingMessage) {
            this.pendingHalfClose = true;
          } else {
            this.nextCall.halfClose();
          }
        });
      }
      setCredentials(credentials) {
        this.nextCall.setCredentials(credentials);
      }
    };
    exports2.InterceptingCall = InterceptingCall;
    function getCall(channel, path, options2) {
      var _a, _b;
      const deadline = (_a = options2.deadline) !== null && _a !== void 0 ? _a : Infinity;
      const host = options2.host;
      const parent2 = (_b = options2.parent) !== null && _b !== void 0 ? _b : null;
      const propagateFlags = options2.propagate_flags;
      const credentials = options2.credentials;
      const call = channel.createCall(path, deadline, host, parent2, propagateFlags);
      if (credentials) {
        call.setCredentials(credentials);
      }
      return call;
    }
    var BaseInterceptingCall = class {
      constructor(call, methodDefinition) {
        this.call = call;
        this.methodDefinition = methodDefinition;
      }
      cancelWithStatus(status, details) {
        this.call.cancelWithStatus(status, details);
      }
      getPeer() {
        return this.call.getPeer();
      }
      setCredentials(credentials) {
        this.call.setCredentials(credentials);
      }
      sendMessageWithContext(context, message) {
        let serialized;
        try {
          serialized = this.methodDefinition.requestSerialize(message);
        } catch (e) {
          this.call.cancelWithStatus(constants_1.Status.INTERNAL, `Request message serialization failure: ${e.message}`);
          return;
        }
        this.call.sendMessageWithContext(context, serialized);
      }
      sendMessage(message) {
        this.sendMessageWithContext({}, message);
      }
      start(metadata, interceptingListener) {
        let readError = null;
        this.call.start(metadata, {
          onReceiveMetadata: (metadata2) => {
            var _a;
            (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, metadata2);
          },
          onReceiveMessage: (message) => {
            var _a;
            let deserialized;
            try {
              deserialized = this.methodDefinition.responseDeserialize(message);
            } catch (e) {
              readError = {
                code: constants_1.Status.INTERNAL,
                details: `Response message parsing error: ${e.message}`,
                metadata: new metadata_1.Metadata()
              };
              this.call.cancelWithStatus(readError.code, readError.details);
              return;
            }
            (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, deserialized);
          },
          onReceiveStatus: (status) => {
            var _a, _b;
            if (readError) {
              (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, readError);
            } else {
              (_b = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(interceptingListener, status);
            }
          }
        });
      }
      startRead() {
        this.call.startRead();
      }
      halfClose() {
        this.call.halfClose();
      }
    };
    var BaseUnaryInterceptingCall = class extends BaseInterceptingCall {
      constructor(call, methodDefinition) {
        super(call, methodDefinition);
      }
      start(metadata, listener) {
        var _a, _b;
        let receivedMessage = false;
        const wrapperListener = {
          onReceiveMetadata: (_b = (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(listener)) !== null && _b !== void 0 ? _b : (metadata2) => {
          },
          onReceiveMessage: (message) => {
            var _a2;
            receivedMessage = true;
            (_a2 = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a2 === void 0 ? void 0 : _a2.call(listener, message);
          },
          onReceiveStatus: (status) => {
            var _a2, _b2;
            if (!receivedMessage) {
              (_a2 = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a2 === void 0 ? void 0 : _a2.call(listener, null);
            }
            (_b2 = listener === null || listener === void 0 ? void 0 : listener.onReceiveStatus) === null || _b2 === void 0 ? void 0 : _b2.call(listener, status);
          }
        };
        super.start(metadata, wrapperListener);
        this.call.startRead();
      }
    };
    var BaseStreamingInterceptingCall = class extends BaseInterceptingCall {
    };
    function getBottomInterceptingCall(channel, options2, methodDefinition) {
      const call = getCall(channel, methodDefinition.path, options2);
      if (methodDefinition.responseStream) {
        return new BaseStreamingInterceptingCall(call, methodDefinition);
      } else {
        return new BaseUnaryInterceptingCall(call, methodDefinition);
      }
    }
    function getInterceptingCall(interceptorArgs, methodDefinition, options2, channel) {
      if (interceptorArgs.clientInterceptors.length > 0 && interceptorArgs.clientInterceptorProviders.length > 0) {
        throw new InterceptorConfigurationError("Both interceptors and interceptor_providers were passed as options to the client constructor. Only one of these is allowed.");
      }
      if (interceptorArgs.callInterceptors.length > 0 && interceptorArgs.callInterceptorProviders.length > 0) {
        throw new InterceptorConfigurationError("Both interceptors and interceptor_providers were passed as call options. Only one of these is allowed.");
      }
      let interceptors = [];
      if (interceptorArgs.callInterceptors.length > 0 || interceptorArgs.callInterceptorProviders.length > 0) {
        interceptors = [].concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map((provider) => provider(methodDefinition))).filter((interceptor) => interceptor);
      } else {
        interceptors = [].concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map((provider) => provider(methodDefinition))).filter((interceptor) => interceptor);
      }
      const interceptorOptions = Object.assign({}, options2, {
        method_definition: methodDefinition
      });
      const getCall2 = interceptors.reduceRight((nextCall, nextInterceptor) => {
        return (currentOptions) => nextInterceptor(currentOptions, nextCall);
      }, (finalOptions) => getBottomInterceptingCall(channel, finalOptions, methodDefinition));
      return getCall2(interceptorOptions);
    }
    exports2.getInterceptingCall = getInterceptingCall;
  }
});

// node_modules/@grpc/grpc-js/build/src/client.js
var require_client = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/client.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Client = void 0;
    var call_1 = require_call();
    var channel_1 = require_channel();
    var constants_1 = require_constants();
    var metadata_1 = require_metadata();
    var client_interceptors_1 = require_client_interceptors();
    var CHANNEL_SYMBOL = Symbol();
    var INTERCEPTOR_SYMBOL = Symbol();
    var INTERCEPTOR_PROVIDER_SYMBOL = Symbol();
    var CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();
    function isFunction(arg) {
      return typeof arg === "function";
    }
    var Client = class {
      constructor(address, credentials, options2 = {}) {
        var _a, _b;
        options2 = Object.assign({}, options2);
        this[INTERCEPTOR_SYMBOL] = (_a = options2.interceptors) !== null && _a !== void 0 ? _a : [];
        delete options2.interceptors;
        this[INTERCEPTOR_PROVIDER_SYMBOL] = (_b = options2.interceptor_providers) !== null && _b !== void 0 ? _b : [];
        delete options2.interceptor_providers;
        if (this[INTERCEPTOR_SYMBOL].length > 0 && this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0) {
          throw new Error("Both interceptors and interceptor_providers were passed as options to the client constructor. Only one of these is allowed.");
        }
        this[CALL_INVOCATION_TRANSFORMER_SYMBOL] = options2.callInvocationTransformer;
        delete options2.callInvocationTransformer;
        if (options2.channelOverride) {
          this[CHANNEL_SYMBOL] = options2.channelOverride;
        } else if (options2.channelFactoryOverride) {
          const channelFactoryOverride = options2.channelFactoryOverride;
          delete options2.channelFactoryOverride;
          this[CHANNEL_SYMBOL] = channelFactoryOverride(address, credentials, options2);
        } else {
          this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials, options2);
        }
      }
      close() {
        this[CHANNEL_SYMBOL].close();
      }
      getChannel() {
        return this[CHANNEL_SYMBOL];
      }
      waitForReady(deadline, callback) {
        const checkState = (err) => {
          if (err) {
            callback(new Error("Failed to connect before the deadline"));
            return;
          }
          let newState;
          try {
            newState = this[CHANNEL_SYMBOL].getConnectivityState(true);
          } catch (e) {
            callback(new Error("The channel has been closed"));
            return;
          }
          if (newState === channel_1.ConnectivityState.READY) {
            callback();
          } else {
            try {
              this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);
            } catch (e) {
              callback(new Error("The channel has been closed"));
            }
          }
        };
        setImmediate(checkState);
      }
      checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {
        if (isFunction(arg1)) {
          return { metadata: new metadata_1.Metadata(), options: {}, callback: arg1 };
        } else if (isFunction(arg2)) {
          if (arg1 instanceof metadata_1.Metadata) {
            return { metadata: arg1, options: {}, callback: arg2 };
          } else {
            return { metadata: new metadata_1.Metadata(), options: arg1, callback: arg2 };
          }
        } else {
          if (!(arg1 instanceof metadata_1.Metadata && arg2 instanceof Object && isFunction(arg3))) {
            throw new Error("Incorrect arguments passed");
          }
          return { metadata: arg1, options: arg2, callback: arg3 };
        }
      }
      makeUnaryRequest(method, serialize, deserialize, argument, metadata, options2, callback) {
        var _a, _b;
        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options2, callback);
        const methodDefinition = {
          path: method,
          requestStream: false,
          responseStream: false,
          requestSerialize: serialize,
          responseDeserialize: deserialize
        };
        let callProperties = {
          argument,
          metadata: checkedArguments.metadata,
          call: new call_1.ClientUnaryCallImpl(),
          channel: this[CHANNEL_SYMBOL],
          methodDefinition,
          callOptions: checkedArguments.options,
          callback: checkedArguments.callback
        };
        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
          callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
        }
        const emitter = callProperties.call;
        const interceptorArgs = {
          clientInterceptors: this[INTERCEPTOR_SYMBOL],
          clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
          callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],
          callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []
        };
        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
        emitter.call = call;
        if (callProperties.callOptions.credentials) {
          call.setCredentials(callProperties.callOptions.credentials);
        }
        let responseMessage = null;
        let receivedStatus = false;
        call.start(callProperties.metadata, {
          onReceiveMetadata: (metadata2) => {
            emitter.emit("metadata", metadata2);
          },
          onReceiveMessage(message) {
            if (responseMessage !== null) {
              call.cancelWithStatus(constants_1.Status.INTERNAL, "Too many responses received");
            }
            responseMessage = message;
          },
          onReceiveStatus(status) {
            if (receivedStatus) {
              return;
            }
            receivedStatus = true;
            if (status.code === constants_1.Status.OK) {
              callProperties.callback(null, responseMessage);
            } else {
              callProperties.callback(call_1.callErrorFromStatus(status));
            }
            emitter.emit("status", status);
          }
        });
        call.sendMessage(argument);
        call.halfClose();
        return emitter;
      }
      makeClientStreamRequest(method, serialize, deserialize, metadata, options2, callback) {
        var _a, _b;
        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options2, callback);
        const methodDefinition = {
          path: method,
          requestStream: true,
          responseStream: false,
          requestSerialize: serialize,
          responseDeserialize: deserialize
        };
        let callProperties = {
          metadata: checkedArguments.metadata,
          call: new call_1.ClientWritableStreamImpl(serialize),
          channel: this[CHANNEL_SYMBOL],
          methodDefinition,
          callOptions: checkedArguments.options,
          callback: checkedArguments.callback
        };
        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
          callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
        }
        const emitter = callProperties.call;
        const interceptorArgs = {
          clientInterceptors: this[INTERCEPTOR_SYMBOL],
          clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
          callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],
          callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []
        };
        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
        emitter.call = call;
        if (callProperties.callOptions.credentials) {
          call.setCredentials(callProperties.callOptions.credentials);
        }
        let responseMessage = null;
        let receivedStatus = false;
        call.start(callProperties.metadata, {
          onReceiveMetadata: (metadata2) => {
            emitter.emit("metadata", metadata2);
          },
          onReceiveMessage(message) {
            if (responseMessage !== null) {
              call.cancelWithStatus(constants_1.Status.INTERNAL, "Too many responses received");
            }
            responseMessage = message;
          },
          onReceiveStatus(status) {
            if (receivedStatus) {
              return;
            }
            receivedStatus = true;
            if (status.code === constants_1.Status.OK) {
              callProperties.callback(null, responseMessage);
            } else {
              callProperties.callback(call_1.callErrorFromStatus(status));
            }
            emitter.emit("status", status);
          }
        });
        return emitter;
      }
      checkMetadataAndOptions(arg1, arg2) {
        let metadata;
        let options2;
        if (arg1 instanceof metadata_1.Metadata) {
          metadata = arg1;
          if (arg2) {
            options2 = arg2;
          } else {
            options2 = {};
          }
        } else {
          if (arg1) {
            options2 = arg1;
          } else {
            options2 = {};
          }
          metadata = new metadata_1.Metadata();
        }
        return { metadata, options: options2 };
      }
      makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options2) {
        var _a, _b;
        const checkedArguments = this.checkMetadataAndOptions(metadata, options2);
        const methodDefinition = {
          path: method,
          requestStream: false,
          responseStream: true,
          requestSerialize: serialize,
          responseDeserialize: deserialize
        };
        let callProperties = {
          argument,
          metadata: checkedArguments.metadata,
          call: new call_1.ClientReadableStreamImpl(deserialize),
          channel: this[CHANNEL_SYMBOL],
          methodDefinition,
          callOptions: checkedArguments.options
        };
        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
          callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
        }
        const stream = callProperties.call;
        const interceptorArgs = {
          clientInterceptors: this[INTERCEPTOR_SYMBOL],
          clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
          callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],
          callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []
        };
        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
        stream.call = call;
        if (callProperties.callOptions.credentials) {
          call.setCredentials(callProperties.callOptions.credentials);
        }
        let receivedStatus = false;
        call.start(callProperties.metadata, {
          onReceiveMetadata(metadata2) {
            stream.emit("metadata", metadata2);
          },
          onReceiveMessage(message) {
            stream.push(message);
          },
          onReceiveStatus(status) {
            if (receivedStatus) {
              return;
            }
            receivedStatus = true;
            stream.push(null);
            if (status.code !== constants_1.Status.OK) {
              stream.emit("error", call_1.callErrorFromStatus(status));
            }
            stream.emit("status", status);
          }
        });
        call.sendMessage(argument);
        call.halfClose();
        return stream;
      }
      makeBidiStreamRequest(method, serialize, deserialize, metadata, options2) {
        var _a, _b;
        const checkedArguments = this.checkMetadataAndOptions(metadata, options2);
        const methodDefinition = {
          path: method,
          requestStream: true,
          responseStream: true,
          requestSerialize: serialize,
          responseDeserialize: deserialize
        };
        let callProperties = {
          metadata: checkedArguments.metadata,
          call: new call_1.ClientDuplexStreamImpl(serialize, deserialize),
          channel: this[CHANNEL_SYMBOL],
          methodDefinition,
          callOptions: checkedArguments.options
        };
        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
          callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
        }
        const stream = callProperties.call;
        const interceptorArgs = {
          clientInterceptors: this[INTERCEPTOR_SYMBOL],
          clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
          callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],
          callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []
        };
        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
        stream.call = call;
        if (callProperties.callOptions.credentials) {
          call.setCredentials(callProperties.callOptions.credentials);
        }
        let receivedStatus = false;
        call.start(callProperties.metadata, {
          onReceiveMetadata(metadata2) {
            stream.emit("metadata", metadata2);
          },
          onReceiveMessage(message) {
            stream.push(message);
          },
          onReceiveStatus(status) {
            if (receivedStatus) {
              return;
            }
            receivedStatus = true;
            stream.push(null);
            if (status.code !== constants_1.Status.OK) {
              stream.emit("error", call_1.callErrorFromStatus(status));
            }
            stream.emit("status", status);
          }
        });
        return stream;
      }
    };
    exports2.Client = Client;
  }
});

// node_modules/@grpc/grpc-js/build/src/make-client.js
var require_make_client = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/make-client.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.loadPackageDefinition = exports2.makeClientConstructor = void 0;
    var client_1 = require_client();
    var requesterFuncs = {
      unary: client_1.Client.prototype.makeUnaryRequest,
      server_stream: client_1.Client.prototype.makeServerStreamRequest,
      client_stream: client_1.Client.prototype.makeClientStreamRequest,
      bidi: client_1.Client.prototype.makeBidiStreamRequest
    };
    function isPrototypePolluted(key) {
      return ["__proto__", "prototype", "constructor"].includes(key);
    }
    function makeClientConstructor(methods, serviceName, classOptions) {
      if (!classOptions) {
        classOptions = {};
      }
      class ServiceClientImpl extends client_1.Client {
      }
      Object.keys(methods).forEach((name2) => {
        if (isPrototypePolluted(name2)) {
          return;
        }
        const attrs = methods[name2];
        let methodType;
        if (typeof name2 === "string" && name2.charAt(0) === "$") {
          throw new Error("Method names cannot start with $");
        }
        if (attrs.requestStream) {
          if (attrs.responseStream) {
            methodType = "bidi";
          } else {
            methodType = "client_stream";
          }
        } else {
          if (attrs.responseStream) {
            methodType = "server_stream";
          } else {
            methodType = "unary";
          }
        }
        const serialize = attrs.requestSerialize;
        const deserialize = attrs.responseDeserialize;
        const methodFunc = partial(requesterFuncs[methodType], attrs.path, serialize, deserialize);
        ServiceClientImpl.prototype[name2] = methodFunc;
        Object.assign(ServiceClientImpl.prototype[name2], attrs);
        if (attrs.originalName && !isPrototypePolluted(attrs.originalName)) {
          ServiceClientImpl.prototype[attrs.originalName] = ServiceClientImpl.prototype[name2];
        }
      });
      ServiceClientImpl.service = methods;
      return ServiceClientImpl;
    }
    exports2.makeClientConstructor = makeClientConstructor;
    function partial(fn, path, serialize, deserialize) {
      return function(...args) {
        return fn.call(this, path, serialize, deserialize, ...args);
      };
    }
    function isProtobufTypeDefinition(obj) {
      return "format" in obj;
    }
    function loadPackageDefinition(packageDef) {
      const result = {};
      for (const serviceFqn in packageDef) {
        if (Object.prototype.hasOwnProperty.call(packageDef, serviceFqn)) {
          const service = packageDef[serviceFqn];
          const nameComponents = serviceFqn.split(".");
          if (nameComponents.some((comp) => isPrototypePolluted(comp))) {
            continue;
          }
          const serviceName = nameComponents[nameComponents.length - 1];
          let current = result;
          for (const packageName of nameComponents.slice(0, -1)) {
            if (!current[packageName]) {
              current[packageName] = {};
            }
            current = current[packageName];
          }
          if (isProtobufTypeDefinition(service)) {
            current[serviceName] = service;
          } else {
            current[serviceName] = makeClientConstructor(service, serviceName, {});
          }
        }
      }
      return result;
    }
    exports2.loadPackageDefinition = loadPackageDefinition;
  }
});

// node_modules/@grpc/grpc-js/build/src/server-call.js
var require_server_call = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/server-call.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Http2ServerCallStream = exports2.ServerDuplexStreamImpl = exports2.ServerWritableStreamImpl = exports2.ServerReadableStreamImpl = exports2.ServerUnaryCallImpl = void 0;
    var events_1 = require("events");
    var http2 = require("http2");
    var stream_1 = require("stream");
    var constants_1 = require_constants();
    var metadata_1 = require_metadata();
    var stream_decoder_1 = require_stream_decoder();
    var logging = require_logging();
    var TRACER_NAME = "server_call";
    function trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    var GRPC_ACCEPT_ENCODING_HEADER = "grpc-accept-encoding";
    var GRPC_ENCODING_HEADER = "grpc-encoding";
    var GRPC_MESSAGE_HEADER = "grpc-message";
    var GRPC_STATUS_HEADER = "grpc-status";
    var GRPC_TIMEOUT_HEADER = "grpc-timeout";
    var DEADLINE_REGEX = /(\d{1,8})\s*([HMSmun])/;
    var deadlineUnitsToMs = {
      H: 36e5,
      M: 6e4,
      S: 1e3,
      m: 1,
      u: 1e-3,
      n: 1e-6
    };
    var defaultResponseHeaders = {
      [GRPC_ACCEPT_ENCODING_HEADER]: "identity",
      [GRPC_ENCODING_HEADER]: "identity",
      [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,
      [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: "application/grpc+proto"
    };
    var defaultResponseOptions = {
      waitForTrailers: true
    };
    var ServerUnaryCallImpl = class extends events_1.EventEmitter {
      constructor(call, metadata, request) {
        super();
        this.call = call;
        this.metadata = metadata;
        this.request = request;
        this.cancelled = false;
        this.call.setupSurfaceCall(this);
      }
      getPeer() {
        return this.call.getPeer();
      }
      sendMetadata(responseMetadata) {
        this.call.sendMetadata(responseMetadata);
      }
      getDeadline() {
        return this.call.getDeadline();
      }
    };
    exports2.ServerUnaryCallImpl = ServerUnaryCallImpl;
    var ServerReadableStreamImpl = class extends stream_1.Readable {
      constructor(call, metadata, deserialize) {
        super({ objectMode: true });
        this.call = call;
        this.metadata = metadata;
        this.deserialize = deserialize;
        this.cancelled = false;
        this.call.setupSurfaceCall(this);
        this.call.setupReadable(this);
      }
      _read(size) {
        if (!this.call.consumeUnpushedMessages(this)) {
          return;
        }
        this.call.resume();
      }
      getPeer() {
        return this.call.getPeer();
      }
      sendMetadata(responseMetadata) {
        this.call.sendMetadata(responseMetadata);
      }
      getDeadline() {
        return this.call.getDeadline();
      }
    };
    exports2.ServerReadableStreamImpl = ServerReadableStreamImpl;
    var ServerWritableStreamImpl = class extends stream_1.Writable {
      constructor(call, metadata, serialize, request) {
        super({ objectMode: true });
        this.call = call;
        this.metadata = metadata;
        this.serialize = serialize;
        this.request = request;
        this.cancelled = false;
        this.trailingMetadata = new metadata_1.Metadata();
        this.call.setupSurfaceCall(this);
        this.on("error", (err) => {
          this.call.sendError(err);
          this.end();
        });
      }
      getPeer() {
        return this.call.getPeer();
      }
      sendMetadata(responseMetadata) {
        this.call.sendMetadata(responseMetadata);
      }
      getDeadline() {
        return this.call.getDeadline();
      }
      _write(chunk, encoding, callback) {
        try {
          const response = this.call.serializeMessage(chunk);
          if (!this.call.write(response)) {
            this.call.once("drain", callback);
            return;
          }
        } catch (err) {
          err.code = constants_1.Status.INTERNAL;
          this.emit("error", err);
        }
        callback();
      }
      _final(callback) {
        this.call.sendStatus({
          code: constants_1.Status.OK,
          details: "OK",
          metadata: this.trailingMetadata
        });
        callback(null);
      }
      end(metadata) {
        if (metadata) {
          this.trailingMetadata = metadata;
        }
        super.end();
      }
    };
    exports2.ServerWritableStreamImpl = ServerWritableStreamImpl;
    var ServerDuplexStreamImpl = class extends stream_1.Duplex {
      constructor(call, metadata, serialize, deserialize) {
        super({ objectMode: true });
        this.call = call;
        this.metadata = metadata;
        this.serialize = serialize;
        this.deserialize = deserialize;
        this.cancelled = false;
        this.trailingMetadata = new metadata_1.Metadata();
        this.call.setupSurfaceCall(this);
        this.call.setupReadable(this);
        this.on("error", (err) => {
          this.call.sendError(err);
          this.end();
        });
      }
      getPeer() {
        return this.call.getPeer();
      }
      sendMetadata(responseMetadata) {
        this.call.sendMetadata(responseMetadata);
      }
      getDeadline() {
        return this.call.getDeadline();
      }
      end(metadata) {
        if (metadata) {
          this.trailingMetadata = metadata;
        }
        super.end();
      }
    };
    exports2.ServerDuplexStreamImpl = ServerDuplexStreamImpl;
    ServerDuplexStreamImpl.prototype._read = ServerReadableStreamImpl.prototype._read;
    ServerDuplexStreamImpl.prototype._write = ServerWritableStreamImpl.prototype._write;
    ServerDuplexStreamImpl.prototype._final = ServerWritableStreamImpl.prototype._final;
    ServerDuplexStreamImpl.prototype.end = ServerWritableStreamImpl.prototype.end;
    var Http2ServerCallStream = class extends events_1.EventEmitter {
      constructor(stream, handler2, options2) {
        super();
        this.stream = stream;
        this.handler = handler2;
        this.options = options2;
        this.cancelled = false;
        this.deadlineTimer = setTimeout(() => {
        }, 0);
        this.deadline = Infinity;
        this.wantTrailers = false;
        this.metadataSent = false;
        this.canPush = false;
        this.isPushPending = false;
        this.bufferedMessages = [];
        this.messagesToPush = [];
        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;
        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
        this.stream.once("error", (err) => {
        });
        this.stream.once("close", () => {
          var _a;
          trace("Request to method " + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + " stream closed with rstCode " + this.stream.rstCode);
          this.cancelled = true;
          this.emit("cancelled", "cancelled");
        });
        this.stream.on("drain", () => {
          this.emit("drain");
        });
        if ("grpc.max_send_message_length" in options2) {
          this.maxSendMessageSize = options2["grpc.max_send_message_length"];
        }
        if ("grpc.max_receive_message_length" in options2) {
          this.maxReceiveMessageSize = options2["grpc.max_receive_message_length"];
        }
        clearTimeout(this.deadlineTimer);
      }
      checkCancelled() {
        if (this.stream.destroyed || this.stream.closed) {
          this.cancelled = true;
        }
        return this.cancelled;
      }
      sendMetadata(customMetadata) {
        if (this.checkCancelled()) {
          return;
        }
        if (this.metadataSent) {
          return;
        }
        this.metadataSent = true;
        const custom = customMetadata ? customMetadata.toHttp2Headers() : null;
        const headers = Object.assign({}, defaultResponseHeaders, custom);
        this.stream.respond(headers, defaultResponseOptions);
      }
      receiveMetadata(headers) {
        const metadata = metadata_1.Metadata.fromHttp2Headers(headers);
        const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);
        if (timeoutHeader.length > 0) {
          const match = timeoutHeader[0].toString().match(DEADLINE_REGEX);
          if (match === null) {
            const err = new Error("Invalid deadline");
            err.code = constants_1.Status.OUT_OF_RANGE;
            this.sendError(err);
            return;
          }
          const timeout = +match[1] * deadlineUnitsToMs[match[2]] | 0;
          const now = new Date();
          this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);
          this.deadlineTimer = setTimeout(handleExpiredDeadline, timeout, this);
          metadata.remove(GRPC_TIMEOUT_HEADER);
        }
        metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);
        metadata.remove(http2.constants.HTTP2_HEADER_TE);
        metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);
        metadata.remove("grpc-encoding");
        metadata.remove("grpc-accept-encoding");
        return metadata;
      }
      receiveUnaryMessage() {
        return new Promise((resolve2, reject) => {
          const stream = this.stream;
          const chunks = [];
          let totalLength = 0;
          stream.on("data", (data) => {
            chunks.push(data);
            totalLength += data.byteLength;
          });
          stream.once("end", async () => {
            try {
              const requestBytes = Buffer.concat(chunks, totalLength);
              if (this.maxReceiveMessageSize !== -1 && requestBytes.length > this.maxReceiveMessageSize) {
                this.sendError({
                  code: constants_1.Status.RESOURCE_EXHAUSTED,
                  details: `Received message larger than max (${requestBytes.length} vs. ${this.maxReceiveMessageSize})`
                });
                resolve2();
              }
              resolve2(this.deserializeMessage(requestBytes));
            } catch (err) {
              err.code = constants_1.Status.INTERNAL;
              this.sendError(err);
              resolve2();
            }
          });
        });
      }
      serializeMessage(value) {
        const messageBuffer = this.handler.serialize(value);
        const byteLength = messageBuffer.byteLength;
        const output = Buffer.allocUnsafe(byteLength + 5);
        output.writeUInt8(0, 0);
        output.writeUInt32BE(byteLength, 1);
        messageBuffer.copy(output, 5);
        return output;
      }
      deserializeMessage(bytes) {
        const receivedMessage = bytes.slice(5);
        return this.handler.deserialize(receivedMessage);
      }
      async sendUnaryMessage(err, value, metadata, flags) {
        if (this.checkCancelled()) {
          return;
        }
        if (!metadata) {
          metadata = new metadata_1.Metadata();
        }
        if (err) {
          if (!Object.prototype.hasOwnProperty.call(err, "metadata")) {
            err.metadata = metadata;
          }
          this.sendError(err);
          return;
        }
        try {
          const response = this.serializeMessage(value);
          this.write(response);
          this.sendStatus({ code: constants_1.Status.OK, details: "OK", metadata });
        } catch (err2) {
          err2.code = constants_1.Status.INTERNAL;
          this.sendError(err2);
        }
      }
      sendStatus(statusObj) {
        var _a;
        if (this.checkCancelled()) {
          return;
        }
        trace("Request to method " + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + " ended with status code: " + constants_1.Status[statusObj.code] + " details: " + statusObj.details);
        clearTimeout(this.deadlineTimer);
        if (!this.wantTrailers) {
          this.wantTrailers = true;
          this.stream.once("wantTrailers", () => {
            const trailersToSend = Object.assign({
              [GRPC_STATUS_HEADER]: statusObj.code,
              [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details)
            }, statusObj.metadata.toHttp2Headers());
            this.stream.sendTrailers(trailersToSend);
          });
          this.sendMetadata();
          this.stream.end();
        }
      }
      sendError(error2) {
        if (this.checkCancelled()) {
          return;
        }
        const status = {
          code: constants_1.Status.UNKNOWN,
          details: "message" in error2 ? error2.message : "Unknown Error",
          metadata: "metadata" in error2 && error2.metadata !== void 0 ? error2.metadata : new metadata_1.Metadata()
        };
        if ("code" in error2 && typeof error2.code === "number" && Number.isInteger(error2.code)) {
          status.code = error2.code;
          if ("details" in error2 && typeof error2.details === "string") {
            status.details = error2.details;
          }
        }
        this.sendStatus(status);
      }
      write(chunk) {
        if (this.checkCancelled()) {
          return;
        }
        if (this.maxSendMessageSize !== -1 && chunk.length > this.maxSendMessageSize) {
          this.sendError({
            code: constants_1.Status.RESOURCE_EXHAUSTED,
            details: `Sent message larger than max (${chunk.length} vs. ${this.maxSendMessageSize})`
          });
          return;
        }
        this.sendMetadata();
        return this.stream.write(chunk);
      }
      resume() {
        this.stream.resume();
      }
      setupSurfaceCall(call) {
        this.once("cancelled", (reason) => {
          call.cancelled = true;
          call.emit("cancelled", reason);
        });
      }
      setupReadable(readable) {
        const decoder = new stream_decoder_1.StreamDecoder();
        this.stream.on("data", async (data) => {
          const messages = decoder.write(data);
          for (const message of messages) {
            if (this.maxReceiveMessageSize !== -1 && message.length > this.maxReceiveMessageSize) {
              this.sendError({
                code: constants_1.Status.RESOURCE_EXHAUSTED,
                details: `Received message larger than max (${message.length} vs. ${this.maxReceiveMessageSize})`
              });
              return;
            }
            this.pushOrBufferMessage(readable, message);
          }
        });
        this.stream.once("end", () => {
          this.pushOrBufferMessage(readable, null);
        });
      }
      consumeUnpushedMessages(readable) {
        this.canPush = true;
        while (this.messagesToPush.length > 0) {
          const nextMessage = this.messagesToPush.shift();
          const canPush = readable.push(nextMessage);
          if (nextMessage === null || canPush === false) {
            this.canPush = false;
            break;
          }
        }
        return this.canPush;
      }
      pushOrBufferMessage(readable, messageBytes) {
        if (this.isPushPending) {
          this.bufferedMessages.push(messageBytes);
        } else {
          this.pushMessage(readable, messageBytes);
        }
      }
      async pushMessage(readable, messageBytes) {
        if (messageBytes === null) {
          if (this.canPush) {
            readable.push(null);
          } else {
            this.messagesToPush.push(null);
          }
          return;
        }
        this.isPushPending = true;
        try {
          const deserialized = await this.deserializeMessage(messageBytes);
          if (this.canPush) {
            if (!readable.push(deserialized)) {
              this.canPush = false;
              this.stream.pause();
            }
          } else {
            this.messagesToPush.push(deserialized);
          }
        } catch (error2) {
          this.bufferedMessages.length = 0;
          if (!("code" in error2 && typeof error2.code === "number" && Number.isInteger(error2.code) && error2.code >= constants_1.Status.OK && error2.code <= constants_1.Status.UNAUTHENTICATED)) {
            error2.code = constants_1.Status.INTERNAL;
          }
          readable.emit("error", error2);
        }
        this.isPushPending = false;
        if (this.bufferedMessages.length > 0) {
          this.pushMessage(readable, this.bufferedMessages.shift());
        }
      }
      getPeer() {
        const socket = this.stream.session.socket;
        if (socket.remoteAddress) {
          if (socket.remotePort) {
            return `${socket.remoteAddress}:${socket.remotePort}`;
          } else {
            return socket.remoteAddress;
          }
        } else {
          return "unknown";
        }
      }
      getDeadline() {
        return this.deadline;
      }
    };
    exports2.Http2ServerCallStream = Http2ServerCallStream;
    function handleExpiredDeadline(call) {
      const err = new Error("Deadline exceeded");
      err.code = constants_1.Status.DEADLINE_EXCEEDED;
      call.sendError(err);
      call.cancelled = true;
      call.emit("cancelled", "deadline");
    }
  }
});

// node_modules/@grpc/grpc-js/build/src/server.js
var require_server = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/server.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Server = void 0;
    var http2 = require("http2");
    var constants_1 = require_constants();
    var metadata_1 = require_metadata();
    var server_call_1 = require_server_call();
    var resolver_1 = require_resolver();
    var logging = require_logging();
    var subchannel_1 = require_subchannel();
    var uri_parser_1 = require_uri_parser();
    var TRACER_NAME = "server";
    function trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    function noop2() {
    }
    function getUnimplementedStatusResponse(methodName) {
      return {
        code: constants_1.Status.UNIMPLEMENTED,
        details: `The server does not implement the method ${methodName}`,
        metadata: new metadata_1.Metadata()
      };
    }
    function getDefaultHandler(handlerType, methodName) {
      const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);
      switch (handlerType) {
        case "unary":
          return (call, callback) => {
            callback(unimplementedStatusResponse, null);
          };
        case "clientStream":
          return (call, callback) => {
            callback(unimplementedStatusResponse, null);
          };
        case "serverStream":
          return (call) => {
            call.emit("error", unimplementedStatusResponse);
          };
        case "bidi":
          return (call) => {
            call.emit("error", unimplementedStatusResponse);
          };
        default:
          throw new Error(`Invalid handlerType ${handlerType}`);
      }
    }
    var Server = class {
      constructor(options2) {
        this.http2ServerList = [];
        this.handlers = new Map();
        this.sessions = new Set();
        this.started = false;
        this.options = options2 !== null && options2 !== void 0 ? options2 : {};
      }
      addProtoService() {
        throw new Error("Not implemented. Use addService() instead");
      }
      addService(service, implementation) {
        if (service === null || typeof service !== "object" || implementation === null || typeof implementation !== "object") {
          throw new Error("addService() requires two objects as arguments");
        }
        const serviceKeys = Object.keys(service);
        if (serviceKeys.length === 0) {
          throw new Error("Cannot add an empty service to a server");
        }
        serviceKeys.forEach((name2) => {
          const attrs = service[name2];
          let methodType;
          if (attrs.requestStream) {
            if (attrs.responseStream) {
              methodType = "bidi";
            } else {
              methodType = "clientStream";
            }
          } else {
            if (attrs.responseStream) {
              methodType = "serverStream";
            } else {
              methodType = "unary";
            }
          }
          let implFn = implementation[name2];
          let impl;
          if (implFn === void 0 && typeof attrs.originalName === "string") {
            implFn = implementation[attrs.originalName];
          }
          if (implFn !== void 0) {
            impl = implFn.bind(implementation);
          } else {
            impl = getDefaultHandler(methodType, name2);
          }
          const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);
          if (success === false) {
            throw new Error(`Method handler for ${attrs.path} already provided.`);
          }
        });
      }
      removeService(service) {
        if (service === null || typeof service !== "object") {
          throw new Error("removeService() requires object as argument");
        }
        const serviceKeys = Object.keys(service);
        serviceKeys.forEach((name2) => {
          const attrs = service[name2];
          this.unregister(attrs.path);
        });
      }
      bind(port, creds) {
        throw new Error("Not implemented. Use bindAsync() instead");
      }
      bindAsync(port, creds, callback) {
        if (this.started === true) {
          throw new Error("server is already started");
        }
        if (typeof port !== "string") {
          throw new TypeError("port must be a string");
        }
        if (creds === null || typeof creds !== "object") {
          throw new TypeError("creds must be an object");
        }
        if (typeof callback !== "function") {
          throw new TypeError("callback must be a function");
        }
        const initialPortUri = uri_parser_1.parseUri(port);
        if (initialPortUri === null) {
          throw new Error(`Could not parse port "${port}"`);
        }
        const portUri = resolver_1.mapUriDefaultScheme(initialPortUri);
        if (portUri === null) {
          throw new Error(`Could not get a default scheme for port "${port}"`);
        }
        const serverOptions = {
          maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER
        };
        if ("grpc-node.max_session_memory" in this.options) {
          serverOptions.maxSessionMemory = this.options["grpc-node.max_session_memory"];
        }
        if ("grpc.max_concurrent_streams" in this.options) {
          serverOptions.settings = {
            maxConcurrentStreams: this.options["grpc.max_concurrent_streams"]
          };
        }
        const setupServer = () => {
          let http2Server;
          if (creds._isSecure()) {
            const secureServerOptions = Object.assign(serverOptions, creds._getSettings());
            http2Server = http2.createSecureServer(secureServerOptions);
          } else {
            http2Server = http2.createServer(serverOptions);
          }
          http2Server.setTimeout(0, noop2);
          this._setupHandlers(http2Server);
          return http2Server;
        };
        const bindSpecificPort = (addressList, portNum, previousCount) => {
          if (addressList.length === 0) {
            return Promise.resolve({ port: portNum, count: previousCount });
          }
          return Promise.all(addressList.map((address) => {
            trace("Attempting to bind " + subchannel_1.subchannelAddressToString(address));
            let addr;
            if (subchannel_1.isTcpSubchannelAddress(address)) {
              addr = {
                host: address.host,
                port: portNum
              };
            } else {
              addr = address;
            }
            const http2Server = setupServer();
            return new Promise((resolve2, reject) => {
              function onError(err) {
                resolve2(err);
              }
              http2Server.once("error", onError);
              http2Server.listen(addr, () => {
                trace("Successfully bound " + subchannel_1.subchannelAddressToString(address));
                this.http2ServerList.push(http2Server);
                const boundAddress = http2Server.address();
                if (typeof boundAddress === "string") {
                  resolve2(portNum);
                } else {
                  resolve2(boundAddress.port);
                }
                http2Server.removeListener("error", onError);
              });
            });
          })).then((results) => {
            let count = 0;
            for (const result of results) {
              if (typeof result === "number") {
                count += 1;
                if (result !== portNum) {
                  throw new Error("Invalid state: multiple port numbers added from single address");
                }
              }
            }
            return {
              port: portNum,
              count: count + previousCount
            };
          });
        };
        const bindWildcardPort = (addressList) => {
          if (addressList.length === 0) {
            return Promise.resolve({ port: 0, count: 0 });
          }
          const address = addressList[0];
          const http2Server = setupServer();
          return new Promise((resolve2, reject) => {
            function onError(err) {
              resolve2(bindWildcardPort(addressList.slice(1)));
            }
            http2Server.once("error", onError);
            http2Server.listen(address, () => {
              this.http2ServerList.push(http2Server);
              resolve2(bindSpecificPort(addressList.slice(1), http2Server.address().port, 1));
              http2Server.removeListener("error", onError);
            });
          });
        };
        const resolverListener = {
          onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError) => {
            resolverListener.onSuccessfulResolution = () => {
            };
            if (addressList.length === 0) {
              callback(new Error(`No addresses resolved for port ${port}`), 0);
              return;
            }
            let bindResultPromise;
            if (subchannel_1.isTcpSubchannelAddress(addressList[0])) {
              if (addressList[0].port === 0) {
                bindResultPromise = bindWildcardPort(addressList);
              } else {
                bindResultPromise = bindSpecificPort(addressList, addressList[0].port, 0);
              }
            } else {
              bindResultPromise = bindSpecificPort(addressList, 1, 0);
            }
            bindResultPromise.then((bindResult) => {
              if (bindResult.count === 0) {
                const errorString = `No address added out of total ${addressList.length} resolved`;
                logging.log(constants_1.LogVerbosity.ERROR, errorString);
                callback(new Error(errorString), 0);
              } else {
                if (bindResult.count < addressList.length) {
                  logging.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);
                }
                callback(null, bindResult.port);
              }
            }, (error2) => {
              const errorString = `No address added out of total ${addressList.length} resolved`;
              logging.log(constants_1.LogVerbosity.ERROR, errorString);
              callback(new Error(errorString), 0);
            });
          },
          onError: (error2) => {
            callback(new Error(error2.details), 0);
          }
        };
        const resolver = resolver_1.createResolver(portUri, resolverListener, this.options);
        resolver.updateResolution();
      }
      forceShutdown() {
        for (const http2Server of this.http2ServerList) {
          if (http2Server.listening) {
            http2Server.close();
          }
        }
        this.started = false;
        this.sessions.forEach((session) => {
          session.destroy(http2.constants.NGHTTP2_CANCEL);
        });
        this.sessions.clear();
      }
      register(name2, handler2, serialize, deserialize, type) {
        if (this.handlers.has(name2)) {
          return false;
        }
        this.handlers.set(name2, {
          func: handler2,
          serialize,
          deserialize,
          type,
          path: name2
        });
        return true;
      }
      unregister(name2) {
        return this.handlers.delete(name2);
      }
      start() {
        if (this.http2ServerList.length === 0 || this.http2ServerList.every((http2Server) => http2Server.listening !== true)) {
          throw new Error("server must be bound in order to start");
        }
        if (this.started === true) {
          throw new Error("server is already started");
        }
        this.started = true;
      }
      tryShutdown(callback) {
        let pendingChecks = 0;
        function maybeCallback() {
          pendingChecks--;
          if (pendingChecks === 0) {
            callback();
          }
        }
        this.started = false;
        for (const http2Server of this.http2ServerList) {
          if (http2Server.listening) {
            pendingChecks++;
            http2Server.close(maybeCallback);
          }
        }
        this.sessions.forEach((session) => {
          if (!session.closed) {
            pendingChecks += 1;
            session.close(maybeCallback);
          }
        });
        if (pendingChecks === 0) {
          callback();
        }
      }
      addHttp2Port() {
        throw new Error("Not yet implemented");
      }
      _setupHandlers(http2Server) {
        if (http2Server === null) {
          return;
        }
        http2Server.on("stream", (stream, headers) => {
          const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];
          if (typeof contentType !== "string" || !contentType.startsWith("application/grpc")) {
            stream.respond({
              [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE
            }, { endStream: true });
            return;
          }
          try {
            const path = headers[http2.constants.HTTP2_HEADER_PATH];
            const serverAddress = http2Server.address();
            let serverAddressString = "null";
            if (serverAddress) {
              if (typeof serverAddress === "string") {
                serverAddressString = serverAddress;
              } else {
                serverAddressString = serverAddress.address + ":" + serverAddress.port;
              }
            }
            trace("Received call to method " + path + " at address " + serverAddressString);
            const handler2 = this.handlers.get(path);
            if (handler2 === void 0) {
              trace("No handler registered for method " + path + ". Sending UNIMPLEMENTED status.");
              throw getUnimplementedStatusResponse(path);
            }
            const call = new server_call_1.Http2ServerCallStream(stream, handler2, this.options);
            const metadata = call.receiveMetadata(headers);
            switch (handler2.type) {
              case "unary":
                handleUnary(call, handler2, metadata);
                break;
              case "clientStream":
                handleClientStreaming(call, handler2, metadata);
                break;
              case "serverStream":
                handleServerStreaming(call, handler2, metadata);
                break;
              case "bidi":
                handleBidiStreaming(call, handler2, metadata);
                break;
              default:
                throw new Error(`Unknown handler type: ${handler2.type}`);
            }
          } catch (err) {
            const call = new server_call_1.Http2ServerCallStream(stream, null, this.options);
            if (err.code === void 0) {
              err.code = constants_1.Status.INTERNAL;
            }
            call.sendError(err);
          }
        });
        http2Server.on("session", (session) => {
          if (!this.started) {
            session.destroy();
            return;
          }
          this.sessions.add(session);
          session.on("close", () => {
            this.sessions.delete(session);
          });
        });
      }
    };
    exports2.Server = Server;
    async function handleUnary(call, handler2, metadata) {
      const request = await call.receiveUnaryMessage();
      if (request === void 0 || call.cancelled) {
        return;
      }
      const emitter = new server_call_1.ServerUnaryCallImpl(call, metadata, request);
      handler2.func(emitter, (err, value, trailer, flags) => {
        call.sendUnaryMessage(err, value, trailer, flags);
      });
    }
    function handleClientStreaming(call, handler2, metadata) {
      const stream = new server_call_1.ServerReadableStreamImpl(call, metadata, handler2.deserialize);
      function respond2(err, value, trailer, flags) {
        stream.destroy();
        call.sendUnaryMessage(err, value, trailer, flags);
      }
      if (call.cancelled) {
        return;
      }
      stream.on("error", respond2);
      handler2.func(stream, respond2);
    }
    async function handleServerStreaming(call, handler2, metadata) {
      const request = await call.receiveUnaryMessage();
      if (request === void 0 || call.cancelled) {
        return;
      }
      const stream = new server_call_1.ServerWritableStreamImpl(call, metadata, handler2.serialize, request);
      handler2.func(stream);
    }
    function handleBidiStreaming(call, handler2, metadata) {
      const stream = new server_call_1.ServerDuplexStreamImpl(call, metadata, handler2.serialize, handler2.deserialize);
      if (call.cancelled) {
        return;
      }
      handler2.func(stream);
    }
  }
});

// node_modules/@grpc/grpc-js/build/src/server-credentials.js
var require_server_credentials = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/server-credentials.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ServerCredentials = void 0;
    var tls_helpers_1 = require_tls_helpers();
    var ServerCredentials = class {
      static createInsecure() {
        return new InsecureServerCredentials();
      }
      static createSsl(rootCerts, keyCertPairs, checkClientCertificate = false) {
        if (rootCerts !== null && !Buffer.isBuffer(rootCerts)) {
          throw new TypeError("rootCerts must be null or a Buffer");
        }
        if (!Array.isArray(keyCertPairs)) {
          throw new TypeError("keyCertPairs must be an array");
        }
        if (typeof checkClientCertificate !== "boolean") {
          throw new TypeError("checkClientCertificate must be a boolean");
        }
        const cert = [];
        const key = [];
        for (let i = 0; i < keyCertPairs.length; i++) {
          const pair = keyCertPairs[i];
          if (pair === null || typeof pair !== "object") {
            throw new TypeError(`keyCertPair[${i}] must be an object`);
          }
          if (!Buffer.isBuffer(pair.private_key)) {
            throw new TypeError(`keyCertPair[${i}].private_key must be a Buffer`);
          }
          if (!Buffer.isBuffer(pair.cert_chain)) {
            throw new TypeError(`keyCertPair[${i}].cert_chain must be a Buffer`);
          }
          cert.push(pair.cert_chain);
          key.push(pair.private_key);
        }
        return new SecureServerCredentials({
          ca: rootCerts || tls_helpers_1.getDefaultRootsData() || void 0,
          cert,
          key,
          requestCert: checkClientCertificate,
          ciphers: tls_helpers_1.CIPHER_SUITES
        });
      }
    };
    exports2.ServerCredentials = ServerCredentials;
    var InsecureServerCredentials = class extends ServerCredentials {
      _isSecure() {
        return false;
      }
      _getSettings() {
        return null;
      }
    };
    var SecureServerCredentials = class extends ServerCredentials {
      constructor(options2) {
        super();
        this.options = options2;
      }
      _isSecure() {
        return true;
      }
      _getSettings() {
        return this.options;
      }
    };
  }
});

// node_modules/@grpc/grpc-js/build/src/status-builder.js
var require_status_builder = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/status-builder.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StatusBuilder = void 0;
    var StatusBuilder = class {
      constructor() {
        this.code = null;
        this.details = null;
        this.metadata = null;
      }
      withCode(code) {
        this.code = code;
        return this;
      }
      withDetails(details) {
        this.details = details;
        return this;
      }
      withMetadata(metadata) {
        this.metadata = metadata;
        return this;
      }
      build() {
        const status = {};
        if (this.code !== null) {
          status.code = this.code;
        }
        if (this.details !== null) {
          status.details = this.details;
        }
        if (this.metadata !== null) {
          status.metadata = this.metadata;
        }
        return status;
      }
    };
    exports2.StatusBuilder = StatusBuilder;
  }
});

// node_modules/@grpc/grpc-js/build/src/experimental.js
var require_experimental = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/experimental.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var logging_1 = require_logging();
    Object.defineProperty(exports2, "trace", { enumerable: true, get: function() {
      return logging_1.trace;
    } });
    var resolver_1 = require_resolver();
    Object.defineProperty(exports2, "registerResolver", { enumerable: true, get: function() {
      return resolver_1.registerResolver;
    } });
    var uri_parser_1 = require_uri_parser();
    Object.defineProperty(exports2, "uriToString", { enumerable: true, get: function() {
      return uri_parser_1.uriToString;
    } });
    var backoff_timeout_1 = require_backoff_timeout();
    Object.defineProperty(exports2, "BackoffTimeout", { enumerable: true, get: function() {
      return backoff_timeout_1.BackoffTimeout;
    } });
    var load_balancer_1 = require_load_balancer();
    Object.defineProperty(exports2, "registerLoadBalancerType", { enumerable: true, get: function() {
      return load_balancer_1.registerLoadBalancerType;
    } });
    Object.defineProperty(exports2, "getFirstUsableConfig", { enumerable: true, get: function() {
      return load_balancer_1.getFirstUsableConfig;
    } });
    Object.defineProperty(exports2, "validateLoadBalancingConfig", { enumerable: true, get: function() {
      return load_balancer_1.validateLoadBalancingConfig;
    } });
    var subchannel_1 = require_subchannel();
    Object.defineProperty(exports2, "subchannelAddressToString", { enumerable: true, get: function() {
      return subchannel_1.subchannelAddressToString;
    } });
    var load_balancer_child_handler_1 = require_load_balancer_child_handler();
    Object.defineProperty(exports2, "ChildLoadBalancerHandler", { enumerable: true, get: function() {
      return load_balancer_child_handler_1.ChildLoadBalancerHandler;
    } });
    var picker_1 = require_picker();
    Object.defineProperty(exports2, "UnavailablePicker", { enumerable: true, get: function() {
      return picker_1.UnavailablePicker;
    } });
    Object.defineProperty(exports2, "QueuePicker", { enumerable: true, get: function() {
      return picker_1.QueuePicker;
    } });
    Object.defineProperty(exports2, "PickResultType", { enumerable: true, get: function() {
      return picker_1.PickResultType;
    } });
    var filter_1 = require_filter();
    Object.defineProperty(exports2, "BaseFilter", { enumerable: true, get: function() {
      return filter_1.BaseFilter;
    } });
    var filter_stack_1 = require_filter_stack();
    Object.defineProperty(exports2, "FilterStackFactory", { enumerable: true, get: function() {
      return filter_stack_1.FilterStackFactory;
    } });
  }
});

// node_modules/@grpc/grpc-js/build/src/index.js
var require_src = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/index.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.experimental = exports2.StatusBuilder = exports2.getClientChannel = exports2.ServerCredentials = exports2.Server = exports2.setLogVerbosity = exports2.setLogger = exports2.load = exports2.loadObject = exports2.CallCredentials = exports2.ChannelCredentials = exports2.waitForClientReady = exports2.closeClient = exports2.Channel = exports2.makeGenericClientConstructor = exports2.makeClientConstructor = exports2.loadPackageDefinition = exports2.Client = exports2.propagate = exports2.connectivityState = exports2.status = exports2.logVerbosity = exports2.Metadata = exports2.credentials = void 0;
    var call_credentials_1 = require_call_credentials();
    Object.defineProperty(exports2, "CallCredentials", { enumerable: true, get: function() {
      return call_credentials_1.CallCredentials;
    } });
    var channel_1 = require_channel();
    Object.defineProperty(exports2, "connectivityState", { enumerable: true, get: function() {
      return channel_1.ConnectivityState;
    } });
    Object.defineProperty(exports2, "Channel", { enumerable: true, get: function() {
      return channel_1.ChannelImplementation;
    } });
    var channel_credentials_1 = require_channel_credentials();
    Object.defineProperty(exports2, "ChannelCredentials", { enumerable: true, get: function() {
      return channel_credentials_1.ChannelCredentials;
    } });
    var client_1 = require_client();
    Object.defineProperty(exports2, "Client", { enumerable: true, get: function() {
      return client_1.Client;
    } });
    var constants_1 = require_constants();
    Object.defineProperty(exports2, "logVerbosity", { enumerable: true, get: function() {
      return constants_1.LogVerbosity;
    } });
    Object.defineProperty(exports2, "status", { enumerable: true, get: function() {
      return constants_1.Status;
    } });
    Object.defineProperty(exports2, "propagate", { enumerable: true, get: function() {
      return constants_1.Propagate;
    } });
    var logging = require_logging();
    var make_client_1 = require_make_client();
    Object.defineProperty(exports2, "loadPackageDefinition", { enumerable: true, get: function() {
      return make_client_1.loadPackageDefinition;
    } });
    Object.defineProperty(exports2, "makeClientConstructor", { enumerable: true, get: function() {
      return make_client_1.makeClientConstructor;
    } });
    Object.defineProperty(exports2, "makeGenericClientConstructor", { enumerable: true, get: function() {
      return make_client_1.makeClientConstructor;
    } });
    var metadata_1 = require_metadata();
    Object.defineProperty(exports2, "Metadata", { enumerable: true, get: function() {
      return metadata_1.Metadata;
    } });
    var server_1 = require_server();
    Object.defineProperty(exports2, "Server", { enumerable: true, get: function() {
      return server_1.Server;
    } });
    var server_credentials_1 = require_server_credentials();
    Object.defineProperty(exports2, "ServerCredentials", { enumerable: true, get: function() {
      return server_credentials_1.ServerCredentials;
    } });
    var status_builder_1 = require_status_builder();
    Object.defineProperty(exports2, "StatusBuilder", { enumerable: true, get: function() {
      return status_builder_1.StatusBuilder;
    } });
    exports2.credentials = {
      combineChannelCredentials: (channelCredentials, ...callCredentials) => {
        return callCredentials.reduce((acc, other) => acc.compose(other), channelCredentials);
      },
      combineCallCredentials: (first, ...additional) => {
        return additional.reduce((acc, other) => acc.compose(other), first);
      },
      createInsecure: channel_credentials_1.ChannelCredentials.createInsecure,
      createSsl: channel_credentials_1.ChannelCredentials.createSsl,
      createFromMetadataGenerator: call_credentials_1.CallCredentials.createFromMetadataGenerator,
      createFromGoogleCredential: call_credentials_1.CallCredentials.createFromGoogleCredential,
      createEmpty: call_credentials_1.CallCredentials.createEmpty
    };
    exports2.closeClient = (client) => client.close();
    exports2.waitForClientReady = (client, deadline, callback) => client.waitForReady(deadline, callback);
    exports2.loadObject = (value, options2) => {
      throw new Error("Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead");
    };
    exports2.load = (filename, format2, options2) => {
      throw new Error("Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead");
    };
    exports2.setLogger = (logger2) => {
      logging.setLogger(logger2);
    };
    exports2.setLogVerbosity = (verbosity) => {
      logging.setLoggerVerbosity(verbosity);
    };
    exports2.getClientChannel = (client) => {
      return client_1.Client.prototype.getChannel.call(client);
    };
    var client_interceptors_1 = require_client_interceptors();
    Object.defineProperty(exports2, "ListenerBuilder", { enumerable: true, get: function() {
      return client_interceptors_1.ListenerBuilder;
    } });
    Object.defineProperty(exports2, "RequesterBuilder", { enumerable: true, get: function() {
      return client_interceptors_1.RequesterBuilder;
    } });
    Object.defineProperty(exports2, "InterceptingCall", { enumerable: true, get: function() {
      return client_interceptors_1.InterceptingCall;
    } });
    Object.defineProperty(exports2, "InterceptorConfigurationError", { enumerable: true, get: function() {
      return client_interceptors_1.InterceptorConfigurationError;
    } });
    var experimental = require_experimental();
    exports2.experimental = experimental;
    var resolver = require_resolver();
    var load_balancer = require_load_balancer();
    var clientVersion = require_package().version;
    (() => {
      logging.trace(constants_1.LogVerbosity.DEBUG, "index", "Loading @grpc/grpc-js version " + clientVersion);
      resolver.registerAll();
      load_balancer.registerAll();
    })();
  }
});

// node_modules/lodash.camelcase/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.camelcase/index.js"(exports2, module2) {
    init_shims();
    var INFINITY = 1 / 0;
    var symbolTag = "[object Symbol]";
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
    var rsComboSymbolsRange = "\\u20d0-\\u20f0";
    var rsDingbatRange = "\\u2700-\\u27bf";
    var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
    var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
    var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
    var rsPunctuationRange = "\\u2000-\\u206f";
    var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
    var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]";
    var rsAstral = "[" + rsAstralRange + "]";
    var rsBreak = "[" + rsBreakRange + "]";
    var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
    var rsDigits = "\\d+";
    var rsDingbat = "[" + rsDingbatRange + "]";
    var rsLower = "[" + rsLowerRange + "]";
    var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsUpper = "[" + rsUpperRange + "]";
    var rsZWJ = "\\u200d";
    var rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")";
    var rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")";
    var rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
    var rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
    var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")",
      rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
      rsUpper + "+" + rsOptUpperContr,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var deburredLetters = {
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "ss"
    };
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index2 = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index2];
      }
      while (++index2 < length) {
        accumulator = iteratee(accumulator, array[index2], index2, array);
      }
      return accumulator;
    }
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? void 0 : object[key];
      };
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var Symbol2 = root.Symbol;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseSlice(array, start2, end) {
      var index2 = -1, length = array.length;
      if (start2 < 0) {
        start2 = -start2 > length ? 0 : length + start2;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start2 > end ? 0 : end - start2 >>> 0;
      start2 >>>= 0;
      var result = Array(length);
      while (++index2 < length) {
        result[index2] = array[index2 + start2];
      }
      return result;
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function castSlice(array, start2, end) {
      var length = array.length;
      end = end === void 0 ? length : end;
      return !start2 && end >= length ? array : baseSlice(array, start2, end);
    }
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);
        var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
        var chr = strSymbols ? strSymbols[0] : string.charAt(0);
        var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
      };
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    var camelCase = createCompounder(function(result, word, index2) {
      word = word.toLowerCase();
      return result + (index2 ? capitalize(word) : word);
    });
    function capitalize(string) {
      return upperFirst(toString(string).toLowerCase());
    }
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    var upperFirst = createCaseFirst("toUpperCase");
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? void 0 : pattern;
      if (pattern === void 0) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }
    module2.exports = camelCase;
  }
});

// node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index2 = 2, pending = true;
      while (index2 < arguments.length)
        params[offset++] = arguments[index2++];
      return new Promise(function executor(resolve2, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve2.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "node_modules/@protobufjs/base64/index.js"(exports2) {
    init_shims();
    "use strict";
    var base642 = exports2;
    base642.length = function length(string) {
      var p = string.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
      return Math.ceil(string.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base642.encode = function encode2(buffer, start2, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start2 < end) {
        var b = buffer[start2++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base642.decode = function decode(string, buffer, offset) {
      var start2 = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string.length; ) {
        var c = string.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start2;
    };
    base642.test = function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    };
  }
});

// node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "node_modules/@protobufjs/float/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = factory2(factory2);
    function factory2(exports3) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
          }
          function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
          }
          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
          }
          function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
          }
          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
          }
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
          }
          function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
          }
          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
          }
          function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
          }
          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0) {
              writeUint(0, buf, pos + off0);
              writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf, pos + off0);
              writeUint(2146959360, buf, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf, pos + off0);
              writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf, pos + off0);
                writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
              }
            }
          }
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports3;
    }
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
  }
});

// node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "node_modules/@protobufjs/inquire/index.js"(exports, module) {
    init_shims();
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});

// node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "node_modules/@protobufjs/utf8/index.js"(exports2) {
    init_shims();
    "use strict";
    var utf8 = exports2;
    utf8.length = function utf8_length(string) {
      var len = 0, c = 0;
      for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer, start2, end) {
      var len = end - start2;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start2 < end) {
        t = buffer[start2++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer[start2++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer[start2++] & 63) << 12 | (buffer[start2++] & 63) << 6 | buffer[start2++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer[start2++] & 63) << 6 | buffer[start2++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function utf8_write(string, buffer, offset) {
      var start2 = offset, c1, c2;
      for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
          buffer[offset++] = c1;
        } else if (c1 < 2048) {
          buffer[offset++] = c1 >> 6 | 192;
          buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer[offset++] = c1 >> 18 | 240;
          buffer[offset++] = c1 >> 12 & 63 | 128;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        } else {
          buffer[offset++] = c1 >> 12 | 224;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start2;
    };
  }
});

// node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = pool;
    function pool(alloc, slice, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
  }
});

// node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign = value < 0;
      if (sign)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash2) {
      if (hash2 === zeroHash)
        return zero;
      return new LongBits((charCodeAt.call(hash2, 0) | charCodeAt.call(hash2, 1) << 8 | charCodeAt.call(hash2, 2) << 16 | charCodeAt.call(hash2, 3) << 24) >>> 0, (charCodeAt.call(hash2, 4) | charCodeAt.call(hash2, 5) << 8 | charCodeAt.call(hash2, 6) << 16 | charCodeAt.call(hash2, 7) << 24) >>> 0);
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "node_modules/protobufjs/src/util/minimal.js"(exports2) {
    init_shims();
    "use strict";
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : [];
    util.emptyObject = Object.freeze ? Object.freeze({}) : {};
    util.isInteger = Number.isInteger || function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString2(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject2(value) {
      return value && typeof value === "object";
    };
    util.isset = util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer2 = util.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : null;
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = util.global.dcodeIO && util.global.dcodeIO.Long || util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash2, unsigned) {
      var bits = util.LongBits.fromHash(hash2);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge(dst, src2, ifNotSet) {
      for (var keys = Object.keys(src2), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src2[keys[i]];
      return dst;
    }
    util.merge = merge;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name2) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
      Object.defineProperty(CustomError.prototype, "name", { get: function() {
        return name2;
      } });
      CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
      };
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name2) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name2)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer2 = util.Buffer;
      if (!Buffer2) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  }
});

// node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "node_modules/protobufjs/src/writer.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base642 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop2() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop2, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create();
    Writer.alloc = function alloc(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer.alloc(len = base642.length(value));
        base642.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop2, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop2, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create();
      BufferWriter._configure();
    };
  }
});

// node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else
          for (var i = 0; i < val.length; )
            buf[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else if (buf.utf8Write)
        buf.utf8Write(val, pos);
      else
        buf.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "node_modules/protobufjs/src/reader.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    } : function create_array2(buffer) {
      if (Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    };
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer2) {
          return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
        })(buffer);
      } : create_array;
    };
    Reader.create = create();
    Reader.prototype._slice = util.Array.prototype.subarray || util.Array.prototype.slice;
    Reader.prototype.uint32 = function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length = this.uint32(), start2 = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf))
        return this.buf.slice(start2, end);
      return start2 === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start2, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : "toNumber";
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer) {
      Reader.call(this, buffer);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(method, requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(), function rpcCallback(err, response) {
          if (err) {
            self2.emit("error", err, method);
            return callback(err);
          }
          if (response === null) {
            self2.end(true);
            return void 0;
          }
          if (!(response instanceof responseCtor)) {
            try {
              response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
            } catch (err2) {
              self2.emit("error", err2, method);
              return callback(err2);
            }
          }
          self2.emit("data", response, method);
          return callback(null, response);
        });
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "node_modules/protobufjs/src/rpc.js"(exports2) {
    init_shims();
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "node_modules/protobufjs/src/roots.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = {};
  }
});

// node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "node_modules/protobufjs/src/index-minimal.js"(exports2) {
    init_shims();
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  }
});

// node_modules/@protobufjs/codegen/index.js
var require_codegen = __commonJS({
  "node_modules/@protobufjs/codegen/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = codegen;
    function codegen(functionParams, functionName) {
      if (typeof functionParams === "string") {
        functionName = functionParams;
        functionParams = void 0;
      }
      var body = [];
      function Codegen(formatStringOrScope) {
        if (typeof formatStringOrScope !== "string") {
          var source = toString();
          if (codegen.verbose)
            console.log("codegen: " + source);
          source = "return " + source;
          if (formatStringOrScope) {
            var scopeKeys = Object.keys(formatStringOrScope), scopeParams = new Array(scopeKeys.length + 1), scopeValues = new Array(scopeKeys.length), scopeOffset = 0;
            while (scopeOffset < scopeKeys.length) {
              scopeParams[scopeOffset] = scopeKeys[scopeOffset];
              scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
            }
            scopeParams[scopeOffset] = source;
            return Function.apply(null, scopeParams).apply(null, scopeValues);
          }
          return Function(source)();
        }
        var formatParams = new Array(arguments.length - 1), formatOffset = 0;
        while (formatOffset < formatParams.length)
          formatParams[formatOffset] = arguments[++formatOffset];
        formatOffset = 0;
        formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {
          var value = formatParams[formatOffset++];
          switch ($1) {
            case "d":
            case "f":
              return String(Number(value));
            case "i":
              return String(Math.floor(value));
            case "j":
              return JSON.stringify(value);
            case "s":
              return String(value);
          }
          return "%";
        });
        if (formatOffset !== formatParams.length)
          throw Error("parameter count mismatch");
        body.push(formatStringOrScope);
        return Codegen;
      }
      function toString(functionNameOverride) {
        return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + "){\n  " + body.join("\n  ") + "\n}";
      }
      Codegen.toString = toString;
      return Codegen;
    }
    codegen.verbose = false;
  }
});

// node_modules/@protobufjs/fetch/index.js
var require_fetch = __commonJS({
  "node_modules/@protobufjs/fetch/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = fetch2;
    var asPromise = require_aspromise();
    var inquire2 = require_inquire();
    var fs = inquire2("fs");
    function fetch2(filename, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      } else if (!options2)
        options2 = {};
      if (!callback)
        return asPromise(fetch2, this, filename, options2);
      if (!options2.xhr && fs && fs.readFile)
        return fs.readFile(filename, function fetchReadFileCallback(err, contents) {
          return err && typeof XMLHttpRequest !== "undefined" ? fetch2.xhr(filename, options2, callback) : err ? callback(err) : callback(null, options2.binary ? contents : contents.toString("utf8"));
        });
      return fetch2.xhr(filename, options2, callback);
    }
    fetch2.xhr = function fetch_xhr(filename, options2, callback) {
      var xhr = new XMLHttpRequest();
      xhr.onreadystatechange = function fetchOnReadyStateChange() {
        if (xhr.readyState !== 4)
          return void 0;
        if (xhr.status !== 0 && xhr.status !== 200)
          return callback(Error("status " + xhr.status));
        if (options2.binary) {
          var buffer = xhr.response;
          if (!buffer) {
            buffer = [];
            for (var i = 0; i < xhr.responseText.length; ++i)
              buffer.push(xhr.responseText.charCodeAt(i) & 255);
          }
          return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer) : buffer);
        }
        return callback(null, xhr.responseText);
      };
      if (options2.binary) {
        if ("overrideMimeType" in xhr)
          xhr.overrideMimeType("text/plain; charset=x-user-defined");
        xhr.responseType = "arraybuffer";
      }
      xhr.open("GET", filename);
      xhr.send();
    };
  }
});

// node_modules/@protobufjs/path/index.js
var require_path = __commonJS({
  "node_modules/@protobufjs/path/index.js"(exports2) {
    init_shims();
    "use strict";
    var path = exports2;
    var isAbsolute = path.isAbsolute = function isAbsolute2(path2) {
      return /^(?:\/|\w+:)/.test(path2);
    };
    var normalize2 = path.normalize = function normalize3(path2) {
      path2 = path2.replace(/\\/g, "/").replace(/\/{2,}/g, "/");
      var parts = path2.split("/"), absolute2 = isAbsolute(path2), prefix = "";
      if (absolute2)
        prefix = parts.shift() + "/";
      for (var i = 0; i < parts.length; ) {
        if (parts[i] === "..") {
          if (i > 0 && parts[i - 1] !== "..")
            parts.splice(--i, 2);
          else if (absolute2)
            parts.splice(i, 1);
          else
            ++i;
        } else if (parts[i] === ".")
          parts.splice(i, 1);
        else
          ++i;
      }
      return prefix + parts.join("/");
    };
    path.resolve = function resolve2(originPath, includePath, alreadyNormalized) {
      if (!alreadyNormalized)
        includePath = normalize2(includePath);
      if (isAbsolute(includePath))
        return includePath;
      if (!alreadyNormalized)
        originPath = normalize2(originPath);
      return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize2(originPath + "/" + includePath) : includePath;
    };
  }
});

// node_modules/protobufjs/src/types.js
var require_types = __commonJS({
  "node_modules/protobufjs/src/types.js"(exports2) {
    init_shims();
    "use strict";
    var types2 = exports2;
    var util = require_util();
    var s2 = [
      "double",
      "float",
      "int32",
      "uint32",
      "sint32",
      "fixed32",
      "sfixed32",
      "int64",
      "uint64",
      "sint64",
      "fixed64",
      "sfixed64",
      "bool",
      "string",
      "bytes"
    ];
    function bake(values, offset) {
      var i = 0, o = {};
      offset |= 0;
      while (i < values.length)
        o[s2[i + offset]] = values[i++];
      return o;
    }
    types2.basic = bake([
      1,
      5,
      0,
      0,
      0,
      5,
      5,
      0,
      0,
      0,
      1,
      1,
      0,
      2,
      2
    ]);
    types2.defaults = bake([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      false,
      "",
      util.emptyArray,
      null
    ]);
    types2.long = bake([
      0,
      0,
      0,
      1,
      1
    ], 7);
    types2.mapKey = bake([
      0,
      0,
      0,
      5,
      5,
      0,
      0,
      0,
      1,
      1,
      0,
      2
    ], 2);
    types2.packed = bake([
      1,
      5,
      0,
      0,
      0,
      5,
      5,
      0,
      0,
      0,
      1,
      1,
      0
    ]);
  }
});

// node_modules/protobufjs/src/field.js
var require_field = __commonJS({
  "node_modules/protobufjs/src/field.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = Field;
    var ReflectionObject = require_object();
    ((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";
    var Enum = require_enum();
    var types2 = require_types();
    var util = require_util();
    var Type;
    var ruleRe = /^required|optional|repeated$/;
    Field.fromJSON = function fromJSON(name2, json) {
      return new Field(name2, json.id, json.type, json.rule, json.extend, json.options, json.comment);
    };
    function Field(name2, id, type, rule, extend, options2, comment) {
      if (util.isObject(rule)) {
        comment = extend;
        options2 = rule;
        rule = extend = void 0;
      } else if (util.isObject(extend)) {
        comment = options2;
        options2 = extend;
        extend = void 0;
      }
      ReflectionObject.call(this, name2, options2);
      if (!util.isInteger(id) || id < 0)
        throw TypeError("id must be a non-negative integer");
      if (!util.isString(type))
        throw TypeError("type must be a string");
      if (rule !== void 0 && !ruleRe.test(rule = rule.toString().toLowerCase()))
        throw TypeError("rule must be a string rule");
      if (extend !== void 0 && !util.isString(extend))
        throw TypeError("extend must be a string");
      if (rule === "proto3_optional") {
        rule = "optional";
      }
      this.rule = rule && rule !== "optional" ? rule : void 0;
      this.type = type;
      this.id = id;
      this.extend = extend || void 0;
      this.required = rule === "required";
      this.optional = !this.required;
      this.repeated = rule === "repeated";
      this.map = false;
      this.message = null;
      this.partOf = null;
      this.typeDefault = null;
      this.defaultValue = null;
      this.long = util.Long ? types2.long[type] !== void 0 : false;
      this.bytes = type === "bytes";
      this.resolvedType = null;
      this.extensionField = null;
      this.declaringField = null;
      this._packed = null;
      this.comment = comment;
    }
    Object.defineProperty(Field.prototype, "packed", {
      get: function() {
        if (this._packed === null)
          this._packed = this.getOption("packed") !== false;
        return this._packed;
      }
    });
    Field.prototype.setOption = function setOption(name2, value, ifNotSet) {
      if (name2 === "packed")
        this._packed = null;
      return ReflectionObject.prototype.setOption.call(this, name2, value, ifNotSet);
    };
    Field.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "rule",
        this.rule !== "optional" && this.rule || void 0,
        "type",
        this.type,
        "id",
        this.id,
        "extend",
        this.extend,
        "options",
        this.options,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    Field.prototype.resolve = function resolve2() {
      if (this.resolved)
        return this;
      if ((this.typeDefault = types2.defaults[this.type]) === void 0) {
        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
        if (this.resolvedType instanceof Type)
          this.typeDefault = null;
        else
          this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]];
      }
      if (this.options && this.options["default"] != null) {
        this.typeDefault = this.options["default"];
        if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string")
          this.typeDefault = this.resolvedType.values[this.typeDefault];
      }
      if (this.options) {
        if (this.options.packed === true || this.options.packed !== void 0 && this.resolvedType && !(this.resolvedType instanceof Enum))
          delete this.options.packed;
        if (!Object.keys(this.options).length)
          this.options = void 0;
      }
      if (this.long) {
        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");
        if (Object.freeze)
          Object.freeze(this.typeDefault);
      } else if (this.bytes && typeof this.typeDefault === "string") {
        var buf;
        if (util.base64.test(this.typeDefault))
          util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);
        else
          util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);
        this.typeDefault = buf;
      }
      if (this.map)
        this.defaultValue = util.emptyObject;
      else if (this.repeated)
        this.defaultValue = util.emptyArray;
      else
        this.defaultValue = this.typeDefault;
      if (this.parent instanceof Type)
        this.parent.ctor.prototype[this.name] = this.defaultValue;
      return ReflectionObject.prototype.resolve.call(this);
    };
    Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {
      if (typeof fieldType === "function")
        fieldType = util.decorateType(fieldType).name;
      else if (fieldType && typeof fieldType === "object")
        fieldType = util.decorateEnum(fieldType).name;
      return function fieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor).add(new Field(fieldName, fieldId, fieldType, fieldRule, { "default": defaultValue }));
      };
    };
    Field._configure = function configure(Type_) {
      Type = Type_;
    };
  }
});

// node_modules/protobufjs/src/oneof.js
var require_oneof = __commonJS({
  "node_modules/protobufjs/src/oneof.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = OneOf;
    var ReflectionObject = require_object();
    ((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";
    var Field = require_field();
    var util = require_util();
    function OneOf(name2, fieldNames, options2, comment) {
      if (!Array.isArray(fieldNames)) {
        options2 = fieldNames;
        fieldNames = void 0;
      }
      ReflectionObject.call(this, name2, options2);
      if (!(fieldNames === void 0 || Array.isArray(fieldNames)))
        throw TypeError("fieldNames must be an Array");
      this.oneof = fieldNames || [];
      this.fieldsArray = [];
      this.comment = comment;
    }
    OneOf.fromJSON = function fromJSON(name2, json) {
      return new OneOf(name2, json.oneof, json.options, json.comment);
    };
    OneOf.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "options",
        this.options,
        "oneof",
        this.oneof,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    function addFieldsToParent(oneof) {
      if (oneof.parent) {
        for (var i = 0; i < oneof.fieldsArray.length; ++i)
          if (!oneof.fieldsArray[i].parent)
            oneof.parent.add(oneof.fieldsArray[i]);
      }
    }
    OneOf.prototype.add = function add(field) {
      if (!(field instanceof Field))
        throw TypeError("field must be a Field");
      if (field.parent && field.parent !== this.parent)
        field.parent.remove(field);
      this.oneof.push(field.name);
      this.fieldsArray.push(field);
      field.partOf = this;
      addFieldsToParent(this);
      return this;
    };
    OneOf.prototype.remove = function remove2(field) {
      if (!(field instanceof Field))
        throw TypeError("field must be a Field");
      var index2 = this.fieldsArray.indexOf(field);
      if (index2 < 0)
        throw Error(field + " is not a member of " + this);
      this.fieldsArray.splice(index2, 1);
      index2 = this.oneof.indexOf(field.name);
      if (index2 > -1)
        this.oneof.splice(index2, 1);
      field.partOf = null;
      return this;
    };
    OneOf.prototype.onAdd = function onAdd(parent2) {
      ReflectionObject.prototype.onAdd.call(this, parent2);
      var self2 = this;
      for (var i = 0; i < this.oneof.length; ++i) {
        var field = parent2.get(this.oneof[i]);
        if (field && !field.partOf) {
          field.partOf = self2;
          self2.fieldsArray.push(field);
        }
      }
      addFieldsToParent(this);
    };
    OneOf.prototype.onRemove = function onRemove(parent2) {
      for (var i = 0, field; i < this.fieldsArray.length; ++i)
        if ((field = this.fieldsArray[i]).parent)
          field.parent.remove(field);
      ReflectionObject.prototype.onRemove.call(this, parent2);
    };
    OneOf.d = function decorateOneOf() {
      var fieldNames = new Array(arguments.length), index2 = 0;
      while (index2 < arguments.length)
        fieldNames[index2] = arguments[index2++];
      return function oneOfDecorator(prototype, oneofName) {
        util.decorateType(prototype.constructor).add(new OneOf(oneofName, fieldNames));
        Object.defineProperty(prototype, oneofName, {
          get: util.oneOfGetter(fieldNames),
          set: util.oneOfSetter(fieldNames)
        });
      };
    };
  }
});

// node_modules/protobufjs/src/namespace.js
var require_namespace = __commonJS({
  "node_modules/protobufjs/src/namespace.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = Namespace;
    var ReflectionObject = require_object();
    ((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";
    var Field = require_field();
    var OneOf = require_oneof();
    var util = require_util();
    var Type;
    var Service;
    var Enum;
    Namespace.fromJSON = function fromJSON(name2, json) {
      return new Namespace(name2, json.options).addJSON(json.nested);
    };
    function arrayToJSON(array, toJSONOptions) {
      if (!(array && array.length))
        return void 0;
      var obj = {};
      for (var i = 0; i < array.length; ++i)
        obj[array[i].name] = array[i].toJSON(toJSONOptions);
      return obj;
    }
    Namespace.arrayToJSON = arrayToJSON;
    Namespace.isReservedId = function isReservedId(reserved2, id) {
      if (reserved2) {
        for (var i = 0; i < reserved2.length; ++i)
          if (typeof reserved2[i] !== "string" && reserved2[i][0] <= id && reserved2[i][1] > id)
            return true;
      }
      return false;
    };
    Namespace.isReservedName = function isReservedName(reserved2, name2) {
      if (reserved2) {
        for (var i = 0; i < reserved2.length; ++i)
          if (reserved2[i] === name2)
            return true;
      }
      return false;
    };
    function Namespace(name2, options2) {
      ReflectionObject.call(this, name2, options2);
      this.nested = void 0;
      this._nestedArray = null;
    }
    function clearCache(namespace) {
      namespace._nestedArray = null;
      return namespace;
    }
    Object.defineProperty(Namespace.prototype, "nestedArray", {
      get: function() {
        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));
      }
    });
    Namespace.prototype.toJSON = function toJSON(toJSONOptions) {
      return util.toObject([
        "options",
        this.options,
        "nested",
        arrayToJSON(this.nestedArray, toJSONOptions)
      ]);
    };
    Namespace.prototype.addJSON = function addJSON(nestedJson) {
      var ns = this;
      if (nestedJson) {
        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {
          nested = nestedJson[names[i]];
          ns.add((nested.fields !== void 0 ? Type.fromJSON : nested.values !== void 0 ? Enum.fromJSON : nested.methods !== void 0 ? Service.fromJSON : nested.id !== void 0 ? Field.fromJSON : Namespace.fromJSON)(names[i], nested));
        }
      }
      return this;
    };
    Namespace.prototype.get = function get(name2) {
      return this.nested && this.nested[name2] || null;
    };
    Namespace.prototype.getEnum = function getEnum(name2) {
      if (this.nested && this.nested[name2] instanceof Enum)
        return this.nested[name2].values;
      throw Error("no such enum: " + name2);
    };
    Namespace.prototype.add = function add(object) {
      if (!(object instanceof Field && object.extend !== void 0 || object instanceof Type || object instanceof Enum || object instanceof Service || object instanceof Namespace || object instanceof OneOf))
        throw TypeError("object must be a valid nested object");
      if (!this.nested)
        this.nested = {};
      else {
        var prev = this.get(object.name);
        if (prev) {
          if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {
            var nested = prev.nestedArray;
            for (var i = 0; i < nested.length; ++i)
              object.add(nested[i]);
            this.remove(prev);
            if (!this.nested)
              this.nested = {};
            object.setOptions(prev.options, true);
          } else
            throw Error("duplicate name '" + object.name + "' in " + this);
        }
      }
      this.nested[object.name] = object;
      object.onAdd(this);
      return clearCache(this);
    };
    Namespace.prototype.remove = function remove2(object) {
      if (!(object instanceof ReflectionObject))
        throw TypeError("object must be a ReflectionObject");
      if (object.parent !== this)
        throw Error(object + " is not a member of " + this);
      delete this.nested[object.name];
      if (!Object.keys(this.nested).length)
        this.nested = void 0;
      object.onRemove(this);
      return clearCache(this);
    };
    Namespace.prototype.define = function define2(path, json) {
      if (util.isString(path))
        path = path.split(".");
      else if (!Array.isArray(path))
        throw TypeError("illegal path");
      if (path && path.length && path[0] === "")
        throw Error("path must be relative");
      var ptr = this;
      while (path.length > 0) {
        var part = path.shift();
        if (ptr.nested && ptr.nested[part]) {
          ptr = ptr.nested[part];
          if (!(ptr instanceof Namespace))
            throw Error("path conflicts with non-namespace objects");
        } else
          ptr.add(ptr = new Namespace(part));
      }
      if (json)
        ptr.addJSON(json);
      return ptr;
    };
    Namespace.prototype.resolveAll = function resolveAll() {
      var nested = this.nestedArray, i = 0;
      while (i < nested.length)
        if (nested[i] instanceof Namespace)
          nested[i++].resolveAll();
        else
          nested[i++].resolve();
      return this.resolve();
    };
    Namespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {
      if (typeof filterTypes === "boolean") {
        parentAlreadyChecked = filterTypes;
        filterTypes = void 0;
      } else if (filterTypes && !Array.isArray(filterTypes))
        filterTypes = [filterTypes];
      if (util.isString(path) && path.length) {
        if (path === ".")
          return this.root;
        path = path.split(".");
      } else if (!path.length)
        return this;
      if (path[0] === "")
        return this.root.lookup(path.slice(1), filterTypes);
      var found = this.get(path[0]);
      if (found) {
        if (path.length === 1) {
          if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)
            return found;
        } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true)))
          return found;
      } else
        for (var i = 0; i < this.nestedArray.length; ++i)
          if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true)))
            return found;
      if (this.parent === null || parentAlreadyChecked)
        return null;
      return this.parent.lookup(path, filterTypes);
    };
    Namespace.prototype.lookupType = function lookupType(path) {
      var found = this.lookup(path, [Type]);
      if (!found)
        throw Error("no such type: " + path);
      return found;
    };
    Namespace.prototype.lookupEnum = function lookupEnum(path) {
      var found = this.lookup(path, [Enum]);
      if (!found)
        throw Error("no such Enum '" + path + "' in " + this);
      return found;
    };
    Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {
      var found = this.lookup(path, [Type, Enum]);
      if (!found)
        throw Error("no such Type or Enum '" + path + "' in " + this);
      return found;
    };
    Namespace.prototype.lookupService = function lookupService(path) {
      var found = this.lookup(path, [Service]);
      if (!found)
        throw Error("no such Service '" + path + "' in " + this);
      return found;
    };
    Namespace._configure = function(Type_, Service_, Enum_) {
      Type = Type_;
      Service = Service_;
      Enum = Enum_;
    };
  }
});

// node_modules/protobufjs/src/mapfield.js
var require_mapfield = __commonJS({
  "node_modules/protobufjs/src/mapfield.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = MapField;
    var Field = require_field();
    ((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";
    var types2 = require_types();
    var util = require_util();
    function MapField(name2, id, keyType, type, options2, comment) {
      Field.call(this, name2, id, type, void 0, void 0, options2, comment);
      if (!util.isString(keyType))
        throw TypeError("keyType must be a string");
      this.keyType = keyType;
      this.resolvedKeyType = null;
      this.map = true;
    }
    MapField.fromJSON = function fromJSON(name2, json) {
      return new MapField(name2, json.id, json.keyType, json.type, json.options, json.comment);
    };
    MapField.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "keyType",
        this.keyType,
        "type",
        this.type,
        "id",
        this.id,
        "extend",
        this.extend,
        "options",
        this.options,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    MapField.prototype.resolve = function resolve2() {
      if (this.resolved)
        return this;
      if (types2.mapKey[this.keyType] === void 0)
        throw Error("invalid key type: " + this.keyType);
      return Field.prototype.resolve.call(this);
    };
    MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {
      if (typeof fieldValueType === "function")
        fieldValueType = util.decorateType(fieldValueType).name;
      else if (fieldValueType && typeof fieldValueType === "object")
        fieldValueType = util.decorateEnum(fieldValueType).name;
      return function mapFieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor).add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
      };
    };
  }
});

// node_modules/protobufjs/src/method.js
var require_method = __commonJS({
  "node_modules/protobufjs/src/method.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = Method;
    var ReflectionObject = require_object();
    ((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";
    var util = require_util();
    function Method(name2, type, requestType, responseType, requestStream, responseStream, options2, comment, parsedOptions) {
      if (util.isObject(requestStream)) {
        options2 = requestStream;
        requestStream = responseStream = void 0;
      } else if (util.isObject(responseStream)) {
        options2 = responseStream;
        responseStream = void 0;
      }
      if (!(type === void 0 || util.isString(type)))
        throw TypeError("type must be a string");
      if (!util.isString(requestType))
        throw TypeError("requestType must be a string");
      if (!util.isString(responseType))
        throw TypeError("responseType must be a string");
      ReflectionObject.call(this, name2, options2);
      this.type = type || "rpc";
      this.requestType = requestType;
      this.requestStream = requestStream ? true : void 0;
      this.responseType = responseType;
      this.responseStream = responseStream ? true : void 0;
      this.resolvedRequestType = null;
      this.resolvedResponseType = null;
      this.comment = comment;
      this.parsedOptions = parsedOptions;
    }
    Method.fromJSON = function fromJSON(name2, json) {
      return new Method(name2, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);
    };
    Method.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "type",
        this.type !== "rpc" && this.type || void 0,
        "requestType",
        this.requestType,
        "requestStream",
        this.requestStream,
        "responseType",
        this.responseType,
        "responseStream",
        this.responseStream,
        "options",
        this.options,
        "comment",
        keepComments ? this.comment : void 0,
        "parsedOptions",
        this.parsedOptions
      ]);
    };
    Method.prototype.resolve = function resolve2() {
      if (this.resolved)
        return this;
      this.resolvedRequestType = this.parent.lookupType(this.requestType);
      this.resolvedResponseType = this.parent.lookupType(this.responseType);
      return ReflectionObject.prototype.resolve.call(this);
    };
  }
});

// node_modules/protobufjs/src/service.js
var require_service2 = __commonJS({
  "node_modules/protobufjs/src/service.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = Service;
    var Namespace = require_namespace();
    ((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = "Service";
    var Method = require_method();
    var util = require_util();
    var rpc = require_rpc();
    function Service(name2, options2) {
      Namespace.call(this, name2, options2);
      this.methods = {};
      this._methodsArray = null;
    }
    Service.fromJSON = function fromJSON(name2, json) {
      var service = new Service(name2, json.options);
      if (json.methods)
        for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i)
          service.add(Method.fromJSON(names[i], json.methods[names[i]]));
      if (json.nested)
        service.addJSON(json.nested);
      service.comment = json.comment;
      return service;
    };
    Service.prototype.toJSON = function toJSON(toJSONOptions) {
      var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "options",
        inherited && inherited.options || void 0,
        "methods",
        Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || {},
        "nested",
        inherited && inherited.nested || void 0,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    Object.defineProperty(Service.prototype, "methodsArray", {
      get: function() {
        return this._methodsArray || (this._methodsArray = util.toArray(this.methods));
      }
    });
    function clearCache(service) {
      service._methodsArray = null;
      return service;
    }
    Service.prototype.get = function get(name2) {
      return this.methods[name2] || Namespace.prototype.get.call(this, name2);
    };
    Service.prototype.resolveAll = function resolveAll() {
      var methods = this.methodsArray;
      for (var i = 0; i < methods.length; ++i)
        methods[i].resolve();
      return Namespace.prototype.resolve.call(this);
    };
    Service.prototype.add = function add(object) {
      if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);
      if (object instanceof Method) {
        this.methods[object.name] = object;
        object.parent = this;
        return clearCache(this);
      }
      return Namespace.prototype.add.call(this, object);
    };
    Service.prototype.remove = function remove2(object) {
      if (object instanceof Method) {
        if (this.methods[object.name] !== object)
          throw Error(object + " is not a member of " + this);
        delete this.methods[object.name];
        object.parent = null;
        return clearCache(this);
      }
      return Namespace.prototype.remove.call(this, object);
    };
    Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {
      var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);
      for (var i = 0, method; i < this.methodsArray.length; ++i) {
        var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\w_]/g, "");
        rpcService[methodName] = util.codegen(["r", "c"], util.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
          m: method,
          q: method.resolvedRequestType.ctor,
          s: method.resolvedResponseType.ctor
        });
      }
      return rpcService;
    };
  }
});

// node_modules/protobufjs/src/message.js
var require_message = __commonJS({
  "node_modules/protobufjs/src/message.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = Message;
    var util = require_minimal();
    function Message(properties) {
      if (properties)
        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          this[keys[i]] = properties[keys[i]];
    }
    Message.create = function create(properties) {
      return this.$type.create(properties);
    };
    Message.encode = function encode2(message, writer) {
      return this.$type.encode(message, writer);
    };
    Message.encodeDelimited = function encodeDelimited(message, writer) {
      return this.$type.encodeDelimited(message, writer);
    };
    Message.decode = function decode(reader) {
      return this.$type.decode(reader);
    };
    Message.decodeDelimited = function decodeDelimited(reader) {
      return this.$type.decodeDelimited(reader);
    };
    Message.verify = function verify(message) {
      return this.$type.verify(message);
    };
    Message.fromObject = function fromObject(object) {
      return this.$type.fromObject(object);
    };
    Message.toObject = function toObject(message, options2) {
      return this.$type.toObject(message, options2);
    };
    Message.prototype.toJSON = function toJSON() {
      return this.$type.toObject(this, util.toJSONOptions);
    };
  }
});

// node_modules/protobufjs/src/decoder.js
var require_decoder = __commonJS({
  "node_modules/protobufjs/src/decoder.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = decoder;
    var Enum = require_enum();
    var types2 = require_types();
    var util = require_util();
    function missing(field) {
      return "missing required '" + field.name + "'";
    }
    function decoder(mtype) {
      var gen = util.codegen(["r", "l"], mtype.name + "$decode")("if(!(r instanceof Reader))")("r=Reader.create(r)")("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field2) {
        return field2.map;
      }).length ? ",k,value" : ""))("while(r.pos<c){")("var t=r.uint32()");
      if (mtype.group)
        gen("if((t&7)===4)")("break");
      gen("switch(t>>>3){");
      var i = 0;
      for (; i < mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(), type = field.resolvedType instanceof Enum ? "int32" : field.type, ref2 = "m" + util.safeProp(field.name);
        gen("case %i:", field.id);
        if (field.map) {
          gen("if(%s===util.emptyObject)", ref2)("%s={}", ref2)("var c2 = r.uint32()+r.pos");
          if (types2.defaults[field.keyType] !== void 0)
            gen("k=%j", types2.defaults[field.keyType]);
          else
            gen("k=null");
          if (types2.defaults[type] !== void 0)
            gen("value=%j", types2.defaults[type]);
          else
            gen("value=null");
          gen("while(r.pos<c2){")("var tag2=r.uint32()")("switch(tag2>>>3){")("case 1: k=r.%s(); break", field.keyType)("case 2:");
          if (types2.basic[type] === void 0)
            gen("value=types[%i].decode(r,r.uint32())", i);
          else
            gen("value=r.%s()", type);
          gen("break")("default:")("r.skipType(tag2&7)")("break")("}")("}");
          if (types2.long[field.keyType] !== void 0)
            gen('%s[typeof k==="object"?util.longToHash(k):k]=value', ref2);
          else
            gen("%s[k]=value", ref2);
        } else if (field.repeated) {
          gen("if(!(%s&&%s.length))", ref2, ref2)("%s=[]", ref2);
          if (types2.packed[type] !== void 0)
            gen("if((t&7)===2){")("var c2=r.uint32()+r.pos")("while(r.pos<c2)")("%s.push(r.%s())", ref2, type)("}else");
          if (types2.basic[type] === void 0)
            gen(field.resolvedType.group ? "%s.push(types[%i].decode(r))" : "%s.push(types[%i].decode(r,r.uint32()))", ref2, i);
          else
            gen("%s.push(r.%s())", ref2, type);
        } else if (types2.basic[type] === void 0)
          gen(field.resolvedType.group ? "%s=types[%i].decode(r)" : "%s=types[%i].decode(r,r.uint32())", ref2, i);
        else
          gen("%s=r.%s()", ref2, type);
        gen("break");
      }
      gen("default:")("r.skipType(t&7)")("break")("}")("}");
      for (i = 0; i < mtype._fieldsArray.length; ++i) {
        var rfield = mtype._fieldsArray[i];
        if (rfield.required)
          gen("if(!m.hasOwnProperty(%j))", rfield.name)("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
      }
      return gen("return m");
    }
  }
});

// node_modules/protobufjs/src/verifier.js
var require_verifier = __commonJS({
  "node_modules/protobufjs/src/verifier.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = verifier;
    var Enum = require_enum();
    var util = require_util();
    function invalid(field, expected) {
      return field.name + ": " + expected + (field.repeated && expected !== "array" ? "[]" : field.map && expected !== "object" ? "{k:" + field.keyType + "}" : "") + " expected";
    }
    function genVerifyValue(gen, field, fieldIndex, ref2) {
      if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) {
          gen("switch(%s){", ref2)("default:")("return%j", invalid(field, "enum value"));
          for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j)
            gen("case %i:", field.resolvedType.values[keys[j]]);
          gen("break")("}");
        } else {
          gen("{")("var e=types[%i].verify(%s);", fieldIndex, ref2)("if(e)")("return%j+e", field.name + ".")("}");
        }
      } else {
        switch (field.type) {
          case "int32":
          case "uint32":
          case "sint32":
          case "fixed32":
          case "sfixed32":
            gen("if(!util.isInteger(%s))", ref2)("return%j", invalid(field, "integer"));
            break;
          case "int64":
          case "uint64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref2, ref2, ref2, ref2)("return%j", invalid(field, "integer|Long"));
            break;
          case "float":
          case "double":
            gen('if(typeof %s!=="number")', ref2)("return%j", invalid(field, "number"));
            break;
          case "bool":
            gen('if(typeof %s!=="boolean")', ref2)("return%j", invalid(field, "boolean"));
            break;
          case "string":
            gen("if(!util.isString(%s))", ref2)("return%j", invalid(field, "string"));
            break;
          case "bytes":
            gen('if(!(%s&&typeof %s.length==="number"||util.isString(%s)))', ref2, ref2, ref2)("return%j", invalid(field, "buffer"));
            break;
        }
      }
      return gen;
    }
    function genVerifyKey(gen, field, ref2) {
      switch (field.keyType) {
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32":
          gen("if(!util.key32Re.test(%s))", ref2)("return%j", invalid(field, "integer key"));
          break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64":
          gen("if(!util.key64Re.test(%s))", ref2)("return%j", invalid(field, "integer|Long key"));
          break;
        case "bool":
          gen("if(!util.key2Re.test(%s))", ref2)("return%j", invalid(field, "boolean key"));
          break;
      }
      return gen;
    }
    function verifier(mtype) {
      var gen = util.codegen(["m"], mtype.name + "$verify")('if(typeof m!=="object"||m===null)')("return%j", "object expected");
      var oneofs = mtype.oneofsArray, seenFirstField = {};
      if (oneofs.length)
        gen("var p={}");
      for (var i = 0; i < mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(), ref2 = "m" + util.safeProp(field.name);
        if (field.optional)
          gen("if(%s!=null&&m.hasOwnProperty(%j)){", ref2, field.name);
        if (field.map) {
          gen("if(!util.isObject(%s))", ref2)("return%j", invalid(field, "object"))("var k=Object.keys(%s)", ref2)("for(var i=0;i<k.length;++i){");
          genVerifyKey(gen, field, "k[i]");
          genVerifyValue(gen, field, i, ref2 + "[k[i]]")("}");
        } else if (field.repeated) {
          gen("if(!Array.isArray(%s))", ref2)("return%j", invalid(field, "array"))("for(var i=0;i<%s.length;++i){", ref2);
          genVerifyValue(gen, field, i, ref2 + "[i]")("}");
        } else {
          if (field.partOf) {
            var oneofProp = util.safeProp(field.partOf.name);
            if (seenFirstField[field.partOf.name] === 1)
              gen("if(p%s===1)", oneofProp)("return%j", field.partOf.name + ": multiple values");
            seenFirstField[field.partOf.name] = 1;
            gen("p%s=1", oneofProp);
          }
          genVerifyValue(gen, field, i, ref2);
        }
        if (field.optional)
          gen("}");
      }
      return gen("return null");
    }
  }
});

// node_modules/protobufjs/src/converter.js
var require_converter = __commonJS({
  "node_modules/protobufjs/src/converter.js"(exports2) {
    init_shims();
    "use strict";
    var converter = exports2;
    var Enum = require_enum();
    var util = require_util();
    function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
      if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) {
          gen("switch(d%s){", prop);
          for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {
            if (field.repeated && values[keys[i]] === field.typeDefault)
              gen("default:");
            gen("case%j:", keys[i])("case %i:", values[keys[i]])("m%s=%j", prop, values[keys[i]])("break");
          }
          gen("}");
        } else
          gen('if(typeof d%s!=="object")', prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
      } else {
        var isUnsigned = false;
        switch (field.type) {
          case "double":
          case "float":
            gen("m%s=Number(d%s)", prop, prop);
            break;
          case "uint32":
          case "fixed32":
            gen("m%s=d%s>>>0", prop, prop);
            break;
          case "int32":
          case "sint32":
          case "sfixed32":
            gen("m%s=d%s|0", prop, prop);
            break;
          case "uint64":
            isUnsigned = true;
          case "int64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen("if(util.Long)")("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)('else if(typeof d%s==="string")', prop)("m%s=parseInt(d%s,10)", prop, prop)('else if(typeof d%s==="number")', prop)("m%s=d%s", prop, prop)('else if(typeof d%s==="object")', prop)("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
            break;
          case "bytes":
            gen('if(typeof d%s==="string")', prop)("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)("else if(d%s.length)", prop)("m%s=d%s", prop, prop);
            break;
          case "string":
            gen("m%s=String(d%s)", prop, prop);
            break;
          case "bool":
            gen("m%s=Boolean(d%s)", prop, prop);
            break;
        }
      }
      return gen;
    }
    converter.fromObject = function fromObject(mtype) {
      var fields = mtype.fieldsArray;
      var gen = util.codegen(["d"], mtype.name + "$fromObject")("if(d instanceof this.ctor)")("return d");
      if (!fields.length)
        return gen("return new this.ctor");
      gen("var m=new this.ctor");
      for (var i = 0; i < fields.length; ++i) {
        var field = fields[i].resolve(), prop = util.safeProp(field.name);
        if (field.map) {
          gen("if(d%s){", prop)('if(typeof d%s!=="object")', prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s={}", prop)("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
          genValuePartial_fromObject(gen, field, i, prop + "[ks[i]]")("}")("}");
        } else if (field.repeated) {
          gen("if(d%s){", prop)("if(!Array.isArray(d%s))", prop)("throw TypeError(%j)", field.fullName + ": array expected")("m%s=[]", prop)("for(var i=0;i<d%s.length;++i){", prop);
          genValuePartial_fromObject(gen, field, i, prop + "[i]")("}")("}");
        } else {
          if (!(field.resolvedType instanceof Enum))
            gen("if(d%s!=null){", prop);
          genValuePartial_fromObject(gen, field, i, prop);
          if (!(field.resolvedType instanceof Enum))
            gen("}");
        }
      }
      return gen("return m");
    };
    function genValuePartial_toObject(gen, field, fieldIndex, prop) {
      if (field.resolvedType) {
        if (field.resolvedType instanceof Enum)
          gen("d%s=o.enums===String?types[%i].values[m%s]:m%s", prop, fieldIndex, prop, prop);
        else
          gen("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
      } else {
        var isUnsigned = false;
        switch (field.type) {
          case "double":
          case "float":
            gen("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
            break;
          case "uint64":
            isUnsigned = true;
          case "int64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen('if(typeof m%s==="number")', prop)("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)("else")("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true" : "", prop);
            break;
          case "bytes":
            gen("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
            break;
          default:
            gen("d%s=m%s", prop, prop);
            break;
        }
      }
      return gen;
    }
    converter.toObject = function toObject(mtype) {
      var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
      if (!fields.length)
        return util.codegen()("return {}");
      var gen = util.codegen(["m", "o"], mtype.name + "$toObject")("if(!o)")("o={}")("var d={}");
      var repeatedFields = [], mapFields = [], normalFields = [], i = 0;
      for (; i < fields.length; ++i)
        if (!fields[i].partOf)
          (fields[i].resolve().repeated ? repeatedFields : fields[i].map ? mapFields : normalFields).push(fields[i]);
      if (repeatedFields.length) {
        gen("if(o.arrays||o.defaults){");
        for (i = 0; i < repeatedFields.length; ++i)
          gen("d%s=[]", util.safeProp(repeatedFields[i].name));
        gen("}");
      }
      if (mapFields.length) {
        gen("if(o.objects||o.defaults){");
        for (i = 0; i < mapFields.length; ++i)
          gen("d%s={}", util.safeProp(mapFields[i].name));
        gen("}");
      }
      if (normalFields.length) {
        gen("if(o.defaults){");
        for (i = 0; i < normalFields.length; ++i) {
          var field = normalFields[i], prop = util.safeProp(field.name);
          if (field.resolvedType instanceof Enum)
            gen("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);
          else if (field.long)
            gen("if(util.Long){")("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)("}else")("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());
          else if (field.bytes) {
            var arrayDefault = "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]";
            gen("if(o.bytes===String)d%s=%j", prop, String.fromCharCode.apply(String, field.typeDefault))("else{")("d%s=%s", prop, arrayDefault)("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", prop, prop)("}");
          } else
            gen("d%s=%j", prop, field.typeDefault);
        }
        gen("}");
      }
      var hasKs2 = false;
      for (i = 0; i < fields.length; ++i) {
        var field = fields[i], index2 = mtype._fieldsArray.indexOf(field), prop = util.safeProp(field.name);
        if (field.map) {
          if (!hasKs2) {
            hasKs2 = true;
            gen("var ks2");
          }
          gen("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)("d%s={}", prop)("for(var j=0;j<ks2.length;++j){");
          genValuePartial_toObject(gen, field, index2, prop + "[ks2[j]]")("}");
        } else if (field.repeated) {
          gen("if(m%s&&m%s.length){", prop, prop)("d%s=[]", prop)("for(var j=0;j<m%s.length;++j){", prop);
          genValuePartial_toObject(gen, field, index2, prop + "[j]")("}");
        } else {
          gen("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name);
          genValuePartial_toObject(gen, field, index2, prop);
          if (field.partOf)
            gen("if(o.oneofs)")("d%s=%j", util.safeProp(field.partOf.name), field.name);
        }
        gen("}");
      }
      return gen("return d");
    };
  }
});

// node_modules/protobufjs/src/wrappers.js
var require_wrappers = __commonJS({
  "node_modules/protobufjs/src/wrappers.js"(exports2) {
    init_shims();
    "use strict";
    var wrappers = exports2;
    var Message = require_message();
    wrappers[".google.protobuf.Any"] = {
      fromObject: function(object) {
        if (object && object["@type"]) {
          var name2 = object["@type"].substring(object["@type"].lastIndexOf("/") + 1);
          var type = this.lookup(name2);
          if (type) {
            var type_url = object["@type"].charAt(0) === "." ? object["@type"].substr(1) : object["@type"];
            if (type_url.indexOf("/") === -1) {
              type_url = "/" + type_url;
            }
            return this.create({
              type_url,
              value: type.encode(type.fromObject(object)).finish()
            });
          }
        }
        return this.fromObject(object);
      },
      toObject: function(message, options2) {
        var googleApi = "type.googleapis.com/";
        var prefix = "";
        var name2 = "";
        if (options2 && options2.json && message.type_url && message.value) {
          name2 = message.type_url.substring(message.type_url.lastIndexOf("/") + 1);
          prefix = message.type_url.substring(0, message.type_url.lastIndexOf("/") + 1);
          var type = this.lookup(name2);
          if (type)
            message = type.decode(message.value);
        }
        if (!(message instanceof this.ctor) && message instanceof Message) {
          var object = message.$type.toObject(message, options2);
          var messageName = message.$type.fullName[0] === "." ? message.$type.fullName.substr(1) : message.$type.fullName;
          if (prefix === "") {
            prefix = googleApi;
          }
          name2 = prefix + messageName;
          object["@type"] = name2;
          return object;
        }
        return this.toObject(message, options2);
      }
    };
  }
});

// node_modules/protobufjs/src/type.js
var require_type = __commonJS({
  "node_modules/protobufjs/src/type.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = Type;
    var Namespace = require_namespace();
    ((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";
    var Enum = require_enum();
    var OneOf = require_oneof();
    var Field = require_field();
    var MapField = require_mapfield();
    var Service = require_service2();
    var Message = require_message();
    var Reader = require_reader();
    var Writer = require_writer();
    var util = require_util();
    var encoder = require_encoder();
    var decoder = require_decoder();
    var verifier = require_verifier();
    var converter = require_converter();
    var wrappers = require_wrappers();
    function Type(name2, options2) {
      Namespace.call(this, name2, options2);
      this.fields = {};
      this.oneofs = void 0;
      this.extensions = void 0;
      this.reserved = void 0;
      this.group = void 0;
      this._fieldsById = null;
      this._fieldsArray = null;
      this._oneofsArray = null;
      this._ctor = null;
    }
    Object.defineProperties(Type.prototype, {
      fieldsById: {
        get: function() {
          if (this._fieldsById)
            return this._fieldsById;
          this._fieldsById = {};
          for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {
            var field = this.fields[names[i]], id = field.id;
            if (this._fieldsById[id])
              throw Error("duplicate id " + id + " in " + this);
            this._fieldsById[id] = field;
          }
          return this._fieldsById;
        }
      },
      fieldsArray: {
        get: function() {
          return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));
        }
      },
      oneofsArray: {
        get: function() {
          return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));
        }
      },
      ctor: {
        get: function() {
          return this._ctor || (this.ctor = Type.generateConstructor(this)());
        },
        set: function(ctor) {
          var prototype = ctor.prototype;
          if (!(prototype instanceof Message)) {
            (ctor.prototype = new Message()).constructor = ctor;
            util.merge(ctor.prototype, prototype);
          }
          ctor.$type = ctor.prototype.$type = this;
          util.merge(ctor, Message, true);
          this._ctor = ctor;
          var i = 0;
          for (; i < this.fieldsArray.length; ++i)
            this._fieldsArray[i].resolve();
          var ctorProperties = {};
          for (i = 0; i < this.oneofsArray.length; ++i)
            ctorProperties[this._oneofsArray[i].resolve().name] = {
              get: util.oneOfGetter(this._oneofsArray[i].oneof),
              set: util.oneOfSetter(this._oneofsArray[i].oneof)
            };
          if (i)
            Object.defineProperties(ctor.prototype, ctorProperties);
        }
      }
    });
    Type.generateConstructor = function generateConstructor(mtype) {
      var gen = util.codegen(["p"], mtype.name);
      for (var i = 0, field; i < mtype.fieldsArray.length; ++i)
        if ((field = mtype._fieldsArray[i]).map)
          gen("this%s={}", util.safeProp(field.name));
        else if (field.repeated)
          gen("this%s=[]", util.safeProp(field.name));
      return gen("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)")("this[ks[i]]=p[ks[i]]");
    };
    function clearCache(type) {
      type._fieldsById = type._fieldsArray = type._oneofsArray = null;
      delete type.encode;
      delete type.decode;
      delete type.verify;
      return type;
    }
    Type.fromJSON = function fromJSON(name2, json) {
      var type = new Type(name2, json.options);
      type.extensions = json.extensions;
      type.reserved = json.reserved;
      var names = Object.keys(json.fields), i = 0;
      for (; i < names.length; ++i)
        type.add((typeof json.fields[names[i]].keyType !== "undefined" ? MapField.fromJSON : Field.fromJSON)(names[i], json.fields[names[i]]));
      if (json.oneofs)
        for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)
          type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));
      if (json.nested)
        for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {
          var nested = json.nested[names[i]];
          type.add((nested.id !== void 0 ? Field.fromJSON : nested.fields !== void 0 ? Type.fromJSON : nested.values !== void 0 ? Enum.fromJSON : nested.methods !== void 0 ? Service.fromJSON : Namespace.fromJSON)(names[i], nested));
        }
      if (json.extensions && json.extensions.length)
        type.extensions = json.extensions;
      if (json.reserved && json.reserved.length)
        type.reserved = json.reserved;
      if (json.group)
        type.group = true;
      if (json.comment)
        type.comment = json.comment;
      return type;
    };
    Type.prototype.toJSON = function toJSON(toJSONOptions) {
      var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "options",
        inherited && inherited.options || void 0,
        "oneofs",
        Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),
        "fields",
        Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) {
          return !obj.declaringField;
        }), toJSONOptions) || {},
        "extensions",
        this.extensions && this.extensions.length ? this.extensions : void 0,
        "reserved",
        this.reserved && this.reserved.length ? this.reserved : void 0,
        "group",
        this.group || void 0,
        "nested",
        inherited && inherited.nested || void 0,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    Type.prototype.resolveAll = function resolveAll() {
      var fields = this.fieldsArray, i = 0;
      while (i < fields.length)
        fields[i++].resolve();
      var oneofs = this.oneofsArray;
      i = 0;
      while (i < oneofs.length)
        oneofs[i++].resolve();
      return Namespace.prototype.resolveAll.call(this);
    };
    Type.prototype.get = function get(name2) {
      return this.fields[name2] || this.oneofs && this.oneofs[name2] || this.nested && this.nested[name2] || null;
    };
    Type.prototype.add = function add(object) {
      if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);
      if (object instanceof Field && object.extend === void 0) {
        if (this._fieldsById ? this._fieldsById[object.id] : this.fieldsById[object.id])
          throw Error("duplicate id " + object.id + " in " + this);
        if (this.isReservedId(object.id))
          throw Error("id " + object.id + " is reserved in " + this);
        if (this.isReservedName(object.name))
          throw Error("name '" + object.name + "' is reserved in " + this);
        if (object.parent)
          object.parent.remove(object);
        this.fields[object.name] = object;
        object.message = this;
        object.onAdd(this);
        return clearCache(this);
      }
      if (object instanceof OneOf) {
        if (!this.oneofs)
          this.oneofs = {};
        this.oneofs[object.name] = object;
        object.onAdd(this);
        return clearCache(this);
      }
      return Namespace.prototype.add.call(this, object);
    };
    Type.prototype.remove = function remove2(object) {
      if (object instanceof Field && object.extend === void 0) {
        if (!this.fields || this.fields[object.name] !== object)
          throw Error(object + " is not a member of " + this);
        delete this.fields[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
      }
      if (object instanceof OneOf) {
        if (!this.oneofs || this.oneofs[object.name] !== object)
          throw Error(object + " is not a member of " + this);
        delete this.oneofs[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
      }
      return Namespace.prototype.remove.call(this, object);
    };
    Type.prototype.isReservedId = function isReservedId(id) {
      return Namespace.isReservedId(this.reserved, id);
    };
    Type.prototype.isReservedName = function isReservedName(name2) {
      return Namespace.isReservedName(this.reserved, name2);
    };
    Type.prototype.create = function create(properties) {
      return new this.ctor(properties);
    };
    Type.prototype.setup = function setup() {
      var fullName = this.fullName, types2 = [];
      for (var i = 0; i < this.fieldsArray.length; ++i)
        types2.push(this._fieldsArray[i].resolve().resolvedType);
      this.encode = encoder(this)({
        Writer,
        types: types2,
        util
      });
      this.decode = decoder(this)({
        Reader,
        types: types2,
        util
      });
      this.verify = verifier(this)({
        types: types2,
        util
      });
      this.fromObject = converter.fromObject(this)({
        types: types2,
        util
      });
      this.toObject = converter.toObject(this)({
        types: types2,
        util
      });
      var wrapper = wrappers[fullName];
      if (wrapper) {
        var originalThis = Object.create(this);
        originalThis.fromObject = this.fromObject;
        this.fromObject = wrapper.fromObject.bind(originalThis);
        originalThis.toObject = this.toObject;
        this.toObject = wrapper.toObject.bind(originalThis);
      }
      return this;
    };
    Type.prototype.encode = function encode_setup(message, writer) {
      return this.setup().encode(message, writer);
    };
    Type.prototype.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
    };
    Type.prototype.decode = function decode_setup(reader, length) {
      return this.setup().decode(reader, length);
    };
    Type.prototype.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof Reader))
        reader = Reader.create(reader);
      return this.decode(reader, reader.uint32());
    };
    Type.prototype.verify = function verify_setup(message) {
      return this.setup().verify(message);
    };
    Type.prototype.fromObject = function fromObject(object) {
      return this.setup().fromObject(object);
    };
    Type.prototype.toObject = function toObject(message, options2) {
      return this.setup().toObject(message, options2);
    };
    Type.d = function decorateType(typeName) {
      return function typeDecorator(target) {
        util.decorateType(target, typeName);
      };
    };
  }
});

// node_modules/protobufjs/src/root.js
var require_root = __commonJS({
  "node_modules/protobufjs/src/root.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = Root2;
    var Namespace = require_namespace();
    ((Root2.prototype = Object.create(Namespace.prototype)).constructor = Root2).className = "Root";
    var Field = require_field();
    var Enum = require_enum();
    var OneOf = require_oneof();
    var util = require_util();
    var Type;
    var parse;
    var common;
    function Root2(options2) {
      Namespace.call(this, "", options2);
      this.deferred = [];
      this.files = [];
    }
    Root2.fromJSON = function fromJSON(json, root) {
      if (!root)
        root = new Root2();
      if (json.options)
        root.setOptions(json.options);
      return root.addJSON(json.nested);
    };
    Root2.prototype.resolvePath = util.path.resolve;
    Root2.prototype.fetch = util.fetch;
    function SYNC() {
    }
    Root2.prototype.load = function load2(filename, options2, callback) {
      if (typeof options2 === "function") {
        callback = options2;
        options2 = void 0;
      }
      var self2 = this;
      if (!callback)
        return util.asPromise(load2, self2, filename, options2);
      var sync = callback === SYNC;
      function finish(err, root) {
        if (!callback)
          return;
        var cb = callback;
        callback = null;
        if (sync)
          throw err;
        cb(err, root);
      }
      function getBundledFileName(filename2) {
        var idx = filename2.lastIndexOf("google/protobuf/");
        if (idx > -1) {
          var altname = filename2.substring(idx);
          if (altname in common)
            return altname;
        }
        return null;
      }
      function process2(filename2, source) {
        try {
          if (util.isString(source) && source.charAt(0) === "{")
            source = JSON.parse(source);
          if (!util.isString(source))
            self2.setOptions(source.options).addJSON(source.nested);
          else {
            parse.filename = filename2;
            var parsed = parse(source, self2, options2), resolved2, i2 = 0;
            if (parsed.imports) {
              for (; i2 < parsed.imports.length; ++i2)
                if (resolved2 = getBundledFileName(parsed.imports[i2]) || self2.resolvePath(filename2, parsed.imports[i2]))
                  fetch2(resolved2);
            }
            if (parsed.weakImports) {
              for (i2 = 0; i2 < parsed.weakImports.length; ++i2)
                if (resolved2 = getBundledFileName(parsed.weakImports[i2]) || self2.resolvePath(filename2, parsed.weakImports[i2]))
                  fetch2(resolved2, true);
            }
          }
        } catch (err) {
          finish(err);
        }
        if (!sync && !queued)
          finish(null, self2);
      }
      function fetch2(filename2, weak) {
        if (self2.files.indexOf(filename2) > -1)
          return;
        self2.files.push(filename2);
        if (filename2 in common) {
          if (sync)
            process2(filename2, common[filename2]);
          else {
            ++queued;
            setTimeout(function() {
              --queued;
              process2(filename2, common[filename2]);
            });
          }
          return;
        }
        if (sync) {
          var source;
          try {
            source = util.fs.readFileSync(filename2).toString("utf8");
          } catch (err) {
            if (!weak)
              finish(err);
            return;
          }
          process2(filename2, source);
        } else {
          ++queued;
          self2.fetch(filename2, function(err, source2) {
            --queued;
            if (!callback)
              return;
            if (err) {
              if (!weak)
                finish(err);
              else if (!queued)
                finish(null, self2);
              return;
            }
            process2(filename2, source2);
          });
        }
      }
      var queued = 0;
      if (util.isString(filename))
        filename = [filename];
      for (var i = 0, resolved; i < filename.length; ++i)
        if (resolved = self2.resolvePath("", filename[i]))
          fetch2(resolved);
      if (sync)
        return self2;
      if (!queued)
        finish(null, self2);
      return void 0;
    };
    Root2.prototype.loadSync = function loadSync(filename, options2) {
      if (!util.isNode)
        throw Error("not supported");
      return this.load(filename, options2, SYNC);
    };
    Root2.prototype.resolveAll = function resolveAll() {
      if (this.deferred.length)
        throw Error("unresolvable extensions: " + this.deferred.map(function(field) {
          return "'extend " + field.extend + "' in " + field.parent.fullName;
        }).join(", "));
      return Namespace.prototype.resolveAll.call(this);
    };
    var exposeRe = /^[A-Z]/;
    function tryHandleExtension(root, field) {
      var extendedType = field.parent.lookup(field.extend);
      if (extendedType) {
        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, void 0, field.options);
        sisterField.declaringField = field;
        field.extensionField = sisterField;
        extendedType.add(sisterField);
        return true;
      }
      return false;
    }
    Root2.prototype._handleAdd = function _handleAdd(object) {
      if (object instanceof Field) {
        if (object.extend !== void 0 && !object.extensionField) {
          if (!tryHandleExtension(this, object))
            this.deferred.push(object);
        }
      } else if (object instanceof Enum) {
        if (exposeRe.test(object.name))
          object.parent[object.name] = object.values;
      } else if (!(object instanceof OneOf)) {
        if (object instanceof Type)
          for (var i = 0; i < this.deferred.length; )
            if (tryHandleExtension(this, this.deferred[i]))
              this.deferred.splice(i, 1);
            else
              ++i;
        for (var j = 0; j < object.nestedArray.length; ++j)
          this._handleAdd(object._nestedArray[j]);
        if (exposeRe.test(object.name))
          object.parent[object.name] = object;
      }
    };
    Root2.prototype._handleRemove = function _handleRemove(object) {
      if (object instanceof Field) {
        if (object.extend !== void 0) {
          if (object.extensionField) {
            object.extensionField.parent.remove(object.extensionField);
            object.extensionField = null;
          } else {
            var index2 = this.deferred.indexOf(object);
            if (index2 > -1)
              this.deferred.splice(index2, 1);
          }
        }
      } else if (object instanceof Enum) {
        if (exposeRe.test(object.name))
          delete object.parent[object.name];
      } else if (object instanceof Namespace) {
        for (var i = 0; i < object.nestedArray.length; ++i)
          this._handleRemove(object._nestedArray[i]);
        if (exposeRe.test(object.name))
          delete object.parent[object.name];
      }
    };
    Root2._configure = function(Type_, parse_, common_) {
      Type = Type_;
      parse = parse_;
      common = common_;
    };
  }
});

// node_modules/protobufjs/src/util.js
var require_util = __commonJS({
  "node_modules/protobufjs/src/util.js"(exports2, module2) {
    init_shims();
    "use strict";
    var util = module2.exports = require_minimal();
    var roots = require_roots();
    var Type;
    var Enum;
    util.codegen = require_codegen();
    util.fetch = require_fetch();
    util.path = require_path();
    util.fs = util.inquire("fs");
    util.toArray = function toArray2(object) {
      if (object) {
        var keys = Object.keys(object), array = new Array(keys.length), index2 = 0;
        while (index2 < keys.length)
          array[index2] = object[keys[index2++]];
        return array;
      }
      return [];
    };
    util.toObject = function toObject(array) {
      var object = {}, index2 = 0;
      while (index2 < array.length) {
        var key = array[index2++], val = array[index2++];
        if (val !== void 0)
          object[key] = val;
      }
      return object;
    };
    var safePropBackslashRe = /\\/g;
    var safePropQuoteRe = /"/g;
    util.isReserved = function isReserved(name2) {
      return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name2);
    };
    util.safeProp = function safeProp2(prop) {
      if (!/^[$\w_]+$/.test(prop) || util.isReserved(prop))
        return '["' + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, '\\"') + '"]';
      return "." + prop;
    };
    util.ucFirst = function ucFirst(str) {
      return str.charAt(0).toUpperCase() + str.substring(1);
    };
    var camelCaseRe = /_([a-z])/g;
    util.camelCase = function camelCase(str) {
      return str.substring(0, 1) + str.substring(1).replace(camelCaseRe, function($0, $1) {
        return $1.toUpperCase();
      });
    };
    util.compareFieldsById = function compareFieldsById(a, b) {
      return a.id - b.id;
    };
    util.decorateType = function decorateType(ctor, typeName) {
      if (ctor.$type) {
        if (typeName && ctor.$type.name !== typeName) {
          util.decorateRoot.remove(ctor.$type);
          ctor.$type.name = typeName;
          util.decorateRoot.add(ctor.$type);
        }
        return ctor.$type;
      }
      if (!Type)
        Type = require_type();
      var type = new Type(typeName || ctor.name);
      util.decorateRoot.add(type);
      type.ctor = ctor;
      Object.defineProperty(ctor, "$type", { value: type, enumerable: false });
      Object.defineProperty(ctor.prototype, "$type", { value: type, enumerable: false });
      return type;
    };
    var decorateEnumIndex = 0;
    util.decorateEnum = function decorateEnum(object) {
      if (object.$type)
        return object.$type;
      if (!Enum)
        Enum = require_enum();
      var enm = new Enum("Enum" + decorateEnumIndex++, object);
      util.decorateRoot.add(enm);
      Object.defineProperty(object, "$type", { value: enm, enumerable: false });
      return enm;
    };
    util.setProperty = function setProperty(dst, path, value) {
      function setProp(dst2, path2, value2) {
        var part = path2.shift();
        if (path2.length > 0) {
          dst2[part] = setProp(dst2[part] || {}, path2, value2);
        } else {
          var prevValue = dst2[part];
          if (prevValue)
            value2 = [].concat(prevValue).concat(value2);
          dst2[part] = value2;
        }
        return dst2;
      }
      if (typeof dst !== "object")
        throw TypeError("dst must be an object");
      if (!path)
        throw TypeError("path must be specified");
      path = path.split(".");
      return setProp(dst, path, value);
    };
    Object.defineProperty(util, "decorateRoot", {
      get: function() {
        return roots["decorated"] || (roots["decorated"] = new (require_root())());
      }
    });
  }
});

// node_modules/protobufjs/src/object.js
var require_object = __commonJS({
  "node_modules/protobufjs/src/object.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = ReflectionObject;
    ReflectionObject.className = "ReflectionObject";
    var util = require_util();
    var Root2;
    function ReflectionObject(name2, options2) {
      if (!util.isString(name2))
        throw TypeError("name must be a string");
      if (options2 && !util.isObject(options2))
        throw TypeError("options must be an object");
      this.options = options2;
      this.parsedOptions = null;
      this.name = name2;
      this.parent = null;
      this.resolved = false;
      this.comment = null;
      this.filename = null;
    }
    Object.defineProperties(ReflectionObject.prototype, {
      root: {
        get: function() {
          var ptr = this;
          while (ptr.parent !== null)
            ptr = ptr.parent;
          return ptr;
        }
      },
      fullName: {
        get: function() {
          var path = [this.name], ptr = this.parent;
          while (ptr) {
            path.unshift(ptr.name);
            ptr = ptr.parent;
          }
          return path.join(".");
        }
      }
    });
    ReflectionObject.prototype.toJSON = function toJSON() {
      throw Error();
    };
    ReflectionObject.prototype.onAdd = function onAdd(parent2) {
      if (this.parent && this.parent !== parent2)
        this.parent.remove(this);
      this.parent = parent2;
      this.resolved = false;
      var root = parent2.root;
      if (root instanceof Root2)
        root._handleAdd(this);
    };
    ReflectionObject.prototype.onRemove = function onRemove(parent2) {
      var root = parent2.root;
      if (root instanceof Root2)
        root._handleRemove(this);
      this.parent = null;
      this.resolved = false;
    };
    ReflectionObject.prototype.resolve = function resolve2() {
      if (this.resolved)
        return this;
      if (this.root instanceof Root2)
        this.resolved = true;
      return this;
    };
    ReflectionObject.prototype.getOption = function getOption(name2) {
      if (this.options)
        return this.options[name2];
      return void 0;
    };
    ReflectionObject.prototype.setOption = function setOption(name2, value, ifNotSet) {
      if (!ifNotSet || !this.options || this.options[name2] === void 0)
        (this.options || (this.options = {}))[name2] = value;
      return this;
    };
    ReflectionObject.prototype.setParsedOption = function setParsedOption(name2, value, propName) {
      if (!this.parsedOptions) {
        this.parsedOptions = [];
      }
      var parsedOptions = this.parsedOptions;
      if (propName) {
        var opt = parsedOptions.find(function(opt2) {
          return Object.prototype.hasOwnProperty.call(opt2, name2);
        });
        if (opt) {
          var newValue = opt[name2];
          util.setProperty(newValue, propName, value);
        } else {
          opt = {};
          opt[name2] = util.setProperty({}, propName, value);
          parsedOptions.push(opt);
        }
      } else {
        var newOpt = {};
        newOpt[name2] = value;
        parsedOptions.push(newOpt);
      }
      return this;
    };
    ReflectionObject.prototype.setOptions = function setOptions(options2, ifNotSet) {
      if (options2)
        for (var keys = Object.keys(options2), i = 0; i < keys.length; ++i)
          this.setOption(keys[i], options2[keys[i]], ifNotSet);
      return this;
    };
    ReflectionObject.prototype.toString = function toString() {
      var className = this.constructor.className, fullName = this.fullName;
      if (fullName.length)
        return className + " " + fullName;
      return className;
    };
    ReflectionObject._configure = function(Root_) {
      Root2 = Root_;
    };
  }
});

// node_modules/protobufjs/src/enum.js
var require_enum = __commonJS({
  "node_modules/protobufjs/src/enum.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = Enum;
    var ReflectionObject = require_object();
    ((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";
    var Namespace = require_namespace();
    var util = require_util();
    function Enum(name2, values, options2, comment, comments) {
      ReflectionObject.call(this, name2, options2);
      if (values && typeof values !== "object")
        throw TypeError("values must be an object");
      this.valuesById = {};
      this.values = Object.create(this.valuesById);
      this.comment = comment;
      this.comments = comments || {};
      this.reserved = void 0;
      if (values) {
        for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)
          if (typeof values[keys[i]] === "number")
            this.valuesById[this.values[keys[i]] = values[keys[i]]] = keys[i];
      }
    }
    Enum.fromJSON = function fromJSON(name2, json) {
      var enm = new Enum(name2, json.values, json.options, json.comment, json.comments);
      enm.reserved = json.reserved;
      return enm;
    };
    Enum.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "options",
        this.options,
        "values",
        this.values,
        "reserved",
        this.reserved && this.reserved.length ? this.reserved : void 0,
        "comment",
        keepComments ? this.comment : void 0,
        "comments",
        keepComments ? this.comments : void 0
      ]);
    };
    Enum.prototype.add = function add(name2, id, comment) {
      if (!util.isString(name2))
        throw TypeError("name must be a string");
      if (!util.isInteger(id))
        throw TypeError("id must be an integer");
      if (this.values[name2] !== void 0)
        throw Error("duplicate name '" + name2 + "' in " + this);
      if (this.isReservedId(id))
        throw Error("id " + id + " is reserved in " + this);
      if (this.isReservedName(name2))
        throw Error("name '" + name2 + "' is reserved in " + this);
      if (this.valuesById[id] !== void 0) {
        if (!(this.options && this.options.allow_alias))
          throw Error("duplicate id " + id + " in " + this);
        this.values[name2] = id;
      } else
        this.valuesById[this.values[name2] = id] = name2;
      this.comments[name2] = comment || null;
      return this;
    };
    Enum.prototype.remove = function remove2(name2) {
      if (!util.isString(name2))
        throw TypeError("name must be a string");
      var val = this.values[name2];
      if (val == null)
        throw Error("name '" + name2 + "' does not exist in " + this);
      delete this.valuesById[val];
      delete this.values[name2];
      delete this.comments[name2];
      return this;
    };
    Enum.prototype.isReservedId = function isReservedId(id) {
      return Namespace.isReservedId(this.reserved, id);
    };
    Enum.prototype.isReservedName = function isReservedName(name2) {
      return Namespace.isReservedName(this.reserved, name2);
    };
  }
});

// node_modules/protobufjs/src/encoder.js
var require_encoder = __commonJS({
  "node_modules/protobufjs/src/encoder.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = encoder;
    var Enum = require_enum();
    var types2 = require_types();
    var util = require_util();
    function genTypePartial(gen, field, fieldIndex, ref2) {
      return field.resolvedType.group ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref2, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0) : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref2, (field.id << 3 | 2) >>> 0);
    }
    function encoder(mtype) {
      var gen = util.codegen(["m", "w"], mtype.name + "$encode")("if(!w)")("w=Writer.create()");
      var i, ref2;
      var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
      for (var i = 0; i < fields.length; ++i) {
        var field = fields[i].resolve(), index2 = mtype._fieldsArray.indexOf(field), type = field.resolvedType instanceof Enum ? "int32" : field.type, wireType = types2.basic[type];
        ref2 = "m" + util.safeProp(field.name);
        if (field.map) {
          gen("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", ref2, field.name)("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref2)("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types2.mapKey[field.keyType], field.keyType);
          if (wireType === void 0)
            gen("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index2, ref2);
          else
            gen(".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref2);
          gen("}")("}");
        } else if (field.repeated) {
          gen("if(%s!=null&&%s.length){", ref2, ref2);
          if (field.packed && types2.packed[type] !== void 0) {
            gen("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)("for(var i=0;i<%s.length;++i)", ref2)("w.%s(%s[i])", type, ref2)("w.ldelim()");
          } else {
            gen("for(var i=0;i<%s.length;++i)", ref2);
            if (wireType === void 0)
              genTypePartial(gen, field, index2, ref2 + "[i]");
            else
              gen("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type, ref2);
          }
          gen("}");
        } else {
          if (field.optional)
            gen("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", ref2, field.name);
          if (wireType === void 0)
            genTypePartial(gen, field, index2, ref2);
          else
            gen("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type, ref2);
        }
      }
      return gen("return w");
    }
  }
});

// node_modules/protobufjs/src/index-light.js
var require_index_light = __commonJS({
  "node_modules/protobufjs/src/index-light.js"(exports2, module2) {
    init_shims();
    "use strict";
    var protobuf = module2.exports = require_index_minimal();
    protobuf.build = "light";
    function load2(filename, root, callback) {
      if (typeof root === "function") {
        callback = root;
        root = new protobuf.Root();
      } else if (!root)
        root = new protobuf.Root();
      return root.load(filename, callback);
    }
    protobuf.load = load2;
    function loadSync(filename, root) {
      if (!root)
        root = new protobuf.Root();
      return root.loadSync(filename);
    }
    protobuf.loadSync = loadSync;
    protobuf.encoder = require_encoder();
    protobuf.decoder = require_decoder();
    protobuf.verifier = require_verifier();
    protobuf.converter = require_converter();
    protobuf.ReflectionObject = require_object();
    protobuf.Namespace = require_namespace();
    protobuf.Root = require_root();
    protobuf.Enum = require_enum();
    protobuf.Type = require_type();
    protobuf.Field = require_field();
    protobuf.OneOf = require_oneof();
    protobuf.MapField = require_mapfield();
    protobuf.Service = require_service2();
    protobuf.Method = require_method();
    protobuf.Message = require_message();
    protobuf.wrappers = require_wrappers();
    protobuf.types = require_types();
    protobuf.util = require_util();
    protobuf.ReflectionObject._configure(protobuf.Root);
    protobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);
    protobuf.Root._configure(protobuf.Type);
    protobuf.Field._configure(protobuf.Type);
  }
});

// node_modules/protobufjs/src/tokenize.js
var require_tokenize = __commonJS({
  "node_modules/protobufjs/src/tokenize.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = tokenize;
    var delimRe = /[\s{}=;:[\],'"()<>]/g;
    var stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g;
    var stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g;
    var setCommentRe = /^ *[*/]+ */;
    var setCommentAltRe = /^\s*\*?\/*/;
    var setCommentSplitRe = /\n/g;
    var whitespaceRe = /\s/;
    var unescapeRe = /\\(.?)/g;
    var unescapeMap = {
      "0": "\0",
      "r": "\r",
      "n": "\n",
      "t": "	"
    };
    function unescape2(str) {
      return str.replace(unescapeRe, function($0, $1) {
        switch ($1) {
          case "\\":
          case "":
            return $1;
          default:
            return unescapeMap[$1] || "";
        }
      });
    }
    tokenize.unescape = unescape2;
    function tokenize(source, alternateCommentMode) {
      source = source.toString();
      var offset = 0, length = source.length, line = 1, commentType = null, commentText = null, commentLine = 0, commentLineEmpty = false, commentIsLeading = false;
      var stack = [];
      var stringDelim = null;
      function illegal(subject) {
        return Error("illegal " + subject + " (line " + line + ")");
      }
      function readString() {
        var re = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
        re.lastIndex = offset - 1;
        var match = re.exec(source);
        if (!match)
          throw illegal("string");
        offset = re.lastIndex;
        push(stringDelim);
        stringDelim = null;
        return unescape2(match[1]);
      }
      function charAt(pos) {
        return source.charAt(pos);
      }
      function setComment(start2, end, isLeading) {
        commentType = source.charAt(start2++);
        commentLine = line;
        commentLineEmpty = false;
        commentIsLeading = isLeading;
        var lookback;
        if (alternateCommentMode) {
          lookback = 2;
        } else {
          lookback = 3;
        }
        var commentOffset = start2 - lookback, c;
        do {
          if (--commentOffset < 0 || (c = source.charAt(commentOffset)) === "\n") {
            commentLineEmpty = true;
            break;
          }
        } while (c === " " || c === "	");
        var lines = source.substring(start2, end).split(setCommentSplitRe);
        for (var i = 0; i < lines.length; ++i)
          lines[i] = lines[i].replace(alternateCommentMode ? setCommentAltRe : setCommentRe, "").trim();
        commentText = lines.join("\n").trim();
      }
      function isDoubleSlashCommentLine(startOffset) {
        var endOffset = findEndOfLine(startOffset);
        var lineText = source.substring(startOffset, endOffset);
        var isComment = /^\s*\/{1,2}/.test(lineText);
        return isComment;
      }
      function findEndOfLine(cursor) {
        var endOffset = cursor;
        while (endOffset < length && charAt(endOffset) !== "\n") {
          endOffset++;
        }
        return endOffset;
      }
      function next() {
        if (stack.length > 0)
          return stack.shift();
        if (stringDelim)
          return readString();
        var repeat, prev, curr, start2, isDoc, isLeadingComment = offset === 0;
        do {
          if (offset === length)
            return null;
          repeat = false;
          while (whitespaceRe.test(curr = charAt(offset))) {
            if (curr === "\n") {
              isLeadingComment = true;
              ++line;
            }
            if (++offset === length)
              return null;
          }
          if (charAt(offset) === "/") {
            if (++offset === length) {
              throw illegal("comment");
            }
            if (charAt(offset) === "/") {
              if (!alternateCommentMode) {
                isDoc = charAt(start2 = offset + 1) === "/";
                while (charAt(++offset) !== "\n") {
                  if (offset === length) {
                    return null;
                  }
                }
                ++offset;
                if (isDoc) {
                  setComment(start2, offset - 1, isLeadingComment);
                }
                ++line;
                repeat = true;
              } else {
                start2 = offset;
                isDoc = false;
                if (isDoubleSlashCommentLine(offset)) {
                  isDoc = true;
                  do {
                    offset = findEndOfLine(offset);
                    if (offset === length) {
                      break;
                    }
                    offset++;
                  } while (isDoubleSlashCommentLine(offset));
                } else {
                  offset = Math.min(length, findEndOfLine(offset) + 1);
                }
                if (isDoc) {
                  setComment(start2, offset, isLeadingComment);
                }
                line++;
                repeat = true;
              }
            } else if ((curr = charAt(offset)) === "*") {
              start2 = offset + 1;
              isDoc = alternateCommentMode || charAt(start2) === "*";
              do {
                if (curr === "\n") {
                  ++line;
                }
                if (++offset === length) {
                  throw illegal("comment");
                }
                prev = curr;
                curr = charAt(offset);
              } while (prev !== "*" || curr !== "/");
              ++offset;
              if (isDoc) {
                setComment(start2, offset - 2, isLeadingComment);
              }
              repeat = true;
            } else {
              return "/";
            }
          }
        } while (repeat);
        var end = offset;
        delimRe.lastIndex = 0;
        var delim = delimRe.test(charAt(end++));
        if (!delim)
          while (end < length && !delimRe.test(charAt(end)))
            ++end;
        var token = source.substring(offset, offset = end);
        if (token === '"' || token === "'")
          stringDelim = token;
        return token;
      }
      function push(token) {
        stack.push(token);
      }
      function peek() {
        if (!stack.length) {
          var token = next();
          if (token === null)
            return null;
          push(token);
        }
        return stack[0];
      }
      function skip(expected, optional) {
        var actual = peek(), equals = actual === expected;
        if (equals) {
          next();
          return true;
        }
        if (!optional)
          throw illegal("token '" + actual + "', '" + expected + "' expected");
        return false;
      }
      function cmnt(trailingLine) {
        var ret = null;
        if (trailingLine === void 0) {
          if (commentLine === line - 1 && (alternateCommentMode || commentType === "*" || commentLineEmpty)) {
            ret = commentIsLeading ? commentText : null;
          }
        } else {
          if (commentLine < trailingLine) {
            peek();
          }
          if (commentLine === trailingLine && !commentLineEmpty && (alternateCommentMode || commentType === "/")) {
            ret = commentIsLeading ? null : commentText;
          }
        }
        return ret;
      }
      return Object.defineProperty({
        next,
        peek,
        push,
        skip,
        cmnt
      }, "line", {
        get: function() {
          return line;
        }
      });
    }
  }
});

// node_modules/protobufjs/src/parse.js
var require_parse = __commonJS({
  "node_modules/protobufjs/src/parse.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = parse;
    parse.filename = null;
    parse.defaults = { keepCase: false };
    var tokenize = require_tokenize();
    var Root2 = require_root();
    var Type = require_type();
    var Field = require_field();
    var MapField = require_mapfield();
    var OneOf = require_oneof();
    var Enum = require_enum();
    var Service = require_service2();
    var Method = require_method();
    var types2 = require_types();
    var util = require_util();
    var base10Re = /^[1-9][0-9]*$/;
    var base10NegRe = /^-?[1-9][0-9]*$/;
    var base16Re = /^0[x][0-9a-fA-F]+$/;
    var base16NegRe = /^-?0[x][0-9a-fA-F]+$/;
    var base8Re = /^0[0-7]+$/;
    var base8NegRe = /^-?0[0-7]+$/;
    var numberRe = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;
    var nameRe = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
    var typeRefRe = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/;
    var fqTypeRefRe = /^(?:\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;
    function parse(source, root, options2) {
      if (!(root instanceof Root2)) {
        options2 = root;
        root = new Root2();
      }
      if (!options2)
        options2 = parse.defaults;
      var preferTrailingComment = options2.preferTrailingComment || false;
      var tn = tokenize(source, options2.alternateCommentMode || false), next = tn.next, push = tn.push, peek = tn.peek, skip = tn.skip, cmnt = tn.cmnt;
      var head = true, pkg, imports, weakImports, syntax, isProto3 = false;
      var ptr = root;
      var applyCase = options2.keepCase ? function(name2) {
        return name2;
      } : util.camelCase;
      function illegal(token2, name2, insideTryCatch) {
        var filename = parse.filename;
        if (!insideTryCatch)
          parse.filename = null;
        return Error("illegal " + (name2 || "token") + " '" + token2 + "' (" + (filename ? filename + ", " : "") + "line " + tn.line + ")");
      }
      function readString() {
        var values = [], token2;
        do {
          if ((token2 = next()) !== '"' && token2 !== "'")
            throw illegal(token2);
          values.push(next());
          skip(token2);
          token2 = peek();
        } while (token2 === '"' || token2 === "'");
        return values.join("");
      }
      function readValue(acceptTypeRef) {
        var token2 = next();
        switch (token2) {
          case "'":
          case '"':
            push(token2);
            return readString();
          case "true":
          case "TRUE":
            return true;
          case "false":
          case "FALSE":
            return false;
        }
        try {
          return parseNumber(token2, true);
        } catch (e) {
          if (acceptTypeRef && typeRefRe.test(token2))
            return token2;
          throw illegal(token2, "value");
        }
      }
      function readRanges(target, acceptStrings) {
        var token2, start2;
        do {
          if (acceptStrings && ((token2 = peek()) === '"' || token2 === "'"))
            target.push(readString());
          else
            target.push([start2 = parseId(next()), skip("to", true) ? parseId(next()) : start2]);
        } while (skip(",", true));
        skip(";");
      }
      function parseNumber(token2, insideTryCatch) {
        var sign = 1;
        if (token2.charAt(0) === "-") {
          sign = -1;
          token2 = token2.substring(1);
        }
        switch (token2) {
          case "inf":
          case "INF":
          case "Inf":
            return sign * Infinity;
          case "nan":
          case "NAN":
          case "Nan":
          case "NaN":
            return NaN;
          case "0":
            return 0;
        }
        if (base10Re.test(token2))
          return sign * parseInt(token2, 10);
        if (base16Re.test(token2))
          return sign * parseInt(token2, 16);
        if (base8Re.test(token2))
          return sign * parseInt(token2, 8);
        if (numberRe.test(token2))
          return sign * parseFloat(token2);
        throw illegal(token2, "number", insideTryCatch);
      }
      function parseId(token2, acceptNegative) {
        switch (token2) {
          case "max":
          case "MAX":
          case "Max":
            return 536870911;
          case "0":
            return 0;
        }
        if (!acceptNegative && token2.charAt(0) === "-")
          throw illegal(token2, "id");
        if (base10NegRe.test(token2))
          return parseInt(token2, 10);
        if (base16NegRe.test(token2))
          return parseInt(token2, 16);
        if (base8NegRe.test(token2))
          return parseInt(token2, 8);
        throw illegal(token2, "id");
      }
      function parsePackage() {
        if (pkg !== void 0)
          throw illegal("package");
        pkg = next();
        if (!typeRefRe.test(pkg))
          throw illegal(pkg, "name");
        ptr = ptr.define(pkg);
        skip(";");
      }
      function parseImport() {
        var token2 = peek();
        var whichImports;
        switch (token2) {
          case "weak":
            whichImports = weakImports || (weakImports = []);
            next();
            break;
          case "public":
            next();
          default:
            whichImports = imports || (imports = []);
            break;
        }
        token2 = readString();
        skip(";");
        whichImports.push(token2);
      }
      function parseSyntax() {
        skip("=");
        syntax = readString();
        isProto3 = syntax === "proto3";
        if (!isProto3 && syntax !== "proto2")
          throw illegal(syntax, "syntax");
        skip(";");
      }
      function parseCommon(parent2, token2) {
        switch (token2) {
          case "option":
            parseOption(parent2, token2);
            skip(";");
            return true;
          case "message":
            parseType(parent2, token2);
            return true;
          case "enum":
            parseEnum(parent2, token2);
            return true;
          case "service":
            parseService(parent2, token2);
            return true;
          case "extend":
            parseExtension(parent2, token2);
            return true;
        }
        return false;
      }
      function ifBlock(obj, fnIf, fnElse) {
        var trailingLine = tn.line;
        if (obj) {
          if (typeof obj.comment !== "string") {
            obj.comment = cmnt();
          }
          obj.filename = parse.filename;
        }
        if (skip("{", true)) {
          var token2;
          while ((token2 = next()) !== "}")
            fnIf(token2);
          skip(";", true);
        } else {
          if (fnElse)
            fnElse();
          skip(";");
          if (obj && (typeof obj.comment !== "string" || preferTrailingComment))
            obj.comment = cmnt(trailingLine) || obj.comment;
        }
      }
      function parseType(parent2, token2) {
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "type name");
        var type = new Type(token2);
        ifBlock(type, function parseType_block(token3) {
          if (parseCommon(type, token3))
            return;
          switch (token3) {
            case "map":
              parseMapField(type, token3);
              break;
            case "required":
            case "repeated":
              parseField(type, token3);
              break;
            case "optional":
              if (isProto3) {
                parseField(type, "proto3_optional");
              } else {
                parseField(type, "optional");
              }
              break;
            case "oneof":
              parseOneOf(type, token3);
              break;
            case "extensions":
              readRanges(type.extensions || (type.extensions = []));
              break;
            case "reserved":
              readRanges(type.reserved || (type.reserved = []), true);
              break;
            default:
              if (!isProto3 || !typeRefRe.test(token3))
                throw illegal(token3);
              push(token3);
              parseField(type, "optional");
              break;
          }
        });
        parent2.add(type);
      }
      function parseField(parent2, rule, extend) {
        var type = next();
        if (type === "group") {
          parseGroup(parent2, rule);
          return;
        }
        if (!typeRefRe.test(type))
          throw illegal(type, "type");
        var name2 = next();
        if (!nameRe.test(name2))
          throw illegal(name2, "name");
        name2 = applyCase(name2);
        skip("=");
        var field = new Field(name2, parseId(next()), type, rule, extend);
        ifBlock(field, function parseField_block(token2) {
          if (token2 === "option") {
            parseOption(field, token2);
            skip(";");
          } else
            throw illegal(token2);
        }, function parseField_line() {
          parseInlineOptions(field);
        });
        if (rule === "proto3_optional") {
          var oneof = new OneOf("_" + name2);
          field.setOption("proto3_optional", true);
          oneof.add(field);
          parent2.add(oneof);
        } else {
          parent2.add(field);
        }
        if (!isProto3 && field.repeated && (types2.packed[type] !== void 0 || types2.basic[type] === void 0))
          field.setOption("packed", false, true);
      }
      function parseGroup(parent2, rule) {
        var name2 = next();
        if (!nameRe.test(name2))
          throw illegal(name2, "name");
        var fieldName = util.lcFirst(name2);
        if (name2 === fieldName)
          name2 = util.ucFirst(name2);
        skip("=");
        var id = parseId(next());
        var type = new Type(name2);
        type.group = true;
        var field = new Field(fieldName, id, name2, rule);
        field.filename = parse.filename;
        ifBlock(type, function parseGroup_block(token2) {
          switch (token2) {
            case "option":
              parseOption(type, token2);
              skip(";");
              break;
            case "required":
            case "repeated":
              parseField(type, token2);
              break;
            case "optional":
              if (isProto3) {
                parseField(type, "proto3_optional");
              } else {
                parseField(type, "optional");
              }
              break;
            default:
              throw illegal(token2);
          }
        });
        parent2.add(type).add(field);
      }
      function parseMapField(parent2) {
        skip("<");
        var keyType = next();
        if (types2.mapKey[keyType] === void 0)
          throw illegal(keyType, "type");
        skip(",");
        var valueType = next();
        if (!typeRefRe.test(valueType))
          throw illegal(valueType, "type");
        skip(">");
        var name2 = next();
        if (!nameRe.test(name2))
          throw illegal(name2, "name");
        skip("=");
        var field = new MapField(applyCase(name2), parseId(next()), keyType, valueType);
        ifBlock(field, function parseMapField_block(token2) {
          if (token2 === "option") {
            parseOption(field, token2);
            skip(";");
          } else
            throw illegal(token2);
        }, function parseMapField_line() {
          parseInlineOptions(field);
        });
        parent2.add(field);
      }
      function parseOneOf(parent2, token2) {
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "name");
        var oneof = new OneOf(applyCase(token2));
        ifBlock(oneof, function parseOneOf_block(token3) {
          if (token3 === "option") {
            parseOption(oneof, token3);
            skip(";");
          } else {
            push(token3);
            parseField(oneof, "optional");
          }
        });
        parent2.add(oneof);
      }
      function parseEnum(parent2, token2) {
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "name");
        var enm = new Enum(token2);
        ifBlock(enm, function parseEnum_block(token3) {
          switch (token3) {
            case "option":
              parseOption(enm, token3);
              skip(";");
              break;
            case "reserved":
              readRanges(enm.reserved || (enm.reserved = []), true);
              break;
            default:
              parseEnumValue(enm, token3);
          }
        });
        parent2.add(enm);
      }
      function parseEnumValue(parent2, token2) {
        if (!nameRe.test(token2))
          throw illegal(token2, "name");
        skip("=");
        var value = parseId(next(), true), dummy = {};
        ifBlock(dummy, function parseEnumValue_block(token3) {
          if (token3 === "option") {
            parseOption(dummy, token3);
            skip(";");
          } else
            throw illegal(token3);
        }, function parseEnumValue_line() {
          parseInlineOptions(dummy);
        });
        parent2.add(token2, value, dummy.comment);
      }
      function parseOption(parent2, token2) {
        var isCustom = skip("(", true);
        if (!typeRefRe.test(token2 = next()))
          throw illegal(token2, "name");
        var name2 = token2;
        var option = name2;
        var propName;
        if (isCustom) {
          skip(")");
          name2 = "(" + name2 + ")";
          option = name2;
          token2 = peek();
          if (fqTypeRefRe.test(token2)) {
            propName = token2.substr(1);
            name2 += token2;
            next();
          }
        }
        skip("=");
        var optionValue = parseOptionValue(parent2, name2);
        setParsedOption(parent2, option, optionValue, propName);
      }
      function parseOptionValue(parent2, name2) {
        if (skip("{", true)) {
          var result = {};
          while (!skip("}", true)) {
            if (!nameRe.test(token = next()))
              throw illegal(token, "name");
            var value;
            var propName = token;
            if (peek() === "{")
              value = parseOptionValue(parent2, name2 + "." + token);
            else {
              skip(":");
              if (peek() === "{")
                value = parseOptionValue(parent2, name2 + "." + token);
              else {
                value = readValue(true);
                setOption(parent2, name2 + "." + token, value);
              }
            }
            var prevValue = result[propName];
            if (prevValue)
              value = [].concat(prevValue).concat(value);
            result[propName] = value;
            skip(",", true);
          }
          return result;
        }
        var simpleValue = readValue(true);
        setOption(parent2, name2, simpleValue);
        return simpleValue;
      }
      function setOption(parent2, name2, value) {
        if (parent2.setOption)
          parent2.setOption(name2, value);
      }
      function setParsedOption(parent2, name2, value, propName) {
        if (parent2.setParsedOption)
          parent2.setParsedOption(name2, value, propName);
      }
      function parseInlineOptions(parent2) {
        if (skip("[", true)) {
          do {
            parseOption(parent2, "option");
          } while (skip(",", true));
          skip("]");
        }
        return parent2;
      }
      function parseService(parent2, token2) {
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "service name");
        var service = new Service(token2);
        ifBlock(service, function parseService_block(token3) {
          if (parseCommon(service, token3))
            return;
          if (token3 === "rpc")
            parseMethod(service, token3);
          else
            throw illegal(token3);
        });
        parent2.add(service);
      }
      function parseMethod(parent2, token2) {
        var commentText = cmnt();
        var type = token2;
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "name");
        var name2 = token2, requestType, requestStream, responseType, responseStream;
        skip("(");
        if (skip("stream", true))
          requestStream = true;
        if (!typeRefRe.test(token2 = next()))
          throw illegal(token2);
        requestType = token2;
        skip(")");
        skip("returns");
        skip("(");
        if (skip("stream", true))
          responseStream = true;
        if (!typeRefRe.test(token2 = next()))
          throw illegal(token2);
        responseType = token2;
        skip(")");
        var method = new Method(name2, type, requestType, responseType, requestStream, responseStream);
        method.comment = commentText;
        ifBlock(method, function parseMethod_block(token3) {
          if (token3 === "option") {
            parseOption(method, token3);
            skip(";");
          } else
            throw illegal(token3);
        });
        parent2.add(method);
      }
      function parseExtension(parent2, token2) {
        if (!typeRefRe.test(token2 = next()))
          throw illegal(token2, "reference");
        var reference = token2;
        ifBlock(null, function parseExtension_block(token3) {
          switch (token3) {
            case "required":
            case "repeated":
              parseField(parent2, token3, reference);
              break;
            case "optional":
              if (isProto3) {
                parseField(parent2, "proto3_optional", reference);
              } else {
                parseField(parent2, "optional", reference);
              }
              break;
            default:
              if (!isProto3 || !typeRefRe.test(token3))
                throw illegal(token3);
              push(token3);
              parseField(parent2, "optional", reference);
              break;
          }
        });
      }
      var token;
      while ((token = next()) !== null) {
        switch (token) {
          case "package":
            if (!head)
              throw illegal(token);
            parsePackage();
            break;
          case "import":
            if (!head)
              throw illegal(token);
            parseImport();
            break;
          case "syntax":
            if (!head)
              throw illegal(token);
            parseSyntax();
            break;
          case "option":
            parseOption(ptr, token);
            skip(";");
            break;
          default:
            if (parseCommon(ptr, token)) {
              head = false;
              continue;
            }
            throw illegal(token);
        }
      }
      parse.filename = null;
      return {
        "package": pkg,
        "imports": imports,
        weakImports,
        syntax,
        root
      };
    }
  }
});

// node_modules/protobufjs/src/common.js
var require_common = __commonJS({
  "node_modules/protobufjs/src/common.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = common;
    var commonRe = /\/|\./;
    function common(name2, json) {
      if (!commonRe.test(name2)) {
        name2 = "google/protobuf/" + name2 + ".proto";
        json = { nested: { google: { nested: { protobuf: { nested: json } } } } };
      }
      common[name2] = json;
    }
    common("any", {
      Any: {
        fields: {
          type_url: {
            type: "string",
            id: 1
          },
          value: {
            type: "bytes",
            id: 2
          }
        }
      }
    });
    var timeType;
    common("duration", {
      Duration: timeType = {
        fields: {
          seconds: {
            type: "int64",
            id: 1
          },
          nanos: {
            type: "int32",
            id: 2
          }
        }
      }
    });
    common("timestamp", {
      Timestamp: timeType
    });
    common("empty", {
      Empty: {
        fields: {}
      }
    });
    common("struct", {
      Struct: {
        fields: {
          fields: {
            keyType: "string",
            type: "Value",
            id: 1
          }
        }
      },
      Value: {
        oneofs: {
          kind: {
            oneof: [
              "nullValue",
              "numberValue",
              "stringValue",
              "boolValue",
              "structValue",
              "listValue"
            ]
          }
        },
        fields: {
          nullValue: {
            type: "NullValue",
            id: 1
          },
          numberValue: {
            type: "double",
            id: 2
          },
          stringValue: {
            type: "string",
            id: 3
          },
          boolValue: {
            type: "bool",
            id: 4
          },
          structValue: {
            type: "Struct",
            id: 5
          },
          listValue: {
            type: "ListValue",
            id: 6
          }
        }
      },
      NullValue: {
        values: {
          NULL_VALUE: 0
        }
      },
      ListValue: {
        fields: {
          values: {
            rule: "repeated",
            type: "Value",
            id: 1
          }
        }
      }
    });
    common("wrappers", {
      DoubleValue: {
        fields: {
          value: {
            type: "double",
            id: 1
          }
        }
      },
      FloatValue: {
        fields: {
          value: {
            type: "float",
            id: 1
          }
        }
      },
      Int64Value: {
        fields: {
          value: {
            type: "int64",
            id: 1
          }
        }
      },
      UInt64Value: {
        fields: {
          value: {
            type: "uint64",
            id: 1
          }
        }
      },
      Int32Value: {
        fields: {
          value: {
            type: "int32",
            id: 1
          }
        }
      },
      UInt32Value: {
        fields: {
          value: {
            type: "uint32",
            id: 1
          }
        }
      },
      BoolValue: {
        fields: {
          value: {
            type: "bool",
            id: 1
          }
        }
      },
      StringValue: {
        fields: {
          value: {
            type: "string",
            id: 1
          }
        }
      },
      BytesValue: {
        fields: {
          value: {
            type: "bytes",
            id: 1
          }
        }
      }
    });
    common("field_mask", {
      FieldMask: {
        fields: {
          paths: {
            rule: "repeated",
            type: "string",
            id: 1
          }
        }
      }
    });
    common.get = function get(file) {
      return common[file] || null;
    };
  }
});

// node_modules/protobufjs/src/index.js
var require_src2 = __commonJS({
  "node_modules/protobufjs/src/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    var protobuf = module2.exports = require_index_light();
    protobuf.build = "full";
    protobuf.tokenize = require_tokenize();
    protobuf.parse = require_parse();
    protobuf.common = require_common();
    protobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);
  }
});

// node_modules/protobufjs/index.js
var require_protobufjs = __commonJS({
  "node_modules/protobufjs/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    module2.exports = require_src2();
  }
});

// node_modules/protobufjs/google/protobuf/descriptor.json
var require_descriptor = __commonJS({
  "node_modules/protobufjs/google/protobuf/descriptor.json"(exports2, module2) {
    module2.exports = {
      nested: {
        google: {
          nested: {
            protobuf: {
              nested: {
                FileDescriptorSet: {
                  fields: {
                    file: {
                      rule: "repeated",
                      type: "FileDescriptorProto",
                      id: 1
                    }
                  }
                },
                FileDescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    package: {
                      type: "string",
                      id: 2
                    },
                    dependency: {
                      rule: "repeated",
                      type: "string",
                      id: 3
                    },
                    publicDependency: {
                      rule: "repeated",
                      type: "int32",
                      id: 10,
                      options: {
                        packed: false
                      }
                    },
                    weakDependency: {
                      rule: "repeated",
                      type: "int32",
                      id: 11,
                      options: {
                        packed: false
                      }
                    },
                    messageType: {
                      rule: "repeated",
                      type: "DescriptorProto",
                      id: 4
                    },
                    enumType: {
                      rule: "repeated",
                      type: "EnumDescriptorProto",
                      id: 5
                    },
                    service: {
                      rule: "repeated",
                      type: "ServiceDescriptorProto",
                      id: 6
                    },
                    extension: {
                      rule: "repeated",
                      type: "FieldDescriptorProto",
                      id: 7
                    },
                    options: {
                      type: "FileOptions",
                      id: 8
                    },
                    sourceCodeInfo: {
                      type: "SourceCodeInfo",
                      id: 9
                    },
                    syntax: {
                      type: "string",
                      id: 12
                    }
                  }
                },
                DescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    field: {
                      rule: "repeated",
                      type: "FieldDescriptorProto",
                      id: 2
                    },
                    extension: {
                      rule: "repeated",
                      type: "FieldDescriptorProto",
                      id: 6
                    },
                    nestedType: {
                      rule: "repeated",
                      type: "DescriptorProto",
                      id: 3
                    },
                    enumType: {
                      rule: "repeated",
                      type: "EnumDescriptorProto",
                      id: 4
                    },
                    extensionRange: {
                      rule: "repeated",
                      type: "ExtensionRange",
                      id: 5
                    },
                    oneofDecl: {
                      rule: "repeated",
                      type: "OneofDescriptorProto",
                      id: 8
                    },
                    options: {
                      type: "MessageOptions",
                      id: 7
                    },
                    reservedRange: {
                      rule: "repeated",
                      type: "ReservedRange",
                      id: 9
                    },
                    reservedName: {
                      rule: "repeated",
                      type: "string",
                      id: 10
                    }
                  },
                  nested: {
                    ExtensionRange: {
                      fields: {
                        start: {
                          type: "int32",
                          id: 1
                        },
                        end: {
                          type: "int32",
                          id: 2
                        }
                      }
                    },
                    ReservedRange: {
                      fields: {
                        start: {
                          type: "int32",
                          id: 1
                        },
                        end: {
                          type: "int32",
                          id: 2
                        }
                      }
                    }
                  }
                },
                FieldDescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    number: {
                      type: "int32",
                      id: 3
                    },
                    label: {
                      type: "Label",
                      id: 4
                    },
                    type: {
                      type: "Type",
                      id: 5
                    },
                    typeName: {
                      type: "string",
                      id: 6
                    },
                    extendee: {
                      type: "string",
                      id: 2
                    },
                    defaultValue: {
                      type: "string",
                      id: 7
                    },
                    oneofIndex: {
                      type: "int32",
                      id: 9
                    },
                    jsonName: {
                      type: "string",
                      id: 10
                    },
                    options: {
                      type: "FieldOptions",
                      id: 8
                    }
                  },
                  nested: {
                    Type: {
                      values: {
                        TYPE_DOUBLE: 1,
                        TYPE_FLOAT: 2,
                        TYPE_INT64: 3,
                        TYPE_UINT64: 4,
                        TYPE_INT32: 5,
                        TYPE_FIXED64: 6,
                        TYPE_FIXED32: 7,
                        TYPE_BOOL: 8,
                        TYPE_STRING: 9,
                        TYPE_GROUP: 10,
                        TYPE_MESSAGE: 11,
                        TYPE_BYTES: 12,
                        TYPE_UINT32: 13,
                        TYPE_ENUM: 14,
                        TYPE_SFIXED32: 15,
                        TYPE_SFIXED64: 16,
                        TYPE_SINT32: 17,
                        TYPE_SINT64: 18
                      }
                    },
                    Label: {
                      values: {
                        LABEL_OPTIONAL: 1,
                        LABEL_REQUIRED: 2,
                        LABEL_REPEATED: 3
                      }
                    }
                  }
                },
                OneofDescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    options: {
                      type: "OneofOptions",
                      id: 2
                    }
                  }
                },
                EnumDescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    value: {
                      rule: "repeated",
                      type: "EnumValueDescriptorProto",
                      id: 2
                    },
                    options: {
                      type: "EnumOptions",
                      id: 3
                    }
                  }
                },
                EnumValueDescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    number: {
                      type: "int32",
                      id: 2
                    },
                    options: {
                      type: "EnumValueOptions",
                      id: 3
                    }
                  }
                },
                ServiceDescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    method: {
                      rule: "repeated",
                      type: "MethodDescriptorProto",
                      id: 2
                    },
                    options: {
                      type: "ServiceOptions",
                      id: 3
                    }
                  }
                },
                MethodDescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    inputType: {
                      type: "string",
                      id: 2
                    },
                    outputType: {
                      type: "string",
                      id: 3
                    },
                    options: {
                      type: "MethodOptions",
                      id: 4
                    },
                    clientStreaming: {
                      type: "bool",
                      id: 5
                    },
                    serverStreaming: {
                      type: "bool",
                      id: 6
                    }
                  }
                },
                FileOptions: {
                  fields: {
                    javaPackage: {
                      type: "string",
                      id: 1
                    },
                    javaOuterClassname: {
                      type: "string",
                      id: 8
                    },
                    javaMultipleFiles: {
                      type: "bool",
                      id: 10
                    },
                    javaGenerateEqualsAndHash: {
                      type: "bool",
                      id: 20,
                      options: {
                        deprecated: true
                      }
                    },
                    javaStringCheckUtf8: {
                      type: "bool",
                      id: 27
                    },
                    optimizeFor: {
                      type: "OptimizeMode",
                      id: 9,
                      options: {
                        default: "SPEED"
                      }
                    },
                    goPackage: {
                      type: "string",
                      id: 11
                    },
                    ccGenericServices: {
                      type: "bool",
                      id: 16
                    },
                    javaGenericServices: {
                      type: "bool",
                      id: 17
                    },
                    pyGenericServices: {
                      type: "bool",
                      id: 18
                    },
                    deprecated: {
                      type: "bool",
                      id: 23
                    },
                    ccEnableArenas: {
                      type: "bool",
                      id: 31
                    },
                    objcClassPrefix: {
                      type: "string",
                      id: 36
                    },
                    csharpNamespace: {
                      type: "string",
                      id: 37
                    },
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ],
                  reserved: [
                    [
                      38,
                      38
                    ]
                  ],
                  nested: {
                    OptimizeMode: {
                      values: {
                        SPEED: 1,
                        CODE_SIZE: 2,
                        LITE_RUNTIME: 3
                      }
                    }
                  }
                },
                MessageOptions: {
                  fields: {
                    messageSetWireFormat: {
                      type: "bool",
                      id: 1
                    },
                    noStandardDescriptorAccessor: {
                      type: "bool",
                      id: 2
                    },
                    deprecated: {
                      type: "bool",
                      id: 3
                    },
                    mapEntry: {
                      type: "bool",
                      id: 7
                    },
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ],
                  reserved: [
                    [
                      8,
                      8
                    ]
                  ]
                },
                FieldOptions: {
                  fields: {
                    ctype: {
                      type: "CType",
                      id: 1,
                      options: {
                        default: "STRING"
                      }
                    },
                    packed: {
                      type: "bool",
                      id: 2
                    },
                    jstype: {
                      type: "JSType",
                      id: 6,
                      options: {
                        default: "JS_NORMAL"
                      }
                    },
                    lazy: {
                      type: "bool",
                      id: 5
                    },
                    deprecated: {
                      type: "bool",
                      id: 3
                    },
                    weak: {
                      type: "bool",
                      id: 10
                    },
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ],
                  reserved: [
                    [
                      4,
                      4
                    ]
                  ],
                  nested: {
                    CType: {
                      values: {
                        STRING: 0,
                        CORD: 1,
                        STRING_PIECE: 2
                      }
                    },
                    JSType: {
                      values: {
                        JS_NORMAL: 0,
                        JS_STRING: 1,
                        JS_NUMBER: 2
                      }
                    }
                  }
                },
                OneofOptions: {
                  fields: {
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ]
                },
                EnumOptions: {
                  fields: {
                    allowAlias: {
                      type: "bool",
                      id: 2
                    },
                    deprecated: {
                      type: "bool",
                      id: 3
                    },
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ]
                },
                EnumValueOptions: {
                  fields: {
                    deprecated: {
                      type: "bool",
                      id: 1
                    },
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ]
                },
                ServiceOptions: {
                  fields: {
                    deprecated: {
                      type: "bool",
                      id: 33
                    },
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ]
                },
                MethodOptions: {
                  fields: {
                    deprecated: {
                      type: "bool",
                      id: 33
                    },
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ]
                },
                UninterpretedOption: {
                  fields: {
                    name: {
                      rule: "repeated",
                      type: "NamePart",
                      id: 2
                    },
                    identifierValue: {
                      type: "string",
                      id: 3
                    },
                    positiveIntValue: {
                      type: "uint64",
                      id: 4
                    },
                    negativeIntValue: {
                      type: "int64",
                      id: 5
                    },
                    doubleValue: {
                      type: "double",
                      id: 6
                    },
                    stringValue: {
                      type: "bytes",
                      id: 7
                    },
                    aggregateValue: {
                      type: "string",
                      id: 8
                    }
                  },
                  nested: {
                    NamePart: {
                      fields: {
                        namePart: {
                          rule: "required",
                          type: "string",
                          id: 1
                        },
                        isExtension: {
                          rule: "required",
                          type: "bool",
                          id: 2
                        }
                      }
                    }
                  }
                },
                SourceCodeInfo: {
                  fields: {
                    location: {
                      rule: "repeated",
                      type: "Location",
                      id: 1
                    }
                  },
                  nested: {
                    Location: {
                      fields: {
                        path: {
                          rule: "repeated",
                          type: "int32",
                          id: 1
                        },
                        span: {
                          rule: "repeated",
                          type: "int32",
                          id: 2
                        },
                        leadingComments: {
                          type: "string",
                          id: 3
                        },
                        trailingComments: {
                          type: "string",
                          id: 4
                        },
                        leadingDetachedComments: {
                          rule: "repeated",
                          type: "string",
                          id: 6
                        }
                      }
                    }
                  }
                },
                GeneratedCodeInfo: {
                  fields: {
                    annotation: {
                      rule: "repeated",
                      type: "Annotation",
                      id: 1
                    }
                  },
                  nested: {
                    Annotation: {
                      fields: {
                        path: {
                          rule: "repeated",
                          type: "int32",
                          id: 1
                        },
                        sourceFile: {
                          type: "string",
                          id: 2
                        },
                        begin: {
                          type: "int32",
                          id: 3
                        },
                        end: {
                          type: "int32",
                          id: 4
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/protobufjs/ext/descriptor/index.js
var require_descriptor2 = __commonJS({
  "node_modules/protobufjs/ext/descriptor/index.js"(exports2, module2) {
    init_shims();
    "use strict";
    var $protobuf = require_protobufjs();
    module2.exports = exports2 = $protobuf.descriptor = $protobuf.Root.fromJSON(require_descriptor()).lookup(".google.protobuf");
    var Namespace = $protobuf.Namespace;
    var Root2 = $protobuf.Root;
    var Enum = $protobuf.Enum;
    var Type = $protobuf.Type;
    var Field = $protobuf.Field;
    var MapField = $protobuf.MapField;
    var OneOf = $protobuf.OneOf;
    var Service = $protobuf.Service;
    var Method = $protobuf.Method;
    Root2.fromDescriptor = function fromDescriptor(descriptor) {
      if (typeof descriptor.length === "number")
        descriptor = exports2.FileDescriptorSet.decode(descriptor);
      var root = new Root2();
      if (descriptor.file) {
        var fileDescriptor, filePackage;
        for (var j = 0, i; j < descriptor.file.length; ++j) {
          filePackage = root;
          if ((fileDescriptor = descriptor.file[j])["package"] && fileDescriptor["package"].length)
            filePackage = root.define(fileDescriptor["package"]);
          if (fileDescriptor.name && fileDescriptor.name.length)
            root.files.push(filePackage.filename = fileDescriptor.name);
          if (fileDescriptor.messageType)
            for (i = 0; i < fileDescriptor.messageType.length; ++i)
              filePackage.add(Type.fromDescriptor(fileDescriptor.messageType[i], fileDescriptor.syntax));
          if (fileDescriptor.enumType)
            for (i = 0; i < fileDescriptor.enumType.length; ++i)
              filePackage.add(Enum.fromDescriptor(fileDescriptor.enumType[i]));
          if (fileDescriptor.extension)
            for (i = 0; i < fileDescriptor.extension.length; ++i)
              filePackage.add(Field.fromDescriptor(fileDescriptor.extension[i]));
          if (fileDescriptor.service)
            for (i = 0; i < fileDescriptor.service.length; ++i)
              filePackage.add(Service.fromDescriptor(fileDescriptor.service[i]));
          var opts = fromDescriptorOptions(fileDescriptor.options, exports2.FileOptions);
          if (opts) {
            var ks = Object.keys(opts);
            for (i = 0; i < ks.length; ++i)
              filePackage.setOption(ks[i], opts[ks[i]]);
          }
        }
      }
      return root;
    };
    Root2.prototype.toDescriptor = function toDescriptor(syntax) {
      var set2 = exports2.FileDescriptorSet.create();
      Root_toDescriptorRecursive(this, set2.file, syntax);
      return set2;
    };
    function Root_toDescriptorRecursive(ns, files, syntax) {
      var file = exports2.FileDescriptorProto.create({ name: ns.filename || (ns.fullName.substring(1).replace(/\./g, "_") || "root") + ".proto" });
      if (syntax)
        file.syntax = syntax;
      if (!(ns instanceof Root2))
        file["package"] = ns.fullName.substring(1);
      for (var i = 0, nested; i < ns.nestedArray.length; ++i)
        if ((nested = ns._nestedArray[i]) instanceof Type)
          file.messageType.push(nested.toDescriptor(syntax));
        else if (nested instanceof Enum)
          file.enumType.push(nested.toDescriptor());
        else if (nested instanceof Field)
          file.extension.push(nested.toDescriptor(syntax));
        else if (nested instanceof Service)
          file.service.push(nested.toDescriptor());
        else if (nested instanceof Namespace)
          Root_toDescriptorRecursive(nested, files, syntax);
      file.options = toDescriptorOptions(ns.options, exports2.FileOptions);
      if (file.messageType.length + file.enumType.length + file.extension.length + file.service.length)
        files.push(file);
    }
    var unnamedMessageIndex = 0;
    Type.fromDescriptor = function fromDescriptor(descriptor, syntax) {
      if (typeof descriptor.length === "number")
        descriptor = exports2.DescriptorProto.decode(descriptor);
      var type = new Type(descriptor.name.length ? descriptor.name : "Type" + unnamedMessageIndex++, fromDescriptorOptions(descriptor.options, exports2.MessageOptions)), i;
      if (descriptor.oneofDecl)
        for (i = 0; i < descriptor.oneofDecl.length; ++i)
          type.add(OneOf.fromDescriptor(descriptor.oneofDecl[i]));
      if (descriptor.field)
        for (i = 0; i < descriptor.field.length; ++i) {
          var field = Field.fromDescriptor(descriptor.field[i], syntax);
          type.add(field);
          if (descriptor.field[i].hasOwnProperty("oneofIndex"))
            type.oneofsArray[descriptor.field[i].oneofIndex].add(field);
        }
      if (descriptor.extension)
        for (i = 0; i < descriptor.extension.length; ++i)
          type.add(Field.fromDescriptor(descriptor.extension[i], syntax));
      if (descriptor.nestedType)
        for (i = 0; i < descriptor.nestedType.length; ++i) {
          type.add(Type.fromDescriptor(descriptor.nestedType[i], syntax));
          if (descriptor.nestedType[i].options && descriptor.nestedType[i].options.mapEntry)
            type.setOption("map_entry", true);
        }
      if (descriptor.enumType)
        for (i = 0; i < descriptor.enumType.length; ++i)
          type.add(Enum.fromDescriptor(descriptor.enumType[i]));
      if (descriptor.extensionRange && descriptor.extensionRange.length) {
        type.extensions = [];
        for (i = 0; i < descriptor.extensionRange.length; ++i)
          type.extensions.push([descriptor.extensionRange[i].start, descriptor.extensionRange[i].end]);
      }
      if (descriptor.reservedRange && descriptor.reservedRange.length || descriptor.reservedName && descriptor.reservedName.length) {
        type.reserved = [];
        if (descriptor.reservedRange)
          for (i = 0; i < descriptor.reservedRange.length; ++i)
            type.reserved.push([descriptor.reservedRange[i].start, descriptor.reservedRange[i].end]);
        if (descriptor.reservedName)
          for (i = 0; i < descriptor.reservedName.length; ++i)
            type.reserved.push(descriptor.reservedName[i]);
      }
      return type;
    };
    Type.prototype.toDescriptor = function toDescriptor(syntax) {
      var descriptor = exports2.DescriptorProto.create({ name: this.name }), i;
      for (i = 0; i < this.fieldsArray.length; ++i) {
        var fieldDescriptor;
        descriptor.field.push(fieldDescriptor = this._fieldsArray[i].toDescriptor(syntax));
        if (this._fieldsArray[i] instanceof MapField) {
          var keyType = toDescriptorType(this._fieldsArray[i].keyType, this._fieldsArray[i].resolvedKeyType), valueType = toDescriptorType(this._fieldsArray[i].type, this._fieldsArray[i].resolvedType), valueTypeName = valueType === 11 || valueType === 14 ? this._fieldsArray[i].resolvedType && shortname(this.parent, this._fieldsArray[i].resolvedType) || this._fieldsArray[i].type : void 0;
          descriptor.nestedType.push(exports2.DescriptorProto.create({
            name: fieldDescriptor.typeName,
            field: [
              exports2.FieldDescriptorProto.create({ name: "key", number: 1, label: 1, type: keyType }),
              exports2.FieldDescriptorProto.create({ name: "value", number: 2, label: 1, type: valueType, typeName: valueTypeName })
            ],
            options: exports2.MessageOptions.create({ mapEntry: true })
          }));
        }
      }
      for (i = 0; i < this.oneofsArray.length; ++i)
        descriptor.oneofDecl.push(this._oneofsArray[i].toDescriptor());
      for (i = 0; i < this.nestedArray.length; ++i) {
        if (this._nestedArray[i] instanceof Field)
          descriptor.field.push(this._nestedArray[i].toDescriptor(syntax));
        else if (this._nestedArray[i] instanceof Type)
          descriptor.nestedType.push(this._nestedArray[i].toDescriptor(syntax));
        else if (this._nestedArray[i] instanceof Enum)
          descriptor.enumType.push(this._nestedArray[i].toDescriptor());
      }
      if (this.extensions)
        for (i = 0; i < this.extensions.length; ++i)
          descriptor.extensionRange.push(exports2.DescriptorProto.ExtensionRange.create({ start: this.extensions[i][0], end: this.extensions[i][1] }));
      if (this.reserved)
        for (i = 0; i < this.reserved.length; ++i)
          if (typeof this.reserved[i] === "string")
            descriptor.reservedName.push(this.reserved[i]);
          else
            descriptor.reservedRange.push(exports2.DescriptorProto.ReservedRange.create({ start: this.reserved[i][0], end: this.reserved[i][1] }));
      descriptor.options = toDescriptorOptions(this.options, exports2.MessageOptions);
      return descriptor;
    };
    var numberRe = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;
    Field.fromDescriptor = function fromDescriptor(descriptor, syntax) {
      if (typeof descriptor.length === "number")
        descriptor = exports2.DescriptorProto.decode(descriptor);
      if (typeof descriptor.number !== "number")
        throw Error("missing field id");
      var fieldType;
      if (descriptor.typeName && descriptor.typeName.length)
        fieldType = descriptor.typeName;
      else
        fieldType = fromDescriptorType(descriptor.type);
      var fieldRule;
      switch (descriptor.label) {
        case 1:
          fieldRule = void 0;
          break;
        case 2:
          fieldRule = "required";
          break;
        case 3:
          fieldRule = "repeated";
          break;
        default:
          throw Error("illegal label: " + descriptor.label);
      }
      var extendee = descriptor.extendee;
      if (descriptor.extendee !== void 0) {
        extendee = extendee.length ? extendee : void 0;
      }
      var field = new Field(descriptor.name.length ? descriptor.name : "field" + descriptor.number, descriptor.number, fieldType, fieldRule, extendee);
      field.options = fromDescriptorOptions(descriptor.options, exports2.FieldOptions);
      if (descriptor.defaultValue && descriptor.defaultValue.length) {
        var defaultValue = descriptor.defaultValue;
        switch (defaultValue) {
          case "true":
          case "TRUE":
            defaultValue = true;
            break;
          case "false":
          case "FALSE":
            defaultValue = false;
            break;
          default:
            var match = numberRe.exec(defaultValue);
            if (match)
              defaultValue = parseInt(defaultValue);
            break;
        }
        field.setOption("default", defaultValue);
      }
      if (packableDescriptorType(descriptor.type)) {
        if (syntax === "proto3") {
          if (descriptor.options && !descriptor.options.packed)
            field.setOption("packed", false);
        } else if (!(descriptor.options && descriptor.options.packed))
          field.setOption("packed", false);
      }
      return field;
    };
    Field.prototype.toDescriptor = function toDescriptor(syntax) {
      var descriptor = exports2.FieldDescriptorProto.create({ name: this.name, number: this.id });
      if (this.map) {
        descriptor.type = 11;
        descriptor.typeName = $protobuf.util.ucFirst(this.name);
        descriptor.label = 3;
      } else {
        switch (descriptor.type = toDescriptorType(this.type, this.resolve().resolvedType)) {
          case 10:
          case 11:
          case 14:
            descriptor.typeName = this.resolvedType ? shortname(this.parent, this.resolvedType) : this.type;
            break;
        }
        switch (this.rule) {
          case "repeated":
            descriptor.label = 3;
            break;
          case "required":
            descriptor.label = 2;
            break;
          default:
            descriptor.label = 1;
            break;
        }
      }
      descriptor.extendee = this.extensionField ? this.extensionField.parent.fullName : this.extend;
      if (this.partOf) {
        if ((descriptor.oneofIndex = this.parent.oneofsArray.indexOf(this.partOf)) < 0)
          throw Error("missing oneof");
      }
      if (this.options) {
        descriptor.options = toDescriptorOptions(this.options, exports2.FieldOptions);
        if (this.options["default"] != null)
          descriptor.defaultValue = String(this.options["default"]);
      }
      if (syntax === "proto3") {
        if (!this.packed)
          (descriptor.options || (descriptor.options = exports2.FieldOptions.create())).packed = false;
      } else if (this.packed)
        (descriptor.options || (descriptor.options = exports2.FieldOptions.create())).packed = true;
      return descriptor;
    };
    var unnamedEnumIndex = 0;
    Enum.fromDescriptor = function fromDescriptor(descriptor) {
      if (typeof descriptor.length === "number")
        descriptor = exports2.EnumDescriptorProto.decode(descriptor);
      var values = {};
      if (descriptor.value)
        for (var i = 0; i < descriptor.value.length; ++i) {
          var name2 = descriptor.value[i].name, value = descriptor.value[i].number || 0;
          values[name2 && name2.length ? name2 : "NAME" + value] = value;
        }
      return new Enum(descriptor.name && descriptor.name.length ? descriptor.name : "Enum" + unnamedEnumIndex++, values, fromDescriptorOptions(descriptor.options, exports2.EnumOptions));
    };
    Enum.prototype.toDescriptor = function toDescriptor() {
      var values = [];
      for (var i = 0, ks = Object.keys(this.values); i < ks.length; ++i)
        values.push(exports2.EnumValueDescriptorProto.create({ name: ks[i], number: this.values[ks[i]] }));
      return exports2.EnumDescriptorProto.create({
        name: this.name,
        value: values,
        options: toDescriptorOptions(this.options, exports2.EnumOptions)
      });
    };
    var unnamedOneofIndex = 0;
    OneOf.fromDescriptor = function fromDescriptor(descriptor) {
      if (typeof descriptor.length === "number")
        descriptor = exports2.OneofDescriptorProto.decode(descriptor);
      return new OneOf(descriptor.name && descriptor.name.length ? descriptor.name : "oneof" + unnamedOneofIndex++);
    };
    OneOf.prototype.toDescriptor = function toDescriptor() {
      return exports2.OneofDescriptorProto.create({
        name: this.name
      });
    };
    var unnamedServiceIndex = 0;
    Service.fromDescriptor = function fromDescriptor(descriptor) {
      if (typeof descriptor.length === "number")
        descriptor = exports2.ServiceDescriptorProto.decode(descriptor);
      var service = new Service(descriptor.name && descriptor.name.length ? descriptor.name : "Service" + unnamedServiceIndex++, fromDescriptorOptions(descriptor.options, exports2.ServiceOptions));
      if (descriptor.method)
        for (var i = 0; i < descriptor.method.length; ++i)
          service.add(Method.fromDescriptor(descriptor.method[i]));
      return service;
    };
    Service.prototype.toDescriptor = function toDescriptor() {
      var methods = [];
      for (var i = 0; i < this.methodsArray.length; ++i)
        methods.push(this._methodsArray[i].toDescriptor());
      return exports2.ServiceDescriptorProto.create({
        name: this.name,
        method: methods,
        options: toDescriptorOptions(this.options, exports2.ServiceOptions)
      });
    };
    var unnamedMethodIndex = 0;
    Method.fromDescriptor = function fromDescriptor(descriptor) {
      if (typeof descriptor.length === "number")
        descriptor = exports2.MethodDescriptorProto.decode(descriptor);
      return new Method(descriptor.name && descriptor.name.length ? descriptor.name : "Method" + unnamedMethodIndex++, "rpc", descriptor.inputType, descriptor.outputType, Boolean(descriptor.clientStreaming), Boolean(descriptor.serverStreaming), fromDescriptorOptions(descriptor.options, exports2.MethodOptions));
    };
    Method.prototype.toDescriptor = function toDescriptor() {
      return exports2.MethodDescriptorProto.create({
        name: this.name,
        inputType: this.resolvedRequestType ? this.resolvedRequestType.fullName : this.requestType,
        outputType: this.resolvedResponseType ? this.resolvedResponseType.fullName : this.responseType,
        clientStreaming: this.requestStream,
        serverStreaming: this.responseStream,
        options: toDescriptorOptions(this.options, exports2.MethodOptions)
      });
    };
    function fromDescriptorType(type) {
      switch (type) {
        case 1:
          return "double";
        case 2:
          return "float";
        case 3:
          return "int64";
        case 4:
          return "uint64";
        case 5:
          return "int32";
        case 6:
          return "fixed64";
        case 7:
          return "fixed32";
        case 8:
          return "bool";
        case 9:
          return "string";
        case 12:
          return "bytes";
        case 13:
          return "uint32";
        case 15:
          return "sfixed32";
        case 16:
          return "sfixed64";
        case 17:
          return "sint32";
        case 18:
          return "sint64";
      }
      throw Error("illegal type: " + type);
    }
    function packableDescriptorType(type) {
      switch (type) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
          return true;
      }
      return false;
    }
    function toDescriptorType(type, resolvedType) {
      switch (type) {
        case "double":
          return 1;
        case "float":
          return 2;
        case "int64":
          return 3;
        case "uint64":
          return 4;
        case "int32":
          return 5;
        case "fixed64":
          return 6;
        case "fixed32":
          return 7;
        case "bool":
          return 8;
        case "string":
          return 9;
        case "bytes":
          return 12;
        case "uint32":
          return 13;
        case "sfixed32":
          return 15;
        case "sfixed64":
          return 16;
        case "sint32":
          return 17;
        case "sint64":
          return 18;
      }
      if (resolvedType instanceof Enum)
        return 14;
      if (resolvedType instanceof Type)
        return resolvedType.group ? 10 : 11;
      throw Error("illegal type: " + type);
    }
    function fromDescriptorOptions(options2, type) {
      if (!options2)
        return void 0;
      var out = [];
      for (var i = 0, field, key, val; i < type.fieldsArray.length; ++i)
        if ((key = (field = type._fieldsArray[i]).name) !== "uninterpretedOption") {
          if (options2.hasOwnProperty(key)) {
            val = options2[key];
            if (field.resolvedType instanceof Enum && typeof val === "number" && field.resolvedType.valuesById[val] !== void 0)
              val = field.resolvedType.valuesById[val];
            out.push(underScore(key), val);
          }
        }
      return out.length ? $protobuf.util.toObject(out) : void 0;
    }
    function toDescriptorOptions(options2, type) {
      if (!options2)
        return void 0;
      var out = [];
      for (var i = 0, ks = Object.keys(options2), key, val; i < ks.length; ++i) {
        val = options2[key = ks[i]];
        if (key === "default")
          continue;
        var field = type.fields[key];
        if (!field && !(field = type.fields[key = $protobuf.util.camelCase(key)]))
          continue;
        out.push(key, val);
      }
      return out.length ? type.fromObject($protobuf.util.toObject(out)) : void 0;
    }
    function shortname(from, to) {
      var fromPath = from.fullName.split("."), toPath = to.fullName.split("."), i = 0, j = 0, k = toPath.length - 1;
      if (!(from instanceof Root2) && to instanceof Namespace)
        while (i < fromPath.length && j < k && fromPath[i] === toPath[j]) {
          var other = to.lookup(fromPath[i++], true);
          if (other !== null && other !== to)
            break;
          ++j;
        }
      else
        for (; i < fromPath.length && j < k && fromPath[i] === toPath[j]; ++i, ++j)
          ;
      return toPath.slice(j).join(".");
    }
    function underScore(str) {
      return str.substring(0, 1) + str.substring(1).replace(/([A-Z])(?=[a-z]|$)/g, function($0, $1) {
        return "_" + $1.toLowerCase();
      });
    }
  }
});

// node_modules/protobufjs/google/protobuf/api.json
var require_api = __commonJS({
  "node_modules/protobufjs/google/protobuf/api.json"(exports2, module2) {
    module2.exports = {
      nested: {
        google: {
          nested: {
            protobuf: {
              nested: {
                Api: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    methods: {
                      rule: "repeated",
                      type: "Method",
                      id: 2
                    },
                    options: {
                      rule: "repeated",
                      type: "Option",
                      id: 3
                    },
                    version: {
                      type: "string",
                      id: 4
                    },
                    sourceContext: {
                      type: "SourceContext",
                      id: 5
                    },
                    mixins: {
                      rule: "repeated",
                      type: "Mixin",
                      id: 6
                    },
                    syntax: {
                      type: "Syntax",
                      id: 7
                    }
                  }
                },
                Method: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    requestTypeUrl: {
                      type: "string",
                      id: 2
                    },
                    requestStreaming: {
                      type: "bool",
                      id: 3
                    },
                    responseTypeUrl: {
                      type: "string",
                      id: 4
                    },
                    responseStreaming: {
                      type: "bool",
                      id: 5
                    },
                    options: {
                      rule: "repeated",
                      type: "Option",
                      id: 6
                    },
                    syntax: {
                      type: "Syntax",
                      id: 7
                    }
                  }
                },
                Mixin: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    root: {
                      type: "string",
                      id: 2
                    }
                  }
                },
                SourceContext: {
                  fields: {
                    fileName: {
                      type: "string",
                      id: 1
                    }
                  }
                },
                Option: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    value: {
                      type: "Any",
                      id: 2
                    }
                  }
                },
                Syntax: {
                  values: {
                    SYNTAX_PROTO2: 0,
                    SYNTAX_PROTO3: 1
                  }
                }
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/protobufjs/google/protobuf/source_context.json
var require_source_context = __commonJS({
  "node_modules/protobufjs/google/protobuf/source_context.json"(exports2, module2) {
    module2.exports = {
      nested: {
        google: {
          nested: {
            protobuf: {
              nested: {
                SourceContext: {
                  fields: {
                    fileName: {
                      type: "string",
                      id: 1
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/protobufjs/google/protobuf/type.json
var require_type2 = __commonJS({
  "node_modules/protobufjs/google/protobuf/type.json"(exports2, module2) {
    module2.exports = {
      nested: {
        google: {
          nested: {
            protobuf: {
              nested: {
                Type: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    fields: {
                      rule: "repeated",
                      type: "Field",
                      id: 2
                    },
                    oneofs: {
                      rule: "repeated",
                      type: "string",
                      id: 3
                    },
                    options: {
                      rule: "repeated",
                      type: "Option",
                      id: 4
                    },
                    sourceContext: {
                      type: "SourceContext",
                      id: 5
                    },
                    syntax: {
                      type: "Syntax",
                      id: 6
                    }
                  }
                },
                Field: {
                  fields: {
                    kind: {
                      type: "Kind",
                      id: 1
                    },
                    cardinality: {
                      type: "Cardinality",
                      id: 2
                    },
                    number: {
                      type: "int32",
                      id: 3
                    },
                    name: {
                      type: "string",
                      id: 4
                    },
                    typeUrl: {
                      type: "string",
                      id: 6
                    },
                    oneofIndex: {
                      type: "int32",
                      id: 7
                    },
                    packed: {
                      type: "bool",
                      id: 8
                    },
                    options: {
                      rule: "repeated",
                      type: "Option",
                      id: 9
                    },
                    jsonName: {
                      type: "string",
                      id: 10
                    },
                    defaultValue: {
                      type: "string",
                      id: 11
                    }
                  },
                  nested: {
                    Kind: {
                      values: {
                        TYPE_UNKNOWN: 0,
                        TYPE_DOUBLE: 1,
                        TYPE_FLOAT: 2,
                        TYPE_INT64: 3,
                        TYPE_UINT64: 4,
                        TYPE_INT32: 5,
                        TYPE_FIXED64: 6,
                        TYPE_FIXED32: 7,
                        TYPE_BOOL: 8,
                        TYPE_STRING: 9,
                        TYPE_GROUP: 10,
                        TYPE_MESSAGE: 11,
                        TYPE_BYTES: 12,
                        TYPE_UINT32: 13,
                        TYPE_ENUM: 14,
                        TYPE_SFIXED32: 15,
                        TYPE_SFIXED64: 16,
                        TYPE_SINT32: 17,
                        TYPE_SINT64: 18
                      }
                    },
                    Cardinality: {
                      values: {
                        CARDINALITY_UNKNOWN: 0,
                        CARDINALITY_OPTIONAL: 1,
                        CARDINALITY_REQUIRED: 2,
                        CARDINALITY_REPEATED: 3
                      }
                    }
                  }
                },
                Enum: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    enumvalue: {
                      rule: "repeated",
                      type: "EnumValue",
                      id: 2
                    },
                    options: {
                      rule: "repeated",
                      type: "Option",
                      id: 3
                    },
                    sourceContext: {
                      type: "SourceContext",
                      id: 4
                    },
                    syntax: {
                      type: "Syntax",
                      id: 5
                    }
                  }
                },
                EnumValue: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    number: {
                      type: "int32",
                      id: 2
                    },
                    options: {
                      rule: "repeated",
                      type: "Option",
                      id: 3
                    }
                  }
                },
                Option: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    value: {
                      type: "Any",
                      id: 2
                    }
                  }
                },
                Syntax: {
                  values: {
                    SYNTAX_PROTO2: 0,
                    SYNTAX_PROTO3: 1
                  }
                },
                Any: {
                  fields: {
                    type_url: {
                      type: "string",
                      id: 1
                    },
                    value: {
                      type: "bytes",
                      id: 2
                    }
                  }
                },
                SourceContext: {
                  fields: {
                    fileName: {
                      type: "string",
                      id: 1
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/@grpc/proto-loader/build/src/util.js
var require_util2 = __commonJS({
  "node_modules/@grpc/proto-loader/build/src/util.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var fs = require("fs");
    var path = require("path");
    var Protobuf = require_protobufjs();
    function addIncludePathResolver(root, includePaths) {
      const originalResolvePath = root.resolvePath;
      root.resolvePath = (origin, target) => {
        if (path.isAbsolute(target)) {
          return target;
        }
        for (const directory of includePaths) {
          const fullPath = path.join(directory, target);
          try {
            fs.accessSync(fullPath, fs.constants.R_OK);
            return fullPath;
          } catch (err) {
            continue;
          }
        }
        process.emitWarning(`${target} not found in any of the include paths ${includePaths}`);
        return originalResolvePath(origin, target);
      };
    }
    async function loadProtosWithOptions(filename, options2) {
      const root = new Protobuf.Root();
      options2 = options2 || {};
      if (!!options2.includeDirs) {
        if (!Array.isArray(options2.includeDirs)) {
          return Promise.reject(new Error("The includeDirs option must be an array"));
        }
        addIncludePathResolver(root, options2.includeDirs);
      }
      const loadedRoot = await root.load(filename, options2);
      loadedRoot.resolveAll();
      return loadedRoot;
    }
    exports2.loadProtosWithOptions = loadProtosWithOptions;
    function loadProtosWithOptionsSync(filename, options2) {
      const root = new Protobuf.Root();
      options2 = options2 || {};
      if (!!options2.includeDirs) {
        if (!Array.isArray(options2.includeDirs)) {
          throw new Error("The includeDirs option must be an array");
        }
        addIncludePathResolver(root, options2.includeDirs);
      }
      const loadedRoot = root.loadSync(filename, options2);
      loadedRoot.resolveAll();
      return loadedRoot;
    }
    exports2.loadProtosWithOptionsSync = loadProtosWithOptionsSync;
    function addCommonProtos() {
      const apiDescriptor = require_api();
      const descriptorDescriptor = require_descriptor();
      const sourceContextDescriptor = require_source_context();
      const typeDescriptor = require_type2();
      Protobuf.common("api", apiDescriptor.nested.google.nested.protobuf.nested);
      Protobuf.common("descriptor", descriptorDescriptor.nested.google.nested.protobuf.nested);
      Protobuf.common("source_context", sourceContextDescriptor.nested.google.nested.protobuf.nested);
      Protobuf.common("type", typeDescriptor.nested.google.nested.protobuf.nested);
    }
    exports2.addCommonProtos = addCommonProtos;
  }
});

// node_modules/@grpc/proto-loader/build/src/index.js
var require_src3 = __commonJS({
  "node_modules/@grpc/proto-loader/build/src/index.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var camelCase = require_lodash();
    var Protobuf = require_protobufjs();
    var descriptor = require_descriptor2();
    var util_1 = require_util2();
    function isAnyExtension(obj) {
      return "@type" in obj && typeof obj["@type"] === "string";
    }
    exports2.isAnyExtension = isAnyExtension;
    var descriptorOptions = {
      longs: String,
      enums: String,
      bytes: String,
      defaults: true,
      oneofs: true,
      json: true
    };
    function joinName(baseName, name2) {
      if (baseName === "") {
        return name2;
      } else {
        return baseName + "." + name2;
      }
    }
    function isHandledReflectionObject(obj) {
      return obj instanceof Protobuf.Service || obj instanceof Protobuf.Type || obj instanceof Protobuf.Enum;
    }
    function isNamespaceBase(obj) {
      return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;
    }
    function getAllHandledReflectionObjects(obj, parentName) {
      const objName = joinName(parentName, obj.name);
      if (isHandledReflectionObject(obj)) {
        return [[objName, obj]];
      } else {
        if (isNamespaceBase(obj) && typeof obj.nested !== "undefined") {
          return Object.keys(obj.nested).map((name2) => {
            return getAllHandledReflectionObjects(obj.nested[name2], objName);
          }).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);
        }
      }
      return [];
    }
    function createDeserializer(cls, options2) {
      return function deserialize(argBuf) {
        return cls.toObject(cls.decode(argBuf), options2);
      };
    }
    function createSerializer(cls) {
      return function serialize(arg) {
        const message = cls.fromObject(arg);
        return cls.encode(message).finish();
      };
    }
    function createMethodDefinition(method, serviceName, options2, fileDescriptors) {
      const requestType = method.resolvedRequestType;
      const responseType = method.resolvedResponseType;
      return {
        path: "/" + serviceName + "/" + method.name,
        requestStream: !!method.requestStream,
        responseStream: !!method.responseStream,
        requestSerialize: createSerializer(requestType),
        requestDeserialize: createDeserializer(requestType, options2),
        responseSerialize: createSerializer(responseType),
        responseDeserialize: createDeserializer(responseType, options2),
        originalName: camelCase(method.name),
        requestType: createMessageDefinition(requestType, fileDescriptors),
        responseType: createMessageDefinition(responseType, fileDescriptors)
      };
    }
    function createServiceDefinition(service, name2, options2, fileDescriptors) {
      const def = {};
      for (const method of service.methodsArray) {
        def[method.name] = createMethodDefinition(method, name2, options2, fileDescriptors);
      }
      return def;
    }
    function createMessageDefinition(message, fileDescriptors) {
      const messageDescriptor = message.toDescriptor("proto3");
      return {
        format: "Protocol Buffer 3 DescriptorProto",
        type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),
        fileDescriptorProtos: fileDescriptors
      };
    }
    function createEnumDefinition(enumType, fileDescriptors) {
      const enumDescriptor = enumType.toDescriptor("proto3");
      return {
        format: "Protocol Buffer 3 EnumDescriptorProto",
        type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),
        fileDescriptorProtos: fileDescriptors
      };
    }
    function createDefinition(obj, name2, options2, fileDescriptors) {
      if (obj instanceof Protobuf.Service) {
        return createServiceDefinition(obj, name2, options2, fileDescriptors);
      } else if (obj instanceof Protobuf.Type) {
        return createMessageDefinition(obj, fileDescriptors);
      } else if (obj instanceof Protobuf.Enum) {
        return createEnumDefinition(obj, fileDescriptors);
      } else {
        throw new Error("Type mismatch in reflection object handling");
      }
    }
    function createPackageDefinition(root, options2) {
      const def = {};
      root.resolveAll();
      const descriptorList = root.toDescriptor("proto3").file;
      const bufferList = descriptorList.map((value) => Buffer.from(descriptor.FileDescriptorProto.encode(value).finish()));
      for (const [name2, obj] of getAllHandledReflectionObjects(root, "")) {
        def[name2] = createDefinition(obj, name2, options2, bufferList);
      }
      return def;
    }
    function createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options2) {
      options2 = options2 || {};
      const root = Protobuf.Root.fromDescriptor(decodedDescriptorSet);
      root.resolveAll();
      return createPackageDefinition(root, options2);
    }
    function load2(filename, options2) {
      return util_1.loadProtosWithOptions(filename, options2).then((loadedRoot) => {
        return createPackageDefinition(loadedRoot, options2);
      });
    }
    exports2.load = load2;
    function loadSync(filename, options2) {
      const loadedRoot = util_1.loadProtosWithOptionsSync(filename, options2);
      return createPackageDefinition(loadedRoot, options2);
    }
    exports2.loadSync = loadSync;
    function fromJSON(json, options2) {
      options2 = options2 || {};
      const loadedRoot = Protobuf.Root.fromJSON(json);
      loadedRoot.resolveAll();
      return createPackageDefinition(loadedRoot, options2);
    }
    exports2.fromJSON = fromJSON;
    function loadFileDescriptorSetFromBuffer(descriptorSet, options2) {
      const decodedDescriptorSet = descriptor.FileDescriptorSet.decode(descriptorSet);
      return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options2);
    }
    exports2.loadFileDescriptorSetFromBuffer = loadFileDescriptorSetFromBuffer;
    function loadFileDescriptorSetFromObject(descriptorSet, options2) {
      const decodedDescriptorSet = descriptor.FileDescriptorSet.fromObject(descriptorSet);
      return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options2);
    }
    exports2.loadFileDescriptorSetFromObject = loadFileDescriptorSetFromObject;
    util_1.addCommonProtos();
  }
});

// node_modules/@firebase/firestore/dist/index.node.cjs.js
var require_index_node_cjs2 = __commonJS({
  "node_modules/@firebase/firestore/dist/index.node.cjs.js"(exports2) {
    init_shims();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tslib2 = require_tslib();
    var app = require_index_cjs3();
    var component = require_index_cjs();
    var logger2 = require_index_cjs2();
    var util$1 = require("util");
    var util = require_index_node_cjs();
    var crypto = require("crypto");
    var grpcJs = require_src();
    var package_json = require_package();
    var path = require("path");
    var protoLoader = require_src3();
    var name2 = "@firebase/firestore";
    var version$12 = "3.1.0";
    var User = function() {
      function User2(uid) {
        this.uid = uid;
      }
      User2.prototype.isAuthenticated = function() {
        return this.uid != null;
      };
      User2.prototype.toKey = function() {
        if (this.isAuthenticated()) {
          return "uid:" + this.uid;
        } else {
          return "anonymous-user";
        }
      };
      User2.prototype.isEqual = function(otherUser) {
        return otherUser.uid === this.uid;
      };
      return User2;
    }();
    User.UNAUTHENTICATED = new User(null);
    User.GOOGLE_CREDENTIALS = new User("google-credentials-uid");
    User.FIRST_PARTY = new User("first-party-uid");
    User.MOCK_USER = new User("mock-user");
    var version2 = "9.1.0";
    var SDK_VERSION2 = version2;
    function setSDKVersion(version3) {
      SDK_VERSION2 = version3;
    }
    function formatJSON(value) {
      return util$1.inspect(value, { depth: 100 });
    }
    var logClient2 = new logger2.Logger("@firebase/firestore");
    function getLogLevel() {
      return logClient2.logLevel;
    }
    function setLogLevel(logLevel) {
      logClient2.setLogLevel(logLevel);
    }
    function logDebug(msg) {
      var obj = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        obj[_i - 1] = arguments[_i];
      }
      if (logClient2.logLevel <= logger2.LogLevel.DEBUG) {
        var args = obj.map(argToString);
        logClient2.debug.apply(logClient2, tslib2.__spreadArray(["Firestore (" + SDK_VERSION2 + "): " + msg], args));
      }
    }
    function logError(msg) {
      var obj = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        obj[_i - 1] = arguments[_i];
      }
      if (logClient2.logLevel <= logger2.LogLevel.ERROR) {
        var args = obj.map(argToString);
        logClient2.error.apply(logClient2, tslib2.__spreadArray(["Firestore (" + SDK_VERSION2 + "): " + msg], args));
      }
    }
    function logWarn(msg) {
      var obj = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        obj[_i - 1] = arguments[_i];
      }
      if (logClient2.logLevel <= logger2.LogLevel.WARN) {
        var args = obj.map(argToString);
        logClient2.warn.apply(logClient2, tslib2.__spreadArray(["Firestore (" + SDK_VERSION2 + "): " + msg], args));
      }
    }
    function argToString(obj) {
      if (typeof obj === "string") {
        return obj;
      } else {
        try {
          return formatJSON(obj);
        } catch (e) {
          return obj;
        }
      }
    }
    function fail(failure) {
      if (failure === void 0) {
        failure = "Unexpected state";
      }
      var message = "FIRESTORE (" + SDK_VERSION2 + ") INTERNAL ASSERTION FAILED: " + failure;
      logError(message);
      throw new Error(message);
    }
    function hardAssert(assertion, message) {
      if (!assertion) {
        fail();
      }
    }
    function debugAssert2(assertion, message) {
      if (!assertion) {
        fail();
      }
    }
    function debugCast(obj, constructor) {
      return obj;
    }
    var Code = {
      OK: "ok",
      CANCELLED: "cancelled",
      UNKNOWN: "unknown",
      INVALID_ARGUMENT: "invalid-argument",
      DEADLINE_EXCEEDED: "deadline-exceeded",
      NOT_FOUND: "not-found",
      ALREADY_EXISTS: "already-exists",
      PERMISSION_DENIED: "permission-denied",
      UNAUTHENTICATED: "unauthenticated",
      RESOURCE_EXHAUSTED: "resource-exhausted",
      FAILED_PRECONDITION: "failed-precondition",
      ABORTED: "aborted",
      OUT_OF_RANGE: "out-of-range",
      UNIMPLEMENTED: "unimplemented",
      INTERNAL: "internal",
      UNAVAILABLE: "unavailable",
      DATA_LOSS: "data-loss"
    };
    var FirestoreError = function(_super) {
      tslib2.__extends(FirestoreError2, _super);
      function FirestoreError2(code, message) {
        var _this = _super.call(this, message) || this;
        _this.code = code;
        _this.message = message;
        _this.name = "FirebaseError";
        _this.toString = function() {
          return _this.name + ": [code=" + _this.code + "]: " + _this.message;
        };
        return _this;
      }
      return FirestoreError2;
    }(Error);
    var Deferred2 = function() {
      function Deferred3() {
        var _this = this;
        this.promise = new Promise(function(resolve2, reject) {
          _this.resolve = resolve2;
          _this.reject = reject;
        });
      }
      return Deferred3;
    }();
    var OAuthToken = function() {
      function OAuthToken2(value, user2) {
        this.user = user2;
        this.type = "OAuth";
        this.authHeaders = {};
        this.authHeaders["Authorization"] = "Bearer " + value;
      }
      return OAuthToken2;
    }();
    var EmptyCredentialsProvider = function() {
      function EmptyCredentialsProvider2() {
      }
      EmptyCredentialsProvider2.prototype.getToken = function() {
        return Promise.resolve(null);
      };
      EmptyCredentialsProvider2.prototype.invalidateToken = function() {
      };
      EmptyCredentialsProvider2.prototype.start = function(asyncQueue, changeListener) {
        asyncQueue.enqueueRetryable(function() {
          return changeListener(User.UNAUTHENTICATED);
        });
      };
      EmptyCredentialsProvider2.prototype.shutdown = function() {
      };
      return EmptyCredentialsProvider2;
    }();
    var EmulatorCredentialsProvider = function() {
      function EmulatorCredentialsProvider2(token) {
        this.token = token;
        this.changeListener = null;
      }
      EmulatorCredentialsProvider2.prototype.getToken = function() {
        return Promise.resolve(this.token);
      };
      EmulatorCredentialsProvider2.prototype.invalidateToken = function() {
      };
      EmulatorCredentialsProvider2.prototype.start = function(asyncQueue, changeListener) {
        var _this = this;
        this.changeListener = changeListener;
        asyncQueue.enqueueRetryable(function() {
          return changeListener(_this.token.user);
        });
      };
      EmulatorCredentialsProvider2.prototype.shutdown = function() {
        this.changeListener = null;
      };
      return EmulatorCredentialsProvider2;
    }();
    var FirebaseCredentialsProvider = function() {
      function FirebaseCredentialsProvider2(authProvider) {
        this.authProvider = authProvider;
        this.currentUser = User.UNAUTHENTICATED;
        this.tokenCounter = 0;
        this.forceRefresh = false;
        this.auth = null;
      }
      FirebaseCredentialsProvider2.prototype.start = function(asyncQueue, changeListener) {
        var _this = this;
        var lastTokenId = this.tokenCounter;
        var guardedChangeListener = function(user2) {
          if (_this.tokenCounter !== lastTokenId) {
            lastTokenId = _this.tokenCounter;
            return changeListener(user2);
          } else {
            return Promise.resolve();
          }
        };
        var nextToken = new Deferred2();
        this.tokenListener = function() {
          _this.tokenCounter++;
          _this.currentUser = _this.getUser();
          nextToken.resolve();
          nextToken = new Deferred2();
          asyncQueue.enqueueRetryable(function() {
            return guardedChangeListener(_this.currentUser);
          });
        };
        var awaitNextToken = function() {
          var currentTokenAttempt = nextToken;
          asyncQueue.enqueueRetryable(function() {
            return tslib2.__awaiter(_this, void 0, void 0, function() {
              return tslib2.__generator(this, function(_d) {
                switch (_d.label) {
                  case 0:
                    return [4, currentTokenAttempt.promise];
                  case 1:
                    _d.sent();
                    return [4, guardedChangeListener(this.currentUser)];
                  case 2:
                    _d.sent();
                    return [2];
                }
              });
            });
          });
        };
        var registerAuth2 = function(auth2) {
          logDebug("FirebaseCredentialsProvider", "Auth detected");
          _this.auth = auth2;
          _this.auth.addAuthTokenListener(_this.tokenListener);
          awaitNextToken();
        };
        this.authProvider.onInit(function(auth2) {
          return registerAuth2(auth2);
        });
        setTimeout(function() {
          if (!_this.auth) {
            var auth2 = _this.authProvider.getImmediate({ optional: true });
            if (auth2) {
              registerAuth2(auth2);
            } else {
              logDebug("FirebaseCredentialsProvider", "Auth not yet detected");
              nextToken.resolve();
              nextToken = new Deferred2();
            }
          }
        }, 0);
        awaitNextToken();
      };
      FirebaseCredentialsProvider2.prototype.getToken = function() {
        var _this = this;
        var initialTokenCounter = this.tokenCounter;
        var forceRefresh = this.forceRefresh;
        this.forceRefresh = false;
        if (!this.auth) {
          return Promise.resolve(null);
        }
        return this.auth.getToken(forceRefresh).then(function(tokenData) {
          if (_this.tokenCounter !== initialTokenCounter) {
            logDebug("FirebaseCredentialsProvider", "getToken aborted due to token change.");
            return _this.getToken();
          } else {
            if (tokenData) {
              hardAssert(typeof tokenData.accessToken === "string");
              return new OAuthToken(tokenData.accessToken, _this.currentUser);
            } else {
              return null;
            }
          }
        });
      };
      FirebaseCredentialsProvider2.prototype.invalidateToken = function() {
        this.forceRefresh = true;
      };
      FirebaseCredentialsProvider2.prototype.shutdown = function() {
        if (this.auth) {
          this.auth.removeAuthTokenListener(this.tokenListener);
        }
      };
      FirebaseCredentialsProvider2.prototype.getUser = function() {
        var currentUid = this.auth && this.auth.getUid();
        hardAssert(currentUid === null || typeof currentUid === "string");
        return new User(currentUid);
      };
      return FirebaseCredentialsProvider2;
    }();
    var FirstPartyToken = function() {
      function FirstPartyToken2(gapi2, sessionIndex, iamToken) {
        this.gapi = gapi2;
        this.sessionIndex = sessionIndex;
        this.iamToken = iamToken;
        this.type = "FirstParty";
        this.user = User.FIRST_PARTY;
      }
      Object.defineProperty(FirstPartyToken2.prototype, "authHeaders", {
        get: function() {
          var headers = {
            "X-Goog-AuthUser": this.sessionIndex
          };
          var authHeader = this.gapi["auth"]["getAuthHeaderValueForFirstParty"]([]);
          if (authHeader) {
            headers["Authorization"] = authHeader;
          }
          if (this.iamToken) {
            headers["X-Goog-Iam-Authorization-Token"] = this.iamToken;
          }
          return headers;
        },
        enumerable: false,
        configurable: true
      });
      return FirstPartyToken2;
    }();
    var FirstPartyCredentialsProvider = function() {
      function FirstPartyCredentialsProvider2(gapi2, sessionIndex, iamToken) {
        this.gapi = gapi2;
        this.sessionIndex = sessionIndex;
        this.iamToken = iamToken;
      }
      FirstPartyCredentialsProvider2.prototype.getToken = function() {
        return Promise.resolve(new FirstPartyToken(this.gapi, this.sessionIndex, this.iamToken));
      };
      FirstPartyCredentialsProvider2.prototype.start = function(asyncQueue, changeListener) {
        asyncQueue.enqueueRetryable(function() {
          return changeListener(User.FIRST_PARTY);
        });
      };
      FirstPartyCredentialsProvider2.prototype.shutdown = function() {
      };
      FirstPartyCredentialsProvider2.prototype.invalidateToken = function() {
      };
      return FirstPartyCredentialsProvider2;
    }();
    function makeCredentialsProvider(credentials) {
      if (!credentials) {
        return new EmptyCredentialsProvider();
      }
      switch (credentials["type"]) {
        case "gapi":
          var client = credentials["client"];
          hardAssert(!!(typeof client === "object" && client !== null && client["auth"] && client["auth"]["getAuthHeaderValueForFirstParty"]));
          return new FirstPartyCredentialsProvider(client, credentials["sessionIndex"] || "0", credentials["iamToken"] || null);
        case "provider":
          return credentials["client"];
        default:
          throw new FirestoreError(Code.INVALID_ARGUMENT, "makeCredentialsProvider failed due to invalid credential type");
      }
    }
    var ListenSequence = function() {
      function ListenSequence2(previousValue, sequenceNumberSyncer) {
        var _this = this;
        this.previousValue = previousValue;
        if (sequenceNumberSyncer) {
          sequenceNumberSyncer.sequenceNumberHandler = function(sequenceNumber) {
            return _this.setPreviousValue(sequenceNumber);
          };
          this.writeNewSequenceNumber = function(sequenceNumber) {
            return sequenceNumberSyncer.writeSequenceNumber(sequenceNumber);
          };
        }
      }
      ListenSequence2.prototype.setPreviousValue = function(externalPreviousValue) {
        this.previousValue = Math.max(externalPreviousValue, this.previousValue);
        return this.previousValue;
      };
      ListenSequence2.prototype.next = function() {
        var nextValue = ++this.previousValue;
        if (this.writeNewSequenceNumber) {
          this.writeNewSequenceNumber(nextValue);
        }
        return nextValue;
      };
      return ListenSequence2;
    }();
    ListenSequence.INVALID = -1;
    var DOCUMENT_KEY_NAME = "__name__";
    var BasePath = function() {
      function BasePath2(segments, offset, length) {
        if (offset === void 0) {
          offset = 0;
        } else if (offset > segments.length) {
          fail();
        }
        if (length === void 0) {
          length = segments.length - offset;
        } else if (length > segments.length - offset) {
          fail();
        }
        this.segments = segments;
        this.offset = offset;
        this.len = length;
      }
      Object.defineProperty(BasePath2.prototype, "length", {
        get: function() {
          return this.len;
        },
        enumerable: false,
        configurable: true
      });
      BasePath2.prototype.isEqual = function(other) {
        return BasePath2.comparator(this, other) === 0;
      };
      BasePath2.prototype.child = function(nameOrPath) {
        var segments = this.segments.slice(this.offset, this.limit());
        if (nameOrPath instanceof BasePath2) {
          nameOrPath.forEach(function(segment) {
            segments.push(segment);
          });
        } else {
          segments.push(nameOrPath);
        }
        return this.construct(segments);
      };
      BasePath2.prototype.limit = function() {
        return this.offset + this.length;
      };
      BasePath2.prototype.popFirst = function(size) {
        size = size === void 0 ? 1 : size;
        return this.construct(this.segments, this.offset + size, this.length - size);
      };
      BasePath2.prototype.popLast = function() {
        return this.construct(this.segments, this.offset, this.length - 1);
      };
      BasePath2.prototype.firstSegment = function() {
        return this.segments[this.offset];
      };
      BasePath2.prototype.lastSegment = function() {
        return this.get(this.length - 1);
      };
      BasePath2.prototype.get = function(index2) {
        return this.segments[this.offset + index2];
      };
      BasePath2.prototype.isEmpty = function() {
        return this.length === 0;
      };
      BasePath2.prototype.isPrefixOf = function(other) {
        if (other.length < this.length) {
          return false;
        }
        for (var i = 0; i < this.length; i++) {
          if (this.get(i) !== other.get(i)) {
            return false;
          }
        }
        return true;
      };
      BasePath2.prototype.isImmediateParentOf = function(potentialChild) {
        if (this.length + 1 !== potentialChild.length) {
          return false;
        }
        for (var i = 0; i < this.length; i++) {
          if (this.get(i) !== potentialChild.get(i)) {
            return false;
          }
        }
        return true;
      };
      BasePath2.prototype.forEach = function(fn) {
        for (var i = this.offset, end = this.limit(); i < end; i++) {
          fn(this.segments[i]);
        }
      };
      BasePath2.prototype.toArray = function() {
        return this.segments.slice(this.offset, this.limit());
      };
      BasePath2.comparator = function(p1, p2) {
        var len = Math.min(p1.length, p2.length);
        for (var i = 0; i < len; i++) {
          var left = p1.get(i);
          var right = p2.get(i);
          if (left < right) {
            return -1;
          }
          if (left > right) {
            return 1;
          }
        }
        if (p1.length < p2.length) {
          return -1;
        }
        if (p1.length > p2.length) {
          return 1;
        }
        return 0;
      };
      return BasePath2;
    }();
    var ResourcePath = function(_super) {
      tslib2.__extends(ResourcePath2, _super);
      function ResourcePath2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ResourcePath2.prototype.construct = function(segments, offset, length) {
        return new ResourcePath2(segments, offset, length);
      };
      ResourcePath2.prototype.canonicalString = function() {
        return this.toArray().join("/");
      };
      ResourcePath2.prototype.toString = function() {
        return this.canonicalString();
      };
      ResourcePath2.fromString = function() {
        var pathComponents = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          pathComponents[_i] = arguments[_i];
        }
        var segments = [];
        for (var _d = 0, pathComponents_1 = pathComponents; _d < pathComponents_1.length; _d++) {
          var path2 = pathComponents_1[_d];
          if (path2.indexOf("//") >= 0) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid segment (" + path2 + "). Paths must not contain // in them.");
          }
          segments.push.apply(segments, path2.split("/").filter(function(segment) {
            return segment.length > 0;
          }));
        }
        return new ResourcePath2(segments);
      };
      ResourcePath2.emptyPath = function() {
        return new ResourcePath2([]);
      };
      return ResourcePath2;
    }(BasePath);
    var identifierRegExp = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
    var FieldPath$1 = function(_super) {
      tslib2.__extends(FieldPath$12, _super);
      function FieldPath$12() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      FieldPath$12.prototype.construct = function(segments, offset, length) {
        return new FieldPath$12(segments, offset, length);
      };
      FieldPath$12.isValidIdentifier = function(segment) {
        return identifierRegExp.test(segment);
      };
      FieldPath$12.prototype.canonicalString = function() {
        return this.toArray().map(function(str) {
          str = str.replace(/\\/g, "\\\\").replace(/`/g, "\\`");
          if (!FieldPath$12.isValidIdentifier(str)) {
            str = "`" + str + "`";
          }
          return str;
        }).join(".");
      };
      FieldPath$12.prototype.toString = function() {
        return this.canonicalString();
      };
      FieldPath$12.prototype.isKeyField = function() {
        return this.length === 1 && this.get(0) === DOCUMENT_KEY_NAME;
      };
      FieldPath$12.keyField = function() {
        return new FieldPath$12([DOCUMENT_KEY_NAME]);
      };
      FieldPath$12.fromServerFormat = function(path2) {
        var segments = [];
        var current = "";
        var i = 0;
        var addCurrentSegment = function() {
          if (current.length === 0) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid field path (" + path2 + "). Paths must not be empty, begin with '.', end with '.', or contain '..'");
          }
          segments.push(current);
          current = "";
        };
        var inBackticks = false;
        while (i < path2.length) {
          var c = path2[i];
          if (c === "\\") {
            if (i + 1 === path2.length) {
              throw new FirestoreError(Code.INVALID_ARGUMENT, "Path has trailing escape character: " + path2);
            }
            var next = path2[i + 1];
            if (!(next === "\\" || next === "." || next === "`")) {
              throw new FirestoreError(Code.INVALID_ARGUMENT, "Path has invalid escape sequence: " + path2);
            }
            current += next;
            i += 2;
          } else if (c === "`") {
            inBackticks = !inBackticks;
            i++;
          } else if (c === "." && !inBackticks) {
            addCurrentSegment();
            i++;
          } else {
            current += c;
            i++;
          }
        }
        addCurrentSegment();
        if (inBackticks) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Unterminated ` in path: " + path2);
        }
        return new FieldPath$12(segments);
      };
      FieldPath$12.emptyPath = function() {
        return new FieldPath$12([]);
      };
      return FieldPath$12;
    }(BasePath);
    var escapeChar = "";
    var encodedSeparatorChar = "";
    var encodedNul = "";
    var encodedEscape = "";
    function encodeResourcePath(path2) {
      var result = "";
      for (var i = 0; i < path2.length; i++) {
        if (result.length > 0) {
          result = encodeSeparator(result);
        }
        result = encodeSegment(path2.get(i), result);
      }
      return encodeSeparator(result);
    }
    function encodeSegment(segment, resultBuf) {
      var result = resultBuf;
      var length = segment.length;
      for (var i = 0; i < length; i++) {
        var c = segment.charAt(i);
        switch (c) {
          case "\0":
            result += escapeChar + encodedNul;
            break;
          case escapeChar:
            result += escapeChar + encodedEscape;
            break;
          default:
            result += c;
        }
      }
      return result;
    }
    function encodeSeparator(result) {
      return result + escapeChar + encodedSeparatorChar;
    }
    function decodeResourcePath(path2) {
      var length = path2.length;
      hardAssert(length >= 2);
      if (length === 2) {
        hardAssert(path2.charAt(0) === escapeChar && path2.charAt(1) === encodedSeparatorChar);
        return ResourcePath.emptyPath();
      }
      var lastReasonableEscapeIndex = length - 2;
      var segments = [];
      var segmentBuilder = "";
      for (var start2 = 0; start2 < length; ) {
        var end = path2.indexOf(escapeChar, start2);
        if (end < 0 || end > lastReasonableEscapeIndex) {
          fail();
        }
        var next = path2.charAt(end + 1);
        switch (next) {
          case encodedSeparatorChar:
            var currentPiece = path2.substring(start2, end);
            var segment = void 0;
            if (segmentBuilder.length === 0) {
              segment = currentPiece;
            } else {
              segmentBuilder += currentPiece;
              segment = segmentBuilder;
              segmentBuilder = "";
            }
            segments.push(segment);
            break;
          case encodedNul:
            segmentBuilder += path2.substring(start2, end);
            segmentBuilder += "\0";
            break;
          case encodedEscape:
            segmentBuilder += path2.substring(start2, end + 1);
            break;
          default:
            fail();
        }
        start2 = end + 2;
      }
      return new ResourcePath(segments);
    }
    var SCHEMA_VERSION = 11;
    var DbTimestamp = function() {
      function DbTimestamp2(seconds, nanoseconds) {
        this.seconds = seconds;
        this.nanoseconds = nanoseconds;
      }
      return DbTimestamp2;
    }();
    var DbPrimaryClient = function() {
      function DbPrimaryClient2(ownerId, allowTabSynchronization, leaseTimestampMs) {
        this.ownerId = ownerId;
        this.allowTabSynchronization = allowTabSynchronization;
        this.leaseTimestampMs = leaseTimestampMs;
      }
      return DbPrimaryClient2;
    }();
    DbPrimaryClient.store = "owner";
    DbPrimaryClient.key = "owner";
    var DbMutationQueue = function() {
      function DbMutationQueue2(userId, lastAcknowledgedBatchId, lastStreamToken) {
        this.userId = userId;
        this.lastAcknowledgedBatchId = lastAcknowledgedBatchId;
        this.lastStreamToken = lastStreamToken;
      }
      return DbMutationQueue2;
    }();
    DbMutationQueue.store = "mutationQueues";
    DbMutationQueue.keyPath = "userId";
    var DbMutationBatch = function() {
      function DbMutationBatch2(userId, batchId, localWriteTimeMs, baseMutations, mutations) {
        this.userId = userId;
        this.batchId = batchId;
        this.localWriteTimeMs = localWriteTimeMs;
        this.baseMutations = baseMutations;
        this.mutations = mutations;
      }
      return DbMutationBatch2;
    }();
    DbMutationBatch.store = "mutations";
    DbMutationBatch.keyPath = "batchId";
    DbMutationBatch.userMutationsIndex = "userMutationsIndex";
    DbMutationBatch.userMutationsKeyPath = ["userId", "batchId"];
    var DbDocumentMutation = function() {
      function DbDocumentMutation2() {
      }
      DbDocumentMutation2.prefixForUser = function(userId) {
        return [userId];
      };
      DbDocumentMutation2.prefixForPath = function(userId, path2) {
        return [userId, encodeResourcePath(path2)];
      };
      DbDocumentMutation2.key = function(userId, path2, batchId) {
        return [userId, encodeResourcePath(path2), batchId];
      };
      return DbDocumentMutation2;
    }();
    DbDocumentMutation.store = "documentMutations";
    DbDocumentMutation.PLACEHOLDER = new DbDocumentMutation();
    var DbNoDocument = function() {
      function DbNoDocument2(path2, readTime) {
        this.path = path2;
        this.readTime = readTime;
      }
      return DbNoDocument2;
    }();
    var DbUnknownDocument = function() {
      function DbUnknownDocument2(path2, version3) {
        this.path = path2;
        this.version = version3;
      }
      return DbUnknownDocument2;
    }();
    var DbRemoteDocument = function() {
      function DbRemoteDocument2(unknownDocument, noDocument, document2, hasCommittedMutations, readTime, parentPath) {
        this.unknownDocument = unknownDocument;
        this.noDocument = noDocument;
        this.document = document2;
        this.hasCommittedMutations = hasCommittedMutations;
        this.readTime = readTime;
        this.parentPath = parentPath;
      }
      return DbRemoteDocument2;
    }();
    DbRemoteDocument.store = "remoteDocuments";
    DbRemoteDocument.readTimeIndex = "readTimeIndex";
    DbRemoteDocument.readTimeIndexPath = "readTime";
    DbRemoteDocument.collectionReadTimeIndex = "collectionReadTimeIndex";
    DbRemoteDocument.collectionReadTimeIndexPath = ["parentPath", "readTime"];
    var DbRemoteDocumentGlobal = function() {
      function DbRemoteDocumentGlobal2(byteSize) {
        this.byteSize = byteSize;
      }
      return DbRemoteDocumentGlobal2;
    }();
    DbRemoteDocumentGlobal.store = "remoteDocumentGlobal";
    DbRemoteDocumentGlobal.key = "remoteDocumentGlobalKey";
    var DbTarget = function() {
      function DbTarget2(targetId, canonicalId2, readTime, resumeToken, lastListenSequenceNumber, lastLimboFreeSnapshotVersion, query2) {
        this.targetId = targetId;
        this.canonicalId = canonicalId2;
        this.readTime = readTime;
        this.resumeToken = resumeToken;
        this.lastListenSequenceNumber = lastListenSequenceNumber;
        this.lastLimboFreeSnapshotVersion = lastLimboFreeSnapshotVersion;
        this.query = query2;
      }
      return DbTarget2;
    }();
    DbTarget.store = "targets";
    DbTarget.keyPath = "targetId";
    DbTarget.queryTargetsIndexName = "queryTargetsIndex";
    DbTarget.queryTargetsKeyPath = ["canonicalId", "targetId"];
    var DbTargetDocument = function() {
      function DbTargetDocument2(targetId, path2, sequenceNumber) {
        this.targetId = targetId;
        this.path = path2;
        this.sequenceNumber = sequenceNumber;
      }
      return DbTargetDocument2;
    }();
    DbTargetDocument.store = "targetDocuments";
    DbTargetDocument.keyPath = ["targetId", "path"];
    DbTargetDocument.documentTargetsIndex = "documentTargetsIndex";
    DbTargetDocument.documentTargetsKeyPath = ["path", "targetId"];
    var DbTargetGlobal = function() {
      function DbTargetGlobal2(highestTargetId, highestListenSequenceNumber, lastRemoteSnapshotVersion, targetCount) {
        this.highestTargetId = highestTargetId;
        this.highestListenSequenceNumber = highestListenSequenceNumber;
        this.lastRemoteSnapshotVersion = lastRemoteSnapshotVersion;
        this.targetCount = targetCount;
      }
      return DbTargetGlobal2;
    }();
    DbTargetGlobal.key = "targetGlobalKey";
    DbTargetGlobal.store = "targetGlobal";
    var DbCollectionParent = function() {
      function DbCollectionParent2(collectionId, parent2) {
        this.collectionId = collectionId;
        this.parent = parent2;
      }
      return DbCollectionParent2;
    }();
    DbCollectionParent.store = "collectionParents";
    DbCollectionParent.keyPath = ["collectionId", "parent"];
    var DbClientMetadata = function() {
      function DbClientMetadata2(clientId, updateTimeMs, networkEnabled, inForeground) {
        this.clientId = clientId;
        this.updateTimeMs = updateTimeMs;
        this.networkEnabled = networkEnabled;
        this.inForeground = inForeground;
      }
      return DbClientMetadata2;
    }();
    DbClientMetadata.store = "clientMetadata";
    DbClientMetadata.keyPath = "clientId";
    var DbBundle = function() {
      function DbBundle2(bundleId, createTime, version3) {
        this.bundleId = bundleId;
        this.createTime = createTime;
        this.version = version3;
      }
      return DbBundle2;
    }();
    DbBundle.store = "bundles";
    DbBundle.keyPath = "bundleId";
    var DbNamedQuery = function() {
      function DbNamedQuery2(name3, readTime, bundledQuery) {
        this.name = name3;
        this.readTime = readTime;
        this.bundledQuery = bundledQuery;
      }
      return DbNamedQuery2;
    }();
    DbNamedQuery.store = "namedQueries";
    DbNamedQuery.keyPath = "name";
    var V1_STORES = [
      DbMutationQueue.store,
      DbMutationBatch.store,
      DbDocumentMutation.store,
      DbRemoteDocument.store,
      DbTarget.store,
      DbPrimaryClient.store,
      DbTargetGlobal.store,
      DbTargetDocument.store
    ];
    var V3_STORES = V1_STORES;
    var V4_STORES = tslib2.__spreadArray(tslib2.__spreadArray([], V3_STORES), [DbClientMetadata.store]);
    var V6_STORES = tslib2.__spreadArray(tslib2.__spreadArray([], V4_STORES), [DbRemoteDocumentGlobal.store]);
    var V8_STORES = tslib2.__spreadArray(tslib2.__spreadArray([], V6_STORES), [DbCollectionParent.store]);
    var V11_STORES = tslib2.__spreadArray(tslib2.__spreadArray([], V8_STORES), [DbBundle.store, DbNamedQuery.store]);
    var ALL_STORES = V11_STORES;
    var PRIMARY_LEASE_LOST_ERROR_MSG = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";
    var PersistenceTransaction = function() {
      function PersistenceTransaction2() {
        this.onCommittedListeners = [];
      }
      PersistenceTransaction2.prototype.addOnCommittedListener = function(listener) {
        this.onCommittedListeners.push(listener);
      };
      PersistenceTransaction2.prototype.raiseOnCommittedEvent = function() {
        this.onCommittedListeners.forEach(function(listener) {
          return listener();
        });
      };
      return PersistenceTransaction2;
    }();
    var PersistencePromise = function() {
      function PersistencePromise2(callback) {
        var _this = this;
        this.nextCallback = null;
        this.catchCallback = null;
        this.result = void 0;
        this.error = void 0;
        this.isDone = false;
        this.callbackAttached = false;
        callback(function(value) {
          _this.isDone = true;
          _this.result = value;
          if (_this.nextCallback) {
            _this.nextCallback(value);
          }
        }, function(error2) {
          _this.isDone = true;
          _this.error = error2;
          if (_this.catchCallback) {
            _this.catchCallback(error2);
          }
        });
      }
      PersistencePromise2.prototype.catch = function(fn) {
        return this.next(void 0, fn);
      };
      PersistencePromise2.prototype.next = function(nextFn, catchFn) {
        var _this = this;
        if (this.callbackAttached) {
          fail();
        }
        this.callbackAttached = true;
        if (this.isDone) {
          if (!this.error) {
            return this.wrapSuccess(nextFn, this.result);
          } else {
            return this.wrapFailure(catchFn, this.error);
          }
        } else {
          return new PersistencePromise2(function(resolve2, reject) {
            _this.nextCallback = function(value) {
              _this.wrapSuccess(nextFn, value).next(resolve2, reject);
            };
            _this.catchCallback = function(error2) {
              _this.wrapFailure(catchFn, error2).next(resolve2, reject);
            };
          });
        }
      };
      PersistencePromise2.prototype.toPromise = function() {
        var _this = this;
        return new Promise(function(resolve2, reject) {
          _this.next(resolve2, reject);
        });
      };
      PersistencePromise2.prototype.wrapUserFunction = function(fn) {
        try {
          var result = fn();
          if (result instanceof PersistencePromise2) {
            return result;
          } else {
            return PersistencePromise2.resolve(result);
          }
        } catch (e) {
          return PersistencePromise2.reject(e);
        }
      };
      PersistencePromise2.prototype.wrapSuccess = function(nextFn, value) {
        if (nextFn) {
          return this.wrapUserFunction(function() {
            return nextFn(value);
          });
        } else {
          return PersistencePromise2.resolve(value);
        }
      };
      PersistencePromise2.prototype.wrapFailure = function(catchFn, error2) {
        if (catchFn) {
          return this.wrapUserFunction(function() {
            return catchFn(error2);
          });
        } else {
          return PersistencePromise2.reject(error2);
        }
      };
      PersistencePromise2.resolve = function(result) {
        return new PersistencePromise2(function(resolve2, reject) {
          resolve2(result);
        });
      };
      PersistencePromise2.reject = function(error2) {
        return new PersistencePromise2(function(resolve2, reject) {
          reject(error2);
        });
      };
      PersistencePromise2.waitFor = function(all) {
        return new PersistencePromise2(function(resolve2, reject) {
          var expectedCount = 0;
          var resolvedCount = 0;
          var done = false;
          all.forEach(function(element) {
            ++expectedCount;
            element.next(function() {
              ++resolvedCount;
              if (done && resolvedCount === expectedCount) {
                resolve2();
              }
            }, function(err) {
              return reject(err);
            });
          });
          done = true;
          if (resolvedCount === expectedCount) {
            resolve2();
          }
        });
      };
      PersistencePromise2.or = function(predicates) {
        var p = PersistencePromise2.resolve(false);
        var _loop_1 = function(predicate2) {
          p = p.next(function(isTrue) {
            if (isTrue) {
              return PersistencePromise2.resolve(isTrue);
            } else {
              return predicate2();
            }
          });
        };
        for (var _i = 0, predicates_1 = predicates; _i < predicates_1.length; _i++) {
          var predicate = predicates_1[_i];
          _loop_1(predicate);
        }
        return p;
      };
      PersistencePromise2.forEach = function(collection3, f) {
        var _this = this;
        var promises = [];
        collection3.forEach(function(r, s2) {
          promises.push(f.call(_this, r, s2));
        });
        return this.waitFor(promises);
      };
      return PersistencePromise2;
    }();
    var LOG_TAG$g = "SimpleDb";
    var TRANSACTION_RETRY_COUNT = 3;
    var SimpleDbTransaction = function() {
      function SimpleDbTransaction2(action, transaction) {
        var _this = this;
        this.action = action;
        this.transaction = transaction;
        this.aborted = false;
        this.completionDeferred = new Deferred2();
        this.transaction.oncomplete = function() {
          _this.completionDeferred.resolve();
        };
        this.transaction.onabort = function() {
          if (transaction.error) {
            _this.completionDeferred.reject(new IndexedDbTransactionError(action, transaction.error));
          } else {
            _this.completionDeferred.resolve();
          }
        };
        this.transaction.onerror = function(event) {
          var error2 = checkForAndReportiOSError(event.target.error);
          _this.completionDeferred.reject(new IndexedDbTransactionError(action, error2));
        };
      }
      SimpleDbTransaction2.open = function(db2, action, mode, objectStoreNames) {
        try {
          return new SimpleDbTransaction2(action, db2.transaction(objectStoreNames, mode));
        } catch (e) {
          throw new IndexedDbTransactionError(action, e);
        }
      };
      Object.defineProperty(SimpleDbTransaction2.prototype, "completionPromise", {
        get: function() {
          return this.completionDeferred.promise;
        },
        enumerable: false,
        configurable: true
      });
      SimpleDbTransaction2.prototype.abort = function(error2) {
        if (error2) {
          this.completionDeferred.reject(error2);
        }
        if (!this.aborted) {
          logDebug(LOG_TAG$g, "Aborting transaction:", error2 ? error2.message : "Client-initiated abort");
          this.aborted = true;
          this.transaction.abort();
        }
      };
      SimpleDbTransaction2.prototype.store = function(storeName) {
        var store = this.transaction.objectStore(storeName);
        return new SimpleDbStore(store);
      };
      return SimpleDbTransaction2;
    }();
    var SimpleDb = function() {
      function SimpleDb2(name3, version3, schemaConverter) {
        this.name = name3;
        this.version = version3;
        this.schemaConverter = schemaConverter;
        var iOSVersion = SimpleDb2.getIOSVersion(util.getUA());
        if (iOSVersion === 12.2) {
          logError("Firestore persistence suffers from a bug in iOS 12.2 Safari that may cause your app to stop working. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.");
        }
      }
      SimpleDb2.delete = function(name3) {
        logDebug(LOG_TAG$g, "Removing database:", name3);
        return wrapRequest(window.indexedDB.deleteDatabase(name3)).toPromise();
      };
      SimpleDb2.isAvailable = function() {
        if (!util.isIndexedDBAvailable()) {
          return false;
        }
        if (SimpleDb2.isMockPersistence()) {
          return true;
        }
        var ua = util.getUA();
        var iOSVersion = SimpleDb2.getIOSVersion(ua);
        var isUnsupportedIOS = 0 < iOSVersion && iOSVersion < 10;
        var androidVersion = SimpleDb2.getAndroidVersion(ua);
        var isUnsupportedAndroid = 0 < androidVersion && androidVersion < 4.5;
        if (ua.indexOf("MSIE ") > 0 || ua.indexOf("Trident/") > 0 || ua.indexOf("Edge/") > 0 || isUnsupportedIOS || isUnsupportedAndroid) {
          return false;
        } else {
          return true;
        }
      };
      SimpleDb2.isMockPersistence = function() {
        var _a;
        return typeof process !== "undefined" && ((_a = process.env) === null || _a === void 0 ? void 0 : _a.USE_MOCK_PERSISTENCE) === "YES";
      };
      SimpleDb2.getStore = function(txn, store) {
        return txn.store(store);
      };
      SimpleDb2.getIOSVersion = function(ua) {
        var iOSVersionRegex = ua.match(/i(?:phone|pad|pod) os ([\d_]+)/i);
        var version3 = iOSVersionRegex ? iOSVersionRegex[1].split("_").slice(0, 2).join(".") : "-1";
        return Number(version3);
      };
      SimpleDb2.getAndroidVersion = function(ua) {
        var androidVersionRegex = ua.match(/Android ([\d.]+)/i);
        var version3 = androidVersionRegex ? androidVersionRegex[1].split(".").slice(0, 2).join(".") : "-1";
        return Number(version3);
      };
      SimpleDb2.prototype.ensureDb = function(action) {
        return tslib2.__awaiter(this, void 0, void 0, function() {
          var _d;
          var _this = this;
          return tslib2.__generator(this, function(_e) {
            switch (_e.label) {
              case 0:
                if (!!this.db)
                  return [3, 2];
                logDebug(LOG_TAG$g, "Opening database:", this.name);
                _d = this;
                return [4, new Promise(function(resolve2, reject) {
                  var request = indexedDB.open(_this.name, _this.version);
                  request.onsuccess = function(event) {
                    var db2 = event.target.result;
                    resolve2(db2);
                  };
                  request.onblocked = function() {
                    reject(new IndexedDbTransactionError(action, "Cannot upgrade IndexedDB schema while another tab is open. Close all tabs that access Firestore and reload this page to proceed."));
                  };
                  request.onerror = function(event) {
                    var error2 = event.target.error;
                    if (error2.name === "VersionError") {
                      reject(new FirestoreError(Code.FAILED_PRECONDITION, "A newer version of the Firestore SDK was previously used and so the persisted data is not compatible with the version of the SDK you are now using. The SDK will operate with persistence disabled. If you need persistence, please re-upgrade to a newer version of the SDK or else clear the persisted IndexedDB data for your app to start fresh."));
                    } else if (error2.name === "InvalidStateError") {
                      reject(new FirestoreError(Code.FAILED_PRECONDITION, "Unable to open an IndexedDB connection. This could be due to running in a private browsing session on a browser whose private browsing sessions do not support IndexedDB: " + error2));
                    } else {
                      reject(new IndexedDbTransactionError(action, error2));
                    }
                  };
                  request.onupgradeneeded = function(event) {
                    logDebug(LOG_TAG$g, 'Database "' + _this.name + '" requires upgrade from version:', event.oldVersion);
                    var db2 = event.target.result;
                    _this.schemaConverter.createOrUpgrade(db2, request.transaction, event.oldVersion, _this.version).next(function() {
                      logDebug(LOG_TAG$g, "Database upgrade to version " + _this.version + " complete");
                    });
                  };
                })];
              case 1:
                _d.db = _e.sent();
                _e.label = 2;
              case 2:
                if (this.versionchangelistener) {
                  this.db.onversionchange = function(event) {
                    return _this.versionchangelistener(event);
                  };
                }
                return [2, this.db];
            }
          });
        });
      };
      SimpleDb2.prototype.setVersionChangeListener = function(versionChangeListener) {
        this.versionchangelistener = versionChangeListener;
        if (this.db) {
          this.db.onversionchange = function(event) {
            return versionChangeListener(event);
          };
        }
      };
      SimpleDb2.prototype.runTransaction = function(action, mode, objectStores, transactionFn) {
        return tslib2.__awaiter(this, void 0, void 0, function() {
          var readonly, attemptNumber, _loop_2, this_1, state_1;
          return tslib2.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                readonly = mode === "readonly";
                attemptNumber = 0;
                _loop_2 = function() {
                  var transaction_1, transactionFnResult, error_1, retryable;
                  return tslib2.__generator(this, function(_e) {
                    switch (_e.label) {
                      case 0:
                        ++attemptNumber;
                        _e.label = 1;
                      case 1:
                        _e.trys.push([1, 4, , 5]);
                        return [4, this_1.ensureDb(action)];
                      case 2:
                        this_1.db = _e.sent();
                        transaction_1 = SimpleDbTransaction.open(this_1.db, action, readonly ? "readonly" : "readwrite", objectStores);
                        transactionFnResult = transactionFn(transaction_1).catch(function(error2) {
                          transaction_1.abort(error2);
                          return PersistencePromise.reject(error2);
                        }).toPromise();
                        transactionFnResult.catch(function() {
                        });
                        return [4, transaction_1.completionPromise];
                      case 3:
                        _e.sent();
                        return [2, { value: transactionFnResult }];
                      case 4:
                        error_1 = _e.sent();
                        retryable = error_1.name !== "FirebaseError" && attemptNumber < TRANSACTION_RETRY_COUNT;
                        logDebug(LOG_TAG$g, "Transaction failed with error:", error_1.message, "Retrying:", retryable);
                        this_1.close();
                        if (!retryable) {
                          return [2, { value: Promise.reject(error_1) }];
                        }
                        return [3, 5];
                      case 5:
                        return [2];
                    }
                  });
                };
                this_1 = this;
                _d.label = 1;
              case 1:
                return [5, _loop_2()];
              case 2:
                state_1 = _d.sent();
                if (typeof state_1 === "object")
                  return [2, state_1.value];
                return [3, 1];
              case 3:
                return [2];
            }
          });
        });
      };
      SimpleDb2.prototype.close = function() {
        if (this.db) {
          this.db.close();
        }
        this.db = void 0;
      };
      return SimpleDb2;
    }();
    var IterationController = function() {
      function IterationController2(dbCursor) {
        this.dbCursor = dbCursor;
        this.shouldStop = false;
        this.nextKey = null;
      }
      Object.defineProperty(IterationController2.prototype, "isDone", {
        get: function() {
          return this.shouldStop;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(IterationController2.prototype, "skipToKey", {
        get: function() {
          return this.nextKey;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(IterationController2.prototype, "cursor", {
        set: function(value) {
          this.dbCursor = value;
        },
        enumerable: false,
        configurable: true
      });
      IterationController2.prototype.done = function() {
        this.shouldStop = true;
      };
      IterationController2.prototype.skip = function(key) {
        this.nextKey = key;
      };
      IterationController2.prototype.delete = function() {
        return wrapRequest(this.dbCursor.delete());
      };
      return IterationController2;
    }();
    var IndexedDbTransactionError = function(_super) {
      tslib2.__extends(IndexedDbTransactionError2, _super);
      function IndexedDbTransactionError2(actionName, cause) {
        var _this = _super.call(this, Code.UNAVAILABLE, "IndexedDB transaction '" + actionName + "' failed: " + cause) || this;
        _this.name = "IndexedDbTransactionError";
        return _this;
      }
      return IndexedDbTransactionError2;
    }(FirestoreError);
    function isIndexedDbTransactionError(e) {
      return e.name === "IndexedDbTransactionError";
    }
    var SimpleDbStore = function() {
      function SimpleDbStore2(store) {
        this.store = store;
      }
      SimpleDbStore2.prototype.put = function(keyOrValue, value) {
        var request;
        if (value !== void 0) {
          logDebug(LOG_TAG$g, "PUT", this.store.name, keyOrValue, value);
          request = this.store.put(value, keyOrValue);
        } else {
          logDebug(LOG_TAG$g, "PUT", this.store.name, "<auto-key>", keyOrValue);
          request = this.store.put(keyOrValue);
        }
        return wrapRequest(request);
      };
      SimpleDbStore2.prototype.add = function(value) {
        logDebug(LOG_TAG$g, "ADD", this.store.name, value, value);
        var request = this.store.add(value);
        return wrapRequest(request);
      };
      SimpleDbStore2.prototype.get = function(key) {
        var _this = this;
        var request = this.store.get(key);
        return wrapRequest(request).next(function(result) {
          if (result === void 0) {
            result = null;
          }
          logDebug(LOG_TAG$g, "GET", _this.store.name, key, result);
          return result;
        });
      };
      SimpleDbStore2.prototype.delete = function(key) {
        logDebug(LOG_TAG$g, "DELETE", this.store.name, key);
        var request = this.store.delete(key);
        return wrapRequest(request);
      };
      SimpleDbStore2.prototype.count = function() {
        logDebug(LOG_TAG$g, "COUNT", this.store.name);
        var request = this.store.count();
        return wrapRequest(request);
      };
      SimpleDbStore2.prototype.loadAll = function(indexOrRange, range) {
        var cursor = this.cursor(this.options(indexOrRange, range));
        var results = [];
        return this.iterateCursor(cursor, function(key, value) {
          results.push(value);
        }).next(function() {
          return results;
        });
      };
      SimpleDbStore2.prototype.deleteAll = function(indexOrRange, range) {
        logDebug(LOG_TAG$g, "DELETE ALL", this.store.name);
        var options2 = this.options(indexOrRange, range);
        options2.keysOnly = false;
        var cursor = this.cursor(options2);
        return this.iterateCursor(cursor, function(key, value, control) {
          return control.delete();
        });
      };
      SimpleDbStore2.prototype.iterate = function(optionsOrCallback, callback) {
        var options2;
        if (!callback) {
          options2 = {};
          callback = optionsOrCallback;
        } else {
          options2 = optionsOrCallback;
        }
        var cursor = this.cursor(options2);
        return this.iterateCursor(cursor, callback);
      };
      SimpleDbStore2.prototype.iterateSerial = function(callback) {
        var cursorRequest = this.cursor({});
        return new PersistencePromise(function(resolve2, reject) {
          cursorRequest.onerror = function(event) {
            var error2 = checkForAndReportiOSError(event.target.error);
            reject(error2);
          };
          cursorRequest.onsuccess = function(event) {
            var cursor = event.target.result;
            if (!cursor) {
              resolve2();
              return;
            }
            callback(cursor.primaryKey, cursor.value).next(function(shouldContinue) {
              if (shouldContinue) {
                cursor.continue();
              } else {
                resolve2();
              }
            });
          };
        });
      };
      SimpleDbStore2.prototype.iterateCursor = function(cursorRequest, fn) {
        var results = [];
        return new PersistencePromise(function(resolve2, reject) {
          cursorRequest.onerror = function(event) {
            reject(event.target.error);
          };
          cursorRequest.onsuccess = function(event) {
            var cursor = event.target.result;
            if (!cursor) {
              resolve2();
              return;
            }
            var controller = new IterationController(cursor);
            var userResult = fn(cursor.primaryKey, cursor.value, controller);
            if (userResult instanceof PersistencePromise) {
              var userPromise = userResult.catch(function(err) {
                controller.done();
                return PersistencePromise.reject(err);
              });
              results.push(userPromise);
            }
            if (controller.isDone) {
              resolve2();
            } else if (controller.skipToKey === null) {
              cursor.continue();
            } else {
              cursor.continue(controller.skipToKey);
            }
          };
        }).next(function() {
          return PersistencePromise.waitFor(results);
        });
      };
      SimpleDbStore2.prototype.options = function(indexOrRange, range) {
        var indexName = void 0;
        if (indexOrRange !== void 0) {
          if (typeof indexOrRange === "string") {
            indexName = indexOrRange;
          } else {
            range = indexOrRange;
          }
        }
        return { index: indexName, range };
      };
      SimpleDbStore2.prototype.cursor = function(options2) {
        var direction = "next";
        if (options2.reverse) {
          direction = "prev";
        }
        if (options2.index) {
          var index2 = this.store.index(options2.index);
          if (options2.keysOnly) {
            return index2.openKeyCursor(options2.range, direction);
          } else {
            return index2.openCursor(options2.range, direction);
          }
        } else {
          return this.store.openCursor(options2.range, direction);
        }
      };
      return SimpleDbStore2;
    }();
    function wrapRequest(request) {
      return new PersistencePromise(function(resolve2, reject) {
        request.onsuccess = function(event) {
          var result = event.target.result;
          resolve2(result);
        };
        request.onerror = function(event) {
          var error2 = checkForAndReportiOSError(event.target.error);
          reject(error2);
        };
      });
    }
    var reportedIOSError = false;
    function checkForAndReportiOSError(error2) {
      var iOSVersion = SimpleDb.getIOSVersion(util.getUA());
      if (iOSVersion >= 12.2 && iOSVersion < 13) {
        var IOS_ERROR = "An internal error was encountered in the Indexed Database server";
        if (error2.message.indexOf(IOS_ERROR) >= 0) {
          var newError_1 = new FirestoreError("internal", "IOS_INDEXEDDB_BUG1: IndexedDb has thrown '" + IOS_ERROR + "'. This is likely due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.");
          if (!reportedIOSError) {
            reportedIOSError = true;
            setTimeout(function() {
              throw newError_1;
            }, 0);
          }
          return newError_1;
        }
      }
      return error2;
    }
    var IndexedDbTransaction = function(_super) {
      tslib2.__extends(IndexedDbTransaction2, _super);
      function IndexedDbTransaction2(simpleDbTransaction, currentSequenceNumber) {
        var _this = _super.call(this) || this;
        _this.simpleDbTransaction = simpleDbTransaction;
        _this.currentSequenceNumber = currentSequenceNumber;
        return _this;
      }
      return IndexedDbTransaction2;
    }(PersistenceTransaction);
    function getStore(txn, store) {
      var indexedDbTransaction = debugCast(txn);
      return SimpleDb.getStore(indexedDbTransaction.simpleDbTransaction, store);
    }
    function randomBytes2(nBytes) {
      return crypto.randomBytes(nBytes);
    }
    var AutoId = function() {
      function AutoId2() {
      }
      AutoId2.newId = function() {
        var chars2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        var maxMultiple = Math.floor(256 / chars2.length) * chars2.length;
        var autoId = "";
        var targetLength = 20;
        while (autoId.length < targetLength) {
          var bytes = randomBytes2(40);
          for (var i = 0; i < bytes.length; ++i) {
            if (autoId.length < targetLength && bytes[i] < maxMultiple) {
              autoId += chars2.charAt(bytes[i] % chars2.length);
            }
          }
        }
        return autoId;
      };
      return AutoId2;
    }();
    function primitiveComparator(left, right) {
      if (left < right) {
        return -1;
      }
      if (left > right) {
        return 1;
      }
      return 0;
    }
    function arrayEquals(left, right, comparator) {
      if (left.length !== right.length) {
        return false;
      }
      return left.every(function(value, index2) {
        return comparator(value, right[index2]);
      });
    }
    function immediateSuccessor(s2) {
      return s2 + "\0";
    }
    var MIN_SECONDS = -62135596800;
    var MS_TO_NANOS = 1e6;
    var Timestamp = function() {
      function Timestamp2(seconds, nanoseconds) {
        this.seconds = seconds;
        this.nanoseconds = nanoseconds;
        if (nanoseconds < 0) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + nanoseconds);
        }
        if (nanoseconds >= 1e9) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + nanoseconds);
        }
        if (seconds < MIN_SECONDS) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Timestamp seconds out of range: " + seconds);
        }
        if (seconds >= 253402300800) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Timestamp seconds out of range: " + seconds);
        }
      }
      Timestamp2.now = function() {
        return Timestamp2.fromMillis(Date.now());
      };
      Timestamp2.fromDate = function(date) {
        return Timestamp2.fromMillis(date.getTime());
      };
      Timestamp2.fromMillis = function(milliseconds) {
        var seconds = Math.floor(milliseconds / 1e3);
        var nanos = Math.floor((milliseconds - seconds * 1e3) * MS_TO_NANOS);
        return new Timestamp2(seconds, nanos);
      };
      Timestamp2.prototype.toDate = function() {
        return new Date(this.toMillis());
      };
      Timestamp2.prototype.toMillis = function() {
        return this.seconds * 1e3 + this.nanoseconds / MS_TO_NANOS;
      };
      Timestamp2.prototype._compareTo = function(other) {
        if (this.seconds === other.seconds) {
          return primitiveComparator(this.nanoseconds, other.nanoseconds);
        }
        return primitiveComparator(this.seconds, other.seconds);
      };
      Timestamp2.prototype.isEqual = function(other) {
        return other.seconds === this.seconds && other.nanoseconds === this.nanoseconds;
      };
      Timestamp2.prototype.toString = function() {
        return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
      };
      Timestamp2.prototype.toJSON = function() {
        return { seconds: this.seconds, nanoseconds: this.nanoseconds };
      };
      Timestamp2.prototype.valueOf = function() {
        var adjustedSeconds = this.seconds - MIN_SECONDS;
        var formattedSeconds = String(adjustedSeconds).padStart(12, "0");
        var formattedNanoseconds = String(this.nanoseconds).padStart(9, "0");
        return formattedSeconds + "." + formattedNanoseconds;
      };
      return Timestamp2;
    }();
    var SnapshotVersion = function() {
      function SnapshotVersion2(timestamp) {
        this.timestamp = timestamp;
      }
      SnapshotVersion2.fromTimestamp = function(value) {
        return new SnapshotVersion2(value);
      };
      SnapshotVersion2.min = function() {
        return new SnapshotVersion2(new Timestamp(0, 0));
      };
      SnapshotVersion2.prototype.compareTo = function(other) {
        return this.timestamp._compareTo(other.timestamp);
      };
      SnapshotVersion2.prototype.isEqual = function(other) {
        return this.timestamp.isEqual(other.timestamp);
      };
      SnapshotVersion2.prototype.toMicroseconds = function() {
        return this.timestamp.seconds * 1e6 + this.timestamp.nanoseconds / 1e3;
      };
      SnapshotVersion2.prototype.toString = function() {
        return "SnapshotVersion(" + this.timestamp.toString() + ")";
      };
      SnapshotVersion2.prototype.toTimestamp = function() {
        return this.timestamp;
      };
      return SnapshotVersion2;
    }();
    function objectSize(obj) {
      var count = 0;
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          count++;
        }
      }
      return count;
    }
    function forEach(obj, fn) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          fn(key, obj[key]);
        }
      }
    }
    function isEmpty2(obj) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          return false;
        }
      }
      return true;
    }
    var FieldMask = function() {
      function FieldMask2(fields) {
        this.fields = fields;
        fields.sort(FieldPath$1.comparator);
      }
      FieldMask2.prototype.covers = function(fieldPath) {
        for (var _i = 0, _d = this.fields; _i < _d.length; _i++) {
          var fieldMaskPath = _d[_i];
          if (fieldMaskPath.isPrefixOf(fieldPath)) {
            return true;
          }
        }
        return false;
      };
      FieldMask2.prototype.isEqual = function(other) {
        return arrayEquals(this.fields, other.fields, function(l, r) {
          return l.isEqual(r);
        });
      };
      return FieldMask2;
    }();
    function decodeBase64(encoded) {
      if (/[^-A-Za-z0-9+/=]/.test(encoded)) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Not a valid Base64 string: " + encoded);
      }
      return new Buffer(encoded, "base64").toString("binary");
    }
    function encodeBase64(raw) {
      return new Buffer(raw, "binary").toString("base64");
    }
    function isBase64Available() {
      return true;
    }
    var ByteString = function() {
      function ByteString2(binaryString) {
        this.binaryString = binaryString;
      }
      ByteString2.fromBase64String = function(base642) {
        var binaryString = decodeBase64(base642);
        return new ByteString2(binaryString);
      };
      ByteString2.fromUint8Array = function(array) {
        var binaryString = binaryStringFromUint8Array(array);
        return new ByteString2(binaryString);
      };
      ByteString2.prototype.toBase64 = function() {
        return encodeBase64(this.binaryString);
      };
      ByteString2.prototype.toUint8Array = function() {
        return uint8ArrayFromBinaryString(this.binaryString);
      };
      ByteString2.prototype.approximateByteSize = function() {
        return this.binaryString.length * 2;
      };
      ByteString2.prototype.compareTo = function(other) {
        return primitiveComparator(this.binaryString, other.binaryString);
      };
      ByteString2.prototype.isEqual = function(other) {
        return this.binaryString === other.binaryString;
      };
      return ByteString2;
    }();
    ByteString.EMPTY_BYTE_STRING = new ByteString("");
    function binaryStringFromUint8Array(array) {
      var binaryString = "";
      for (var i = 0; i < array.length; ++i) {
        binaryString += String.fromCharCode(array[i]);
      }
      return binaryString;
    }
    function uint8ArrayFromBinaryString(binaryString) {
      var buffer = new Uint8Array(binaryString.length);
      for (var i = 0; i < binaryString.length; i++) {
        buffer[i] = binaryString.charCodeAt(i);
      }
      return buffer;
    }
    var ISO_TIMESTAMP_REG_EXP = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
    function normalizeTimestamp(date) {
      hardAssert(!!date);
      if (typeof date === "string") {
        var nanos = 0;
        var fraction = ISO_TIMESTAMP_REG_EXP.exec(date);
        hardAssert(!!fraction);
        if (fraction[1]) {
          var nanoStr = fraction[1];
          nanoStr = (nanoStr + "000000000").substr(0, 9);
          nanos = Number(nanoStr);
        }
        var parsedDate = new Date(date);
        var seconds = Math.floor(parsedDate.getTime() / 1e3);
        return { seconds, nanos };
      } else {
        var seconds = normalizeNumber(date.seconds);
        var nanos = normalizeNumber(date.nanos);
        return { seconds, nanos };
      }
    }
    function normalizeNumber(value) {
      if (typeof value === "number") {
        return value;
      } else if (typeof value === "string") {
        return Number(value);
      } else {
        return 0;
      }
    }
    function normalizeByteString(blob) {
      if (typeof blob === "string") {
        return ByteString.fromBase64String(blob);
      } else {
        return ByteString.fromUint8Array(blob);
      }
    }
    var SERVER_TIMESTAMP_SENTINEL = "server_timestamp";
    var TYPE_KEY = "__type__";
    var PREVIOUS_VALUE_KEY = "__previous_value__";
    var LOCAL_WRITE_TIME_KEY = "__local_write_time__";
    function isServerTimestamp(value) {
      var _a, _b;
      var type = (_b = (((_a = value === null || value === void 0 ? void 0 : value.mapValue) === null || _a === void 0 ? void 0 : _a.fields) || {})[TYPE_KEY]) === null || _b === void 0 ? void 0 : _b.stringValue;
      return type === SERVER_TIMESTAMP_SENTINEL;
    }
    function serverTimestamp$1(localWriteTime, previousValue) {
      var _d;
      var mapValue = {
        fields: (_d = {}, _d[TYPE_KEY] = {
          stringValue: SERVER_TIMESTAMP_SENTINEL
        }, _d[LOCAL_WRITE_TIME_KEY] = {
          timestampValue: {
            seconds: localWriteTime.seconds,
            nanos: localWriteTime.nanoseconds
          }
        }, _d)
      };
      if (previousValue) {
        mapValue.fields[PREVIOUS_VALUE_KEY] = previousValue;
      }
      return { mapValue };
    }
    function getPreviousValue(value) {
      var previousValue = value.mapValue.fields[PREVIOUS_VALUE_KEY];
      if (isServerTimestamp(previousValue)) {
        return getPreviousValue(previousValue);
      }
      return previousValue;
    }
    function getLocalWriteTime(value) {
      var localWriteTime = normalizeTimestamp(value.mapValue.fields[LOCAL_WRITE_TIME_KEY].timestampValue);
      return new Timestamp(localWriteTime.seconds, localWriteTime.nanos);
    }
    var BATCHID_UNKNOWN = -1;
    function isNullOrUndefined(value) {
      return value === null || value === void 0;
    }
    function isNegativeZero(value) {
      return value === 0 && 1 / value === 1 / -0;
    }
    function isSafeInteger(value) {
      return typeof value === "number" && Number.isInteger(value) && !isNegativeZero(value) && value <= Number.MAX_SAFE_INTEGER && value >= Number.MIN_SAFE_INTEGER;
    }
    var DocumentKey = function() {
      function DocumentKey2(path2) {
        this.path = path2;
      }
      DocumentKey2.fromPath = function(path2) {
        return new DocumentKey2(ResourcePath.fromString(path2));
      };
      DocumentKey2.fromName = function(name3) {
        return new DocumentKey2(ResourcePath.fromString(name3).popFirst(5));
      };
      DocumentKey2.prototype.hasCollectionId = function(collectionId) {
        return this.path.length >= 2 && this.path.get(this.path.length - 2) === collectionId;
      };
      DocumentKey2.prototype.isEqual = function(other) {
        return other !== null && ResourcePath.comparator(this.path, other.path) === 0;
      };
      DocumentKey2.prototype.toString = function() {
        return this.path.toString();
      };
      DocumentKey2.comparator = function(k1, k2) {
        return ResourcePath.comparator(k1.path, k2.path);
      };
      DocumentKey2.isDocumentKey = function(path2) {
        return path2.length % 2 === 0;
      };
      DocumentKey2.fromSegments = function(segments) {
        return new DocumentKey2(new ResourcePath(segments.slice()));
      };
      return DocumentKey2;
    }();
    function typeOrder(value) {
      if ("nullValue" in value) {
        return 0;
      } else if ("booleanValue" in value) {
        return 1;
      } else if ("integerValue" in value || "doubleValue" in value) {
        return 2;
      } else if ("timestampValue" in value) {
        return 3;
      } else if ("stringValue" in value) {
        return 5;
      } else if ("bytesValue" in value) {
        return 6;
      } else if ("referenceValue" in value) {
        return 7;
      } else if ("geoPointValue" in value) {
        return 8;
      } else if ("arrayValue" in value) {
        return 9;
      } else if ("mapValue" in value) {
        if (isServerTimestamp(value)) {
          return 4;
        }
        return 10;
      } else {
        return fail();
      }
    }
    function valueEquals(left, right) {
      var leftType = typeOrder(left);
      var rightType = typeOrder(right);
      if (leftType !== rightType) {
        return false;
      }
      switch (leftType) {
        case 0:
          return true;
        case 1:
          return left.booleanValue === right.booleanValue;
        case 4:
          return getLocalWriteTime(left).isEqual(getLocalWriteTime(right));
        case 3:
          return timestampEquals(left, right);
        case 5:
          return left.stringValue === right.stringValue;
        case 6:
          return blobEquals(left, right);
        case 7:
          return left.referenceValue === right.referenceValue;
        case 8:
          return geoPointEquals(left, right);
        case 2:
          return numberEquals(left, right);
        case 9:
          return arrayEquals(left.arrayValue.values || [], right.arrayValue.values || [], valueEquals);
        case 10:
          return objectEquals(left, right);
        default:
          return fail();
      }
    }
    function timestampEquals(left, right) {
      if (typeof left.timestampValue === "string" && typeof right.timestampValue === "string" && left.timestampValue.length === right.timestampValue.length) {
        return left.timestampValue === right.timestampValue;
      }
      var leftTimestamp = normalizeTimestamp(left.timestampValue);
      var rightTimestamp = normalizeTimestamp(right.timestampValue);
      return leftTimestamp.seconds === rightTimestamp.seconds && leftTimestamp.nanos === rightTimestamp.nanos;
    }
    function geoPointEquals(left, right) {
      return normalizeNumber(left.geoPointValue.latitude) === normalizeNumber(right.geoPointValue.latitude) && normalizeNumber(left.geoPointValue.longitude) === normalizeNumber(right.geoPointValue.longitude);
    }
    function blobEquals(left, right) {
      return normalizeByteString(left.bytesValue).isEqual(normalizeByteString(right.bytesValue));
    }
    function numberEquals(left, right) {
      if ("integerValue" in left && "integerValue" in right) {
        return normalizeNumber(left.integerValue) === normalizeNumber(right.integerValue);
      } else if ("doubleValue" in left && "doubleValue" in right) {
        var n1 = normalizeNumber(left.doubleValue);
        var n2 = normalizeNumber(right.doubleValue);
        if (n1 === n2) {
          return isNegativeZero(n1) === isNegativeZero(n2);
        } else {
          return isNaN(n1) && isNaN(n2);
        }
      }
      return false;
    }
    function objectEquals(left, right) {
      var leftMap = left.mapValue.fields || {};
      var rightMap = right.mapValue.fields || {};
      if (objectSize(leftMap) !== objectSize(rightMap)) {
        return false;
      }
      for (var key in leftMap) {
        if (leftMap.hasOwnProperty(key)) {
          if (rightMap[key] === void 0 || !valueEquals(leftMap[key], rightMap[key])) {
            return false;
          }
        }
      }
      return true;
    }
    function arrayValueContains(haystack, needle) {
      return (haystack.values || []).find(function(v) {
        return valueEquals(v, needle);
      }) !== void 0;
    }
    function valueCompare(left, right) {
      var leftType = typeOrder(left);
      var rightType = typeOrder(right);
      if (leftType !== rightType) {
        return primitiveComparator(leftType, rightType);
      }
      switch (leftType) {
        case 0:
          return 0;
        case 1:
          return primitiveComparator(left.booleanValue, right.booleanValue);
        case 2:
          return compareNumbers(left, right);
        case 3:
          return compareTimestamps(left.timestampValue, right.timestampValue);
        case 4:
          return compareTimestamps(getLocalWriteTime(left), getLocalWriteTime(right));
        case 5:
          return primitiveComparator(left.stringValue, right.stringValue);
        case 6:
          return compareBlobs(left.bytesValue, right.bytesValue);
        case 7:
          return compareReferences(left.referenceValue, right.referenceValue);
        case 8:
          return compareGeoPoints(left.geoPointValue, right.geoPointValue);
        case 9:
          return compareArrays(left.arrayValue, right.arrayValue);
        case 10:
          return compareMaps(left.mapValue, right.mapValue);
        default:
          throw fail();
      }
    }
    function compareNumbers(left, right) {
      var leftNumber = normalizeNumber(left.integerValue || left.doubleValue);
      var rightNumber = normalizeNumber(right.integerValue || right.doubleValue);
      if (leftNumber < rightNumber) {
        return -1;
      } else if (leftNumber > rightNumber) {
        return 1;
      } else if (leftNumber === rightNumber) {
        return 0;
      } else {
        if (isNaN(leftNumber)) {
          return isNaN(rightNumber) ? 0 : -1;
        } else {
          return 1;
        }
      }
    }
    function compareTimestamps(left, right) {
      if (typeof left === "string" && typeof right === "string" && left.length === right.length) {
        return primitiveComparator(left, right);
      }
      var leftTimestamp = normalizeTimestamp(left);
      var rightTimestamp = normalizeTimestamp(right);
      var comparison = primitiveComparator(leftTimestamp.seconds, rightTimestamp.seconds);
      if (comparison !== 0) {
        return comparison;
      }
      return primitiveComparator(leftTimestamp.nanos, rightTimestamp.nanos);
    }
    function compareReferences(leftPath, rightPath) {
      var leftSegments = leftPath.split("/");
      var rightSegments = rightPath.split("/");
      for (var i = 0; i < leftSegments.length && i < rightSegments.length; i++) {
        var comparison = primitiveComparator(leftSegments[i], rightSegments[i]);
        if (comparison !== 0) {
          return comparison;
        }
      }
      return primitiveComparator(leftSegments.length, rightSegments.length);
    }
    function compareGeoPoints(left, right) {
      var comparison = primitiveComparator(normalizeNumber(left.latitude), normalizeNumber(right.latitude));
      if (comparison !== 0) {
        return comparison;
      }
      return primitiveComparator(normalizeNumber(left.longitude), normalizeNumber(right.longitude));
    }
    function compareBlobs(left, right) {
      var leftBytes = normalizeByteString(left);
      var rightBytes = normalizeByteString(right);
      return leftBytes.compareTo(rightBytes);
    }
    function compareArrays(left, right) {
      var leftArray = left.values || [];
      var rightArray = right.values || [];
      for (var i = 0; i < leftArray.length && i < rightArray.length; ++i) {
        var compare = valueCompare(leftArray[i], rightArray[i]);
        if (compare) {
          return compare;
        }
      }
      return primitiveComparator(leftArray.length, rightArray.length);
    }
    function compareMaps(left, right) {
      var leftMap = left.fields || {};
      var leftKeys = Object.keys(leftMap);
      var rightMap = right.fields || {};
      var rightKeys = Object.keys(rightMap);
      leftKeys.sort();
      rightKeys.sort();
      for (var i = 0; i < leftKeys.length && i < rightKeys.length; ++i) {
        var keyCompare = primitiveComparator(leftKeys[i], rightKeys[i]);
        if (keyCompare !== 0) {
          return keyCompare;
        }
        var compare = valueCompare(leftMap[leftKeys[i]], rightMap[rightKeys[i]]);
        if (compare !== 0) {
          return compare;
        }
      }
      return primitiveComparator(leftKeys.length, rightKeys.length);
    }
    function canonicalId(value) {
      return canonifyValue(value);
    }
    function canonifyValue(value) {
      if ("nullValue" in value) {
        return "null";
      } else if ("booleanValue" in value) {
        return "" + value.booleanValue;
      } else if ("integerValue" in value) {
        return "" + value.integerValue;
      } else if ("doubleValue" in value) {
        return "" + value.doubleValue;
      } else if ("timestampValue" in value) {
        return canonifyTimestamp(value.timestampValue);
      } else if ("stringValue" in value) {
        return value.stringValue;
      } else if ("bytesValue" in value) {
        return canonifyByteString(value.bytesValue);
      } else if ("referenceValue" in value) {
        return canonifyReference(value.referenceValue);
      } else if ("geoPointValue" in value) {
        return canonifyGeoPoint(value.geoPointValue);
      } else if ("arrayValue" in value) {
        return canonifyArray(value.arrayValue);
      } else if ("mapValue" in value) {
        return canonifyMap(value.mapValue);
      } else {
        return fail();
      }
    }
    function canonifyByteString(byteString) {
      return normalizeByteString(byteString).toBase64();
    }
    function canonifyTimestamp(timestamp) {
      var normalizedTimestamp = normalizeTimestamp(timestamp);
      return "time(" + normalizedTimestamp.seconds + "," + normalizedTimestamp.nanos + ")";
    }
    function canonifyGeoPoint(geoPoint) {
      return "geo(" + geoPoint.latitude + "," + geoPoint.longitude + ")";
    }
    function canonifyReference(referenceValue) {
      return DocumentKey.fromName(referenceValue).toString();
    }
    function canonifyMap(mapValue) {
      var sortedKeys = Object.keys(mapValue.fields || {}).sort();
      var result = "{";
      var first = true;
      for (var _i = 0, sortedKeys_1 = sortedKeys; _i < sortedKeys_1.length; _i++) {
        var key = sortedKeys_1[_i];
        if (!first) {
          result += ",";
        } else {
          first = false;
        }
        result += key + ":" + canonifyValue(mapValue.fields[key]);
      }
      return result + "}";
    }
    function canonifyArray(arrayValue) {
      var result = "[";
      var first = true;
      for (var _i = 0, _d = arrayValue.values || []; _i < _d.length; _i++) {
        var value = _d[_i];
        if (!first) {
          result += ",";
        } else {
          first = false;
        }
        result += canonifyValue(value);
      }
      return result + "]";
    }
    function refValue(databaseId, key) {
      return {
        referenceValue: "projects/" + databaseId.projectId + "/databases/" + databaseId.database + "/documents/" + key.path.canonicalString()
      };
    }
    function isInteger(value) {
      return !!value && "integerValue" in value;
    }
    function isDouble(value) {
      return !!value && "doubleValue" in value;
    }
    function isNumber(value) {
      return isInteger(value) || isDouble(value);
    }
    function isArray(value) {
      return !!value && "arrayValue" in value;
    }
    function isNullValue(value) {
      return !!value && "nullValue" in value;
    }
    function isNanValue(value) {
      return !!value && "doubleValue" in value && isNaN(Number(value.doubleValue));
    }
    function isMapValue(value) {
      return !!value && "mapValue" in value;
    }
    function deepClone(source) {
      if (source.geoPointValue) {
        return { geoPointValue: Object.assign({}, source.geoPointValue) };
      } else if (source.timestampValue && typeof source.timestampValue === "object") {
        return { timestampValue: Object.assign({}, source.timestampValue) };
      } else if (source.mapValue) {
        var target_1 = { mapValue: { fields: {} } };
        forEach(source.mapValue.fields, function(key, val) {
          return target_1.mapValue.fields[key] = deepClone(val);
        });
        return target_1;
      } else if (source.arrayValue) {
        var target = { arrayValue: { values: [] } };
        for (var i = 0; i < (source.arrayValue.values || []).length; ++i) {
          target.arrayValue.values[i] = deepClone(source.arrayValue.values[i]);
        }
        return target;
      } else {
        return Object.assign({}, source);
      }
    }
    var ObjectValue = function() {
      function ObjectValue2(value) {
        this.value = value;
      }
      ObjectValue2.empty = function() {
        return new ObjectValue2({ mapValue: {} });
      };
      ObjectValue2.prototype.field = function(path2) {
        if (path2.isEmpty()) {
          return this.value;
        } else {
          var currentLevel = this.value;
          for (var i = 0; i < path2.length - 1; ++i) {
            currentLevel = (currentLevel.mapValue.fields || {})[path2.get(i)];
            if (!isMapValue(currentLevel)) {
              return null;
            }
          }
          currentLevel = (currentLevel.mapValue.fields || {})[path2.lastSegment()];
          return currentLevel || null;
        }
      };
      ObjectValue2.prototype.set = function(path2, value) {
        var fieldsMap = this.getFieldsMap(path2.popLast());
        fieldsMap[path2.lastSegment()] = deepClone(value);
      };
      ObjectValue2.prototype.setAll = function(data) {
        var _this = this;
        var parent2 = FieldPath$1.emptyPath();
        var upserts = {};
        var deletes = [];
        data.forEach(function(value, path2) {
          if (!parent2.isImmediateParentOf(path2)) {
            var fieldsMap_1 = _this.getFieldsMap(parent2);
            _this.applyChanges(fieldsMap_1, upserts, deletes);
            upserts = {};
            deletes = [];
            parent2 = path2.popLast();
          }
          if (value) {
            upserts[path2.lastSegment()] = deepClone(value);
          } else {
            deletes.push(path2.lastSegment());
          }
        });
        var fieldsMap = this.getFieldsMap(parent2);
        this.applyChanges(fieldsMap, upserts, deletes);
      };
      ObjectValue2.prototype.delete = function(path2) {
        var nestedValue = this.field(path2.popLast());
        if (isMapValue(nestedValue) && nestedValue.mapValue.fields) {
          delete nestedValue.mapValue.fields[path2.lastSegment()];
        }
      };
      ObjectValue2.prototype.isEqual = function(other) {
        return valueEquals(this.value, other.value);
      };
      ObjectValue2.prototype.getFieldsMap = function(path2) {
        var current = this.value;
        if (!current.mapValue.fields) {
          current.mapValue = { fields: {} };
        }
        for (var i = 0; i < path2.length; ++i) {
          var next = current.mapValue.fields[path2.get(i)];
          if (!isMapValue(next) || !next.mapValue.fields) {
            next = { mapValue: { fields: {} } };
            current.mapValue.fields[path2.get(i)] = next;
          }
          current = next;
        }
        return current.mapValue.fields;
      };
      ObjectValue2.prototype.applyChanges = function(fieldsMap, inserts, deletes) {
        forEach(inserts, function(key, val) {
          return fieldsMap[key] = val;
        });
        for (var _i = 0, deletes_1 = deletes; _i < deletes_1.length; _i++) {
          var field = deletes_1[_i];
          delete fieldsMap[field];
        }
      };
      ObjectValue2.prototype.clone = function() {
        return new ObjectValue2(deepClone(this.value));
      };
      return ObjectValue2;
    }();
    function extractFieldMask(value) {
      var fields = [];
      forEach(value.fields, function(key, value2) {
        var currentPath = new FieldPath$1([key]);
        if (isMapValue(value2)) {
          var nestedMask = extractFieldMask(value2.mapValue);
          var nestedFields = nestedMask.fields;
          if (nestedFields.length === 0) {
            fields.push(currentPath);
          } else {
            for (var _i = 0, nestedFields_1 = nestedFields; _i < nestedFields_1.length; _i++) {
              var nestedPath = nestedFields_1[_i];
              fields.push(currentPath.child(nestedPath));
            }
          }
        } else {
          fields.push(currentPath);
        }
      });
      return new FieldMask(fields);
    }
    var MutableDocument = function() {
      function MutableDocument2(key, documentType, version3, data, documentState) {
        this.key = key;
        this.documentType = documentType;
        this.version = version3;
        this.data = data;
        this.documentState = documentState;
      }
      MutableDocument2.newInvalidDocument = function(documentKey) {
        return new MutableDocument2(documentKey, 0, SnapshotVersion.min(), ObjectValue.empty(), 0);
      };
      MutableDocument2.newFoundDocument = function(documentKey, version3, value) {
        return new MutableDocument2(documentKey, 1, version3, value, 0);
      };
      MutableDocument2.newNoDocument = function(documentKey, version3) {
        return new MutableDocument2(documentKey, 2, version3, ObjectValue.empty(), 0);
      };
      MutableDocument2.newUnknownDocument = function(documentKey, version3) {
        return new MutableDocument2(documentKey, 3, version3, ObjectValue.empty(), 2);
      };
      MutableDocument2.prototype.convertToFoundDocument = function(version3, value) {
        this.version = version3;
        this.documentType = 1;
        this.data = value;
        this.documentState = 0;
        return this;
      };
      MutableDocument2.prototype.convertToNoDocument = function(version3) {
        this.version = version3;
        this.documentType = 2;
        this.data = ObjectValue.empty();
        this.documentState = 0;
        return this;
      };
      MutableDocument2.prototype.convertToUnknownDocument = function(version3) {
        this.version = version3;
        this.documentType = 3;
        this.data = ObjectValue.empty();
        this.documentState = 2;
        return this;
      };
      MutableDocument2.prototype.setHasCommittedMutations = function() {
        this.documentState = 2;
        return this;
      };
      MutableDocument2.prototype.setHasLocalMutations = function() {
        this.documentState = 1;
        return this;
      };
      Object.defineProperty(MutableDocument2.prototype, "hasLocalMutations", {
        get: function() {
          return this.documentState === 1;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MutableDocument2.prototype, "hasCommittedMutations", {
        get: function() {
          return this.documentState === 2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MutableDocument2.prototype, "hasPendingWrites", {
        get: function() {
          return this.hasLocalMutations || this.hasCommittedMutations;
        },
        enumerable: false,
        configurable: true
      });
      MutableDocument2.prototype.isValidDocument = function() {
        return this.documentType !== 0;
      };
      MutableDocument2.prototype.isFoundDocument = function() {
        return this.documentType === 1;
      };
      MutableDocument2.prototype.isNoDocument = function() {
        return this.documentType === 2;
      };
      MutableDocument2.prototype.isUnknownDocument = function() {
        return this.documentType === 3;
      };
      MutableDocument2.prototype.isEqual = function(other) {
        return other instanceof MutableDocument2 && this.key.isEqual(other.key) && this.version.isEqual(other.version) && this.documentType === other.documentType && this.documentState === other.documentState && this.data.isEqual(other.data);
      };
      MutableDocument2.prototype.clone = function() {
        return new MutableDocument2(this.key, this.documentType, this.version, this.data.clone(), this.documentState);
      };
      MutableDocument2.prototype.toString = function() {
        return "Document(" + this.key + ", " + this.version + ", " + JSON.stringify(this.data.value) + ", " + ("{documentType: " + this.documentType + "}), ") + ("{documentState: " + this.documentState + "})");
      };
      return MutableDocument2;
    }();
    function compareDocumentsByField(field, d1, d2) {
      var v1 = d1.data.field(field);
      var v2 = d2.data.field(field);
      if (v1 !== null && v2 !== null) {
        return valueCompare(v1, v2);
      } else {
        return fail();
      }
    }
    var TargetImpl = function() {
      function TargetImpl2(path2, collectionGroup2, orderBy2, filters, limit2, startAt2, endAt2) {
        if (collectionGroup2 === void 0) {
          collectionGroup2 = null;
        }
        if (orderBy2 === void 0) {
          orderBy2 = [];
        }
        if (filters === void 0) {
          filters = [];
        }
        if (limit2 === void 0) {
          limit2 = null;
        }
        if (startAt2 === void 0) {
          startAt2 = null;
        }
        if (endAt2 === void 0) {
          endAt2 = null;
        }
        this.path = path2;
        this.collectionGroup = collectionGroup2;
        this.orderBy = orderBy2;
        this.filters = filters;
        this.limit = limit2;
        this.startAt = startAt2;
        this.endAt = endAt2;
        this.memoizedCanonicalId = null;
      }
      return TargetImpl2;
    }();
    function newTarget(path2, collectionGroup2, orderBy2, filters, limit2, startAt2, endAt2) {
      if (collectionGroup2 === void 0) {
        collectionGroup2 = null;
      }
      if (orderBy2 === void 0) {
        orderBy2 = [];
      }
      if (filters === void 0) {
        filters = [];
      }
      if (limit2 === void 0) {
        limit2 = null;
      }
      if (startAt2 === void 0) {
        startAt2 = null;
      }
      if (endAt2 === void 0) {
        endAt2 = null;
      }
      return new TargetImpl(path2, collectionGroup2, orderBy2, filters, limit2, startAt2, endAt2);
    }
    function canonifyTarget(target) {
      var targetImpl = debugCast(target);
      if (targetImpl.memoizedCanonicalId === null) {
        var canonicalId_1 = targetImpl.path.canonicalString();
        if (targetImpl.collectionGroup !== null) {
          canonicalId_1 += "|cg:" + targetImpl.collectionGroup;
        }
        canonicalId_1 += "|f:";
        canonicalId_1 += targetImpl.filters.map(function(f) {
          return canonifyFilter(f);
        }).join(",");
        canonicalId_1 += "|ob:";
        canonicalId_1 += targetImpl.orderBy.map(function(o) {
          return canonifyOrderBy(o);
        }).join(",");
        if (!isNullOrUndefined(targetImpl.limit)) {
          canonicalId_1 += "|l:";
          canonicalId_1 += targetImpl.limit;
        }
        if (targetImpl.startAt) {
          canonicalId_1 += "|lb:";
          canonicalId_1 += canonifyBound(targetImpl.startAt);
        }
        if (targetImpl.endAt) {
          canonicalId_1 += "|ub:";
          canonicalId_1 += canonifyBound(targetImpl.endAt);
        }
        targetImpl.memoizedCanonicalId = canonicalId_1;
      }
      return targetImpl.memoizedCanonicalId;
    }
    function stringifyTarget(target) {
      var str = target.path.canonicalString();
      if (target.collectionGroup !== null) {
        str += " collectionGroup=" + target.collectionGroup;
      }
      if (target.filters.length > 0) {
        str += ", filters: [" + target.filters.map(function(f) {
          return stringifyFilter(f);
        }).join(", ") + "]";
      }
      if (!isNullOrUndefined(target.limit)) {
        str += ", limit: " + target.limit;
      }
      if (target.orderBy.length > 0) {
        str += ", orderBy: [" + target.orderBy.map(function(o) {
          return stringifyOrderBy(o);
        }).join(", ") + "]";
      }
      if (target.startAt) {
        str += ", startAt: " + canonifyBound(target.startAt);
      }
      if (target.endAt) {
        str += ", endAt: " + canonifyBound(target.endAt);
      }
      return "Target(" + str + ")";
    }
    function targetEquals(left, right) {
      if (left.limit !== right.limit) {
        return false;
      }
      if (left.orderBy.length !== right.orderBy.length) {
        return false;
      }
      for (var i = 0; i < left.orderBy.length; i++) {
        if (!orderByEquals(left.orderBy[i], right.orderBy[i])) {
          return false;
        }
      }
      if (left.filters.length !== right.filters.length) {
        return false;
      }
      for (var i = 0; i < left.filters.length; i++) {
        if (!filterEquals(left.filters[i], right.filters[i])) {
          return false;
        }
      }
      if (left.collectionGroup !== right.collectionGroup) {
        return false;
      }
      if (!left.path.isEqual(right.path)) {
        return false;
      }
      if (!boundEquals(left.startAt, right.startAt)) {
        return false;
      }
      return boundEquals(left.endAt, right.endAt);
    }
    function isDocumentTarget(target) {
      return DocumentKey.isDocumentKey(target.path) && target.collectionGroup === null && target.filters.length === 0;
    }
    var Filter = function() {
      function Filter2() {
      }
      return Filter2;
    }();
    var FieldFilter = function(_super) {
      tslib2.__extends(FieldFilter2, _super);
      function FieldFilter2(field, op, value) {
        var _this = _super.call(this) || this;
        _this.field = field;
        _this.op = op;
        _this.value = value;
        return _this;
      }
      FieldFilter2.create = function(field, op, value) {
        if (field.isKeyField()) {
          if (op === "in" || op === "not-in") {
            return this.createKeyFieldInFilter(field, op, value);
          } else {
            return new KeyFieldFilter(field, op, value);
          }
        } else if (op === "array-contains") {
          return new ArrayContainsFilter(field, value);
        } else if (op === "in") {
          return new InFilter(field, value);
        } else if (op === "not-in") {
          return new NotInFilter(field, value);
        } else if (op === "array-contains-any") {
          return new ArrayContainsAnyFilter(field, value);
        } else {
          return new FieldFilter2(field, op, value);
        }
      };
      FieldFilter2.createKeyFieldInFilter = function(field, op, value) {
        return op === "in" ? new KeyFieldInFilter(field, value) : new KeyFieldNotInFilter(field, value);
      };
      FieldFilter2.prototype.matches = function(doc2) {
        var other = doc2.data.field(this.field);
        if (this.op === "!=") {
          return other !== null && this.matchesComparison(valueCompare(other, this.value));
        }
        return other !== null && typeOrder(this.value) === typeOrder(other) && this.matchesComparison(valueCompare(other, this.value));
      };
      FieldFilter2.prototype.matchesComparison = function(comparison) {
        switch (this.op) {
          case "<":
            return comparison < 0;
          case "<=":
            return comparison <= 0;
          case "==":
            return comparison === 0;
          case "!=":
            return comparison !== 0;
          case ">":
            return comparison > 0;
          case ">=":
            return comparison >= 0;
          default:
            return fail();
        }
      };
      FieldFilter2.prototype.isInequality = function() {
        return [
          "<",
          "<=",
          ">",
          ">=",
          "!=",
          "not-in"
        ].indexOf(this.op) >= 0;
      };
      return FieldFilter2;
    }(Filter);
    function canonifyFilter(filter2) {
      return filter2.field.canonicalString() + filter2.op.toString() + canonicalId(filter2.value);
    }
    function filterEquals(f1, f2) {
      return f1.op === f2.op && f1.field.isEqual(f2.field) && valueEquals(f1.value, f2.value);
    }
    function stringifyFilter(filter2) {
      return filter2.field.canonicalString() + " " + filter2.op + " " + canonicalId(filter2.value);
    }
    var KeyFieldFilter = function(_super) {
      tslib2.__extends(KeyFieldFilter2, _super);
      function KeyFieldFilter2(field, op, value) {
        var _this = _super.call(this, field, op, value) || this;
        _this.key = DocumentKey.fromName(value.referenceValue);
        return _this;
      }
      KeyFieldFilter2.prototype.matches = function(doc2) {
        var comparison = DocumentKey.comparator(doc2.key, this.key);
        return this.matchesComparison(comparison);
      };
      return KeyFieldFilter2;
    }(FieldFilter);
    var KeyFieldInFilter = function(_super) {
      tslib2.__extends(KeyFieldInFilter2, _super);
      function KeyFieldInFilter2(field, value) {
        var _this = _super.call(this, field, "in", value) || this;
        _this.keys = extractDocumentKeysFromArrayValue("in", value);
        return _this;
      }
      KeyFieldInFilter2.prototype.matches = function(doc2) {
        return this.keys.some(function(key) {
          return key.isEqual(doc2.key);
        });
      };
      return KeyFieldInFilter2;
    }(FieldFilter);
    var KeyFieldNotInFilter = function(_super) {
      tslib2.__extends(KeyFieldNotInFilter2, _super);
      function KeyFieldNotInFilter2(field, value) {
        var _this = _super.call(this, field, "not-in", value) || this;
        _this.keys = extractDocumentKeysFromArrayValue("not-in", value);
        return _this;
      }
      KeyFieldNotInFilter2.prototype.matches = function(doc2) {
        return !this.keys.some(function(key) {
          return key.isEqual(doc2.key);
        });
      };
      return KeyFieldNotInFilter2;
    }(FieldFilter);
    function extractDocumentKeysFromArrayValue(op, value) {
      var _a;
      return (((_a = value.arrayValue) === null || _a === void 0 ? void 0 : _a.values) || []).map(function(v) {
        return DocumentKey.fromName(v.referenceValue);
      });
    }
    var ArrayContainsFilter = function(_super) {
      tslib2.__extends(ArrayContainsFilter2, _super);
      function ArrayContainsFilter2(field, value) {
        return _super.call(this, field, "array-contains", value) || this;
      }
      ArrayContainsFilter2.prototype.matches = function(doc2) {
        var other = doc2.data.field(this.field);
        return isArray(other) && arrayValueContains(other.arrayValue, this.value);
      };
      return ArrayContainsFilter2;
    }(FieldFilter);
    var InFilter = function(_super) {
      tslib2.__extends(InFilter2, _super);
      function InFilter2(field, value) {
        return _super.call(this, field, "in", value) || this;
      }
      InFilter2.prototype.matches = function(doc2) {
        var other = doc2.data.field(this.field);
        return other !== null && arrayValueContains(this.value.arrayValue, other);
      };
      return InFilter2;
    }(FieldFilter);
    var NotInFilter = function(_super) {
      tslib2.__extends(NotInFilter2, _super);
      function NotInFilter2(field, value) {
        return _super.call(this, field, "not-in", value) || this;
      }
      NotInFilter2.prototype.matches = function(doc2) {
        if (arrayValueContains(this.value.arrayValue, { nullValue: "NULL_VALUE" })) {
          return false;
        }
        var other = doc2.data.field(this.field);
        return other !== null && !arrayValueContains(this.value.arrayValue, other);
      };
      return NotInFilter2;
    }(FieldFilter);
    var ArrayContainsAnyFilter = function(_super) {
      tslib2.__extends(ArrayContainsAnyFilter2, _super);
      function ArrayContainsAnyFilter2(field, value) {
        return _super.call(this, field, "array-contains-any", value) || this;
      }
      ArrayContainsAnyFilter2.prototype.matches = function(doc2) {
        var _this = this;
        var other = doc2.data.field(this.field);
        if (!isArray(other) || !other.arrayValue.values) {
          return false;
        }
        return other.arrayValue.values.some(function(val) {
          return arrayValueContains(_this.value.arrayValue, val);
        });
      };
      return ArrayContainsAnyFilter2;
    }(FieldFilter);
    var Bound = function() {
      function Bound2(position, before) {
        this.position = position;
        this.before = before;
      }
      return Bound2;
    }();
    function canonifyBound(bound) {
      return (bound.before ? "b" : "a") + ":" + bound.position.map(function(p) {
        return canonicalId(p);
      }).join(",");
    }
    var OrderBy = function() {
      function OrderBy2(field, dir) {
        if (dir === void 0) {
          dir = "asc";
        }
        this.field = field;
        this.dir = dir;
      }
      return OrderBy2;
    }();
    function canonifyOrderBy(orderBy2) {
      return orderBy2.field.canonicalString() + orderBy2.dir;
    }
    function stringifyOrderBy(orderBy2) {
      return orderBy2.field.canonicalString() + " (" + orderBy2.dir + ")";
    }
    function orderByEquals(left, right) {
      return left.dir === right.dir && left.field.isEqual(right.field);
    }
    function sortsBeforeDocument(bound, orderBy2, doc2) {
      var comparison = 0;
      for (var i = 0; i < bound.position.length; i++) {
        var orderByComponent = orderBy2[i];
        var component2 = bound.position[i];
        if (orderByComponent.field.isKeyField()) {
          comparison = DocumentKey.comparator(DocumentKey.fromName(component2.referenceValue), doc2.key);
        } else {
          var docValue = doc2.data.field(orderByComponent.field);
          comparison = valueCompare(component2, docValue);
        }
        if (orderByComponent.dir === "desc") {
          comparison = comparison * -1;
        }
        if (comparison !== 0) {
          break;
        }
      }
      return bound.before ? comparison <= 0 : comparison < 0;
    }
    function boundEquals(left, right) {
      if (left === null) {
        return right === null;
      } else if (right === null) {
        return false;
      }
      if (left.before !== right.before || left.position.length !== right.position.length) {
        return false;
      }
      for (var i = 0; i < left.position.length; i++) {
        var leftPosition = left.position[i];
        var rightPosition = right.position[i];
        if (!valueEquals(leftPosition, rightPosition)) {
          return false;
        }
      }
      return true;
    }
    var QueryImpl = function() {
      function QueryImpl2(path2, collectionGroup2, explicitOrderBy, filters, limit2, limitType, startAt2, endAt2) {
        if (collectionGroup2 === void 0) {
          collectionGroup2 = null;
        }
        if (explicitOrderBy === void 0) {
          explicitOrderBy = [];
        }
        if (filters === void 0) {
          filters = [];
        }
        if (limit2 === void 0) {
          limit2 = null;
        }
        if (limitType === void 0) {
          limitType = "F";
        }
        if (startAt2 === void 0) {
          startAt2 = null;
        }
        if (endAt2 === void 0) {
          endAt2 = null;
        }
        this.path = path2;
        this.collectionGroup = collectionGroup2;
        this.explicitOrderBy = explicitOrderBy;
        this.filters = filters;
        this.limit = limit2;
        this.limitType = limitType;
        this.startAt = startAt2;
        this.endAt = endAt2;
        this.memoizedOrderBy = null;
        this.memoizedTarget = null;
        if (this.startAt)
          ;
        if (this.endAt)
          ;
      }
      return QueryImpl2;
    }();
    function newQuery(path2, collectionGroup2, explicitOrderBy, filters, limit2, limitType, startAt2, endAt2) {
      return new QueryImpl(path2, collectionGroup2, explicitOrderBy, filters, limit2, limitType, startAt2, endAt2);
    }
    function newQueryForPath(path2) {
      return new QueryImpl(path2);
    }
    function asCollectionQueryAtPath(query2, path2) {
      return new QueryImpl(path2, null, query2.explicitOrderBy.slice(), query2.filters.slice(), query2.limit, query2.limitType, query2.startAt, query2.endAt);
    }
    function matchesAllDocuments(query2) {
      return query2.filters.length === 0 && query2.limit === null && query2.startAt == null && query2.endAt == null && (query2.explicitOrderBy.length === 0 || query2.explicitOrderBy.length === 1 && query2.explicitOrderBy[0].field.isKeyField());
    }
    function hasLimitToFirst(query2) {
      return !isNullOrUndefined(query2.limit) && query2.limitType === "F";
    }
    function hasLimitToLast(query2) {
      return !isNullOrUndefined(query2.limit) && query2.limitType === "L";
    }
    function getFirstOrderByField(query2) {
      return query2.explicitOrderBy.length > 0 ? query2.explicitOrderBy[0].field : null;
    }
    function getInequalityFilterField(query2) {
      for (var _i = 0, _d = query2.filters; _i < _d.length; _i++) {
        var filter2 = _d[_i];
        if (filter2.isInequality()) {
          return filter2.field;
        }
      }
      return null;
    }
    function findFilterOperator(query2, operators) {
      for (var _i = 0, _d = query2.filters; _i < _d.length; _i++) {
        var filter2 = _d[_i];
        if (operators.indexOf(filter2.op) >= 0) {
          return filter2.op;
        }
      }
      return null;
    }
    function newQueryForCollectionGroup(collectionId) {
      return new QueryImpl(ResourcePath.emptyPath(), collectionId);
    }
    function isDocumentQuery$1(query2) {
      return DocumentKey.isDocumentKey(query2.path) && query2.collectionGroup === null && query2.filters.length === 0;
    }
    function isCollectionGroupQuery(query2) {
      return query2.collectionGroup !== null;
    }
    function queryOrderBy(query2) {
      var queryImpl = debugCast(query2);
      if (queryImpl.memoizedOrderBy === null) {
        queryImpl.memoizedOrderBy = [];
        var inequalityField = getInequalityFilterField(queryImpl);
        var firstOrderByField = getFirstOrderByField(queryImpl);
        if (inequalityField !== null && firstOrderByField === null) {
          if (!inequalityField.isKeyField()) {
            queryImpl.memoizedOrderBy.push(new OrderBy(inequalityField));
          }
          queryImpl.memoizedOrderBy.push(new OrderBy(FieldPath$1.keyField(), "asc"));
        } else {
          var foundKeyOrdering = false;
          for (var _i = 0, _d = queryImpl.explicitOrderBy; _i < _d.length; _i++) {
            var orderBy_1 = _d[_i];
            queryImpl.memoizedOrderBy.push(orderBy_1);
            if (orderBy_1.field.isKeyField()) {
              foundKeyOrdering = true;
            }
          }
          if (!foundKeyOrdering) {
            var lastDirection = queryImpl.explicitOrderBy.length > 0 ? queryImpl.explicitOrderBy[queryImpl.explicitOrderBy.length - 1].dir : "asc";
            queryImpl.memoizedOrderBy.push(new OrderBy(FieldPath$1.keyField(), lastDirection));
          }
        }
      }
      return queryImpl.memoizedOrderBy;
    }
    function queryToTarget(query2) {
      var queryImpl = debugCast(query2);
      if (!queryImpl.memoizedTarget) {
        if (queryImpl.limitType === "F") {
          queryImpl.memoizedTarget = newTarget(queryImpl.path, queryImpl.collectionGroup, queryOrderBy(queryImpl), queryImpl.filters, queryImpl.limit, queryImpl.startAt, queryImpl.endAt);
        } else {
          var orderBys = [];
          for (var _i = 0, _d = queryOrderBy(queryImpl); _i < _d.length; _i++) {
            var orderBy_2 = _d[_i];
            var dir = orderBy_2.dir === "desc" ? "asc" : "desc";
            orderBys.push(new OrderBy(orderBy_2.field, dir));
          }
          var startAt_1 = queryImpl.endAt ? new Bound(queryImpl.endAt.position, !queryImpl.endAt.before) : null;
          var endAt_1 = queryImpl.startAt ? new Bound(queryImpl.startAt.position, !queryImpl.startAt.before) : null;
          queryImpl.memoizedTarget = newTarget(queryImpl.path, queryImpl.collectionGroup, orderBys, queryImpl.filters, queryImpl.limit, startAt_1, endAt_1);
        }
      }
      return queryImpl.memoizedTarget;
    }
    function queryWithAddedFilter(query2, filter2) {
      var newFilters = query2.filters.concat([filter2]);
      return new QueryImpl(query2.path, query2.collectionGroup, query2.explicitOrderBy.slice(), newFilters, query2.limit, query2.limitType, query2.startAt, query2.endAt);
    }
    function queryWithAddedOrderBy(query2, orderBy2) {
      var newOrderBy = query2.explicitOrderBy.concat([orderBy2]);
      return new QueryImpl(query2.path, query2.collectionGroup, newOrderBy, query2.filters.slice(), query2.limit, query2.limitType, query2.startAt, query2.endAt);
    }
    function queryWithLimit(query2, limit2, limitType) {
      return new QueryImpl(query2.path, query2.collectionGroup, query2.explicitOrderBy.slice(), query2.filters.slice(), limit2, limitType, query2.startAt, query2.endAt);
    }
    function queryWithStartAt(query2, bound) {
      return new QueryImpl(query2.path, query2.collectionGroup, query2.explicitOrderBy.slice(), query2.filters.slice(), query2.limit, query2.limitType, bound, query2.endAt);
    }
    function queryWithEndAt(query2, bound) {
      return new QueryImpl(query2.path, query2.collectionGroup, query2.explicitOrderBy.slice(), query2.filters.slice(), query2.limit, query2.limitType, query2.startAt, bound);
    }
    function queryEquals(left, right) {
      return targetEquals(queryToTarget(left), queryToTarget(right)) && left.limitType === right.limitType;
    }
    function canonifyQuery(query2) {
      return canonifyTarget(queryToTarget(query2)) + "|lt:" + query2.limitType;
    }
    function stringifyQuery(query2) {
      return "Query(target=" + stringifyTarget(queryToTarget(query2)) + "; limitType=" + query2.limitType + ")";
    }
    function queryMatches(query2, doc2) {
      return doc2.isFoundDocument() && queryMatchesPathAndCollectionGroup(query2, doc2) && queryMatchesOrderBy(query2, doc2) && queryMatchesFilters(query2, doc2) && queryMatchesBounds(query2, doc2);
    }
    function queryMatchesPathAndCollectionGroup(query2, doc2) {
      var docPath = doc2.key.path;
      if (query2.collectionGroup !== null) {
        return doc2.key.hasCollectionId(query2.collectionGroup) && query2.path.isPrefixOf(docPath);
      } else if (DocumentKey.isDocumentKey(query2.path)) {
        return query2.path.isEqual(docPath);
      } else {
        return query2.path.isImmediateParentOf(docPath);
      }
    }
    function queryMatchesOrderBy(query2, doc2) {
      for (var _i = 0, _d = query2.explicitOrderBy; _i < _d.length; _i++) {
        var orderBy_3 = _d[_i];
        if (!orderBy_3.field.isKeyField() && doc2.data.field(orderBy_3.field) === null) {
          return false;
        }
      }
      return true;
    }
    function queryMatchesFilters(query2, doc2) {
      for (var _i = 0, _d = query2.filters; _i < _d.length; _i++) {
        var filter2 = _d[_i];
        if (!filter2.matches(doc2)) {
          return false;
        }
      }
      return true;
    }
    function queryMatchesBounds(query2, doc2) {
      if (query2.startAt && !sortsBeforeDocument(query2.startAt, queryOrderBy(query2), doc2)) {
        return false;
      }
      if (query2.endAt && sortsBeforeDocument(query2.endAt, queryOrderBy(query2), doc2)) {
        return false;
      }
      return true;
    }
    function newQueryComparator(query2) {
      return function(d1, d2) {
        var comparedOnKeyField = false;
        for (var _i = 0, _d = queryOrderBy(query2); _i < _d.length; _i++) {
          var orderBy_4 = _d[_i];
          var comp = compareDocs(orderBy_4, d1, d2);
          if (comp !== 0) {
            return comp;
          }
          comparedOnKeyField = comparedOnKeyField || orderBy_4.field.isKeyField();
        }
        return 0;
      };
    }
    function compareDocs(orderBy2, d1, d2) {
      var comparison = orderBy2.field.isKeyField() ? DocumentKey.comparator(d1.key, d2.key) : compareDocumentsByField(orderBy2.field, d1, d2);
      switch (orderBy2.dir) {
        case "asc":
          return comparison;
        case "desc":
          return -1 * comparison;
        default:
          return fail();
      }
    }
    var SortedMap = function() {
      function SortedMap2(comparator, root) {
        this.comparator = comparator;
        this.root = root ? root : LLRBNode.EMPTY;
      }
      SortedMap2.prototype.insert = function(key, value) {
        return new SortedMap2(this.comparator, this.root.insert(key, value, this.comparator).copy(null, null, LLRBNode.BLACK, null, null));
      };
      SortedMap2.prototype.remove = function(key) {
        return new SortedMap2(this.comparator, this.root.remove(key, this.comparator).copy(null, null, LLRBNode.BLACK, null, null));
      };
      SortedMap2.prototype.get = function(key) {
        var node = this.root;
        while (!node.isEmpty()) {
          var cmp = this.comparator(key, node.key);
          if (cmp === 0) {
            return node.value;
          } else if (cmp < 0) {
            node = node.left;
          } else if (cmp > 0) {
            node = node.right;
          }
        }
        return null;
      };
      SortedMap2.prototype.indexOf = function(key) {
        var prunedNodes = 0;
        var node = this.root;
        while (!node.isEmpty()) {
          var cmp = this.comparator(key, node.key);
          if (cmp === 0) {
            return prunedNodes + node.left.size;
          } else if (cmp < 0) {
            node = node.left;
          } else {
            prunedNodes += node.left.size + 1;
            node = node.right;
          }
        }
        return -1;
      };
      SortedMap2.prototype.isEmpty = function() {
        return this.root.isEmpty();
      };
      Object.defineProperty(SortedMap2.prototype, "size", {
        get: function() {
          return this.root.size;
        },
        enumerable: false,
        configurable: true
      });
      SortedMap2.prototype.minKey = function() {
        return this.root.minKey();
      };
      SortedMap2.prototype.maxKey = function() {
        return this.root.maxKey();
      };
      SortedMap2.prototype.inorderTraversal = function(action) {
        return this.root.inorderTraversal(action);
      };
      SortedMap2.prototype.forEach = function(fn) {
        this.inorderTraversal(function(k, v) {
          fn(k, v);
          return false;
        });
      };
      SortedMap2.prototype.toString = function() {
        var descriptions = [];
        this.inorderTraversal(function(k, v) {
          descriptions.push(k + ":" + v);
          return false;
        });
        return "{" + descriptions.join(", ") + "}";
      };
      SortedMap2.prototype.reverseTraversal = function(action) {
        return this.root.reverseTraversal(action);
      };
      SortedMap2.prototype.getIterator = function() {
        return new SortedMapIterator(this.root, null, this.comparator, false);
      };
      SortedMap2.prototype.getIteratorFrom = function(key) {
        return new SortedMapIterator(this.root, key, this.comparator, false);
      };
      SortedMap2.prototype.getReverseIterator = function() {
        return new SortedMapIterator(this.root, null, this.comparator, true);
      };
      SortedMap2.prototype.getReverseIteratorFrom = function(key) {
        return new SortedMapIterator(this.root, key, this.comparator, true);
      };
      return SortedMap2;
    }();
    var SortedMapIterator = function() {
      function SortedMapIterator2(node, startKey, comparator, isReverse) {
        this.isReverse = isReverse;
        this.nodeStack = [];
        var cmp = 1;
        while (!node.isEmpty()) {
          cmp = startKey ? comparator(node.key, startKey) : 1;
          if (isReverse) {
            cmp *= -1;
          }
          if (cmp < 0) {
            if (this.isReverse) {
              node = node.left;
            } else {
              node = node.right;
            }
          } else if (cmp === 0) {
            this.nodeStack.push(node);
            break;
          } else {
            this.nodeStack.push(node);
            if (this.isReverse) {
              node = node.right;
            } else {
              node = node.left;
            }
          }
        }
      }
      SortedMapIterator2.prototype.getNext = function() {
        var node = this.nodeStack.pop();
        var result = { key: node.key, value: node.value };
        if (this.isReverse) {
          node = node.left;
          while (!node.isEmpty()) {
            this.nodeStack.push(node);
            node = node.right;
          }
        } else {
          node = node.right;
          while (!node.isEmpty()) {
            this.nodeStack.push(node);
            node = node.left;
          }
        }
        return result;
      };
      SortedMapIterator2.prototype.hasNext = function() {
        return this.nodeStack.length > 0;
      };
      SortedMapIterator2.prototype.peek = function() {
        if (this.nodeStack.length === 0) {
          return null;
        }
        var node = this.nodeStack[this.nodeStack.length - 1];
        return { key: node.key, value: node.value };
      };
      return SortedMapIterator2;
    }();
    var LLRBNode = function() {
      function LLRBNode2(key, value, color, left, right) {
        this.key = key;
        this.value = value;
        this.color = color != null ? color : LLRBNode2.RED;
        this.left = left != null ? left : LLRBNode2.EMPTY;
        this.right = right != null ? right : LLRBNode2.EMPTY;
        this.size = this.left.size + 1 + this.right.size;
      }
      LLRBNode2.prototype.copy = function(key, value, color, left, right) {
        return new LLRBNode2(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);
      };
      LLRBNode2.prototype.isEmpty = function() {
        return false;
      };
      LLRBNode2.prototype.inorderTraversal = function(action) {
        return this.left.inorderTraversal(action) || action(this.key, this.value) || this.right.inorderTraversal(action);
      };
      LLRBNode2.prototype.reverseTraversal = function(action) {
        return this.right.reverseTraversal(action) || action(this.key, this.value) || this.left.reverseTraversal(action);
      };
      LLRBNode2.prototype.min = function() {
        if (this.left.isEmpty()) {
          return this;
        } else {
          return this.left.min();
        }
      };
      LLRBNode2.prototype.minKey = function() {
        return this.min().key;
      };
      LLRBNode2.prototype.maxKey = function() {
        if (this.right.isEmpty()) {
          return this.key;
        } else {
          return this.right.maxKey();
        }
      };
      LLRBNode2.prototype.insert = function(key, value, comparator) {
        var n = this;
        var cmp = comparator(key, n.key);
        if (cmp < 0) {
          n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);
        } else if (cmp === 0) {
          n = n.copy(null, value, null, null, null);
        } else {
          n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));
        }
        return n.fixUp();
      };
      LLRBNode2.prototype.removeMin = function() {
        if (this.left.isEmpty()) {
          return LLRBNode2.EMPTY;
        }
        var n = this;
        if (!n.left.isRed() && !n.left.left.isRed()) {
          n = n.moveRedLeft();
        }
        n = n.copy(null, null, null, n.left.removeMin(), null);
        return n.fixUp();
      };
      LLRBNode2.prototype.remove = function(key, comparator) {
        var smallest;
        var n = this;
        if (comparator(key, n.key) < 0) {
          if (!n.left.isEmpty() && !n.left.isRed() && !n.left.left.isRed()) {
            n = n.moveRedLeft();
          }
          n = n.copy(null, null, null, n.left.remove(key, comparator), null);
        } else {
          if (n.left.isRed()) {
            n = n.rotateRight();
          }
          if (!n.right.isEmpty() && !n.right.isRed() && !n.right.left.isRed()) {
            n = n.moveRedRight();
          }
          if (comparator(key, n.key) === 0) {
            if (n.right.isEmpty()) {
              return LLRBNode2.EMPTY;
            } else {
              smallest = n.right.min();
              n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin());
            }
          }
          n = n.copy(null, null, null, null, n.right.remove(key, comparator));
        }
        return n.fixUp();
      };
      LLRBNode2.prototype.isRed = function() {
        return this.color;
      };
      LLRBNode2.prototype.fixUp = function() {
        var n = this;
        if (n.right.isRed() && !n.left.isRed()) {
          n = n.rotateLeft();
        }
        if (n.left.isRed() && n.left.left.isRed()) {
          n = n.rotateRight();
        }
        if (n.left.isRed() && n.right.isRed()) {
          n = n.colorFlip();
        }
        return n;
      };
      LLRBNode2.prototype.moveRedLeft = function() {
        var n = this.colorFlip();
        if (n.right.left.isRed()) {
          n = n.copy(null, null, null, null, n.right.rotateRight());
          n = n.rotateLeft();
          n = n.colorFlip();
        }
        return n;
      };
      LLRBNode2.prototype.moveRedRight = function() {
        var n = this.colorFlip();
        if (n.left.left.isRed()) {
          n = n.rotateRight();
          n = n.colorFlip();
        }
        return n;
      };
      LLRBNode2.prototype.rotateLeft = function() {
        var nl = this.copy(null, null, LLRBNode2.RED, null, this.right.left);
        return this.right.copy(null, null, this.color, nl, null);
      };
      LLRBNode2.prototype.rotateRight = function() {
        var nr = this.copy(null, null, LLRBNode2.RED, this.left.right, null);
        return this.left.copy(null, null, this.color, null, nr);
      };
      LLRBNode2.prototype.colorFlip = function() {
        var left = this.left.copy(null, null, !this.left.color, null, null);
        var right = this.right.copy(null, null, !this.right.color, null, null);
        return this.copy(null, null, !this.color, left, right);
      };
      LLRBNode2.prototype.checkMaxDepth = function() {
        var blackDepth = this.check();
        if (Math.pow(2, blackDepth) <= this.size + 1) {
          return true;
        } else {
          return false;
        }
      };
      LLRBNode2.prototype.check = function() {
        if (this.isRed() && this.left.isRed()) {
          throw fail();
        }
        if (this.right.isRed()) {
          throw fail();
        }
        var blackDepth = this.left.check();
        if (blackDepth !== this.right.check()) {
          throw fail();
        } else {
          return blackDepth + (this.isRed() ? 0 : 1);
        }
      };
      return LLRBNode2;
    }();
    LLRBNode.EMPTY = null;
    LLRBNode.RED = true;
    LLRBNode.BLACK = false;
    var LLRBEmptyNode = function() {
      function LLRBEmptyNode2() {
        this.size = 0;
      }
      Object.defineProperty(LLRBEmptyNode2.prototype, "key", {
        get: function() {
          throw fail();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(LLRBEmptyNode2.prototype, "value", {
        get: function() {
          throw fail();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(LLRBEmptyNode2.prototype, "color", {
        get: function() {
          throw fail();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(LLRBEmptyNode2.prototype, "left", {
        get: function() {
          throw fail();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(LLRBEmptyNode2.prototype, "right", {
        get: function() {
          throw fail();
        },
        enumerable: false,
        configurable: true
      });
      LLRBEmptyNode2.prototype.copy = function(key, value, color, left, right) {
        return this;
      };
      LLRBEmptyNode2.prototype.insert = function(key, value, comparator) {
        return new LLRBNode(key, value);
      };
      LLRBEmptyNode2.prototype.remove = function(key, comparator) {
        return this;
      };
      LLRBEmptyNode2.prototype.isEmpty = function() {
        return true;
      };
      LLRBEmptyNode2.prototype.inorderTraversal = function(action) {
        return false;
      };
      LLRBEmptyNode2.prototype.reverseTraversal = function(action) {
        return false;
      };
      LLRBEmptyNode2.prototype.minKey = function() {
        return null;
      };
      LLRBEmptyNode2.prototype.maxKey = function() {
        return null;
      };
      LLRBEmptyNode2.prototype.isRed = function() {
        return false;
      };
      LLRBEmptyNode2.prototype.checkMaxDepth = function() {
        return true;
      };
      LLRBEmptyNode2.prototype.check = function() {
        return 0;
      };
      return LLRBEmptyNode2;
    }();
    LLRBNode.EMPTY = new LLRBEmptyNode();
    var SortedSet = function() {
      function SortedSet2(comparator) {
        this.comparator = comparator;
        this.data = new SortedMap(this.comparator);
      }
      SortedSet2.prototype.has = function(elem) {
        return this.data.get(elem) !== null;
      };
      SortedSet2.prototype.first = function() {
        return this.data.minKey();
      };
      SortedSet2.prototype.last = function() {
        return this.data.maxKey();
      };
      Object.defineProperty(SortedSet2.prototype, "size", {
        get: function() {
          return this.data.size;
        },
        enumerable: false,
        configurable: true
      });
      SortedSet2.prototype.indexOf = function(elem) {
        return this.data.indexOf(elem);
      };
      SortedSet2.prototype.forEach = function(cb) {
        this.data.inorderTraversal(function(k, v) {
          cb(k);
          return false;
        });
      };
      SortedSet2.prototype.forEachInRange = function(range, cb) {
        var iter = this.data.getIteratorFrom(range[0]);
        while (iter.hasNext()) {
          var elem = iter.getNext();
          if (this.comparator(elem.key, range[1]) >= 0) {
            return;
          }
          cb(elem.key);
        }
      };
      SortedSet2.prototype.forEachWhile = function(cb, start2) {
        var iter;
        if (start2 !== void 0) {
          iter = this.data.getIteratorFrom(start2);
        } else {
          iter = this.data.getIterator();
        }
        while (iter.hasNext()) {
          var elem = iter.getNext();
          var result = cb(elem.key);
          if (!result) {
            return;
          }
        }
      };
      SortedSet2.prototype.firstAfterOrEqual = function(elem) {
        var iter = this.data.getIteratorFrom(elem);
        return iter.hasNext() ? iter.getNext().key : null;
      };
      SortedSet2.prototype.getIterator = function() {
        return new SortedSetIterator(this.data.getIterator());
      };
      SortedSet2.prototype.getIteratorFrom = function(key) {
        return new SortedSetIterator(this.data.getIteratorFrom(key));
      };
      SortedSet2.prototype.add = function(elem) {
        return this.copy(this.data.remove(elem).insert(elem, true));
      };
      SortedSet2.prototype.delete = function(elem) {
        if (!this.has(elem)) {
          return this;
        }
        return this.copy(this.data.remove(elem));
      };
      SortedSet2.prototype.isEmpty = function() {
        return this.data.isEmpty();
      };
      SortedSet2.prototype.unionWith = function(other) {
        var result = this;
        if (result.size < other.size) {
          result = other;
          other = this;
        }
        other.forEach(function(elem) {
          result = result.add(elem);
        });
        return result;
      };
      SortedSet2.prototype.isEqual = function(other) {
        if (!(other instanceof SortedSet2)) {
          return false;
        }
        if (this.size !== other.size) {
          return false;
        }
        var thisIt = this.data.getIterator();
        var otherIt = other.data.getIterator();
        while (thisIt.hasNext()) {
          var thisElem = thisIt.getNext().key;
          var otherElem = otherIt.getNext().key;
          if (this.comparator(thisElem, otherElem) !== 0) {
            return false;
          }
        }
        return true;
      };
      SortedSet2.prototype.toArray = function() {
        var res = [];
        this.forEach(function(targetId) {
          res.push(targetId);
        });
        return res;
      };
      SortedSet2.prototype.toString = function() {
        var result = [];
        this.forEach(function(elem) {
          return result.push(elem);
        });
        return "SortedSet(" + result.toString() + ")";
      };
      SortedSet2.prototype.copy = function(data) {
        var result = new SortedSet2(this.comparator);
        result.data = data;
        return result;
      };
      return SortedSet2;
    }();
    var SortedSetIterator = function() {
      function SortedSetIterator2(iter) {
        this.iter = iter;
      }
      SortedSetIterator2.prototype.getNext = function() {
        return this.iter.getNext().key;
      };
      SortedSetIterator2.prototype.hasNext = function() {
        return this.iter.hasNext();
      };
      return SortedSetIterator2;
    }();
    var EMPTY_MUTABLE_DOCUMENT_MAP = new SortedMap(DocumentKey.comparator);
    function mutableDocumentMap() {
      return EMPTY_MUTABLE_DOCUMENT_MAP;
    }
    var EMPTY_DOCUMENT_MAP = new SortedMap(DocumentKey.comparator);
    function documentMap() {
      return EMPTY_DOCUMENT_MAP;
    }
    var EMPTY_DOCUMENT_VERSION_MAP = new SortedMap(DocumentKey.comparator);
    function documentVersionMap() {
      return EMPTY_DOCUMENT_VERSION_MAP;
    }
    var EMPTY_DOCUMENT_KEY_SET = new SortedSet(DocumentKey.comparator);
    function documentKeySet() {
      var keys = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        keys[_i] = arguments[_i];
      }
      var set2 = EMPTY_DOCUMENT_KEY_SET;
      for (var _d = 0, keys_1 = keys; _d < keys_1.length; _d++) {
        var key = keys_1[_d];
        set2 = set2.add(key);
      }
      return set2;
    }
    var EMPTY_TARGET_ID_SET = new SortedSet(primitiveComparator);
    function targetIdSet() {
      return EMPTY_TARGET_ID_SET;
    }
    function toDouble(serializer, value) {
      if (serializer.useProto3Json) {
        if (isNaN(value)) {
          return { doubleValue: "NaN" };
        } else if (value === Infinity) {
          return { doubleValue: "Infinity" };
        } else if (value === -Infinity) {
          return { doubleValue: "-Infinity" };
        }
      }
      return { doubleValue: isNegativeZero(value) ? "-0" : value };
    }
    function toInteger(value) {
      return { integerValue: "" + value };
    }
    function toNumber(serializer, value) {
      return isSafeInteger(value) ? toInteger(value) : toDouble(serializer, value);
    }
    var TransformOperation = function() {
      function TransformOperation2() {
        this._ = void 0;
      }
      return TransformOperation2;
    }();
    function applyTransformOperationToLocalView(transform, previousValue, localWriteTime) {
      if (transform instanceof ServerTimestampTransform) {
        return serverTimestamp$1(localWriteTime, previousValue);
      } else if (transform instanceof ArrayUnionTransformOperation) {
        return applyArrayUnionTransformOperation(transform, previousValue);
      } else if (transform instanceof ArrayRemoveTransformOperation) {
        return applyArrayRemoveTransformOperation(transform, previousValue);
      } else {
        return applyNumericIncrementTransformOperationToLocalView(transform, previousValue);
      }
    }
    function applyTransformOperationToRemoteDocument(transform, previousValue, transformResult) {
      if (transform instanceof ArrayUnionTransformOperation) {
        return applyArrayUnionTransformOperation(transform, previousValue);
      } else if (transform instanceof ArrayRemoveTransformOperation) {
        return applyArrayRemoveTransformOperation(transform, previousValue);
      }
      return transformResult;
    }
    function computeTransformOperationBaseValue(transform, previousValue) {
      if (transform instanceof NumericIncrementTransformOperation) {
        return isNumber(previousValue) ? previousValue : { integerValue: 0 };
      }
      return null;
    }
    function transformOperationEquals(left, right) {
      if (left instanceof ArrayUnionTransformOperation && right instanceof ArrayUnionTransformOperation) {
        return arrayEquals(left.elements, right.elements, valueEquals);
      } else if (left instanceof ArrayRemoveTransformOperation && right instanceof ArrayRemoveTransformOperation) {
        return arrayEquals(left.elements, right.elements, valueEquals);
      } else if (left instanceof NumericIncrementTransformOperation && right instanceof NumericIncrementTransformOperation) {
        return valueEquals(left.operand, right.operand);
      }
      return left instanceof ServerTimestampTransform && right instanceof ServerTimestampTransform;
    }
    var ServerTimestampTransform = function(_super) {
      tslib2.__extends(ServerTimestampTransform2, _super);
      function ServerTimestampTransform2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return ServerTimestampTransform2;
    }(TransformOperation);
    var ArrayUnionTransformOperation = function(_super) {
      tslib2.__extends(ArrayUnionTransformOperation2, _super);
      function ArrayUnionTransformOperation2(elements) {
        var _this = _super.call(this) || this;
        _this.elements = elements;
        return _this;
      }
      return ArrayUnionTransformOperation2;
    }(TransformOperation);
    function applyArrayUnionTransformOperation(transform, previousValue) {
      var values = coercedFieldValuesArray(previousValue);
      var _loop_3 = function(toUnion2) {
        if (!values.some(function(element) {
          return valueEquals(element, toUnion2);
        })) {
          values.push(toUnion2);
        }
      };
      for (var _i = 0, _d = transform.elements; _i < _d.length; _i++) {
        var toUnion = _d[_i];
        _loop_3(toUnion);
      }
      return { arrayValue: { values } };
    }
    var ArrayRemoveTransformOperation = function(_super) {
      tslib2.__extends(ArrayRemoveTransformOperation2, _super);
      function ArrayRemoveTransformOperation2(elements) {
        var _this = _super.call(this) || this;
        _this.elements = elements;
        return _this;
      }
      return ArrayRemoveTransformOperation2;
    }(TransformOperation);
    function applyArrayRemoveTransformOperation(transform, previousValue) {
      var values = coercedFieldValuesArray(previousValue);
      var _loop_4 = function(toRemove2) {
        values = values.filter(function(element) {
          return !valueEquals(element, toRemove2);
        });
      };
      for (var _i = 0, _d = transform.elements; _i < _d.length; _i++) {
        var toRemove = _d[_i];
        _loop_4(toRemove);
      }
      return { arrayValue: { values } };
    }
    var NumericIncrementTransformOperation = function(_super) {
      tslib2.__extends(NumericIncrementTransformOperation2, _super);
      function NumericIncrementTransformOperation2(serializer, operand) {
        var _this = _super.call(this) || this;
        _this.serializer = serializer;
        _this.operand = operand;
        return _this;
      }
      return NumericIncrementTransformOperation2;
    }(TransformOperation);
    function applyNumericIncrementTransformOperationToLocalView(transform, previousValue) {
      var baseValue = computeTransformOperationBaseValue(transform, previousValue);
      var sum = asNumber(baseValue) + asNumber(transform.operand);
      if (isInteger(baseValue) && isInteger(transform.operand)) {
        return toInteger(sum);
      } else {
        return toDouble(transform.serializer, sum);
      }
    }
    function asNumber(value) {
      return normalizeNumber(value.integerValue || value.doubleValue);
    }
    function coercedFieldValuesArray(value) {
      return isArray(value) && value.arrayValue.values ? value.arrayValue.values.slice() : [];
    }
    var FieldTransform = function() {
      function FieldTransform2(field, transform) {
        this.field = field;
        this.transform = transform;
      }
      return FieldTransform2;
    }();
    function fieldTransformEquals(left, right) {
      return left.field.isEqual(right.field) && transformOperationEquals(left.transform, right.transform);
    }
    function fieldTransformsAreEqual(left, right) {
      if (left === void 0 && right === void 0) {
        return true;
      }
      if (left && right) {
        return arrayEquals(left, right, function(l, r) {
          return fieldTransformEquals(l, r);
        });
      }
      return false;
    }
    var MutationResult = function() {
      function MutationResult2(version3, transformResults) {
        this.version = version3;
        this.transformResults = transformResults;
      }
      return MutationResult2;
    }();
    var Precondition = function() {
      function Precondition2(updateTime, exists) {
        this.updateTime = updateTime;
        this.exists = exists;
      }
      Precondition2.none = function() {
        return new Precondition2();
      };
      Precondition2.exists = function(exists) {
        return new Precondition2(void 0, exists);
      };
      Precondition2.updateTime = function(version3) {
        return new Precondition2(version3);
      };
      Object.defineProperty(Precondition2.prototype, "isNone", {
        get: function() {
          return this.updateTime === void 0 && this.exists === void 0;
        },
        enumerable: false,
        configurable: true
      });
      Precondition2.prototype.isEqual = function(other) {
        return this.exists === other.exists && (this.updateTime ? !!other.updateTime && this.updateTime.isEqual(other.updateTime) : !other.updateTime);
      };
      return Precondition2;
    }();
    function preconditionIsValidForDocument(precondition, document2) {
      if (precondition.updateTime !== void 0) {
        return document2.isFoundDocument() && document2.version.isEqual(precondition.updateTime);
      } else if (precondition.exists !== void 0) {
        return precondition.exists === document2.isFoundDocument();
      } else {
        return true;
      }
    }
    var Mutation = function() {
      function Mutation2() {
      }
      return Mutation2;
    }();
    function mutationApplyToRemoteDocument(mutation, document2, mutationResult) {
      if (mutation instanceof SetMutation) {
        setMutationApplyToRemoteDocument(mutation, document2, mutationResult);
      } else if (mutation instanceof PatchMutation) {
        patchMutationApplyToRemoteDocument(mutation, document2, mutationResult);
      } else {
        deleteMutationApplyToRemoteDocument(mutation, document2, mutationResult);
      }
    }
    function mutationApplyToLocalView(mutation, document2, localWriteTime) {
      if (mutation instanceof SetMutation) {
        setMutationApplyToLocalView(mutation, document2, localWriteTime);
      } else if (mutation instanceof PatchMutation) {
        patchMutationApplyToLocalView(mutation, document2, localWriteTime);
      } else {
        deleteMutationApplyToLocalView(mutation, document2);
      }
    }
    function mutationExtractBaseValue(mutation, document2) {
      var baseObject = null;
      for (var _i = 0, _d = mutation.fieldTransforms; _i < _d.length; _i++) {
        var fieldTransform = _d[_i];
        var existingValue = document2.data.field(fieldTransform.field);
        var coercedValue = computeTransformOperationBaseValue(fieldTransform.transform, existingValue || null);
        if (coercedValue != null) {
          if (baseObject == null) {
            baseObject = ObjectValue.empty();
          }
          baseObject.set(fieldTransform.field, coercedValue);
        }
      }
      return baseObject ? baseObject : null;
    }
    function mutationEquals(left, right) {
      if (left.type !== right.type) {
        return false;
      }
      if (!left.key.isEqual(right.key)) {
        return false;
      }
      if (!left.precondition.isEqual(right.precondition)) {
        return false;
      }
      if (!fieldTransformsAreEqual(left.fieldTransforms, right.fieldTransforms)) {
        return false;
      }
      if (left.type === 0) {
        return left.value.isEqual(right.value);
      }
      if (left.type === 1) {
        return left.data.isEqual(right.data) && left.fieldMask.isEqual(right.fieldMask);
      }
      return true;
    }
    function getPostMutationVersion(document2) {
      return document2.isFoundDocument() ? document2.version : SnapshotVersion.min();
    }
    var SetMutation = function(_super) {
      tslib2.__extends(SetMutation2, _super);
      function SetMutation2(key, value, precondition, fieldTransforms) {
        if (fieldTransforms === void 0) {
          fieldTransforms = [];
        }
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.value = value;
        _this.precondition = precondition;
        _this.fieldTransforms = fieldTransforms;
        _this.type = 0;
        return _this;
      }
      return SetMutation2;
    }(Mutation);
    function setMutationApplyToRemoteDocument(mutation, document2, mutationResult) {
      var newData = mutation.value.clone();
      var transformResults = serverTransformResults(mutation.fieldTransforms, document2, mutationResult.transformResults);
      newData.setAll(transformResults);
      document2.convertToFoundDocument(mutationResult.version, newData).setHasCommittedMutations();
    }
    function setMutationApplyToLocalView(mutation, document2, localWriteTime) {
      if (!preconditionIsValidForDocument(mutation.precondition, document2)) {
        return;
      }
      var newData = mutation.value.clone();
      var transformResults = localTransformResults(mutation.fieldTransforms, localWriteTime, document2);
      newData.setAll(transformResults);
      document2.convertToFoundDocument(getPostMutationVersion(document2), newData).setHasLocalMutations();
    }
    var PatchMutation = function(_super) {
      tslib2.__extends(PatchMutation2, _super);
      function PatchMutation2(key, data, fieldMask, precondition, fieldTransforms) {
        if (fieldTransforms === void 0) {
          fieldTransforms = [];
        }
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.data = data;
        _this.fieldMask = fieldMask;
        _this.precondition = precondition;
        _this.fieldTransforms = fieldTransforms;
        _this.type = 1;
        return _this;
      }
      return PatchMutation2;
    }(Mutation);
    function patchMutationApplyToRemoteDocument(mutation, document2, mutationResult) {
      if (!preconditionIsValidForDocument(mutation.precondition, document2)) {
        document2.convertToUnknownDocument(mutationResult.version);
        return;
      }
      var transformResults = serverTransformResults(mutation.fieldTransforms, document2, mutationResult.transformResults);
      var newData = document2.data;
      newData.setAll(getPatch(mutation));
      newData.setAll(transformResults);
      document2.convertToFoundDocument(mutationResult.version, newData).setHasCommittedMutations();
    }
    function patchMutationApplyToLocalView(mutation, document2, localWriteTime) {
      if (!preconditionIsValidForDocument(mutation.precondition, document2)) {
        return;
      }
      var transformResults = localTransformResults(mutation.fieldTransforms, localWriteTime, document2);
      var newData = document2.data;
      newData.setAll(getPatch(mutation));
      newData.setAll(transformResults);
      document2.convertToFoundDocument(getPostMutationVersion(document2), newData).setHasLocalMutations();
    }
    function getPatch(mutation) {
      var result = new Map();
      mutation.fieldMask.fields.forEach(function(fieldPath) {
        if (!fieldPath.isEmpty()) {
          var newValue = mutation.data.field(fieldPath);
          result.set(fieldPath, newValue);
        }
      });
      return result;
    }
    function serverTransformResults(fieldTransforms, mutableDocument, serverTransformResults2) {
      var transformResults = new Map();
      hardAssert(fieldTransforms.length === serverTransformResults2.length);
      for (var i = 0; i < serverTransformResults2.length; i++) {
        var fieldTransform = fieldTransforms[i];
        var transform = fieldTransform.transform;
        var previousValue = mutableDocument.data.field(fieldTransform.field);
        transformResults.set(fieldTransform.field, applyTransformOperationToRemoteDocument(transform, previousValue, serverTransformResults2[i]));
      }
      return transformResults;
    }
    function localTransformResults(fieldTransforms, localWriteTime, mutableDocument) {
      var transformResults = new Map();
      for (var _i = 0, fieldTransforms_1 = fieldTransforms; _i < fieldTransforms_1.length; _i++) {
        var fieldTransform = fieldTransforms_1[_i];
        var transform = fieldTransform.transform;
        var previousValue = mutableDocument.data.field(fieldTransform.field);
        transformResults.set(fieldTransform.field, applyTransformOperationToLocalView(transform, previousValue, localWriteTime));
      }
      return transformResults;
    }
    var DeleteMutation = function(_super) {
      tslib2.__extends(DeleteMutation2, _super);
      function DeleteMutation2(key, precondition) {
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.precondition = precondition;
        _this.type = 2;
        _this.fieldTransforms = [];
        return _this;
      }
      return DeleteMutation2;
    }(Mutation);
    function deleteMutationApplyToRemoteDocument(mutation, document2, mutationResult) {
      document2.convertToNoDocument(mutationResult.version).setHasCommittedMutations();
    }
    function deleteMutationApplyToLocalView(mutation, document2) {
      if (preconditionIsValidForDocument(mutation.precondition, document2)) {
        document2.convertToNoDocument(SnapshotVersion.min());
      }
    }
    var VerifyMutation = function(_super) {
      tslib2.__extends(VerifyMutation2, _super);
      function VerifyMutation2(key, precondition) {
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.precondition = precondition;
        _this.type = 3;
        _this.fieldTransforms = [];
        return _this;
      }
      return VerifyMutation2;
    }(Mutation);
    var MutationBatch = function() {
      function MutationBatch2(batchId, localWriteTime, baseMutations, mutations) {
        this.batchId = batchId;
        this.localWriteTime = localWriteTime;
        this.baseMutations = baseMutations;
        this.mutations = mutations;
      }
      MutationBatch2.prototype.applyToRemoteDocument = function(document2, batchResult) {
        var mutationResults = batchResult.mutationResults;
        for (var i = 0; i < this.mutations.length; i++) {
          var mutation = this.mutations[i];
          if (mutation.key.isEqual(document2.key)) {
            var mutationResult = mutationResults[i];
            mutationApplyToRemoteDocument(mutation, document2, mutationResult);
          }
        }
      };
      MutationBatch2.prototype.applyToLocalView = function(document2) {
        for (var _i = 0, _d = this.baseMutations; _i < _d.length; _i++) {
          var mutation = _d[_i];
          if (mutation.key.isEqual(document2.key)) {
            mutationApplyToLocalView(mutation, document2, this.localWriteTime);
          }
        }
        for (var _e = 0, _f = this.mutations; _e < _f.length; _e++) {
          var mutation = _f[_e];
          if (mutation.key.isEqual(document2.key)) {
            mutationApplyToLocalView(mutation, document2, this.localWriteTime);
          }
        }
      };
      MutationBatch2.prototype.applyToLocalDocumentSet = function(documentMap2) {
        var _this = this;
        this.mutations.forEach(function(m) {
          var document2 = documentMap2.get(m.key);
          var mutableDocument = document2;
          _this.applyToLocalView(mutableDocument);
          if (!document2.isValidDocument()) {
            mutableDocument.convertToNoDocument(SnapshotVersion.min());
          }
        });
      };
      MutationBatch2.prototype.keys = function() {
        return this.mutations.reduce(function(keys, m) {
          return keys.add(m.key);
        }, documentKeySet());
      };
      MutationBatch2.prototype.isEqual = function(other) {
        return this.batchId === other.batchId && arrayEquals(this.mutations, other.mutations, function(l, r) {
          return mutationEquals(l, r);
        }) && arrayEquals(this.baseMutations, other.baseMutations, function(l, r) {
          return mutationEquals(l, r);
        });
      };
      return MutationBatch2;
    }();
    var MutationBatchResult = function() {
      function MutationBatchResult2(batch, commitVersion, mutationResults, docVersions) {
        this.batch = batch;
        this.commitVersion = commitVersion;
        this.mutationResults = mutationResults;
        this.docVersions = docVersions;
      }
      MutationBatchResult2.from = function(batch, commitVersion, results) {
        hardAssert(batch.mutations.length === results.length);
        var versionMap = documentVersionMap();
        var mutations = batch.mutations;
        for (var i = 0; i < mutations.length; i++) {
          versionMap = versionMap.insert(mutations[i].key, results[i].version);
        }
        return new MutationBatchResult2(batch, commitVersion, results, versionMap);
      };
      return MutationBatchResult2;
    }();
    var ExistenceFilter = function() {
      function ExistenceFilter2(count) {
        this.count = count;
      }
      return ExistenceFilter2;
    }();
    var RpcCode;
    (function(RpcCode2) {
      RpcCode2[RpcCode2["OK"] = 0] = "OK";
      RpcCode2[RpcCode2["CANCELLED"] = 1] = "CANCELLED";
      RpcCode2[RpcCode2["UNKNOWN"] = 2] = "UNKNOWN";
      RpcCode2[RpcCode2["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
      RpcCode2[RpcCode2["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
      RpcCode2[RpcCode2["NOT_FOUND"] = 5] = "NOT_FOUND";
      RpcCode2[RpcCode2["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
      RpcCode2[RpcCode2["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
      RpcCode2[RpcCode2["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
      RpcCode2[RpcCode2["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
      RpcCode2[RpcCode2["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
      RpcCode2[RpcCode2["ABORTED"] = 10] = "ABORTED";
      RpcCode2[RpcCode2["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
      RpcCode2[RpcCode2["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
      RpcCode2[RpcCode2["INTERNAL"] = 13] = "INTERNAL";
      RpcCode2[RpcCode2["UNAVAILABLE"] = 14] = "UNAVAILABLE";
      RpcCode2[RpcCode2["DATA_LOSS"] = 15] = "DATA_LOSS";
    })(RpcCode || (RpcCode = {}));
    function isPermanentError(code) {
      switch (code) {
        case Code.OK:
          return fail();
        case Code.CANCELLED:
        case Code.UNKNOWN:
        case Code.DEADLINE_EXCEEDED:
        case Code.RESOURCE_EXHAUSTED:
        case Code.INTERNAL:
        case Code.UNAVAILABLE:
        case Code.UNAUTHENTICATED:
          return false;
        case Code.INVALID_ARGUMENT:
        case Code.NOT_FOUND:
        case Code.ALREADY_EXISTS:
        case Code.PERMISSION_DENIED:
        case Code.FAILED_PRECONDITION:
        case Code.ABORTED:
        case Code.OUT_OF_RANGE:
        case Code.UNIMPLEMENTED:
        case Code.DATA_LOSS:
          return true;
        default:
          return fail();
      }
    }
    function isPermanentWriteError(code) {
      return isPermanentError(code) && code !== Code.ABORTED;
    }
    function mapCodeFromRpcCode(code) {
      if (code === void 0) {
        logError("GRPC error has no .code");
        return Code.UNKNOWN;
      }
      switch (code) {
        case RpcCode.OK:
          return Code.OK;
        case RpcCode.CANCELLED:
          return Code.CANCELLED;
        case RpcCode.UNKNOWN:
          return Code.UNKNOWN;
        case RpcCode.DEADLINE_EXCEEDED:
          return Code.DEADLINE_EXCEEDED;
        case RpcCode.RESOURCE_EXHAUSTED:
          return Code.RESOURCE_EXHAUSTED;
        case RpcCode.INTERNAL:
          return Code.INTERNAL;
        case RpcCode.UNAVAILABLE:
          return Code.UNAVAILABLE;
        case RpcCode.UNAUTHENTICATED:
          return Code.UNAUTHENTICATED;
        case RpcCode.INVALID_ARGUMENT:
          return Code.INVALID_ARGUMENT;
        case RpcCode.NOT_FOUND:
          return Code.NOT_FOUND;
        case RpcCode.ALREADY_EXISTS:
          return Code.ALREADY_EXISTS;
        case RpcCode.PERMISSION_DENIED:
          return Code.PERMISSION_DENIED;
        case RpcCode.FAILED_PRECONDITION:
          return Code.FAILED_PRECONDITION;
        case RpcCode.ABORTED:
          return Code.ABORTED;
        case RpcCode.OUT_OF_RANGE:
          return Code.OUT_OF_RANGE;
        case RpcCode.UNIMPLEMENTED:
          return Code.UNIMPLEMENTED;
        case RpcCode.DATA_LOSS:
          return Code.DATA_LOSS;
        default:
          return fail();
      }
    }
    var RemoteEvent = function() {
      function RemoteEvent2(snapshotVersion, targetChanges, targetMismatches, documentUpdates, resolvedLimboDocuments) {
        this.snapshotVersion = snapshotVersion;
        this.targetChanges = targetChanges;
        this.targetMismatches = targetMismatches;
        this.documentUpdates = documentUpdates;
        this.resolvedLimboDocuments = resolvedLimboDocuments;
      }
      RemoteEvent2.createSynthesizedRemoteEventForCurrentChange = function(targetId, current) {
        var targetChanges = new Map();
        targetChanges.set(targetId, TargetChange.createSynthesizedTargetChangeForCurrentChange(targetId, current));
        return new RemoteEvent2(SnapshotVersion.min(), targetChanges, targetIdSet(), mutableDocumentMap(), documentKeySet());
      };
      return RemoteEvent2;
    }();
    var TargetChange = function() {
      function TargetChange2(resumeToken, current, addedDocuments, modifiedDocuments, removedDocuments) {
        this.resumeToken = resumeToken;
        this.current = current;
        this.addedDocuments = addedDocuments;
        this.modifiedDocuments = modifiedDocuments;
        this.removedDocuments = removedDocuments;
      }
      TargetChange2.createSynthesizedTargetChangeForCurrentChange = function(targetId, current) {
        return new TargetChange2(ByteString.EMPTY_BYTE_STRING, current, documentKeySet(), documentKeySet(), documentKeySet());
      };
      return TargetChange2;
    }();
    var DocumentWatchChange = function() {
      function DocumentWatchChange2(updatedTargetIds, removedTargetIds, key, newDoc) {
        this.updatedTargetIds = updatedTargetIds;
        this.removedTargetIds = removedTargetIds;
        this.key = key;
        this.newDoc = newDoc;
      }
      return DocumentWatchChange2;
    }();
    var ExistenceFilterChange = function() {
      function ExistenceFilterChange2(targetId, existenceFilter) {
        this.targetId = targetId;
        this.existenceFilter = existenceFilter;
      }
      return ExistenceFilterChange2;
    }();
    var WatchTargetChange = function() {
      function WatchTargetChange2(state, targetIds, resumeToken, cause) {
        if (resumeToken === void 0) {
          resumeToken = ByteString.EMPTY_BYTE_STRING;
        }
        if (cause === void 0) {
          cause = null;
        }
        this.state = state;
        this.targetIds = targetIds;
        this.resumeToken = resumeToken;
        this.cause = cause;
      }
      return WatchTargetChange2;
    }();
    var TargetState = function() {
      function TargetState2() {
        this.pendingResponses = 0;
        this.documentChanges = snapshotChangesMap();
        this._resumeToken = ByteString.EMPTY_BYTE_STRING;
        this._current = false;
        this._hasPendingChanges = true;
      }
      Object.defineProperty(TargetState2.prototype, "current", {
        get: function() {
          return this._current;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TargetState2.prototype, "resumeToken", {
        get: function() {
          return this._resumeToken;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TargetState2.prototype, "isPending", {
        get: function() {
          return this.pendingResponses !== 0;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TargetState2.prototype, "hasPendingChanges", {
        get: function() {
          return this._hasPendingChanges;
        },
        enumerable: false,
        configurable: true
      });
      TargetState2.prototype.updateResumeToken = function(resumeToken) {
        if (resumeToken.approximateByteSize() > 0) {
          this._hasPendingChanges = true;
          this._resumeToken = resumeToken;
        }
      };
      TargetState2.prototype.toTargetChange = function() {
        var addedDocuments = documentKeySet();
        var modifiedDocuments = documentKeySet();
        var removedDocuments = documentKeySet();
        this.documentChanges.forEach(function(key, changeType) {
          switch (changeType) {
            case 0:
              addedDocuments = addedDocuments.add(key);
              break;
            case 2:
              modifiedDocuments = modifiedDocuments.add(key);
              break;
            case 1:
              removedDocuments = removedDocuments.add(key);
              break;
            default:
              fail();
          }
        });
        return new TargetChange(this._resumeToken, this._current, addedDocuments, modifiedDocuments, removedDocuments);
      };
      TargetState2.prototype.clearPendingChanges = function() {
        this._hasPendingChanges = false;
        this.documentChanges = snapshotChangesMap();
      };
      TargetState2.prototype.addDocumentChange = function(key, changeType) {
        this._hasPendingChanges = true;
        this.documentChanges = this.documentChanges.insert(key, changeType);
      };
      TargetState2.prototype.removeDocumentChange = function(key) {
        this._hasPendingChanges = true;
        this.documentChanges = this.documentChanges.remove(key);
      };
      TargetState2.prototype.recordPendingTargetRequest = function() {
        this.pendingResponses += 1;
      };
      TargetState2.prototype.recordTargetResponse = function() {
        this.pendingResponses -= 1;
      };
      TargetState2.prototype.markCurrent = function() {
        this._hasPendingChanges = true;
        this._current = true;
      };
      return TargetState2;
    }();
    var LOG_TAG$f = "WatchChangeAggregator";
    var WatchChangeAggregator = function() {
      function WatchChangeAggregator2(metadataProvider) {
        this.metadataProvider = metadataProvider;
        this.targetStates = new Map();
        this.pendingDocumentUpdates = mutableDocumentMap();
        this.pendingDocumentTargetMapping = documentTargetMap();
        this.pendingTargetResets = new SortedSet(primitiveComparator);
      }
      WatchChangeAggregator2.prototype.handleDocumentChange = function(docChange) {
        for (var _i = 0, _d = docChange.updatedTargetIds; _i < _d.length; _i++) {
          var targetId = _d[_i];
          if (docChange.newDoc && docChange.newDoc.isFoundDocument()) {
            this.addDocumentToTarget(targetId, docChange.newDoc);
          } else {
            this.removeDocumentFromTarget(targetId, docChange.key, docChange.newDoc);
          }
        }
        for (var _e = 0, _f = docChange.removedTargetIds; _e < _f.length; _e++) {
          var targetId = _f[_e];
          this.removeDocumentFromTarget(targetId, docChange.key, docChange.newDoc);
        }
      };
      WatchChangeAggregator2.prototype.handleTargetChange = function(targetChange) {
        var _this = this;
        this.forEachTarget(targetChange, function(targetId) {
          var targetState = _this.ensureTargetState(targetId);
          switch (targetChange.state) {
            case 0:
              if (_this.isActiveTarget(targetId)) {
                targetState.updateResumeToken(targetChange.resumeToken);
              }
              break;
            case 1:
              targetState.recordTargetResponse();
              if (!targetState.isPending) {
                targetState.clearPendingChanges();
              }
              targetState.updateResumeToken(targetChange.resumeToken);
              break;
            case 2:
              targetState.recordTargetResponse();
              if (!targetState.isPending) {
                _this.removeTarget(targetId);
              }
              break;
            case 3:
              if (_this.isActiveTarget(targetId)) {
                targetState.markCurrent();
                targetState.updateResumeToken(targetChange.resumeToken);
              }
              break;
            case 4:
              if (_this.isActiveTarget(targetId)) {
                _this.resetTarget(targetId);
                targetState.updateResumeToken(targetChange.resumeToken);
              }
              break;
            default:
              fail();
          }
        });
      };
      WatchChangeAggregator2.prototype.forEachTarget = function(targetChange, fn) {
        var _this = this;
        if (targetChange.targetIds.length > 0) {
          targetChange.targetIds.forEach(fn);
        } else {
          this.targetStates.forEach(function(_, targetId) {
            if (_this.isActiveTarget(targetId)) {
              fn(targetId);
            }
          });
        }
      };
      WatchChangeAggregator2.prototype.handleExistenceFilter = function(watchChange) {
        var targetId = watchChange.targetId;
        var expectedCount = watchChange.existenceFilter.count;
        var targetData = this.targetDataForActiveTarget(targetId);
        if (targetData) {
          var target = targetData.target;
          if (isDocumentTarget(target)) {
            if (expectedCount === 0) {
              var key = new DocumentKey(target.path);
              this.removeDocumentFromTarget(targetId, key, MutableDocument.newNoDocument(key, SnapshotVersion.min()));
            } else {
              hardAssert(expectedCount === 1);
            }
          } else {
            var currentSize = this.getCurrentDocumentCountForTarget(targetId);
            if (currentSize !== expectedCount) {
              this.resetTarget(targetId);
              this.pendingTargetResets = this.pendingTargetResets.add(targetId);
            }
          }
        }
      };
      WatchChangeAggregator2.prototype.createRemoteEvent = function(snapshotVersion) {
        var _this = this;
        var targetChanges = new Map();
        this.targetStates.forEach(function(targetState, targetId) {
          var targetData = _this.targetDataForActiveTarget(targetId);
          if (targetData) {
            if (targetState.current && isDocumentTarget(targetData.target)) {
              var key = new DocumentKey(targetData.target.path);
              if (_this.pendingDocumentUpdates.get(key) === null && !_this.targetContainsDocument(targetId, key)) {
                _this.removeDocumentFromTarget(targetId, key, MutableDocument.newNoDocument(key, snapshotVersion));
              }
            }
            if (targetState.hasPendingChanges) {
              targetChanges.set(targetId, targetState.toTargetChange());
              targetState.clearPendingChanges();
            }
          }
        });
        var resolvedLimboDocuments = documentKeySet();
        this.pendingDocumentTargetMapping.forEach(function(key, targets) {
          var isOnlyLimboTarget = true;
          targets.forEachWhile(function(targetId) {
            var targetData = _this.targetDataForActiveTarget(targetId);
            if (targetData && targetData.purpose !== 2) {
              isOnlyLimboTarget = false;
              return false;
            }
            return true;
          });
          if (isOnlyLimboTarget) {
            resolvedLimboDocuments = resolvedLimboDocuments.add(key);
          }
        });
        var remoteEvent = new RemoteEvent(snapshotVersion, targetChanges, this.pendingTargetResets, this.pendingDocumentUpdates, resolvedLimboDocuments);
        this.pendingDocumentUpdates = mutableDocumentMap();
        this.pendingDocumentTargetMapping = documentTargetMap();
        this.pendingTargetResets = new SortedSet(primitiveComparator);
        return remoteEvent;
      };
      WatchChangeAggregator2.prototype.addDocumentToTarget = function(targetId, document2) {
        if (!this.isActiveTarget(targetId)) {
          return;
        }
        var changeType = this.targetContainsDocument(targetId, document2.key) ? 2 : 0;
        var targetState = this.ensureTargetState(targetId);
        targetState.addDocumentChange(document2.key, changeType);
        this.pendingDocumentUpdates = this.pendingDocumentUpdates.insert(document2.key, document2);
        this.pendingDocumentTargetMapping = this.pendingDocumentTargetMapping.insert(document2.key, this.ensureDocumentTargetMapping(document2.key).add(targetId));
      };
      WatchChangeAggregator2.prototype.removeDocumentFromTarget = function(targetId, key, updatedDocument) {
        if (!this.isActiveTarget(targetId)) {
          return;
        }
        var targetState = this.ensureTargetState(targetId);
        if (this.targetContainsDocument(targetId, key)) {
          targetState.addDocumentChange(key, 1);
        } else {
          targetState.removeDocumentChange(key);
        }
        this.pendingDocumentTargetMapping = this.pendingDocumentTargetMapping.insert(key, this.ensureDocumentTargetMapping(key).delete(targetId));
        if (updatedDocument) {
          this.pendingDocumentUpdates = this.pendingDocumentUpdates.insert(key, updatedDocument);
        }
      };
      WatchChangeAggregator2.prototype.removeTarget = function(targetId) {
        this.targetStates.delete(targetId);
      };
      WatchChangeAggregator2.prototype.getCurrentDocumentCountForTarget = function(targetId) {
        var targetState = this.ensureTargetState(targetId);
        var targetChange = targetState.toTargetChange();
        return this.metadataProvider.getRemoteKeysForTarget(targetId).size + targetChange.addedDocuments.size - targetChange.removedDocuments.size;
      };
      WatchChangeAggregator2.prototype.recordPendingTargetRequest = function(targetId) {
        var targetState = this.ensureTargetState(targetId);
        targetState.recordPendingTargetRequest();
      };
      WatchChangeAggregator2.prototype.ensureTargetState = function(targetId) {
        var result = this.targetStates.get(targetId);
        if (!result) {
          result = new TargetState();
          this.targetStates.set(targetId, result);
        }
        return result;
      };
      WatchChangeAggregator2.prototype.ensureDocumentTargetMapping = function(key) {
        var targetMapping = this.pendingDocumentTargetMapping.get(key);
        if (!targetMapping) {
          targetMapping = new SortedSet(primitiveComparator);
          this.pendingDocumentTargetMapping = this.pendingDocumentTargetMapping.insert(key, targetMapping);
        }
        return targetMapping;
      };
      WatchChangeAggregator2.prototype.isActiveTarget = function(targetId) {
        var targetActive = this.targetDataForActiveTarget(targetId) !== null;
        if (!targetActive) {
          logDebug(LOG_TAG$f, "Detected inactive target", targetId);
        }
        return targetActive;
      };
      WatchChangeAggregator2.prototype.targetDataForActiveTarget = function(targetId) {
        var targetState = this.targetStates.get(targetId);
        return targetState && targetState.isPending ? null : this.metadataProvider.getTargetDataForTarget(targetId);
      };
      WatchChangeAggregator2.prototype.resetTarget = function(targetId) {
        var _this = this;
        this.targetStates.set(targetId, new TargetState());
        var existingKeys = this.metadataProvider.getRemoteKeysForTarget(targetId);
        existingKeys.forEach(function(key) {
          _this.removeDocumentFromTarget(targetId, key, null);
        });
      };
      WatchChangeAggregator2.prototype.targetContainsDocument = function(targetId, key) {
        var existingKeys = this.metadataProvider.getRemoteKeysForTarget(targetId);
        return existingKeys.has(key);
      };
      return WatchChangeAggregator2;
    }();
    function documentTargetMap() {
      return new SortedMap(DocumentKey.comparator);
    }
    function snapshotChangesMap() {
      return new SortedMap(DocumentKey.comparator);
    }
    var DIRECTIONS = function() {
      var dirs = {};
      dirs["asc"] = "ASCENDING";
      dirs["desc"] = "DESCENDING";
      return dirs;
    }();
    var OPERATORS = function() {
      var ops = {};
      ops["<"] = "LESS_THAN";
      ops["<="] = "LESS_THAN_OR_EQUAL";
      ops[">"] = "GREATER_THAN";
      ops[">="] = "GREATER_THAN_OR_EQUAL";
      ops["=="] = "EQUAL";
      ops["!="] = "NOT_EQUAL";
      ops["array-contains"] = "ARRAY_CONTAINS";
      ops["in"] = "IN";
      ops["not-in"] = "NOT_IN";
      ops["array-contains-any"] = "ARRAY_CONTAINS_ANY";
      return ops;
    }();
    function assertPresent(value, description) {
    }
    var JsonProtoSerializer = function() {
      function JsonProtoSerializer2(databaseId, useProto3Json) {
        this.databaseId = databaseId;
        this.useProto3Json = useProto3Json;
      }
      return JsonProtoSerializer2;
    }();
    function fromRpcStatus(status) {
      var code = status.code === void 0 ? Code.UNKNOWN : mapCodeFromRpcCode(status.code);
      return new FirestoreError(code, status.message || "");
    }
    function toInt32Proto(serializer, val) {
      if (serializer.useProto3Json || isNullOrUndefined(val)) {
        return val;
      } else {
        return { value: val };
      }
    }
    function fromInt32Proto(val) {
      var result;
      if (typeof val === "object") {
        result = val.value;
      } else {
        result = val;
      }
      return isNullOrUndefined(result) ? null : result;
    }
    function toTimestamp(serializer, timestamp) {
      if (serializer.useProto3Json) {
        var jsDateStr = new Date(timestamp.seconds * 1e3).toISOString();
        var strUntilSeconds = jsDateStr.replace(/\.\d*/, "").replace("Z", "");
        var nanoStr = ("000000000" + timestamp.nanoseconds).slice(-9);
        return strUntilSeconds + "." + nanoStr + "Z";
      } else {
        return {
          seconds: "" + timestamp.seconds,
          nanos: timestamp.nanoseconds
        };
      }
    }
    function fromTimestamp(date) {
      var timestamp = normalizeTimestamp(date);
      return new Timestamp(timestamp.seconds, timestamp.nanos);
    }
    function toBytes(serializer, bytes) {
      if (serializer.useProto3Json) {
        return bytes.toBase64();
      } else {
        return bytes.toUint8Array();
      }
    }
    function fromBytes(serializer, value) {
      if (serializer.useProto3Json) {
        hardAssert(value === void 0 || typeof value === "string");
        return ByteString.fromBase64String(value ? value : "");
      } else {
        hardAssert(value === void 0 || value instanceof Uint8Array);
        return ByteString.fromUint8Array(value ? value : new Uint8Array());
      }
    }
    function toVersion(serializer, version3) {
      return toTimestamp(serializer, version3.toTimestamp());
    }
    function fromVersion(version3) {
      hardAssert(!!version3);
      return SnapshotVersion.fromTimestamp(fromTimestamp(version3));
    }
    function toResourceName(databaseId, path2) {
      return fullyQualifiedPrefixPath(databaseId).child("documents").child(path2).canonicalString();
    }
    function fromResourceName(name3) {
      var resource = ResourcePath.fromString(name3);
      hardAssert(isValidResourceName(resource));
      return resource;
    }
    function toName(serializer, key) {
      return toResourceName(serializer.databaseId, key.path);
    }
    function fromName(serializer, name3) {
      var resource = fromResourceName(name3);
      if (resource.get(1) !== serializer.databaseId.projectId) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + resource.get(1) + " vs " + serializer.databaseId.projectId);
      }
      if (resource.get(3) !== serializer.databaseId.database) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + resource.get(3) + " vs " + serializer.databaseId.database);
      }
      return new DocumentKey(extractLocalPathFromResourceName(resource));
    }
    function toQueryPath(serializer, path2) {
      return toResourceName(serializer.databaseId, path2);
    }
    function fromQueryPath(name3) {
      var resourceName = fromResourceName(name3);
      if (resourceName.length === 4) {
        return ResourcePath.emptyPath();
      }
      return extractLocalPathFromResourceName(resourceName);
    }
    function getEncodedDatabaseId(serializer) {
      var path2 = new ResourcePath([
        "projects",
        serializer.databaseId.projectId,
        "databases",
        serializer.databaseId.database
      ]);
      return path2.canonicalString();
    }
    function fullyQualifiedPrefixPath(databaseId) {
      return new ResourcePath([
        "projects",
        databaseId.projectId,
        "databases",
        databaseId.database
      ]);
    }
    function extractLocalPathFromResourceName(resourceName) {
      hardAssert(resourceName.length > 4 && resourceName.get(4) === "documents");
      return resourceName.popFirst(5);
    }
    function toMutationDocument(serializer, key, fields) {
      return {
        name: toName(serializer, key),
        fields: fields.value.mapValue.fields
      };
    }
    function toDocument(serializer, document2) {
      return {
        name: toName(serializer, document2.key),
        fields: document2.data.value.mapValue.fields,
        updateTime: toTimestamp(serializer, document2.version.toTimestamp())
      };
    }
    function fromDocument(serializer, document2, hasCommittedMutations) {
      var key = fromName(serializer, document2.name);
      var version3 = fromVersion(document2.updateTime);
      var data = new ObjectValue({ mapValue: { fields: document2.fields } });
      var result = MutableDocument.newFoundDocument(key, version3, data);
      if (hasCommittedMutations) {
        result.setHasCommittedMutations();
      }
      return hasCommittedMutations ? result.setHasCommittedMutations() : result;
    }
    function fromFound(serializer, doc2) {
      hardAssert(!!doc2.found);
      assertPresent(doc2.found.name);
      assertPresent(doc2.found.updateTime);
      var key = fromName(serializer, doc2.found.name);
      var version3 = fromVersion(doc2.found.updateTime);
      var data = new ObjectValue({ mapValue: { fields: doc2.found.fields } });
      return MutableDocument.newFoundDocument(key, version3, data);
    }
    function fromMissing(serializer, result) {
      hardAssert(!!result.missing);
      hardAssert(!!result.readTime);
      var key = fromName(serializer, result.missing);
      var version3 = fromVersion(result.readTime);
      return MutableDocument.newNoDocument(key, version3);
    }
    function fromBatchGetDocumentsResponse(serializer, result) {
      if ("found" in result) {
        return fromFound(serializer, result);
      } else if ("missing" in result) {
        return fromMissing(serializer, result);
      }
      return fail();
    }
    function fromWatchChange(serializer, change) {
      var watchChange;
      if ("targetChange" in change) {
        assertPresent(change.targetChange);
        var state = fromWatchTargetChangeState(change.targetChange.targetChangeType || "NO_CHANGE");
        var targetIds = change.targetChange.targetIds || [];
        var resumeToken = fromBytes(serializer, change.targetChange.resumeToken);
        var causeProto = change.targetChange.cause;
        var cause = causeProto && fromRpcStatus(causeProto);
        watchChange = new WatchTargetChange(state, targetIds, resumeToken, cause || null);
      } else if ("documentChange" in change) {
        assertPresent(change.documentChange);
        var entityChange = change.documentChange;
        assertPresent(entityChange.document);
        assertPresent(entityChange.document.name);
        assertPresent(entityChange.document.updateTime);
        var key = fromName(serializer, entityChange.document.name);
        var version_1 = fromVersion(entityChange.document.updateTime);
        var data = new ObjectValue({
          mapValue: { fields: entityChange.document.fields }
        });
        var doc_1 = MutableDocument.newFoundDocument(key, version_1, data);
        var updatedTargetIds = entityChange.targetIds || [];
        var removedTargetIds = entityChange.removedTargetIds || [];
        watchChange = new DocumentWatchChange(updatedTargetIds, removedTargetIds, doc_1.key, doc_1);
      } else if ("documentDelete" in change) {
        assertPresent(change.documentDelete);
        var docDelete = change.documentDelete;
        assertPresent(docDelete.document);
        var key = fromName(serializer, docDelete.document);
        var version_2 = docDelete.readTime ? fromVersion(docDelete.readTime) : SnapshotVersion.min();
        var doc_2 = MutableDocument.newNoDocument(key, version_2);
        var removedTargetIds = docDelete.removedTargetIds || [];
        watchChange = new DocumentWatchChange([], removedTargetIds, doc_2.key, doc_2);
      } else if ("documentRemove" in change) {
        assertPresent(change.documentRemove);
        var docRemove = change.documentRemove;
        assertPresent(docRemove.document);
        var key = fromName(serializer, docRemove.document);
        var removedTargetIds = docRemove.removedTargetIds || [];
        watchChange = new DocumentWatchChange([], removedTargetIds, key, null);
      } else if ("filter" in change) {
        assertPresent(change.filter);
        var filter2 = change.filter;
        assertPresent(filter2.targetId);
        var count = filter2.count || 0;
        var existenceFilter = new ExistenceFilter(count);
        var targetId = filter2.targetId;
        watchChange = new ExistenceFilterChange(targetId, existenceFilter);
      } else {
        return fail();
      }
      return watchChange;
    }
    function fromWatchTargetChangeState(state) {
      if (state === "NO_CHANGE") {
        return 0;
      } else if (state === "ADD") {
        return 1;
      } else if (state === "REMOVE") {
        return 2;
      } else if (state === "CURRENT") {
        return 3;
      } else if (state === "RESET") {
        return 4;
      } else {
        return fail();
      }
    }
    function versionFromListenResponse(change) {
      if (!("targetChange" in change)) {
        return SnapshotVersion.min();
      }
      var targetChange = change.targetChange;
      if (targetChange.targetIds && targetChange.targetIds.length) {
        return SnapshotVersion.min();
      }
      if (!targetChange.readTime) {
        return SnapshotVersion.min();
      }
      return fromVersion(targetChange.readTime);
    }
    function toMutation(serializer, mutation) {
      var result;
      if (mutation instanceof SetMutation) {
        result = {
          update: toMutationDocument(serializer, mutation.key, mutation.value)
        };
      } else if (mutation instanceof DeleteMutation) {
        result = { delete: toName(serializer, mutation.key) };
      } else if (mutation instanceof PatchMutation) {
        result = {
          update: toMutationDocument(serializer, mutation.key, mutation.data),
          updateMask: toDocumentMask(mutation.fieldMask)
        };
      } else if (mutation instanceof VerifyMutation) {
        result = {
          verify: toName(serializer, mutation.key)
        };
      } else {
        return fail();
      }
      if (mutation.fieldTransforms.length > 0) {
        result.updateTransforms = mutation.fieldTransforms.map(function(transform) {
          return toFieldTransform(serializer, transform);
        });
      }
      if (!mutation.precondition.isNone) {
        result.currentDocument = toPrecondition(serializer, mutation.precondition);
      }
      return result;
    }
    function fromMutation(serializer, proto) {
      var precondition = proto.currentDocument ? fromPrecondition(proto.currentDocument) : Precondition.none();
      var fieldTransforms = proto.updateTransforms ? proto.updateTransforms.map(function(transform) {
        return fromFieldTransform(serializer, transform);
      }) : [];
      if (proto.update) {
        assertPresent(proto.update.name);
        var key = fromName(serializer, proto.update.name);
        var value = new ObjectValue({
          mapValue: { fields: proto.update.fields }
        });
        if (proto.updateMask) {
          var fieldMask = fromDocumentMask(proto.updateMask);
          return new PatchMutation(key, value, fieldMask, precondition, fieldTransforms);
        } else {
          return new SetMutation(key, value, precondition, fieldTransforms);
        }
      } else if (proto.delete) {
        var key = fromName(serializer, proto.delete);
        return new DeleteMutation(key, precondition);
      } else if (proto.verify) {
        var key = fromName(serializer, proto.verify);
        return new VerifyMutation(key, precondition);
      } else {
        return fail();
      }
    }
    function toPrecondition(serializer, precondition) {
      if (precondition.updateTime !== void 0) {
        return {
          updateTime: toVersion(serializer, precondition.updateTime)
        };
      } else if (precondition.exists !== void 0) {
        return { exists: precondition.exists };
      } else {
        return fail();
      }
    }
    function fromPrecondition(precondition) {
      if (precondition.updateTime !== void 0) {
        return Precondition.updateTime(fromVersion(precondition.updateTime));
      } else if (precondition.exists !== void 0) {
        return Precondition.exists(precondition.exists);
      } else {
        return Precondition.none();
      }
    }
    function fromWriteResult(proto, commitTime) {
      var version3 = proto.updateTime ? fromVersion(proto.updateTime) : fromVersion(commitTime);
      if (version3.isEqual(SnapshotVersion.min())) {
        version3 = fromVersion(commitTime);
      }
      return new MutationResult(version3, proto.transformResults || []);
    }
    function fromWriteResults(protos, commitTime) {
      if (protos && protos.length > 0) {
        hardAssert(commitTime !== void 0);
        return protos.map(function(proto) {
          return fromWriteResult(proto, commitTime);
        });
      } else {
        return [];
      }
    }
    function toFieldTransform(serializer, fieldTransform) {
      var transform = fieldTransform.transform;
      if (transform instanceof ServerTimestampTransform) {
        return {
          fieldPath: fieldTransform.field.canonicalString(),
          setToServerValue: "REQUEST_TIME"
        };
      } else if (transform instanceof ArrayUnionTransformOperation) {
        return {
          fieldPath: fieldTransform.field.canonicalString(),
          appendMissingElements: {
            values: transform.elements
          }
        };
      } else if (transform instanceof ArrayRemoveTransformOperation) {
        return {
          fieldPath: fieldTransform.field.canonicalString(),
          removeAllFromArray: {
            values: transform.elements
          }
        };
      } else if (transform instanceof NumericIncrementTransformOperation) {
        return {
          fieldPath: fieldTransform.field.canonicalString(),
          increment: transform.operand
        };
      } else {
        throw fail();
      }
    }
    function fromFieldTransform(serializer, proto) {
      var transform = null;
      if ("setToServerValue" in proto) {
        hardAssert(proto.setToServerValue === "REQUEST_TIME");
        transform = new ServerTimestampTransform();
      } else if ("appendMissingElements" in proto) {
        var values = proto.appendMissingElements.values || [];
        transform = new ArrayUnionTransformOperation(values);
      } else if ("removeAllFromArray" in proto) {
        var values = proto.removeAllFromArray.values || [];
        transform = new ArrayRemoveTransformOperation(values);
      } else if ("increment" in proto) {
        transform = new NumericIncrementTransformOperation(serializer, proto.increment);
      } else {
        fail();
      }
      var fieldPath = FieldPath$1.fromServerFormat(proto.fieldPath);
      return new FieldTransform(fieldPath, transform);
    }
    function toDocumentsTarget(serializer, target) {
      return { documents: [toQueryPath(serializer, target.path)] };
    }
    function fromDocumentsTarget(documentsTarget) {
      var count = documentsTarget.documents.length;
      hardAssert(count === 1);
      var name3 = documentsTarget.documents[0];
      return queryToTarget(newQueryForPath(fromQueryPath(name3)));
    }
    function toQueryTarget(serializer, target) {
      var result = { structuredQuery: {} };
      var path2 = target.path;
      if (target.collectionGroup !== null) {
        result.parent = toQueryPath(serializer, path2);
        result.structuredQuery.from = [
          {
            collectionId: target.collectionGroup,
            allDescendants: true
          }
        ];
      } else {
        result.parent = toQueryPath(serializer, path2.popLast());
        result.structuredQuery.from = [{ collectionId: path2.lastSegment() }];
      }
      var where2 = toFilter(target.filters);
      if (where2) {
        result.structuredQuery.where = where2;
      }
      var orderBy2 = toOrder(target.orderBy);
      if (orderBy2) {
        result.structuredQuery.orderBy = orderBy2;
      }
      var limit2 = toInt32Proto(serializer, target.limit);
      if (limit2 !== null) {
        result.structuredQuery.limit = limit2;
      }
      if (target.startAt) {
        result.structuredQuery.startAt = toCursor(target.startAt);
      }
      if (target.endAt) {
        result.structuredQuery.endAt = toCursor(target.endAt);
      }
      return result;
    }
    function convertQueryTargetToQuery(target) {
      var path2 = fromQueryPath(target.parent);
      var query2 = target.structuredQuery;
      var fromCount = query2.from ? query2.from.length : 0;
      var collectionGroup2 = null;
      if (fromCount > 0) {
        hardAssert(fromCount === 1);
        var from = query2.from[0];
        if (from.allDescendants) {
          collectionGroup2 = from.collectionId;
        } else {
          path2 = path2.child(from.collectionId);
        }
      }
      var filterBy = [];
      if (query2.where) {
        filterBy = fromFilter(query2.where);
      }
      var orderBy2 = [];
      if (query2.orderBy) {
        orderBy2 = fromOrder(query2.orderBy);
      }
      var limit2 = null;
      if (query2.limit) {
        limit2 = fromInt32Proto(query2.limit);
      }
      var startAt2 = null;
      if (query2.startAt) {
        startAt2 = fromCursor(query2.startAt);
      }
      var endAt2 = null;
      if (query2.endAt) {
        endAt2 = fromCursor(query2.endAt);
      }
      return newQuery(path2, collectionGroup2, orderBy2, filterBy, limit2, "F", startAt2, endAt2);
    }
    function fromQueryTarget(target) {
      return queryToTarget(convertQueryTargetToQuery(target));
    }
    function toListenRequestLabels(serializer, targetData) {
      var value = toLabel(serializer, targetData.purpose);
      if (value == null) {
        return null;
      } else {
        return {
          "goog-listen-tags": value
        };
      }
    }
    function toLabel(serializer, purpose) {
      switch (purpose) {
        case 0:
          return null;
        case 1:
          return "existence-filter-mismatch";
        case 2:
          return "limbo-document";
        default:
          return fail();
      }
    }
    function toTarget(serializer, targetData) {
      var result;
      var target = targetData.target;
      if (isDocumentTarget(target)) {
        result = { documents: toDocumentsTarget(serializer, target) };
      } else {
        result = { query: toQueryTarget(serializer, target) };
      }
      result.targetId = targetData.targetId;
      if (targetData.resumeToken.approximateByteSize() > 0) {
        result.resumeToken = toBytes(serializer, targetData.resumeToken);
      } else if (targetData.snapshotVersion.compareTo(SnapshotVersion.min()) > 0) {
        result.readTime = toTimestamp(serializer, targetData.snapshotVersion.toTimestamp());
      }
      return result;
    }
    function toFilter(filters) {
      if (filters.length === 0) {
        return;
      }
      var protos = filters.map(function(filter2) {
        return toUnaryOrFieldFilter(filter2);
      });
      if (protos.length === 1) {
        return protos[0];
      }
      return { compositeFilter: { op: "AND", filters: protos } };
    }
    function fromFilter(filter2) {
      if (!filter2) {
        return [];
      } else if (filter2.unaryFilter !== void 0) {
        return [fromUnaryFilter(filter2)];
      } else if (filter2.fieldFilter !== void 0) {
        return [fromFieldFilter(filter2)];
      } else if (filter2.compositeFilter !== void 0) {
        return filter2.compositeFilter.filters.map(function(f) {
          return fromFilter(f);
        }).reduce(function(accum, current) {
          return accum.concat(current);
        });
      } else {
        return fail();
      }
    }
    function toOrder(orderBys) {
      if (orderBys.length === 0) {
        return;
      }
      return orderBys.map(function(order) {
        return toPropertyOrder(order);
      });
    }
    function fromOrder(orderBys) {
      return orderBys.map(function(order) {
        return fromPropertyOrder(order);
      });
    }
    function toCursor(cursor) {
      return {
        before: cursor.before,
        values: cursor.position
      };
    }
    function fromCursor(cursor) {
      var before = !!cursor.before;
      var position = cursor.values || [];
      return new Bound(position, before);
    }
    function toDirection(dir) {
      return DIRECTIONS[dir];
    }
    function fromDirection(dir) {
      switch (dir) {
        case "ASCENDING":
          return "asc";
        case "DESCENDING":
          return "desc";
        default:
          return void 0;
      }
    }
    function toOperatorName(op) {
      return OPERATORS[op];
    }
    function fromOperatorName(op) {
      switch (op) {
        case "EQUAL":
          return "==";
        case "NOT_EQUAL":
          return "!=";
        case "GREATER_THAN":
          return ">";
        case "GREATER_THAN_OR_EQUAL":
          return ">=";
        case "LESS_THAN":
          return "<";
        case "LESS_THAN_OR_EQUAL":
          return "<=";
        case "ARRAY_CONTAINS":
          return "array-contains";
        case "IN":
          return "in";
        case "NOT_IN":
          return "not-in";
        case "ARRAY_CONTAINS_ANY":
          return "array-contains-any";
        case "OPERATOR_UNSPECIFIED":
          return fail();
        default:
          return fail();
      }
    }
    function toFieldPathReference(path2) {
      return { fieldPath: path2.canonicalString() };
    }
    function fromFieldPathReference(fieldReference) {
      return FieldPath$1.fromServerFormat(fieldReference.fieldPath);
    }
    function toPropertyOrder(orderBy2) {
      return {
        field: toFieldPathReference(orderBy2.field),
        direction: toDirection(orderBy2.dir)
      };
    }
    function fromPropertyOrder(orderBy2) {
      return new OrderBy(fromFieldPathReference(orderBy2.field), fromDirection(orderBy2.direction));
    }
    function fromFieldFilter(filter2) {
      return FieldFilter.create(fromFieldPathReference(filter2.fieldFilter.field), fromOperatorName(filter2.fieldFilter.op), filter2.fieldFilter.value);
    }
    function toUnaryOrFieldFilter(filter2) {
      if (filter2.op === "==") {
        if (isNanValue(filter2.value)) {
          return {
            unaryFilter: {
              field: toFieldPathReference(filter2.field),
              op: "IS_NAN"
            }
          };
        } else if (isNullValue(filter2.value)) {
          return {
            unaryFilter: {
              field: toFieldPathReference(filter2.field),
              op: "IS_NULL"
            }
          };
        }
      } else if (filter2.op === "!=") {
        if (isNanValue(filter2.value)) {
          return {
            unaryFilter: {
              field: toFieldPathReference(filter2.field),
              op: "IS_NOT_NAN"
            }
          };
        } else if (isNullValue(filter2.value)) {
          return {
            unaryFilter: {
              field: toFieldPathReference(filter2.field),
              op: "IS_NOT_NULL"
            }
          };
        }
      }
      return {
        fieldFilter: {
          field: toFieldPathReference(filter2.field),
          op: toOperatorName(filter2.op),
          value: filter2.value
        }
      };
    }
    function fromUnaryFilter(filter2) {
      switch (filter2.unaryFilter.op) {
        case "IS_NAN":
          var nanField = fromFieldPathReference(filter2.unaryFilter.field);
          return FieldFilter.create(nanField, "==", {
            doubleValue: NaN
          });
        case "IS_NULL":
          var nullField = fromFieldPathReference(filter2.unaryFilter.field);
          return FieldFilter.create(nullField, "==", {
            nullValue: "NULL_VALUE"
          });
        case "IS_NOT_NAN":
          var notNanField = fromFieldPathReference(filter2.unaryFilter.field);
          return FieldFilter.create(notNanField, "!=", {
            doubleValue: NaN
          });
        case "IS_NOT_NULL":
          var notNullField = fromFieldPathReference(filter2.unaryFilter.field);
          return FieldFilter.create(notNullField, "!=", {
            nullValue: "NULL_VALUE"
          });
        case "OPERATOR_UNSPECIFIED":
          return fail();
        default:
          return fail();
      }
    }
    function toDocumentMask(fieldMask) {
      var canonicalFields = [];
      fieldMask.fields.forEach(function(field) {
        return canonicalFields.push(field.canonicalString());
      });
      return {
        fieldPaths: canonicalFields
      };
    }
    function fromDocumentMask(proto) {
      var paths = proto.fieldPaths || [];
      return new FieldMask(paths.map(function(path2) {
        return FieldPath$1.fromServerFormat(path2);
      }));
    }
    function isValidResourceName(path2) {
      return path2.length >= 4 && path2.get(0) === "projects" && path2.get(2) === "databases";
    }
    var TargetData = function() {
      function TargetData2(target, targetId, purpose, sequenceNumber, snapshotVersion, lastLimboFreeSnapshotVersion, resumeToken) {
        if (snapshotVersion === void 0) {
          snapshotVersion = SnapshotVersion.min();
        }
        if (lastLimboFreeSnapshotVersion === void 0) {
          lastLimboFreeSnapshotVersion = SnapshotVersion.min();
        }
        if (resumeToken === void 0) {
          resumeToken = ByteString.EMPTY_BYTE_STRING;
        }
        this.target = target;
        this.targetId = targetId;
        this.purpose = purpose;
        this.sequenceNumber = sequenceNumber;
        this.snapshotVersion = snapshotVersion;
        this.lastLimboFreeSnapshotVersion = lastLimboFreeSnapshotVersion;
        this.resumeToken = resumeToken;
      }
      TargetData2.prototype.withSequenceNumber = function(sequenceNumber) {
        return new TargetData2(this.target, this.targetId, this.purpose, sequenceNumber, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken);
      };
      TargetData2.prototype.withResumeToken = function(resumeToken, snapshotVersion) {
        return new TargetData2(this.target, this.targetId, this.purpose, this.sequenceNumber, snapshotVersion, this.lastLimboFreeSnapshotVersion, resumeToken);
      };
      TargetData2.prototype.withLastLimboFreeSnapshotVersion = function(lastLimboFreeSnapshotVersion) {
        return new TargetData2(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, lastLimboFreeSnapshotVersion, this.resumeToken);
      };
      return TargetData2;
    }();
    var LocalSerializer = function() {
      function LocalSerializer2(remoteSerializer) {
        this.remoteSerializer = remoteSerializer;
      }
      return LocalSerializer2;
    }();
    function fromDbRemoteDocument(localSerializer, remoteDoc) {
      if (remoteDoc.document) {
        return fromDocument(localSerializer.remoteSerializer, remoteDoc.document, !!remoteDoc.hasCommittedMutations);
      } else if (remoteDoc.noDocument) {
        var key = DocumentKey.fromSegments(remoteDoc.noDocument.path);
        var version_3 = fromDbTimestamp(remoteDoc.noDocument.readTime);
        var document_1 = MutableDocument.newNoDocument(key, version_3);
        return remoteDoc.hasCommittedMutations ? document_1.setHasCommittedMutations() : document_1;
      } else if (remoteDoc.unknownDocument) {
        var key = DocumentKey.fromSegments(remoteDoc.unknownDocument.path);
        var version_4 = fromDbTimestamp(remoteDoc.unknownDocument.version);
        return MutableDocument.newUnknownDocument(key, version_4);
      } else {
        return fail();
      }
    }
    function toDbRemoteDocument(localSerializer, document2, readTime) {
      var dbReadTime = toDbTimestampKey(readTime);
      var parentPath = document2.key.path.popLast().toArray();
      if (document2.isFoundDocument()) {
        var doc_3 = toDocument(localSerializer.remoteSerializer, document2);
        var hasCommittedMutations = document2.hasCommittedMutations;
        return new DbRemoteDocument(null, null, doc_3, hasCommittedMutations, dbReadTime, parentPath);
      } else if (document2.isNoDocument()) {
        var path2 = document2.key.path.toArray();
        var readTime_1 = toDbTimestamp(document2.version);
        var hasCommittedMutations = document2.hasCommittedMutations;
        return new DbRemoteDocument(null, new DbNoDocument(path2, readTime_1), null, hasCommittedMutations, dbReadTime, parentPath);
      } else if (document2.isUnknownDocument()) {
        var path2 = document2.key.path.toArray();
        var readTime_2 = toDbTimestamp(document2.version);
        return new DbRemoteDocument(new DbUnknownDocument(path2, readTime_2), null, null, true, dbReadTime, parentPath);
      } else {
        return fail();
      }
    }
    function toDbTimestampKey(snapshotVersion) {
      var timestamp = snapshotVersion.toTimestamp();
      return [timestamp.seconds, timestamp.nanoseconds];
    }
    function fromDbTimestampKey(dbTimestampKey) {
      var timestamp = new Timestamp(dbTimestampKey[0], dbTimestampKey[1]);
      return SnapshotVersion.fromTimestamp(timestamp);
    }
    function toDbTimestamp(snapshotVersion) {
      var timestamp = snapshotVersion.toTimestamp();
      return new DbTimestamp(timestamp.seconds, timestamp.nanoseconds);
    }
    function fromDbTimestamp(dbTimestamp) {
      var timestamp = new Timestamp(dbTimestamp.seconds, dbTimestamp.nanoseconds);
      return SnapshotVersion.fromTimestamp(timestamp);
    }
    function toDbMutationBatch(localSerializer, userId, batch) {
      var serializedBaseMutations = batch.baseMutations.map(function(m) {
        return toMutation(localSerializer.remoteSerializer, m);
      });
      var serializedMutations = batch.mutations.map(function(m) {
        return toMutation(localSerializer.remoteSerializer, m);
      });
      return new DbMutationBatch(userId, batch.batchId, batch.localWriteTime.toMillis(), serializedBaseMutations, serializedMutations);
    }
    function fromDbMutationBatch(localSerializer, dbBatch) {
      var baseMutations = (dbBatch.baseMutations || []).map(function(m) {
        return fromMutation(localSerializer.remoteSerializer, m);
      });
      for (var i = 0; i < dbBatch.mutations.length - 1; ++i) {
        var currentMutation = dbBatch.mutations[i];
        var hasTransform = i + 1 < dbBatch.mutations.length && dbBatch.mutations[i + 1].transform !== void 0;
        if (hasTransform) {
          var transformMutation = dbBatch.mutations[i + 1];
          currentMutation.updateTransforms = transformMutation.transform.fieldTransforms;
          dbBatch.mutations.splice(i + 1, 1);
          ++i;
        }
      }
      var mutations = dbBatch.mutations.map(function(m) {
        return fromMutation(localSerializer.remoteSerializer, m);
      });
      var timestamp = Timestamp.fromMillis(dbBatch.localWriteTimeMs);
      return new MutationBatch(dbBatch.batchId, timestamp, baseMutations, mutations);
    }
    function fromDbTarget(dbTarget) {
      var version3 = fromDbTimestamp(dbTarget.readTime);
      var lastLimboFreeSnapshotVersion = dbTarget.lastLimboFreeSnapshotVersion !== void 0 ? fromDbTimestamp(dbTarget.lastLimboFreeSnapshotVersion) : SnapshotVersion.min();
      var target;
      if (isDocumentQuery(dbTarget.query)) {
        target = fromDocumentsTarget(dbTarget.query);
      } else {
        target = fromQueryTarget(dbTarget.query);
      }
      return new TargetData(target, dbTarget.targetId, 0, dbTarget.lastListenSequenceNumber, version3, lastLimboFreeSnapshotVersion, ByteString.fromBase64String(dbTarget.resumeToken));
    }
    function toDbTarget(localSerializer, targetData) {
      var dbTimestamp = toDbTimestamp(targetData.snapshotVersion);
      var dbLastLimboFreeTimestamp = toDbTimestamp(targetData.lastLimboFreeSnapshotVersion);
      var queryProto;
      if (isDocumentTarget(targetData.target)) {
        queryProto = toDocumentsTarget(localSerializer.remoteSerializer, targetData.target);
      } else {
        queryProto = toQueryTarget(localSerializer.remoteSerializer, targetData.target);
      }
      var resumeToken = targetData.resumeToken.toBase64();
      return new DbTarget(targetData.targetId, canonifyTarget(targetData.target), dbTimestamp, resumeToken, targetData.sequenceNumber, dbLastLimboFreeTimestamp, queryProto);
    }
    function isDocumentQuery(dbQuery) {
      return dbQuery.documents !== void 0;
    }
    function fromDbBundle(dbBundle) {
      return {
        id: dbBundle.bundleId,
        createTime: fromDbTimestamp(dbBundle.createTime),
        version: dbBundle.version
      };
    }
    function toDbBundle(metadata) {
      return {
        bundleId: metadata.id,
        createTime: toDbTimestamp(fromVersion(metadata.createTime)),
        version: metadata.version
      };
    }
    function fromDbNamedQuery(dbNamedQuery) {
      return {
        name: dbNamedQuery.name,
        query: fromBundledQuery(dbNamedQuery.bundledQuery),
        readTime: fromDbTimestamp(dbNamedQuery.readTime)
      };
    }
    function toDbNamedQuery(query2) {
      return {
        name: query2.name,
        readTime: toDbTimestamp(fromVersion(query2.readTime)),
        bundledQuery: query2.bundledQuery
      };
    }
    function fromBundledQuery(bundledQuery) {
      var query2 = convertQueryTargetToQuery({
        parent: bundledQuery.parent,
        structuredQuery: bundledQuery.structuredQuery
      });
      if (bundledQuery.limitType === "LAST") {
        return queryWithLimit(query2, query2.limit, "L");
      }
      return query2;
    }
    function fromProtoNamedQuery(namedQuery2) {
      return {
        name: namedQuery2.name,
        query: fromBundledQuery(namedQuery2.bundledQuery),
        readTime: fromVersion(namedQuery2.readTime)
      };
    }
    function fromBundleMetadata(metadata) {
      return {
        id: metadata.id,
        version: metadata.version,
        createTime: fromVersion(metadata.createTime)
      };
    }
    var IndexedDbBundleCache = function() {
      function IndexedDbBundleCache2() {
      }
      IndexedDbBundleCache2.prototype.getBundleMetadata = function(transaction, bundleId) {
        return bundlesStore(transaction).get(bundleId).next(function(bundle) {
          if (bundle) {
            return fromDbBundle(bundle);
          }
          return void 0;
        });
      };
      IndexedDbBundleCache2.prototype.saveBundleMetadata = function(transaction, bundleMetadata) {
        return bundlesStore(transaction).put(toDbBundle(bundleMetadata));
      };
      IndexedDbBundleCache2.prototype.getNamedQuery = function(transaction, queryName) {
        return namedQueriesStore(transaction).get(queryName).next(function(query2) {
          if (query2) {
            return fromDbNamedQuery(query2);
          }
          return void 0;
        });
      };
      IndexedDbBundleCache2.prototype.saveNamedQuery = function(transaction, query2) {
        return namedQueriesStore(transaction).put(toDbNamedQuery(query2));
      };
      return IndexedDbBundleCache2;
    }();
    function bundlesStore(txn) {
      return getStore(txn, DbBundle.store);
    }
    function namedQueriesStore(txn) {
      return getStore(txn, DbNamedQuery.store);
    }
    var MemoryIndexManager = function() {
      function MemoryIndexManager2() {
        this.collectionParentIndex = new MemoryCollectionParentIndex();
      }
      MemoryIndexManager2.prototype.addToCollectionParentIndex = function(transaction, collectionPath) {
        this.collectionParentIndex.add(collectionPath);
        return PersistencePromise.resolve();
      };
      MemoryIndexManager2.prototype.getCollectionParents = function(transaction, collectionId) {
        return PersistencePromise.resolve(this.collectionParentIndex.getEntries(collectionId));
      };
      return MemoryIndexManager2;
    }();
    var MemoryCollectionParentIndex = function() {
      function MemoryCollectionParentIndex2() {
        this.index = {};
      }
      MemoryCollectionParentIndex2.prototype.add = function(collectionPath) {
        var collectionId = collectionPath.lastSegment();
        var parentPath = collectionPath.popLast();
        var existingParents = this.index[collectionId] || new SortedSet(ResourcePath.comparator);
        var added = !existingParents.has(parentPath);
        this.index[collectionId] = existingParents.add(parentPath);
        return added;
      };
      MemoryCollectionParentIndex2.prototype.has = function(collectionPath) {
        var collectionId = collectionPath.lastSegment();
        var parentPath = collectionPath.popLast();
        var existingParents = this.index[collectionId];
        return existingParents && existingParents.has(parentPath);
      };
      MemoryCollectionParentIndex2.prototype.getEntries = function(collectionId) {
        var parentPaths = this.index[collectionId] || new SortedSet(ResourcePath.comparator);
        return parentPaths.toArray();
      };
      return MemoryCollectionParentIndex2;
    }();
    var IndexedDbIndexManager = function() {
      function IndexedDbIndexManager2() {
        this.collectionParentsCache = new MemoryCollectionParentIndex();
      }
      IndexedDbIndexManager2.prototype.addToCollectionParentIndex = function(transaction, collectionPath) {
        var _this = this;
        if (!this.collectionParentsCache.has(collectionPath)) {
          var collectionId = collectionPath.lastSegment();
          var parentPath = collectionPath.popLast();
          transaction.addOnCommittedListener(function() {
            _this.collectionParentsCache.add(collectionPath);
          });
          var collectionParent = {
            collectionId,
            parent: encodeResourcePath(parentPath)
          };
          return collectionParentsStore(transaction).put(collectionParent);
        }
        return PersistencePromise.resolve();
      };
      IndexedDbIndexManager2.prototype.getCollectionParents = function(transaction, collectionId) {
        var parentPaths = [];
        var range = IDBKeyRange.bound([collectionId, ""], [immediateSuccessor(collectionId), ""], false, true);
        return collectionParentsStore(transaction).loadAll(range).next(function(entries) {
          for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
            var entry = entries_1[_i];
            if (entry.collectionId !== collectionId) {
              break;
            }
            parentPaths.push(decodeResourcePath(entry.parent));
          }
          return parentPaths;
        });
      };
      return IndexedDbIndexManager2;
    }();
    function collectionParentsStore(txn) {
      return getStore(txn, DbCollectionParent.store);
    }
    function removeMutationBatch(txn, userId, batch) {
      var mutationStore = txn.store(DbMutationBatch.store);
      var indexTxn = txn.store(DbDocumentMutation.store);
      var promises = [];
      var range = IDBKeyRange.only(batch.batchId);
      var numDeleted = 0;
      var removePromise = mutationStore.iterate({ range }, function(key, value, control) {
        numDeleted++;
        return control.delete();
      });
      promises.push(removePromise.next(function() {
        hardAssert(numDeleted === 1);
      }));
      var removedDocuments = [];
      for (var _i = 0, _d = batch.mutations; _i < _d.length; _i++) {
        var mutation = _d[_i];
        var indexKey = DbDocumentMutation.key(userId, mutation.key.path, batch.batchId);
        promises.push(indexTxn.delete(indexKey));
        removedDocuments.push(mutation.key);
      }
      return PersistencePromise.waitFor(promises).next(function() {
        return removedDocuments;
      });
    }
    function dbDocumentSize(doc2) {
      if (!doc2) {
        return 0;
      }
      var value;
      if (doc2.document) {
        value = doc2.document;
      } else if (doc2.unknownDocument) {
        value = doc2.unknownDocument;
      } else if (doc2.noDocument) {
        value = doc2.noDocument;
      } else {
        throw fail();
      }
      return JSON.stringify(value).length;
    }
    var IndexedDbMutationQueue = function() {
      function IndexedDbMutationQueue2(userId, serializer, indexManager, referenceDelegate) {
        this.userId = userId;
        this.serializer = serializer;
        this.indexManager = indexManager;
        this.referenceDelegate = referenceDelegate;
        this.documentKeysByBatchId = {};
      }
      IndexedDbMutationQueue2.forUser = function(user2, serializer, indexManager, referenceDelegate) {
        hardAssert(user2.uid !== "");
        var userId = user2.isAuthenticated() ? user2.uid : "";
        return new IndexedDbMutationQueue2(userId, serializer, indexManager, referenceDelegate);
      };
      IndexedDbMutationQueue2.prototype.checkEmpty = function(transaction) {
        var empty2 = true;
        var range = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);
        return mutationsStore(transaction).iterate({ index: DbMutationBatch.userMutationsIndex, range }, function(key, value, control) {
          empty2 = false;
          control.done();
        }).next(function() {
          return empty2;
        });
      };
      IndexedDbMutationQueue2.prototype.addMutationBatch = function(transaction, localWriteTime, baseMutations, mutations) {
        var _this = this;
        var documentStore = documentMutationsStore(transaction);
        var mutationStore = mutationsStore(transaction);
        return mutationStore.add({}).next(function(batchId) {
          hardAssert(typeof batchId === "number");
          var batch = new MutationBatch(batchId, localWriteTime, baseMutations, mutations);
          var dbBatch = toDbMutationBatch(_this.serializer, _this.userId, batch);
          var promises = [];
          var collectionParents = new SortedSet(function(l, r) {
            return primitiveComparator(l.canonicalString(), r.canonicalString());
          });
          for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {
            var mutation = mutations_1[_i];
            var indexKey = DbDocumentMutation.key(_this.userId, mutation.key.path, batchId);
            collectionParents = collectionParents.add(mutation.key.path.popLast());
            promises.push(mutationStore.put(dbBatch));
            promises.push(documentStore.put(indexKey, DbDocumentMutation.PLACEHOLDER));
          }
          collectionParents.forEach(function(parent2) {
            promises.push(_this.indexManager.addToCollectionParentIndex(transaction, parent2));
          });
          transaction.addOnCommittedListener(function() {
            _this.documentKeysByBatchId[batchId] = batch.keys();
          });
          return PersistencePromise.waitFor(promises).next(function() {
            return batch;
          });
        });
      };
      IndexedDbMutationQueue2.prototype.lookupMutationBatch = function(transaction, batchId) {
        var _this = this;
        return mutationsStore(transaction).get(batchId).next(function(dbBatch) {
          if (dbBatch) {
            hardAssert(dbBatch.userId === _this.userId);
            return fromDbMutationBatch(_this.serializer, dbBatch);
          }
          return null;
        });
      };
      IndexedDbMutationQueue2.prototype.lookupMutationKeys = function(transaction, batchId) {
        var _this = this;
        if (this.documentKeysByBatchId[batchId]) {
          return PersistencePromise.resolve(this.documentKeysByBatchId[batchId]);
        } else {
          return this.lookupMutationBatch(transaction, batchId).next(function(batch) {
            if (batch) {
              var keys = batch.keys();
              _this.documentKeysByBatchId[batchId] = keys;
              return keys;
            } else {
              return null;
            }
          });
        }
      };
      IndexedDbMutationQueue2.prototype.getNextMutationBatchAfterBatchId = function(transaction, batchId) {
        var _this = this;
        var nextBatchId = batchId + 1;
        var range = IDBKeyRange.lowerBound([this.userId, nextBatchId]);
        var foundBatch = null;
        return mutationsStore(transaction).iterate({ index: DbMutationBatch.userMutationsIndex, range }, function(key, dbBatch, control) {
          if (dbBatch.userId === _this.userId) {
            hardAssert(dbBatch.batchId >= nextBatchId);
            foundBatch = fromDbMutationBatch(_this.serializer, dbBatch);
          }
          control.done();
        }).next(function() {
          return foundBatch;
        });
      };
      IndexedDbMutationQueue2.prototype.getHighestUnacknowledgedBatchId = function(transaction) {
        var range = IDBKeyRange.upperBound([
          this.userId,
          Number.POSITIVE_INFINITY
        ]);
        var batchId = BATCHID_UNKNOWN;
        return mutationsStore(transaction).iterate({ index: DbMutationBatch.userMutationsIndex, range, reverse: true }, function(key, dbBatch, control) {
          batchId = dbBatch.batchId;
          control.done();
        }).next(function() {
          return batchId;
        });
      };
      IndexedDbMutationQueue2.prototype.getAllMutationBatches = function(transaction) {
        var _this = this;
        var range = IDBKeyRange.bound([this.userId, BATCHID_UNKNOWN], [this.userId, Number.POSITIVE_INFINITY]);
        return mutationsStore(transaction).loadAll(DbMutationBatch.userMutationsIndex, range).next(function(dbBatches) {
          return dbBatches.map(function(dbBatch) {
            return fromDbMutationBatch(_this.serializer, dbBatch);
          });
        });
      };
      IndexedDbMutationQueue2.prototype.getAllMutationBatchesAffectingDocumentKey = function(transaction, documentKey) {
        var _this = this;
        var indexPrefix = DbDocumentMutation.prefixForPath(this.userId, documentKey.path);
        var indexStart = IDBKeyRange.lowerBound(indexPrefix);
        var results = [];
        return documentMutationsStore(transaction).iterate({ range: indexStart }, function(indexKey, _, control) {
          var userID = indexKey[0], encodedPath = indexKey[1], batchId = indexKey[2];
          var path2 = decodeResourcePath(encodedPath);
          if (userID !== _this.userId || !documentKey.path.isEqual(path2)) {
            control.done();
            return;
          }
          return mutationsStore(transaction).get(batchId).next(function(mutation) {
            if (!mutation) {
              throw fail();
            }
            hardAssert(mutation.userId === _this.userId);
            results.push(fromDbMutationBatch(_this.serializer, mutation));
          });
        }).next(function() {
          return results;
        });
      };
      IndexedDbMutationQueue2.prototype.getAllMutationBatchesAffectingDocumentKeys = function(transaction, documentKeys) {
        var _this = this;
        var uniqueBatchIDs = new SortedSet(primitiveComparator);
        var promises = [];
        documentKeys.forEach(function(documentKey) {
          var indexStart = DbDocumentMutation.prefixForPath(_this.userId, documentKey.path);
          var range = IDBKeyRange.lowerBound(indexStart);
          var promise = documentMutationsStore(transaction).iterate({ range }, function(indexKey, _, control) {
            var userID = indexKey[0], encodedPath = indexKey[1], batchID = indexKey[2];
            var path2 = decodeResourcePath(encodedPath);
            if (userID !== _this.userId || !documentKey.path.isEqual(path2)) {
              control.done();
              return;
            }
            uniqueBatchIDs = uniqueBatchIDs.add(batchID);
          });
          promises.push(promise);
        });
        return PersistencePromise.waitFor(promises).next(function() {
          return _this.lookupMutationBatches(transaction, uniqueBatchIDs);
        });
      };
      IndexedDbMutationQueue2.prototype.getAllMutationBatchesAffectingQuery = function(transaction, query2) {
        var _this = this;
        var queryPath = query2.path;
        var immediateChildrenLength = queryPath.length + 1;
        var indexPrefix = DbDocumentMutation.prefixForPath(this.userId, queryPath);
        var indexStart = IDBKeyRange.lowerBound(indexPrefix);
        var uniqueBatchIDs = new SortedSet(primitiveComparator);
        return documentMutationsStore(transaction).iterate({ range: indexStart }, function(indexKey, _, control) {
          var userID = indexKey[0], encodedPath = indexKey[1], batchID = indexKey[2];
          var path2 = decodeResourcePath(encodedPath);
          if (userID !== _this.userId || !queryPath.isPrefixOf(path2)) {
            control.done();
            return;
          }
          if (path2.length !== immediateChildrenLength) {
            return;
          }
          uniqueBatchIDs = uniqueBatchIDs.add(batchID);
        }).next(function() {
          return _this.lookupMutationBatches(transaction, uniqueBatchIDs);
        });
      };
      IndexedDbMutationQueue2.prototype.lookupMutationBatches = function(transaction, batchIDs) {
        var _this = this;
        var results = [];
        var promises = [];
        batchIDs.forEach(function(batchId) {
          promises.push(mutationsStore(transaction).get(batchId).next(function(mutation) {
            if (mutation === null) {
              throw fail();
            }
            hardAssert(mutation.userId === _this.userId);
            results.push(fromDbMutationBatch(_this.serializer, mutation));
          }));
        });
        return PersistencePromise.waitFor(promises).next(function() {
          return results;
        });
      };
      IndexedDbMutationQueue2.prototype.removeMutationBatch = function(transaction, batch) {
        var _this = this;
        return removeMutationBatch(transaction.simpleDbTransaction, this.userId, batch).next(function(removedDocuments) {
          transaction.addOnCommittedListener(function() {
            _this.removeCachedMutationKeys(batch.batchId);
          });
          return PersistencePromise.forEach(removedDocuments, function(key) {
            return _this.referenceDelegate.markPotentiallyOrphaned(transaction, key);
          });
        });
      };
      IndexedDbMutationQueue2.prototype.removeCachedMutationKeys = function(batchId) {
        delete this.documentKeysByBatchId[batchId];
      };
      IndexedDbMutationQueue2.prototype.performConsistencyCheck = function(txn) {
        var _this = this;
        return this.checkEmpty(txn).next(function(empty2) {
          if (!empty2) {
            return PersistencePromise.resolve();
          }
          var startRange = IDBKeyRange.lowerBound(DbDocumentMutation.prefixForUser(_this.userId));
          var danglingMutationReferences = [];
          return documentMutationsStore(txn).iterate({ range: startRange }, function(key, _, control) {
            var userID = key[0];
            if (userID !== _this.userId) {
              control.done();
              return;
            } else {
              var path2 = decodeResourcePath(key[1]);
              danglingMutationReferences.push(path2);
            }
          }).next(function() {
            hardAssert(danglingMutationReferences.length === 0);
          });
        });
      };
      IndexedDbMutationQueue2.prototype.containsKey = function(txn, key) {
        return mutationQueueContainsKey(txn, this.userId, key);
      };
      IndexedDbMutationQueue2.prototype.getMutationQueueMetadata = function(transaction) {
        var _this = this;
        return mutationQueuesStore(transaction).get(this.userId).next(function(metadata) {
          return metadata || new DbMutationQueue(_this.userId, BATCHID_UNKNOWN, "");
        });
      };
      return IndexedDbMutationQueue2;
    }();
    function mutationQueueContainsKey(txn, userId, key) {
      var indexKey = DbDocumentMutation.prefixForPath(userId, key.path);
      var encodedPath = indexKey[1];
      var startRange = IDBKeyRange.lowerBound(indexKey);
      var containsKey = false;
      return documentMutationsStore(txn).iterate({ range: startRange, keysOnly: true }, function(key2, value, control) {
        var userID = key2[0], keyPath = key2[1];
        key2[2];
        if (userID === userId && keyPath === encodedPath) {
          containsKey = true;
        }
        control.done();
      }).next(function() {
        return containsKey;
      });
    }
    function mutationQueuesContainKey(txn, docKey) {
      var found = false;
      return mutationQueuesStore(txn).iterateSerial(function(userId) {
        return mutationQueueContainsKey(txn, userId, docKey).next(function(containsKey) {
          if (containsKey) {
            found = true;
          }
          return PersistencePromise.resolve(!containsKey);
        });
      }).next(function() {
        return found;
      });
    }
    function mutationsStore(txn) {
      return getStore(txn, DbMutationBatch.store);
    }
    function documentMutationsStore(txn) {
      return getStore(txn, DbDocumentMutation.store);
    }
    function mutationQueuesStore(txn) {
      return getStore(txn, DbMutationQueue.store);
    }
    var OFFSET = 2;
    var TargetIdGenerator = function() {
      function TargetIdGenerator2(lastId) {
        this.lastId = lastId;
      }
      TargetIdGenerator2.prototype.next = function() {
        this.lastId += OFFSET;
        return this.lastId;
      };
      TargetIdGenerator2.forTargetCache = function() {
        return new TargetIdGenerator2(2 - OFFSET);
      };
      TargetIdGenerator2.forSyncEngine = function() {
        return new TargetIdGenerator2(1 - OFFSET);
      };
      return TargetIdGenerator2;
    }();
    var IndexedDbTargetCache = function() {
      function IndexedDbTargetCache2(referenceDelegate, serializer) {
        this.referenceDelegate = referenceDelegate;
        this.serializer = serializer;
      }
      IndexedDbTargetCache2.prototype.allocateTargetId = function(transaction) {
        var _this = this;
        return this.retrieveMetadata(transaction).next(function(metadata) {
          var targetIdGenerator = new TargetIdGenerator(metadata.highestTargetId);
          metadata.highestTargetId = targetIdGenerator.next();
          return _this.saveMetadata(transaction, metadata).next(function() {
            return metadata.highestTargetId;
          });
        });
      };
      IndexedDbTargetCache2.prototype.getLastRemoteSnapshotVersion = function(transaction) {
        return this.retrieveMetadata(transaction).next(function(metadata) {
          return SnapshotVersion.fromTimestamp(new Timestamp(metadata.lastRemoteSnapshotVersion.seconds, metadata.lastRemoteSnapshotVersion.nanoseconds));
        });
      };
      IndexedDbTargetCache2.prototype.getHighestSequenceNumber = function(transaction) {
        return this.retrieveMetadata(transaction).next(function(targetGlobal) {
          return targetGlobal.highestListenSequenceNumber;
        });
      };
      IndexedDbTargetCache2.prototype.setTargetsMetadata = function(transaction, highestListenSequenceNumber, lastRemoteSnapshotVersion) {
        var _this = this;
        return this.retrieveMetadata(transaction).next(function(metadata) {
          metadata.highestListenSequenceNumber = highestListenSequenceNumber;
          if (lastRemoteSnapshotVersion) {
            metadata.lastRemoteSnapshotVersion = lastRemoteSnapshotVersion.toTimestamp();
          }
          if (highestListenSequenceNumber > metadata.highestListenSequenceNumber) {
            metadata.highestListenSequenceNumber = highestListenSequenceNumber;
          }
          return _this.saveMetadata(transaction, metadata);
        });
      };
      IndexedDbTargetCache2.prototype.addTargetData = function(transaction, targetData) {
        var _this = this;
        return this.saveTargetData(transaction, targetData).next(function() {
          return _this.retrieveMetadata(transaction).next(function(metadata) {
            metadata.targetCount += 1;
            _this.updateMetadataFromTargetData(targetData, metadata);
            return _this.saveMetadata(transaction, metadata);
          });
        });
      };
      IndexedDbTargetCache2.prototype.updateTargetData = function(transaction, targetData) {
        return this.saveTargetData(transaction, targetData);
      };
      IndexedDbTargetCache2.prototype.removeTargetData = function(transaction, targetData) {
        var _this = this;
        return this.removeMatchingKeysForTargetId(transaction, targetData.targetId).next(function() {
          return targetsStore(transaction).delete(targetData.targetId);
        }).next(function() {
          return _this.retrieveMetadata(transaction);
        }).next(function(metadata) {
          hardAssert(metadata.targetCount > 0);
          metadata.targetCount -= 1;
          return _this.saveMetadata(transaction, metadata);
        });
      };
      IndexedDbTargetCache2.prototype.removeTargets = function(txn, upperBound, activeTargetIds) {
        var _this = this;
        var count = 0;
        var promises = [];
        return targetsStore(txn).iterate(function(key, value) {
          var targetData = fromDbTarget(value);
          if (targetData.sequenceNumber <= upperBound && activeTargetIds.get(targetData.targetId) === null) {
            count++;
            promises.push(_this.removeTargetData(txn, targetData));
          }
        }).next(function() {
          return PersistencePromise.waitFor(promises);
        }).next(function() {
          return count;
        });
      };
      IndexedDbTargetCache2.prototype.forEachTarget = function(txn, f) {
        return targetsStore(txn).iterate(function(key, value) {
          var targetData = fromDbTarget(value);
          f(targetData);
        });
      };
      IndexedDbTargetCache2.prototype.retrieveMetadata = function(transaction) {
        return globalTargetStore(transaction).get(DbTargetGlobal.key).next(function(metadata) {
          hardAssert(metadata !== null);
          return metadata;
        });
      };
      IndexedDbTargetCache2.prototype.saveMetadata = function(transaction, metadata) {
        return globalTargetStore(transaction).put(DbTargetGlobal.key, metadata);
      };
      IndexedDbTargetCache2.prototype.saveTargetData = function(transaction, targetData) {
        return targetsStore(transaction).put(toDbTarget(this.serializer, targetData));
      };
      IndexedDbTargetCache2.prototype.updateMetadataFromTargetData = function(targetData, metadata) {
        var updated = false;
        if (targetData.targetId > metadata.highestTargetId) {
          metadata.highestTargetId = targetData.targetId;
          updated = true;
        }
        if (targetData.sequenceNumber > metadata.highestListenSequenceNumber) {
          metadata.highestListenSequenceNumber = targetData.sequenceNumber;
          updated = true;
        }
        return updated;
      };
      IndexedDbTargetCache2.prototype.getTargetCount = function(transaction) {
        return this.retrieveMetadata(transaction).next(function(metadata) {
          return metadata.targetCount;
        });
      };
      IndexedDbTargetCache2.prototype.getTargetData = function(transaction, target) {
        var canonicalId2 = canonifyTarget(target);
        var range = IDBKeyRange.bound([canonicalId2, Number.NEGATIVE_INFINITY], [canonicalId2, Number.POSITIVE_INFINITY]);
        var result = null;
        return targetsStore(transaction).iterate({ range, index: DbTarget.queryTargetsIndexName }, function(key, value, control) {
          var found = fromDbTarget(value);
          if (targetEquals(target, found.target)) {
            result = found;
            control.done();
          }
        }).next(function() {
          return result;
        });
      };
      IndexedDbTargetCache2.prototype.addMatchingKeys = function(txn, keys, targetId) {
        var _this = this;
        var promises = [];
        var store = documentTargetStore(txn);
        keys.forEach(function(key) {
          var path2 = encodeResourcePath(key.path);
          promises.push(store.put(new DbTargetDocument(targetId, path2)));
          promises.push(_this.referenceDelegate.addReference(txn, targetId, key));
        });
        return PersistencePromise.waitFor(promises);
      };
      IndexedDbTargetCache2.prototype.removeMatchingKeys = function(txn, keys, targetId) {
        var _this = this;
        var store = documentTargetStore(txn);
        return PersistencePromise.forEach(keys, function(key) {
          var path2 = encodeResourcePath(key.path);
          return PersistencePromise.waitFor([
            store.delete([targetId, path2]),
            _this.referenceDelegate.removeReference(txn, targetId, key)
          ]);
        });
      };
      IndexedDbTargetCache2.prototype.removeMatchingKeysForTargetId = function(txn, targetId) {
        var store = documentTargetStore(txn);
        var range = IDBKeyRange.bound([targetId], [targetId + 1], false, true);
        return store.delete(range);
      };
      IndexedDbTargetCache2.prototype.getMatchingKeysForTargetId = function(txn, targetId) {
        var range = IDBKeyRange.bound([targetId], [targetId + 1], false, true);
        var store = documentTargetStore(txn);
        var result = documentKeySet();
        return store.iterate({ range, keysOnly: true }, function(key, _, control) {
          var path2 = decodeResourcePath(key[1]);
          var docKey = new DocumentKey(path2);
          result = result.add(docKey);
        }).next(function() {
          return result;
        });
      };
      IndexedDbTargetCache2.prototype.containsKey = function(txn, key) {
        var path2 = encodeResourcePath(key.path);
        var range = IDBKeyRange.bound([path2], [immediateSuccessor(path2)], false, true);
        var count = 0;
        return documentTargetStore(txn).iterate({
          index: DbTargetDocument.documentTargetsIndex,
          keysOnly: true,
          range
        }, function(_d, _, control) {
          var targetId = _d[0];
          _d[1];
          if (targetId !== 0) {
            count++;
            control.done();
          }
        }).next(function() {
          return count > 0;
        });
      };
      IndexedDbTargetCache2.prototype.getTargetDataForTarget = function(transaction, targetId) {
        return targetsStore(transaction).get(targetId).next(function(found) {
          if (found) {
            return fromDbTarget(found);
          } else {
            return null;
          }
        });
      };
      return IndexedDbTargetCache2;
    }();
    function targetsStore(txn) {
      return getStore(txn, DbTarget.store);
    }
    function globalTargetStore(txn) {
      return getStore(txn, DbTargetGlobal.store);
    }
    function documentTargetStore(txn) {
      return getStore(txn, DbTargetDocument.store);
    }
    function ignoreIfPrimaryLeaseLoss(err) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        return tslib2.__generator(this, function(_d) {
          if (err.code === Code.FAILED_PRECONDITION && err.message === PRIMARY_LEASE_LOST_ERROR_MSG) {
            logDebug("LocalStore", "Unexpectedly lost primary lease");
          } else {
            throw err;
          }
          return [2];
        });
      });
    }
    var GC_DID_NOT_RUN = {
      didRun: false,
      sequenceNumbersCollected: 0,
      targetsRemoved: 0,
      documentsRemoved: 0
    };
    var LRU_COLLECTION_DISABLED = -1;
    var LRU_DEFAULT_CACHE_SIZE_BYTES = 40 * 1024 * 1024;
    var LruParams = function() {
      function LruParams2(cacheSizeCollectionThreshold, percentileToCollect, maximumSequenceNumbersToCollect) {
        this.cacheSizeCollectionThreshold = cacheSizeCollectionThreshold;
        this.percentileToCollect = percentileToCollect;
        this.maximumSequenceNumbersToCollect = maximumSequenceNumbersToCollect;
      }
      LruParams2.withCacheSize = function(cacheSize) {
        return new LruParams2(cacheSize, LruParams2.DEFAULT_COLLECTION_PERCENTILE, LruParams2.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);
      };
      return LruParams2;
    }();
    LruParams.DEFAULT_COLLECTION_PERCENTILE = 10;
    LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3;
    LruParams.DEFAULT = new LruParams(LRU_DEFAULT_CACHE_SIZE_BYTES, LruParams.DEFAULT_COLLECTION_PERCENTILE, LruParams.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);
    LruParams.DISABLED = new LruParams(LRU_COLLECTION_DISABLED, 0, 0);
    var LOG_TAG$e = "LruGarbageCollector";
    var LRU_MINIMUM_CACHE_SIZE_BYTES = 1 * 1024 * 1024;
    var INITIAL_GC_DELAY_MS = 1 * 60 * 1e3;
    var REGULAR_GC_DELAY_MS = 5 * 60 * 1e3;
    function bufferEntryComparator(_d, _e) {
      var aSequence = _d[0], aIndex = _d[1];
      var bSequence = _e[0], bIndex = _e[1];
      var seqCmp = primitiveComparator(aSequence, bSequence);
      if (seqCmp === 0) {
        return primitiveComparator(aIndex, bIndex);
      } else {
        return seqCmp;
      }
    }
    var RollingSequenceNumberBuffer = function() {
      function RollingSequenceNumberBuffer2(maxElements) {
        this.maxElements = maxElements;
        this.buffer = new SortedSet(bufferEntryComparator);
        this.previousIndex = 0;
      }
      RollingSequenceNumberBuffer2.prototype.nextIndex = function() {
        return ++this.previousIndex;
      };
      RollingSequenceNumberBuffer2.prototype.addElement = function(sequenceNumber) {
        var entry = [sequenceNumber, this.nextIndex()];
        if (this.buffer.size < this.maxElements) {
          this.buffer = this.buffer.add(entry);
        } else {
          var highestValue = this.buffer.last();
          if (bufferEntryComparator(entry, highestValue) < 0) {
            this.buffer = this.buffer.delete(highestValue).add(entry);
          }
        }
      };
      Object.defineProperty(RollingSequenceNumberBuffer2.prototype, "maxValue", {
        get: function() {
          return this.buffer.last()[0];
        },
        enumerable: false,
        configurable: true
      });
      return RollingSequenceNumberBuffer2;
    }();
    var LruScheduler = function() {
      function LruScheduler2(garbageCollector, asyncQueue) {
        this.garbageCollector = garbageCollector;
        this.asyncQueue = asyncQueue;
        this.hasRun = false;
        this.gcTask = null;
      }
      LruScheduler2.prototype.start = function(localStore2) {
        if (this.garbageCollector.params.cacheSizeCollectionThreshold !== LRU_COLLECTION_DISABLED) {
          this.scheduleGC(localStore2);
        }
      };
      LruScheduler2.prototype.stop = function() {
        if (this.gcTask) {
          this.gcTask.cancel();
          this.gcTask = null;
        }
      };
      Object.defineProperty(LruScheduler2.prototype, "started", {
        get: function() {
          return this.gcTask !== null;
        },
        enumerable: false,
        configurable: true
      });
      LruScheduler2.prototype.scheduleGC = function(localStore2) {
        var _this = this;
        var delay = this.hasRun ? REGULAR_GC_DELAY_MS : INITIAL_GC_DELAY_MS;
        logDebug("LruGarbageCollector", "Garbage collection scheduled in " + delay + "ms");
        this.gcTask = this.asyncQueue.enqueueAfterDelay("lru_garbage_collection", delay, function() {
          return tslib2.__awaiter(_this, void 0, void 0, function() {
            var e_1;
            return tslib2.__generator(this, function(_d) {
              switch (_d.label) {
                case 0:
                  this.gcTask = null;
                  this.hasRun = true;
                  _d.label = 1;
                case 1:
                  _d.trys.push([1, 3, , 7]);
                  return [4, localStore2.collectGarbage(this.garbageCollector)];
                case 2:
                  _d.sent();
                  return [3, 7];
                case 3:
                  e_1 = _d.sent();
                  if (!isIndexedDbTransactionError(e_1))
                    return [3, 4];
                  logDebug(LOG_TAG$e, "Ignoring IndexedDB error during garbage collection: ", e_1);
                  return [3, 6];
                case 4:
                  return [4, ignoreIfPrimaryLeaseLoss(e_1)];
                case 5:
                  _d.sent();
                  _d.label = 6;
                case 6:
                  return [3, 7];
                case 7:
                  return [4, this.scheduleGC(localStore2)];
                case 8:
                  _d.sent();
                  return [2];
              }
            });
          });
        });
      };
      return LruScheduler2;
    }();
    var LruGarbageCollectorImpl = function() {
      function LruGarbageCollectorImpl2(delegate, params) {
        this.delegate = delegate;
        this.params = params;
      }
      LruGarbageCollectorImpl2.prototype.calculateTargetCount = function(txn, percentile) {
        return this.delegate.getSequenceNumberCount(txn).next(function(targetCount) {
          return Math.floor(percentile / 100 * targetCount);
        });
      };
      LruGarbageCollectorImpl2.prototype.nthSequenceNumber = function(txn, n) {
        var _this = this;
        if (n === 0) {
          return PersistencePromise.resolve(ListenSequence.INVALID);
        }
        var buffer = new RollingSequenceNumberBuffer(n);
        return this.delegate.forEachTarget(txn, function(target) {
          return buffer.addElement(target.sequenceNumber);
        }).next(function() {
          return _this.delegate.forEachOrphanedDocumentSequenceNumber(txn, function(sequenceNumber) {
            return buffer.addElement(sequenceNumber);
          });
        }).next(function() {
          return buffer.maxValue;
        });
      };
      LruGarbageCollectorImpl2.prototype.removeTargets = function(txn, upperBound, activeTargetIds) {
        return this.delegate.removeTargets(txn, upperBound, activeTargetIds);
      };
      LruGarbageCollectorImpl2.prototype.removeOrphanedDocuments = function(txn, upperBound) {
        return this.delegate.removeOrphanedDocuments(txn, upperBound);
      };
      LruGarbageCollectorImpl2.prototype.collect = function(txn, activeTargetIds) {
        var _this = this;
        if (this.params.cacheSizeCollectionThreshold === LRU_COLLECTION_DISABLED) {
          logDebug("LruGarbageCollector", "Garbage collection skipped; disabled");
          return PersistencePromise.resolve(GC_DID_NOT_RUN);
        }
        return this.getCacheSize(txn).next(function(cacheSize) {
          if (cacheSize < _this.params.cacheSizeCollectionThreshold) {
            logDebug("LruGarbageCollector", "Garbage collection skipped; Cache size " + cacheSize + " " + ("is lower than threshold " + _this.params.cacheSizeCollectionThreshold));
            return GC_DID_NOT_RUN;
          } else {
            return _this.runGarbageCollection(txn, activeTargetIds);
          }
        });
      };
      LruGarbageCollectorImpl2.prototype.getCacheSize = function(txn) {
        return this.delegate.getCacheSize(txn);
      };
      LruGarbageCollectorImpl2.prototype.runGarbageCollection = function(txn, activeTargetIds) {
        var _this = this;
        var upperBoundSequenceNumber;
        var sequenceNumbersToCollect, targetsRemoved;
        var countedTargetsTs, foundUpperBoundTs, removedTargetsTs, removedDocumentsTs;
        var startTs = Date.now();
        return this.calculateTargetCount(txn, this.params.percentileToCollect).next(function(sequenceNumbers) {
          if (sequenceNumbers > _this.params.maximumSequenceNumbersToCollect) {
            logDebug("LruGarbageCollector", "Capping sequence numbers to collect down " + ("to the maximum of " + _this.params.maximumSequenceNumbersToCollect + " ") + ("from " + sequenceNumbers));
            sequenceNumbersToCollect = _this.params.maximumSequenceNumbersToCollect;
          } else {
            sequenceNumbersToCollect = sequenceNumbers;
          }
          countedTargetsTs = Date.now();
          return _this.nthSequenceNumber(txn, sequenceNumbersToCollect);
        }).next(function(upperBound) {
          upperBoundSequenceNumber = upperBound;
          foundUpperBoundTs = Date.now();
          return _this.removeTargets(txn, upperBoundSequenceNumber, activeTargetIds);
        }).next(function(numTargetsRemoved) {
          targetsRemoved = numTargetsRemoved;
          removedTargetsTs = Date.now();
          return _this.removeOrphanedDocuments(txn, upperBoundSequenceNumber);
        }).next(function(documentsRemoved) {
          removedDocumentsTs = Date.now();
          if (getLogLevel() <= logger2.LogLevel.DEBUG) {
            var desc = "LRU Garbage Collection\n" + ("	Counted targets in " + (countedTargetsTs - startTs) + "ms\n") + ("	Determined least recently used " + sequenceNumbersToCollect + " in ") + (foundUpperBoundTs - countedTargetsTs + "ms\n") + ("	Removed " + targetsRemoved + " targets in ") + (removedTargetsTs - foundUpperBoundTs + "ms\n") + ("	Removed " + documentsRemoved + " documents in ") + (removedDocumentsTs - removedTargetsTs + "ms\n") + ("Total Duration: " + (removedDocumentsTs - startTs) + "ms");
            logDebug("LruGarbageCollector", desc);
          }
          return PersistencePromise.resolve({
            didRun: true,
            sequenceNumbersCollected: sequenceNumbersToCollect,
            targetsRemoved,
            documentsRemoved
          });
        });
      };
      return LruGarbageCollectorImpl2;
    }();
    function newLruGarbageCollector(delegate, params) {
      return new LruGarbageCollectorImpl(delegate, params);
    }
    var IndexedDbLruDelegateImpl = function() {
      function IndexedDbLruDelegateImpl2(db2, params) {
        this.db = db2;
        this.garbageCollector = newLruGarbageCollector(this, params);
      }
      IndexedDbLruDelegateImpl2.prototype.getSequenceNumberCount = function(txn) {
        var docCountPromise = this.orphanedDocumentCount(txn);
        var targetCountPromise = this.db.getTargetCache().getTargetCount(txn);
        return targetCountPromise.next(function(targetCount) {
          return docCountPromise.next(function(docCount) {
            return targetCount + docCount;
          });
        });
      };
      IndexedDbLruDelegateImpl2.prototype.orphanedDocumentCount = function(txn) {
        var orphanedCount = 0;
        return this.forEachOrphanedDocumentSequenceNumber(txn, function(_) {
          orphanedCount++;
        }).next(function() {
          return orphanedCount;
        });
      };
      IndexedDbLruDelegateImpl2.prototype.forEachTarget = function(txn, f) {
        return this.db.getTargetCache().forEachTarget(txn, f);
      };
      IndexedDbLruDelegateImpl2.prototype.forEachOrphanedDocumentSequenceNumber = function(txn, f) {
        return this.forEachOrphanedDocument(txn, function(docKey, sequenceNumber) {
          return f(sequenceNumber);
        });
      };
      IndexedDbLruDelegateImpl2.prototype.addReference = function(txn, targetId, key) {
        return writeSentinelKey(txn, key);
      };
      IndexedDbLruDelegateImpl2.prototype.removeReference = function(txn, targetId, key) {
        return writeSentinelKey(txn, key);
      };
      IndexedDbLruDelegateImpl2.prototype.removeTargets = function(txn, upperBound, activeTargetIds) {
        return this.db.getTargetCache().removeTargets(txn, upperBound, activeTargetIds);
      };
      IndexedDbLruDelegateImpl2.prototype.markPotentiallyOrphaned = function(txn, key) {
        return writeSentinelKey(txn, key);
      };
      IndexedDbLruDelegateImpl2.prototype.isPinned = function(txn, docKey) {
        return mutationQueuesContainKey(txn, docKey);
      };
      IndexedDbLruDelegateImpl2.prototype.removeOrphanedDocuments = function(txn, upperBound) {
        var _this = this;
        var documentCache = this.db.getRemoteDocumentCache();
        var changeBuffer = documentCache.newChangeBuffer();
        var promises = [];
        var documentCount = 0;
        var iteration = this.forEachOrphanedDocument(txn, function(docKey, sequenceNumber) {
          if (sequenceNumber <= upperBound) {
            var p = _this.isPinned(txn, docKey).next(function(isPinned) {
              if (!isPinned) {
                documentCount++;
                return changeBuffer.getEntry(txn, docKey).next(function() {
                  changeBuffer.removeEntry(docKey);
                  return documentTargetStore(txn).delete(sentinelKey$1(docKey));
                });
              }
            });
            promises.push(p);
          }
        });
        return iteration.next(function() {
          return PersistencePromise.waitFor(promises);
        }).next(function() {
          return changeBuffer.apply(txn);
        }).next(function() {
          return documentCount;
        });
      };
      IndexedDbLruDelegateImpl2.prototype.removeTarget = function(txn, targetData) {
        var updated = targetData.withSequenceNumber(txn.currentSequenceNumber);
        return this.db.getTargetCache().updateTargetData(txn, updated);
      };
      IndexedDbLruDelegateImpl2.prototype.updateLimboDocument = function(txn, key) {
        return writeSentinelKey(txn, key);
      };
      IndexedDbLruDelegateImpl2.prototype.forEachOrphanedDocument = function(txn, f) {
        var store = documentTargetStore(txn);
        var nextToReport = ListenSequence.INVALID;
        var nextPath;
        return store.iterate({
          index: DbTargetDocument.documentTargetsIndex
        }, function(_d, _e) {
          var targetId = _d[0];
          _d[1];
          var path2 = _e.path, sequenceNumber = _e.sequenceNumber;
          if (targetId === 0) {
            if (nextToReport !== ListenSequence.INVALID) {
              f(new DocumentKey(decodeResourcePath(nextPath)), nextToReport);
            }
            nextToReport = sequenceNumber;
            nextPath = path2;
          } else {
            nextToReport = ListenSequence.INVALID;
          }
        }).next(function() {
          if (nextToReport !== ListenSequence.INVALID) {
            f(new DocumentKey(decodeResourcePath(nextPath)), nextToReport);
          }
        });
      };
      IndexedDbLruDelegateImpl2.prototype.getCacheSize = function(txn) {
        return this.db.getRemoteDocumentCache().getSize(txn);
      };
      return IndexedDbLruDelegateImpl2;
    }();
    function sentinelKey$1(key) {
      return [0, encodeResourcePath(key.path)];
    }
    function sentinelRow(key, sequenceNumber) {
      return new DbTargetDocument(0, encodeResourcePath(key.path), sequenceNumber);
    }
    function writeSentinelKey(txn, key) {
      return documentTargetStore(txn).put(sentinelRow(key, txn.currentSequenceNumber));
    }
    var ObjectMap = function() {
      function ObjectMap2(mapKeyFn, equalsFn) {
        this.mapKeyFn = mapKeyFn;
        this.equalsFn = equalsFn;
        this.inner = {};
      }
      ObjectMap2.prototype.get = function(key) {
        var id = this.mapKeyFn(key);
        var matches = this.inner[id];
        if (matches === void 0) {
          return void 0;
        }
        for (var _i = 0, matches_1 = matches; _i < matches_1.length; _i++) {
          var _d = matches_1[_i], otherKey = _d[0], value = _d[1];
          if (this.equalsFn(otherKey, key)) {
            return value;
          }
        }
        return void 0;
      };
      ObjectMap2.prototype.has = function(key) {
        return this.get(key) !== void 0;
      };
      ObjectMap2.prototype.set = function(key, value) {
        var id = this.mapKeyFn(key);
        var matches = this.inner[id];
        if (matches === void 0) {
          this.inner[id] = [[key, value]];
          return;
        }
        for (var i = 0; i < matches.length; i++) {
          if (this.equalsFn(matches[i][0], key)) {
            matches[i] = [key, value];
            return;
          }
        }
        matches.push([key, value]);
      };
      ObjectMap2.prototype.delete = function(key) {
        var id = this.mapKeyFn(key);
        var matches = this.inner[id];
        if (matches === void 0) {
          return false;
        }
        for (var i = 0; i < matches.length; i++) {
          if (this.equalsFn(matches[i][0], key)) {
            if (matches.length === 1) {
              delete this.inner[id];
            } else {
              matches.splice(i, 1);
            }
            return true;
          }
        }
        return false;
      };
      ObjectMap2.prototype.forEach = function(fn) {
        forEach(this.inner, function(_, entries) {
          for (var _i = 0, entries_2 = entries; _i < entries_2.length; _i++) {
            var _d = entries_2[_i], k = _d[0], v = _d[1];
            fn(k, v);
          }
        });
      };
      ObjectMap2.prototype.isEmpty = function() {
        return isEmpty2(this.inner);
      };
      return ObjectMap2;
    }();
    var RemoteDocumentChangeBuffer = function() {
      function RemoteDocumentChangeBuffer2() {
        this.changes = new ObjectMap(function(key) {
          return key.toString();
        }, function(l, r) {
          return l.isEqual(r);
        });
        this.changesApplied = false;
      }
      RemoteDocumentChangeBuffer2.prototype.getReadTime = function(key) {
        var change = this.changes.get(key);
        if (change) {
          return change.readTime;
        }
        return SnapshotVersion.min();
      };
      RemoteDocumentChangeBuffer2.prototype.addEntry = function(document2, readTime) {
        this.assertNotApplied();
        this.changes.set(document2.key, { document: document2, readTime });
      };
      RemoteDocumentChangeBuffer2.prototype.removeEntry = function(key, readTime) {
        if (readTime === void 0) {
          readTime = null;
        }
        this.assertNotApplied();
        this.changes.set(key, {
          document: MutableDocument.newInvalidDocument(key),
          readTime
        });
      };
      RemoteDocumentChangeBuffer2.prototype.getEntry = function(transaction, documentKey) {
        this.assertNotApplied();
        var bufferedEntry = this.changes.get(documentKey);
        if (bufferedEntry !== void 0) {
          return PersistencePromise.resolve(bufferedEntry.document);
        } else {
          return this.getFromCache(transaction, documentKey);
        }
      };
      RemoteDocumentChangeBuffer2.prototype.getEntries = function(transaction, documentKeys) {
        return this.getAllFromCache(transaction, documentKeys);
      };
      RemoteDocumentChangeBuffer2.prototype.apply = function(transaction) {
        this.assertNotApplied();
        this.changesApplied = true;
        return this.applyChanges(transaction);
      };
      RemoteDocumentChangeBuffer2.prototype.assertNotApplied = function() {
      };
      return RemoteDocumentChangeBuffer2;
    }();
    var IndexedDbRemoteDocumentCacheImpl = function() {
      function IndexedDbRemoteDocumentCacheImpl2(serializer, indexManager) {
        this.serializer = serializer;
        this.indexManager = indexManager;
      }
      IndexedDbRemoteDocumentCacheImpl2.prototype.addEntry = function(transaction, key, doc2) {
        var documentStore = remoteDocumentsStore(transaction);
        return documentStore.put(dbKey(key), doc2);
      };
      IndexedDbRemoteDocumentCacheImpl2.prototype.removeEntry = function(transaction, documentKey) {
        var store = remoteDocumentsStore(transaction);
        var key = dbKey(documentKey);
        return store.delete(key);
      };
      IndexedDbRemoteDocumentCacheImpl2.prototype.updateMetadata = function(transaction, sizeDelta) {
        var _this = this;
        return this.getMetadata(transaction).next(function(metadata) {
          metadata.byteSize += sizeDelta;
          return _this.setMetadata(transaction, metadata);
        });
      };
      IndexedDbRemoteDocumentCacheImpl2.prototype.getEntry = function(transaction, documentKey) {
        var _this = this;
        return remoteDocumentsStore(transaction).get(dbKey(documentKey)).next(function(dbRemoteDoc) {
          return _this.maybeDecodeDocument(documentKey, dbRemoteDoc);
        });
      };
      IndexedDbRemoteDocumentCacheImpl2.prototype.getSizedEntry = function(transaction, documentKey) {
        var _this = this;
        return remoteDocumentsStore(transaction).get(dbKey(documentKey)).next(function(dbRemoteDoc) {
          var doc2 = _this.maybeDecodeDocument(documentKey, dbRemoteDoc);
          return {
            document: doc2,
            size: dbDocumentSize(dbRemoteDoc)
          };
        });
      };
      IndexedDbRemoteDocumentCacheImpl2.prototype.getEntries = function(transaction, documentKeys) {
        var _this = this;
        var results = mutableDocumentMap();
        return this.forEachDbEntry(transaction, documentKeys, function(key, dbRemoteDoc) {
          var doc2 = _this.maybeDecodeDocument(key, dbRemoteDoc);
          results = results.insert(key, doc2);
        }).next(function() {
          return results;
        });
      };
      IndexedDbRemoteDocumentCacheImpl2.prototype.getSizedEntries = function(transaction, documentKeys) {
        var _this = this;
        var results = mutableDocumentMap();
        var sizeMap = new SortedMap(DocumentKey.comparator);
        return this.forEachDbEntry(transaction, documentKeys, function(key, dbRemoteDoc) {
          var doc2 = _this.maybeDecodeDocument(key, dbRemoteDoc);
          results = results.insert(key, doc2);
          sizeMap = sizeMap.insert(key, dbDocumentSize(dbRemoteDoc));
        }).next(function() {
          return { documents: results, sizeMap };
        });
      };
      IndexedDbRemoteDocumentCacheImpl2.prototype.forEachDbEntry = function(transaction, documentKeys, callback) {
        if (documentKeys.isEmpty()) {
          return PersistencePromise.resolve();
        }
        var range = IDBKeyRange.bound(documentKeys.first().path.toArray(), documentKeys.last().path.toArray());
        var keyIter = documentKeys.getIterator();
        var nextKey = keyIter.getNext();
        return remoteDocumentsStore(transaction).iterate({ range }, function(potentialKeyRaw, dbRemoteDoc, control) {
          var potentialKey = DocumentKey.fromSegments(potentialKeyRaw);
          while (nextKey && DocumentKey.comparator(nextKey, potentialKey) < 0) {
            callback(nextKey, null);
            nextKey = keyIter.getNext();
          }
          if (nextKey && nextKey.isEqual(potentialKey)) {
            callback(nextKey, dbRemoteDoc);
            nextKey = keyIter.hasNext() ? keyIter.getNext() : null;
          }
          if (nextKey) {
            control.skip(nextKey.path.toArray());
          } else {
            control.done();
          }
        }).next(function() {
          while (nextKey) {
            callback(nextKey, null);
            nextKey = keyIter.hasNext() ? keyIter.getNext() : null;
          }
        });
      };
      IndexedDbRemoteDocumentCacheImpl2.prototype.getDocumentsMatchingQuery = function(transaction, query2, sinceReadTime) {
        var _this = this;
        var results = mutableDocumentMap();
        var immediateChildrenPathLength = query2.path.length + 1;
        var iterationOptions = {};
        if (sinceReadTime.isEqual(SnapshotVersion.min())) {
          var startKey = query2.path.toArray();
          iterationOptions.range = IDBKeyRange.lowerBound(startKey);
        } else {
          var collectionKey = query2.path.toArray();
          var readTimeKey = toDbTimestampKey(sinceReadTime);
          iterationOptions.range = IDBKeyRange.lowerBound([collectionKey, readTimeKey], true);
          iterationOptions.index = DbRemoteDocument.collectionReadTimeIndex;
        }
        return remoteDocumentsStore(transaction).iterate(iterationOptions, function(key, dbRemoteDoc, control) {
          if (key.length !== immediateChildrenPathLength) {
            return;
          }
          var document2 = fromDbRemoteDocument(_this.serializer, dbRemoteDoc);
          if (!query2.path.isPrefixOf(document2.key.path)) {
            control.done();
          } else if (queryMatches(query2, document2)) {
            results = results.insert(document2.key, document2);
          }
        }).next(function() {
          return results;
        });
      };
      IndexedDbRemoteDocumentCacheImpl2.prototype.newChangeBuffer = function(options2) {
        return new IndexedDbRemoteDocumentChangeBuffer(this, !!options2 && options2.trackRemovals);
      };
      IndexedDbRemoteDocumentCacheImpl2.prototype.getSize = function(txn) {
        return this.getMetadata(txn).next(function(metadata) {
          return metadata.byteSize;
        });
      };
      IndexedDbRemoteDocumentCacheImpl2.prototype.getMetadata = function(txn) {
        return documentGlobalStore(txn).get(DbRemoteDocumentGlobal.key).next(function(metadata) {
          hardAssert(!!metadata);
          return metadata;
        });
      };
      IndexedDbRemoteDocumentCacheImpl2.prototype.setMetadata = function(txn, metadata) {
        return documentGlobalStore(txn).put(DbRemoteDocumentGlobal.key, metadata);
      };
      IndexedDbRemoteDocumentCacheImpl2.prototype.maybeDecodeDocument = function(documentKey, dbRemoteDoc) {
        if (dbRemoteDoc) {
          var doc_4 = fromDbRemoteDocument(this.serializer, dbRemoteDoc);
          var isSentinelRemoval = doc_4.isNoDocument() && doc_4.version.isEqual(SnapshotVersion.min());
          if (!isSentinelRemoval) {
            return doc_4;
          }
        }
        return MutableDocument.newInvalidDocument(documentKey);
      };
      return IndexedDbRemoteDocumentCacheImpl2;
    }();
    function newIndexedDbRemoteDocumentCache(serializer, indexManager) {
      return new IndexedDbRemoteDocumentCacheImpl(serializer, indexManager);
    }
    function remoteDocumentCacheGetNewDocumentChanges(remoteDocumentCache, transaction, sinceReadTime) {
      var remoteDocumentCacheImpl = debugCast(remoteDocumentCache);
      var changedDocs = mutableDocumentMap();
      var lastReadTime = toDbTimestampKey(sinceReadTime);
      var documentsStore = remoteDocumentsStore(transaction);
      var range = IDBKeyRange.lowerBound(lastReadTime, true);
      return documentsStore.iterate({ index: DbRemoteDocument.readTimeIndex, range }, function(_, dbRemoteDoc) {
        var doc2 = fromDbRemoteDocument(remoteDocumentCacheImpl.serializer, dbRemoteDoc);
        changedDocs = changedDocs.insert(doc2.key, doc2);
        lastReadTime = dbRemoteDoc.readTime;
      }).next(function() {
        return {
          changedDocs,
          readTime: fromDbTimestampKey(lastReadTime)
        };
      });
    }
    function remoteDocumentCacheGetLastReadTime(transaction) {
      var documentsStore = remoteDocumentsStore(transaction);
      var readTime = SnapshotVersion.min();
      return documentsStore.iterate({ index: DbRemoteDocument.readTimeIndex, reverse: true }, function(key, dbRemoteDoc, control) {
        if (dbRemoteDoc.readTime) {
          readTime = fromDbTimestampKey(dbRemoteDoc.readTime);
        }
        control.done();
      }).next(function() {
        return readTime;
      });
    }
    var IndexedDbRemoteDocumentChangeBuffer = function(_super) {
      tslib2.__extends(IndexedDbRemoteDocumentChangeBuffer2, _super);
      function IndexedDbRemoteDocumentChangeBuffer2(documentCache, trackRemovals) {
        var _this = _super.call(this) || this;
        _this.documentCache = documentCache;
        _this.trackRemovals = trackRemovals;
        _this.documentSizes = new ObjectMap(function(key) {
          return key.toString();
        }, function(l, r) {
          return l.isEqual(r);
        });
        return _this;
      }
      IndexedDbRemoteDocumentChangeBuffer2.prototype.applyChanges = function(transaction) {
        var _this = this;
        var promises = [];
        var sizeDelta = 0;
        var collectionParents = new SortedSet(function(l, r) {
          return primitiveComparator(l.canonicalString(), r.canonicalString());
        });
        this.changes.forEach(function(key, documentChange) {
          var previousSize = _this.documentSizes.get(key);
          if (documentChange.document.isValidDocument()) {
            var doc_5 = toDbRemoteDocument(_this.documentCache.serializer, documentChange.document, _this.getReadTime(key));
            collectionParents = collectionParents.add(key.path.popLast());
            var size = dbDocumentSize(doc_5);
            sizeDelta += size - previousSize;
            promises.push(_this.documentCache.addEntry(transaction, key, doc_5));
          } else {
            sizeDelta -= previousSize;
            if (_this.trackRemovals) {
              var deletedDoc = toDbRemoteDocument(_this.documentCache.serializer, MutableDocument.newNoDocument(key, SnapshotVersion.min()), _this.getReadTime(key));
              promises.push(_this.documentCache.addEntry(transaction, key, deletedDoc));
            } else {
              promises.push(_this.documentCache.removeEntry(transaction, key));
            }
          }
        });
        collectionParents.forEach(function(parent2) {
          promises.push(_this.documentCache.indexManager.addToCollectionParentIndex(transaction, parent2));
        });
        promises.push(this.documentCache.updateMetadata(transaction, sizeDelta));
        return PersistencePromise.waitFor(promises);
      };
      IndexedDbRemoteDocumentChangeBuffer2.prototype.getFromCache = function(transaction, documentKey) {
        var _this = this;
        return this.documentCache.getSizedEntry(transaction, documentKey).next(function(getResult) {
          _this.documentSizes.set(documentKey, getResult.size);
          return getResult.document;
        });
      };
      IndexedDbRemoteDocumentChangeBuffer2.prototype.getAllFromCache = function(transaction, documentKeys) {
        var _this = this;
        return this.documentCache.getSizedEntries(transaction, documentKeys).next(function(_d) {
          var documents = _d.documents, sizeMap = _d.sizeMap;
          sizeMap.forEach(function(documentKey, size) {
            _this.documentSizes.set(documentKey, size);
          });
          return documents;
        });
      };
      return IndexedDbRemoteDocumentChangeBuffer2;
    }(RemoteDocumentChangeBuffer);
    function documentGlobalStore(txn) {
      return getStore(txn, DbRemoteDocumentGlobal.store);
    }
    function remoteDocumentsStore(txn) {
      return getStore(txn, DbRemoteDocument.store);
    }
    function dbKey(docKey) {
      return docKey.path.toArray();
    }
    var SchemaConverter = function() {
      function SchemaConverter2(serializer) {
        this.serializer = serializer;
      }
      SchemaConverter2.prototype.createOrUpgrade = function(db2, txn, fromVersion2, toVersion2) {
        var _this = this;
        hardAssert(fromVersion2 < toVersion2 && fromVersion2 >= 0 && toVersion2 <= SCHEMA_VERSION);
        var simpleDbTransaction = new SimpleDbTransaction("createOrUpgrade", txn);
        if (fromVersion2 < 1 && toVersion2 >= 1) {
          createPrimaryClientStore(db2);
          createMutationQueue(db2);
          createQueryCache(db2);
          createRemoteDocumentCache(db2);
        }
        var p = PersistencePromise.resolve();
        if (fromVersion2 < 3 && toVersion2 >= 3) {
          if (fromVersion2 !== 0) {
            dropQueryCache(db2);
            createQueryCache(db2);
          }
          p = p.next(function() {
            return writeEmptyTargetGlobalEntry(simpleDbTransaction);
          });
        }
        if (fromVersion2 < 4 && toVersion2 >= 4) {
          if (fromVersion2 !== 0) {
            p = p.next(function() {
              return upgradeMutationBatchSchemaAndMigrateData(db2, simpleDbTransaction);
            });
          }
          p = p.next(function() {
            createClientMetadataStore(db2);
          });
        }
        if (fromVersion2 < 5 && toVersion2 >= 5) {
          p = p.next(function() {
            return _this.removeAcknowledgedMutations(simpleDbTransaction);
          });
        }
        if (fromVersion2 < 6 && toVersion2 >= 6) {
          p = p.next(function() {
            createDocumentGlobalStore(db2);
            return _this.addDocumentGlobal(simpleDbTransaction);
          });
        }
        if (fromVersion2 < 7 && toVersion2 >= 7) {
          p = p.next(function() {
            return _this.ensureSequenceNumbers(simpleDbTransaction);
          });
        }
        if (fromVersion2 < 8 && toVersion2 >= 8) {
          p = p.next(function() {
            return _this.createCollectionParentIndex(db2, simpleDbTransaction);
          });
        }
        if (fromVersion2 < 9 && toVersion2 >= 9) {
          p = p.next(function() {
            dropRemoteDocumentChangesStore(db2);
            createRemoteDocumentReadTimeIndex(txn);
          });
        }
        if (fromVersion2 < 10 && toVersion2 >= 10) {
          p = p.next(function() {
            return _this.rewriteCanonicalIds(simpleDbTransaction);
          });
        }
        if (fromVersion2 < 11 && toVersion2 >= 11) {
          p = p.next(function() {
            createBundlesStore(db2);
            createNamedQueriesStore(db2);
          });
        }
        return p;
      };
      SchemaConverter2.prototype.addDocumentGlobal = function(txn) {
        var byteCount = 0;
        return txn.store(DbRemoteDocument.store).iterate(function(_, doc2) {
          byteCount += dbDocumentSize(doc2);
        }).next(function() {
          var metadata = new DbRemoteDocumentGlobal(byteCount);
          return txn.store(DbRemoteDocumentGlobal.store).put(DbRemoteDocumentGlobal.key, metadata);
        });
      };
      SchemaConverter2.prototype.removeAcknowledgedMutations = function(txn) {
        var _this = this;
        var queuesStore = txn.store(DbMutationQueue.store);
        var mutationsStore2 = txn.store(DbMutationBatch.store);
        return queuesStore.loadAll().next(function(queues) {
          return PersistencePromise.forEach(queues, function(queue) {
            var range = IDBKeyRange.bound([queue.userId, BATCHID_UNKNOWN], [queue.userId, queue.lastAcknowledgedBatchId]);
            return mutationsStore2.loadAll(DbMutationBatch.userMutationsIndex, range).next(function(dbBatches) {
              return PersistencePromise.forEach(dbBatches, function(dbBatch) {
                hardAssert(dbBatch.userId === queue.userId);
                var batch = fromDbMutationBatch(_this.serializer, dbBatch);
                return removeMutationBatch(txn, queue.userId, batch).next(function() {
                });
              });
            });
          });
        });
      };
      SchemaConverter2.prototype.ensureSequenceNumbers = function(txn) {
        var documentTargetStore2 = txn.store(DbTargetDocument.store);
        var documentsStore = txn.store(DbRemoteDocument.store);
        var globalTargetStore2 = txn.store(DbTargetGlobal.store);
        return globalTargetStore2.get(DbTargetGlobal.key).next(function(metadata) {
          var writeSentinelKey2 = function(path2) {
            return documentTargetStore2.put(new DbTargetDocument(0, encodeResourcePath(path2), metadata.highestListenSequenceNumber));
          };
          var promises = [];
          return documentsStore.iterate(function(key, doc2) {
            var path2 = new ResourcePath(key);
            var docSentinelKey = sentinelKey(path2);
            promises.push(documentTargetStore2.get(docSentinelKey).next(function(maybeSentinel) {
              if (!maybeSentinel) {
                return writeSentinelKey2(path2);
              } else {
                return PersistencePromise.resolve();
              }
            }));
          }).next(function() {
            return PersistencePromise.waitFor(promises);
          });
        });
      };
      SchemaConverter2.prototype.createCollectionParentIndex = function(db2, txn) {
        db2.createObjectStore(DbCollectionParent.store, {
          keyPath: DbCollectionParent.keyPath
        });
        var collectionParentsStore2 = txn.store(DbCollectionParent.store);
        var cache = new MemoryCollectionParentIndex();
        var addEntry = function(collectionPath) {
          if (cache.add(collectionPath)) {
            var collectionId = collectionPath.lastSegment();
            var parentPath = collectionPath.popLast();
            return collectionParentsStore2.put({
              collectionId,
              parent: encodeResourcePath(parentPath)
            });
          }
        };
        return txn.store(DbRemoteDocument.store).iterate({ keysOnly: true }, function(pathSegments, _) {
          var path2 = new ResourcePath(pathSegments);
          return addEntry(path2.popLast());
        }).next(function() {
          return txn.store(DbDocumentMutation.store).iterate({ keysOnly: true }, function(_d, _) {
            _d[0];
            var encodedPath = _d[1];
            _d[2];
            var path2 = decodeResourcePath(encodedPath);
            return addEntry(path2.popLast());
          });
        });
      };
      SchemaConverter2.prototype.rewriteCanonicalIds = function(txn) {
        var _this = this;
        var targetStore = txn.store(DbTarget.store);
        return targetStore.iterate(function(key, originalDbTarget) {
          var originalTargetData = fromDbTarget(originalDbTarget);
          var updatedDbTarget = toDbTarget(_this.serializer, originalTargetData);
          return targetStore.put(updatedDbTarget);
        });
      };
      return SchemaConverter2;
    }();
    function sentinelKey(path2) {
      return [0, encodeResourcePath(path2)];
    }
    function createPrimaryClientStore(db2) {
      db2.createObjectStore(DbPrimaryClient.store);
    }
    function createMutationQueue(db2) {
      db2.createObjectStore(DbMutationQueue.store, {
        keyPath: DbMutationQueue.keyPath
      });
      var mutationBatchesStore = db2.createObjectStore(DbMutationBatch.store, {
        keyPath: DbMutationBatch.keyPath,
        autoIncrement: true
      });
      mutationBatchesStore.createIndex(DbMutationBatch.userMutationsIndex, DbMutationBatch.userMutationsKeyPath, { unique: true });
      db2.createObjectStore(DbDocumentMutation.store);
    }
    function upgradeMutationBatchSchemaAndMigrateData(db2, txn) {
      var v1MutationsStore = txn.store(DbMutationBatch.store);
      return v1MutationsStore.loadAll().next(function(existingMutations) {
        db2.deleteObjectStore(DbMutationBatch.store);
        var mutationsStore2 = db2.createObjectStore(DbMutationBatch.store, {
          keyPath: DbMutationBatch.keyPath,
          autoIncrement: true
        });
        mutationsStore2.createIndex(DbMutationBatch.userMutationsIndex, DbMutationBatch.userMutationsKeyPath, { unique: true });
        var v3MutationsStore = txn.store(DbMutationBatch.store);
        var writeAll = existingMutations.map(function(mutation) {
          return v3MutationsStore.put(mutation);
        });
        return PersistencePromise.waitFor(writeAll);
      });
    }
    function createRemoteDocumentCache(db2) {
      db2.createObjectStore(DbRemoteDocument.store);
    }
    function createDocumentGlobalStore(db2) {
      db2.createObjectStore(DbRemoteDocumentGlobal.store);
    }
    function createQueryCache(db2) {
      var targetDocumentsStore = db2.createObjectStore(DbTargetDocument.store, {
        keyPath: DbTargetDocument.keyPath
      });
      targetDocumentsStore.createIndex(DbTargetDocument.documentTargetsIndex, DbTargetDocument.documentTargetsKeyPath, { unique: true });
      var targetStore = db2.createObjectStore(DbTarget.store, {
        keyPath: DbTarget.keyPath
      });
      targetStore.createIndex(DbTarget.queryTargetsIndexName, DbTarget.queryTargetsKeyPath, { unique: true });
      db2.createObjectStore(DbTargetGlobal.store);
    }
    function dropQueryCache(db2) {
      db2.deleteObjectStore(DbTargetDocument.store);
      db2.deleteObjectStore(DbTarget.store);
      db2.deleteObjectStore(DbTargetGlobal.store);
    }
    function dropRemoteDocumentChangesStore(db2) {
      if (db2.objectStoreNames.contains("remoteDocumentChanges")) {
        db2.deleteObjectStore("remoteDocumentChanges");
      }
    }
    function writeEmptyTargetGlobalEntry(txn) {
      var globalStore = txn.store(DbTargetGlobal.store);
      var metadata = new DbTargetGlobal(0, 0, SnapshotVersion.min().toTimestamp(), 0);
      return globalStore.put(DbTargetGlobal.key, metadata);
    }
    function createRemoteDocumentReadTimeIndex(txn) {
      var remoteDocumentStore = txn.objectStore(DbRemoteDocument.store);
      remoteDocumentStore.createIndex(DbRemoteDocument.readTimeIndex, DbRemoteDocument.readTimeIndexPath, { unique: false });
      remoteDocumentStore.createIndex(DbRemoteDocument.collectionReadTimeIndex, DbRemoteDocument.collectionReadTimeIndexPath, { unique: false });
    }
    function createClientMetadataStore(db2) {
      db2.createObjectStore(DbClientMetadata.store, {
        keyPath: DbClientMetadata.keyPath
      });
    }
    function createBundlesStore(db2) {
      db2.createObjectStore(DbBundle.store, {
        keyPath: DbBundle.keyPath
      });
    }
    function createNamedQueriesStore(db2) {
      db2.createObjectStore(DbNamedQuery.store, {
        keyPath: DbNamedQuery.keyPath
      });
    }
    var LOG_TAG$d = "IndexedDbPersistence";
    var MAX_CLIENT_AGE_MS = 30 * 60 * 1e3;
    var MAX_PRIMARY_ELIGIBLE_AGE_MS = 5e3;
    var CLIENT_METADATA_REFRESH_INTERVAL_MS = 4e3;
    var PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG = "Failed to obtain exclusive access to the persistence layer. To allow shared access, multi-tab synchronization has to be enabled in all tabs. If you are using `experimentalForceOwningTab:true`, make sure that only one tab has persistence enabled at any given time.";
    var UNSUPPORTED_PLATFORM_ERROR_MSG = "This platform is either missing IndexedDB or is known to have an incomplete implementation. Offline persistence has been disabled.";
    var ZOMBIED_CLIENTS_KEY_PREFIX = "firestore_zombie";
    var MAIN_DATABASE = "main";
    var IndexedDbPersistence = function() {
      function IndexedDbPersistence2(allowTabSynchronization, persistenceKey, clientId, lruParams, queue, window2, document2, serializer, sequenceNumberSyncer, forceOwningTab) {
        this.allowTabSynchronization = allowTabSynchronization;
        this.persistenceKey = persistenceKey;
        this.clientId = clientId;
        this.queue = queue;
        this.window = window2;
        this.document = document2;
        this.sequenceNumberSyncer = sequenceNumberSyncer;
        this.forceOwningTab = forceOwningTab;
        this.listenSequence = null;
        this._started = false;
        this.isPrimary = false;
        this.networkEnabled = true;
        this.windowUnloadHandler = null;
        this.inForeground = false;
        this.documentVisibilityHandler = null;
        this.clientMetadataRefresher = null;
        this.lastGarbageCollectionTime = Number.NEGATIVE_INFINITY;
        this.primaryStateListener = function(_) {
          return Promise.resolve();
        };
        if (!IndexedDbPersistence2.isAvailable()) {
          throw new FirestoreError(Code.UNIMPLEMENTED, UNSUPPORTED_PLATFORM_ERROR_MSG);
        }
        this.referenceDelegate = new IndexedDbLruDelegateImpl(this, lruParams);
        this.dbName = persistenceKey + MAIN_DATABASE;
        this.serializer = new LocalSerializer(serializer);
        this.simpleDb = new SimpleDb(this.dbName, SCHEMA_VERSION, new SchemaConverter(this.serializer));
        this.targetCache = new IndexedDbTargetCache(this.referenceDelegate, this.serializer);
        this.indexManager = new IndexedDbIndexManager();
        this.remoteDocumentCache = newIndexedDbRemoteDocumentCache(this.serializer, this.indexManager);
        this.bundleCache = new IndexedDbBundleCache();
        if (this.window && this.window.localStorage) {
          this.webStorage = this.window.localStorage;
        } else {
          this.webStorage = null;
          if (forceOwningTab === false) {
            logError(LOG_TAG$d, "LocalStorage is unavailable. As a result, persistence may not work reliably. In particular enablePersistence() could fail immediately after refreshing the page.");
          }
        }
      }
      IndexedDbPersistence2.prototype.start = function() {
        var _this = this;
        return this.updateClientMetadataAndTryBecomePrimary().then(function() {
          if (!_this.isPrimary && !_this.allowTabSynchronization) {
            throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG);
          }
          _this.attachVisibilityHandler();
          _this.attachWindowUnloadHook();
          _this.scheduleClientMetadataAndPrimaryLeaseRefreshes();
          return _this.runTransaction("getHighestListenSequenceNumber", "readonly", function(txn) {
            return _this.targetCache.getHighestSequenceNumber(txn);
          });
        }).then(function(highestListenSequenceNumber) {
          _this.listenSequence = new ListenSequence(highestListenSequenceNumber, _this.sequenceNumberSyncer);
        }).then(function() {
          _this._started = true;
        }).catch(function(reason) {
          _this.simpleDb && _this.simpleDb.close();
          return Promise.reject(reason);
        });
      };
      IndexedDbPersistence2.prototype.setPrimaryStateListener = function(primaryStateListener) {
        var _this = this;
        this.primaryStateListener = function(primaryState) {
          return tslib2.__awaiter(_this, void 0, void 0, function() {
            return tslib2.__generator(this, function(_d) {
              if (this.started) {
                return [2, primaryStateListener(primaryState)];
              }
              return [2];
            });
          });
        };
        return primaryStateListener(this.isPrimary);
      };
      IndexedDbPersistence2.prototype.setDatabaseDeletedListener = function(databaseDeletedListener) {
        var _this = this;
        this.simpleDb.setVersionChangeListener(function(event) {
          return tslib2.__awaiter(_this, void 0, void 0, function() {
            return tslib2.__generator(this, function(_d) {
              switch (_d.label) {
                case 0:
                  if (!(event.newVersion === null))
                    return [3, 2];
                  return [4, databaseDeletedListener()];
                case 1:
                  _d.sent();
                  _d.label = 2;
                case 2:
                  return [2];
              }
            });
          });
        });
      };
      IndexedDbPersistence2.prototype.setNetworkEnabled = function(networkEnabled) {
        var _this = this;
        if (this.networkEnabled !== networkEnabled) {
          this.networkEnabled = networkEnabled;
          this.queue.enqueueAndForget(function() {
            return tslib2.__awaiter(_this, void 0, void 0, function() {
              return tslib2.__generator(this, function(_d) {
                switch (_d.label) {
                  case 0:
                    if (!this.started)
                      return [3, 2];
                    return [4, this.updateClientMetadataAndTryBecomePrimary()];
                  case 1:
                    _d.sent();
                    _d.label = 2;
                  case 2:
                    return [2];
                }
              });
            });
          });
        }
      };
      IndexedDbPersistence2.prototype.updateClientMetadataAndTryBecomePrimary = function() {
        var _this = this;
        return this.runTransaction("updateClientMetadataAndTryBecomePrimary", "readwrite", function(txn) {
          var metadataStore = clientMetadataStore(txn);
          return metadataStore.put(new DbClientMetadata(_this.clientId, Date.now(), _this.networkEnabled, _this.inForeground)).next(function() {
            if (_this.isPrimary) {
              return _this.verifyPrimaryLease(txn).next(function(success) {
                if (!success) {
                  _this.isPrimary = false;
                  _this.queue.enqueueRetryable(function() {
                    return _this.primaryStateListener(false);
                  });
                }
              });
            }
          }).next(function() {
            return _this.canActAsPrimary(txn);
          }).next(function(canActAsPrimary) {
            if (_this.isPrimary && !canActAsPrimary) {
              return _this.releasePrimaryLeaseIfHeld(txn).next(function() {
                return false;
              });
            } else if (canActAsPrimary) {
              return _this.acquireOrExtendPrimaryLease(txn).next(function() {
                return true;
              });
            } else {
              return false;
            }
          });
        }).catch(function(e) {
          if (isIndexedDbTransactionError(e)) {
            logDebug(LOG_TAG$d, "Failed to extend owner lease: ", e);
            return _this.isPrimary;
          }
          if (!_this.allowTabSynchronization) {
            throw e;
          }
          logDebug(LOG_TAG$d, "Releasing owner lease after error during lease refresh", e);
          return false;
        }).then(function(isPrimary) {
          if (_this.isPrimary !== isPrimary) {
            _this.queue.enqueueRetryable(function() {
              return _this.primaryStateListener(isPrimary);
            });
          }
          _this.isPrimary = isPrimary;
        });
      };
      IndexedDbPersistence2.prototype.verifyPrimaryLease = function(txn) {
        var _this = this;
        var store = primaryClientStore(txn);
        return store.get(DbPrimaryClient.key).next(function(primaryClient) {
          return PersistencePromise.resolve(_this.isLocalClient(primaryClient));
        });
      };
      IndexedDbPersistence2.prototype.removeClientMetadata = function(txn) {
        var metadataStore = clientMetadataStore(txn);
        return metadataStore.delete(this.clientId);
      };
      IndexedDbPersistence2.prototype.maybeGarbageCollectMultiClientState = function() {
        return tslib2.__awaiter(this, void 0, void 0, function() {
          var inactiveClients, _i, inactiveClients_1, inactiveClient;
          var _this = this;
          return tslib2.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                if (!(this.isPrimary && !this.isWithinAge(this.lastGarbageCollectionTime, MAX_CLIENT_AGE_MS)))
                  return [3, 2];
                this.lastGarbageCollectionTime = Date.now();
                return [4, this.runTransaction("maybeGarbageCollectMultiClientState", "readwrite-primary", function(txn) {
                  var metadataStore = getStore(txn, DbClientMetadata.store);
                  return metadataStore.loadAll().next(function(existingClients) {
                    var active = _this.filterActiveClients(existingClients, MAX_CLIENT_AGE_MS);
                    var inactive = existingClients.filter(function(client) {
                      return active.indexOf(client) === -1;
                    });
                    return PersistencePromise.forEach(inactive, function(inactiveClient2) {
                      return metadataStore.delete(inactiveClient2.clientId);
                    }).next(function() {
                      return inactive;
                    });
                  });
                }).catch(function() {
                  return [];
                })];
              case 1:
                inactiveClients = _d.sent();
                if (this.webStorage) {
                  for (_i = 0, inactiveClients_1 = inactiveClients; _i < inactiveClients_1.length; _i++) {
                    inactiveClient = inactiveClients_1[_i];
                    this.webStorage.removeItem(this.zombiedClientLocalStorageKey(inactiveClient.clientId));
                  }
                }
                _d.label = 2;
              case 2:
                return [2];
            }
          });
        });
      };
      IndexedDbPersistence2.prototype.scheduleClientMetadataAndPrimaryLeaseRefreshes = function() {
        var _this = this;
        this.clientMetadataRefresher = this.queue.enqueueAfterDelay("client_metadata_refresh", CLIENT_METADATA_REFRESH_INTERVAL_MS, function() {
          return _this.updateClientMetadataAndTryBecomePrimary().then(function() {
            return _this.maybeGarbageCollectMultiClientState();
          }).then(function() {
            return _this.scheduleClientMetadataAndPrimaryLeaseRefreshes();
          });
        });
      };
      IndexedDbPersistence2.prototype.isLocalClient = function(client) {
        return client ? client.ownerId === this.clientId : false;
      };
      IndexedDbPersistence2.prototype.canActAsPrimary = function(txn) {
        var _this = this;
        if (this.forceOwningTab) {
          return PersistencePromise.resolve(true);
        }
        var store = primaryClientStore(txn);
        return store.get(DbPrimaryClient.key).next(function(currentPrimary) {
          var currentLeaseIsValid = currentPrimary !== null && _this.isWithinAge(currentPrimary.leaseTimestampMs, MAX_PRIMARY_ELIGIBLE_AGE_MS) && !_this.isClientZombied(currentPrimary.ownerId);
          if (currentLeaseIsValid) {
            if (_this.isLocalClient(currentPrimary) && _this.networkEnabled) {
              return true;
            }
            if (!_this.isLocalClient(currentPrimary)) {
              if (!currentPrimary.allowTabSynchronization) {
                throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG);
              }
              return false;
            }
          }
          if (_this.networkEnabled && _this.inForeground) {
            return true;
          }
          return clientMetadataStore(txn).loadAll().next(function(existingClients) {
            var preferredCandidate = _this.filterActiveClients(existingClients, MAX_PRIMARY_ELIGIBLE_AGE_MS).find(function(otherClient) {
              if (_this.clientId !== otherClient.clientId) {
                var otherClientHasBetterNetworkState = !_this.networkEnabled && otherClient.networkEnabled;
                var otherClientHasBetterVisibility = !_this.inForeground && otherClient.inForeground;
                var otherClientHasSameNetworkState = _this.networkEnabled === otherClient.networkEnabled;
                if (otherClientHasBetterNetworkState || otherClientHasBetterVisibility && otherClientHasSameNetworkState) {
                  return true;
                }
              }
              return false;
            });
            return preferredCandidate === void 0;
          });
        }).next(function(canActAsPrimary) {
          if (_this.isPrimary !== canActAsPrimary) {
            logDebug(LOG_TAG$d, "Client " + (canActAsPrimary ? "is" : "is not") + " eligible for a primary lease.");
          }
          return canActAsPrimary;
        });
      };
      IndexedDbPersistence2.prototype.shutdown = function() {
        return tslib2.__awaiter(this, void 0, void 0, function() {
          var _this = this;
          return tslib2.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                this._started = false;
                this.markClientZombied();
                if (this.clientMetadataRefresher) {
                  this.clientMetadataRefresher.cancel();
                  this.clientMetadataRefresher = null;
                }
                this.detachVisibilityHandler();
                this.detachWindowUnloadHook();
                return [4, this.simpleDb.runTransaction("shutdown", "readwrite", [DbPrimaryClient.store, DbClientMetadata.store], function(simpleDbTxn) {
                  var persistenceTransaction = new IndexedDbTransaction(simpleDbTxn, ListenSequence.INVALID);
                  return _this.releasePrimaryLeaseIfHeld(persistenceTransaction).next(function() {
                    return _this.removeClientMetadata(persistenceTransaction);
                  });
                })];
              case 1:
                _d.sent();
                this.simpleDb.close();
                this.removeClientZombiedEntry();
                return [2];
            }
          });
        });
      };
      IndexedDbPersistence2.prototype.filterActiveClients = function(clients, activityThresholdMs) {
        var _this = this;
        return clients.filter(function(client) {
          return _this.isWithinAge(client.updateTimeMs, activityThresholdMs) && !_this.isClientZombied(client.clientId);
        });
      };
      IndexedDbPersistence2.prototype.getActiveClients = function() {
        var _this = this;
        return this.runTransaction("getActiveClients", "readonly", function(txn) {
          return clientMetadataStore(txn).loadAll().next(function(clients) {
            return _this.filterActiveClients(clients, MAX_CLIENT_AGE_MS).map(function(clientMetadata) {
              return clientMetadata.clientId;
            });
          });
        });
      };
      Object.defineProperty(IndexedDbPersistence2.prototype, "started", {
        get: function() {
          return this._started;
        },
        enumerable: false,
        configurable: true
      });
      IndexedDbPersistence2.prototype.getMutationQueue = function(user2) {
        return IndexedDbMutationQueue.forUser(user2, this.serializer, this.indexManager, this.referenceDelegate);
      };
      IndexedDbPersistence2.prototype.getTargetCache = function() {
        return this.targetCache;
      };
      IndexedDbPersistence2.prototype.getRemoteDocumentCache = function() {
        return this.remoteDocumentCache;
      };
      IndexedDbPersistence2.prototype.getIndexManager = function() {
        return this.indexManager;
      };
      IndexedDbPersistence2.prototype.getBundleCache = function() {
        return this.bundleCache;
      };
      IndexedDbPersistence2.prototype.runTransaction = function(action, mode, transactionOperation) {
        var _this = this;
        logDebug(LOG_TAG$d, "Starting transaction:", action);
        var simpleDbMode = mode === "readonly" ? "readonly" : "readwrite";
        var persistenceTransaction;
        return this.simpleDb.runTransaction(action, simpleDbMode, ALL_STORES, function(simpleDbTxn) {
          persistenceTransaction = new IndexedDbTransaction(simpleDbTxn, _this.listenSequence ? _this.listenSequence.next() : ListenSequence.INVALID);
          if (mode === "readwrite-primary") {
            return _this.verifyPrimaryLease(persistenceTransaction).next(function(holdsPrimaryLease) {
              if (holdsPrimaryLease) {
                return true;
              }
              return _this.canActAsPrimary(persistenceTransaction);
            }).next(function(holdsPrimaryLease) {
              if (!holdsPrimaryLease) {
                logError("Failed to obtain primary lease for action '" + action + "'.");
                _this.isPrimary = false;
                _this.queue.enqueueRetryable(function() {
                  return _this.primaryStateListener(false);
                });
                throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_LOST_ERROR_MSG);
              }
              return transactionOperation(persistenceTransaction);
            }).next(function(result) {
              return _this.acquireOrExtendPrimaryLease(persistenceTransaction).next(function() {
                return result;
              });
            });
          } else {
            return _this.verifyAllowTabSynchronization(persistenceTransaction).next(function() {
              return transactionOperation(persistenceTransaction);
            });
          }
        }).then(function(result) {
          persistenceTransaction.raiseOnCommittedEvent();
          return result;
        });
      };
      IndexedDbPersistence2.prototype.verifyAllowTabSynchronization = function(txn) {
        var _this = this;
        var store = primaryClientStore(txn);
        return store.get(DbPrimaryClient.key).next(function(currentPrimary) {
          var currentLeaseIsValid = currentPrimary !== null && _this.isWithinAge(currentPrimary.leaseTimestampMs, MAX_PRIMARY_ELIGIBLE_AGE_MS) && !_this.isClientZombied(currentPrimary.ownerId);
          if (currentLeaseIsValid && !_this.isLocalClient(currentPrimary)) {
            if (!_this.forceOwningTab && (!_this.allowTabSynchronization || !currentPrimary.allowTabSynchronization)) {
              throw new FirestoreError(Code.FAILED_PRECONDITION, PRIMARY_LEASE_EXCLUSIVE_ERROR_MSG);
            }
          }
        });
      };
      IndexedDbPersistence2.prototype.acquireOrExtendPrimaryLease = function(txn) {
        var newPrimary = new DbPrimaryClient(this.clientId, this.allowTabSynchronization, Date.now());
        return primaryClientStore(txn).put(DbPrimaryClient.key, newPrimary);
      };
      IndexedDbPersistence2.isAvailable = function() {
        return SimpleDb.isAvailable();
      };
      IndexedDbPersistence2.prototype.releasePrimaryLeaseIfHeld = function(txn) {
        var _this = this;
        var store = primaryClientStore(txn);
        return store.get(DbPrimaryClient.key).next(function(primaryClient) {
          if (_this.isLocalClient(primaryClient)) {
            logDebug(LOG_TAG$d, "Releasing primary lease.");
            return store.delete(DbPrimaryClient.key);
          } else {
            return PersistencePromise.resolve();
          }
        });
      };
      IndexedDbPersistence2.prototype.isWithinAge = function(updateTimeMs, maxAgeMs) {
        var now = Date.now();
        var minAcceptable = now - maxAgeMs;
        var maxAcceptable = now;
        if (updateTimeMs < minAcceptable) {
          return false;
        } else if (updateTimeMs > maxAcceptable) {
          logError("Detected an update time that is in the future: " + updateTimeMs + " > " + maxAcceptable);
          return false;
        }
        return true;
      };
      IndexedDbPersistence2.prototype.attachVisibilityHandler = function() {
        var _this = this;
        if (this.document !== null && typeof this.document.addEventListener === "function") {
          this.documentVisibilityHandler = function() {
            _this.queue.enqueueAndForget(function() {
              _this.inForeground = _this.document.visibilityState === "visible";
              return _this.updateClientMetadataAndTryBecomePrimary();
            });
          };
          this.document.addEventListener("visibilitychange", this.documentVisibilityHandler);
          this.inForeground = this.document.visibilityState === "visible";
        }
      };
      IndexedDbPersistence2.prototype.detachVisibilityHandler = function() {
        if (this.documentVisibilityHandler) {
          this.document.removeEventListener("visibilitychange", this.documentVisibilityHandler);
          this.documentVisibilityHandler = null;
        }
      };
      IndexedDbPersistence2.prototype.attachWindowUnloadHook = function() {
        var _this = this;
        var _a;
        if (typeof ((_a = this.window) === null || _a === void 0 ? void 0 : _a.addEventListener) === "function") {
          this.windowUnloadHandler = function() {
            _this.markClientZombied();
            if (util.isSafari() && navigator.appVersion.match("Version/14")) {
              _this.queue.enterRestrictedMode(true);
            }
            _this.queue.enqueueAndForget(function() {
              return _this.shutdown();
            });
          };
          this.window.addEventListener("pagehide", this.windowUnloadHandler);
        }
      };
      IndexedDbPersistence2.prototype.detachWindowUnloadHook = function() {
        if (this.windowUnloadHandler) {
          this.window.removeEventListener("pagehide", this.windowUnloadHandler);
          this.windowUnloadHandler = null;
        }
      };
      IndexedDbPersistence2.prototype.isClientZombied = function(clientId) {
        var _a;
        try {
          var isZombied = ((_a = this.webStorage) === null || _a === void 0 ? void 0 : _a.getItem(this.zombiedClientLocalStorageKey(clientId))) !== null;
          logDebug(LOG_TAG$d, "Client '" + clientId + "' " + (isZombied ? "is" : "is not") + " zombied in LocalStorage");
          return isZombied;
        } catch (e) {
          logError(LOG_TAG$d, "Failed to get zombied client id.", e);
          return false;
        }
      };
      IndexedDbPersistence2.prototype.markClientZombied = function() {
        if (!this.webStorage) {
          return;
        }
        try {
          this.webStorage.setItem(this.zombiedClientLocalStorageKey(this.clientId), String(Date.now()));
        } catch (e) {
          logError("Failed to set zombie client id.", e);
        }
      };
      IndexedDbPersistence2.prototype.removeClientZombiedEntry = function() {
        if (!this.webStorage) {
          return;
        }
        try {
          this.webStorage.removeItem(this.zombiedClientLocalStorageKey(this.clientId));
        } catch (e) {
        }
      };
      IndexedDbPersistence2.prototype.zombiedClientLocalStorageKey = function(clientId) {
        return ZOMBIED_CLIENTS_KEY_PREFIX + "_" + this.persistenceKey + "_" + clientId;
      };
      return IndexedDbPersistence2;
    }();
    function primaryClientStore(txn) {
      return getStore(txn, DbPrimaryClient.store);
    }
    function clientMetadataStore(txn) {
      return getStore(txn, DbClientMetadata.store);
    }
    function indexedDbStoragePrefix(databaseId, persistenceKey) {
      var database = databaseId.projectId;
      if (!databaseId.isDefaultDatabase) {
        database += "." + databaseId.database;
      }
      return "firestore/" + persistenceKey + "/" + database + "/";
    }
    function indexedDbClearPersistence(persistenceKey) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var dbName;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              if (!SimpleDb.isAvailable()) {
                return [2, Promise.resolve()];
              }
              dbName = persistenceKey + MAIN_DATABASE;
              return [4, SimpleDb.delete(dbName)];
            case 1:
              _d.sent();
              return [2];
          }
        });
      });
    }
    var LocalDocumentsView = function() {
      function LocalDocumentsView2(remoteDocumentCache, mutationQueue, indexManager) {
        this.remoteDocumentCache = remoteDocumentCache;
        this.mutationQueue = mutationQueue;
        this.indexManager = indexManager;
      }
      LocalDocumentsView2.prototype.getDocument = function(transaction, key) {
        var _this = this;
        return this.mutationQueue.getAllMutationBatchesAffectingDocumentKey(transaction, key).next(function(batches) {
          return _this.getDocumentInternal(transaction, key, batches);
        });
      };
      LocalDocumentsView2.prototype.getDocumentInternal = function(transaction, key, inBatches) {
        return this.remoteDocumentCache.getEntry(transaction, key).next(function(doc2) {
          for (var _i = 0, inBatches_1 = inBatches; _i < inBatches_1.length; _i++) {
            var batch = inBatches_1[_i];
            batch.applyToLocalView(doc2);
          }
          return doc2;
        });
      };
      LocalDocumentsView2.prototype.applyLocalMutationsToDocuments = function(docs, batches) {
        docs.forEach(function(key, localView) {
          for (var _i = 0, batches_1 = batches; _i < batches_1.length; _i++) {
            var batch = batches_1[_i];
            batch.applyToLocalView(localView);
          }
        });
      };
      LocalDocumentsView2.prototype.getDocuments = function(transaction, keys) {
        var _this = this;
        return this.remoteDocumentCache.getEntries(transaction, keys).next(function(docs) {
          return _this.applyLocalViewToDocuments(transaction, docs).next(function() {
            return docs;
          });
        });
      };
      LocalDocumentsView2.prototype.applyLocalViewToDocuments = function(transaction, baseDocs) {
        var _this = this;
        return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(transaction, baseDocs).next(function(batches) {
          return _this.applyLocalMutationsToDocuments(baseDocs, batches);
        });
      };
      LocalDocumentsView2.prototype.getDocumentsMatchingQuery = function(transaction, query2, sinceReadTime) {
        if (isDocumentQuery$1(query2)) {
          return this.getDocumentsMatchingDocumentQuery(transaction, query2.path);
        } else if (isCollectionGroupQuery(query2)) {
          return this.getDocumentsMatchingCollectionGroupQuery(transaction, query2, sinceReadTime);
        } else {
          return this.getDocumentsMatchingCollectionQuery(transaction, query2, sinceReadTime);
        }
      };
      LocalDocumentsView2.prototype.getDocumentsMatchingDocumentQuery = function(transaction, docPath) {
        return this.getDocument(transaction, new DocumentKey(docPath)).next(function(document2) {
          var result = documentMap();
          if (document2.isFoundDocument()) {
            result = result.insert(document2.key, document2);
          }
          return result;
        });
      };
      LocalDocumentsView2.prototype.getDocumentsMatchingCollectionGroupQuery = function(transaction, query2, sinceReadTime) {
        var _this = this;
        var collectionId = query2.collectionGroup;
        var results = documentMap();
        return this.indexManager.getCollectionParents(transaction, collectionId).next(function(parents) {
          return PersistencePromise.forEach(parents, function(parent2) {
            var collectionQuery = asCollectionQueryAtPath(query2, parent2.child(collectionId));
            return _this.getDocumentsMatchingCollectionQuery(transaction, collectionQuery, sinceReadTime).next(function(r) {
              r.forEach(function(key, doc2) {
                results = results.insert(key, doc2);
              });
            });
          }).next(function() {
            return results;
          });
        });
      };
      LocalDocumentsView2.prototype.getDocumentsMatchingCollectionQuery = function(transaction, query2, sinceReadTime) {
        var _this = this;
        var results;
        var mutationBatches;
        return this.remoteDocumentCache.getDocumentsMatchingQuery(transaction, query2, sinceReadTime).next(function(queryResults) {
          results = queryResults;
          return _this.mutationQueue.getAllMutationBatchesAffectingQuery(transaction, query2);
        }).next(function(matchingMutationBatches) {
          mutationBatches = matchingMutationBatches;
          return _this.addMissingBaseDocuments(transaction, mutationBatches, results).next(function(mergedDocuments) {
            results = mergedDocuments;
            for (var _i = 0, mutationBatches_1 = mutationBatches; _i < mutationBatches_1.length; _i++) {
              var batch = mutationBatches_1[_i];
              for (var _d = 0, _e = batch.mutations; _d < _e.length; _d++) {
                var mutation = _e[_d];
                var key = mutation.key;
                var document_2 = results.get(key);
                if (document_2 == null) {
                  document_2 = MutableDocument.newInvalidDocument(key);
                  results = results.insert(key, document_2);
                }
                mutationApplyToLocalView(mutation, document_2, batch.localWriteTime);
                if (!document_2.isFoundDocument()) {
                  results = results.remove(key);
                }
              }
            }
          });
        }).next(function() {
          results.forEach(function(key, doc2) {
            if (!queryMatches(query2, doc2)) {
              results = results.remove(key);
            }
          });
          return results;
        });
      };
      LocalDocumentsView2.prototype.addMissingBaseDocuments = function(transaction, matchingMutationBatches, existingDocuments) {
        var missingBaseDocEntriesForPatching = documentKeySet();
        for (var _i = 0, matchingMutationBatches_1 = matchingMutationBatches; _i < matchingMutationBatches_1.length; _i++) {
          var batch = matchingMutationBatches_1[_i];
          for (var _d = 0, _e = batch.mutations; _d < _e.length; _d++) {
            var mutation = _e[_d];
            if (mutation instanceof PatchMutation && existingDocuments.get(mutation.key) === null) {
              missingBaseDocEntriesForPatching = missingBaseDocEntriesForPatching.add(mutation.key);
            }
          }
        }
        var mergedDocuments = existingDocuments;
        return this.remoteDocumentCache.getEntries(transaction, missingBaseDocEntriesForPatching).next(function(missingBaseDocs) {
          missingBaseDocs.forEach(function(key, doc2) {
            if (doc2.isFoundDocument()) {
              mergedDocuments = mergedDocuments.insert(key, doc2);
            }
          });
          return mergedDocuments;
        });
      };
      return LocalDocumentsView2;
    }();
    var LOG_TAG$c = "LocalStore";
    var RESUME_TOKEN_MAX_AGE_MICROS = 5 * 60 * 1e6;
    var LocalStoreImpl = function() {
      function LocalStoreImpl2(persistence, queryEngine, initialUser, serializer) {
        this.persistence = persistence;
        this.queryEngine = queryEngine;
        this.serializer = serializer;
        this.targetDataByTarget = new SortedMap(primitiveComparator);
        this.targetIdByTarget = new ObjectMap(function(t) {
          return canonifyTarget(t);
        }, targetEquals);
        this.lastDocumentChangeReadTime = SnapshotVersion.min();
        this.mutationQueue = persistence.getMutationQueue(initialUser);
        this.remoteDocuments = persistence.getRemoteDocumentCache();
        this.targetCache = persistence.getTargetCache();
        this.localDocuments = new LocalDocumentsView(this.remoteDocuments, this.mutationQueue, this.persistence.getIndexManager());
        this.bundleCache = persistence.getBundleCache();
        this.queryEngine.setLocalDocumentsView(this.localDocuments);
      }
      LocalStoreImpl2.prototype.collectGarbage = function(garbageCollector) {
        var _this = this;
        return this.persistence.runTransaction("Collect garbage", "readwrite-primary", function(txn) {
          return garbageCollector.collect(txn, _this.targetDataByTarget);
        });
      };
      return LocalStoreImpl2;
    }();
    function newLocalStore(persistence, queryEngine, initialUser, serializer) {
      return new LocalStoreImpl(persistence, queryEngine, initialUser, serializer);
    }
    function localStoreHandleUserChange(localStore2, user2) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var localStoreImpl, newMutationQueue, newLocalDocuments, result;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              localStoreImpl = debugCast(localStore2);
              newMutationQueue = localStoreImpl.mutationQueue;
              newLocalDocuments = localStoreImpl.localDocuments;
              return [4, localStoreImpl.persistence.runTransaction("Handle user change", "readonly", function(txn) {
                var oldBatches;
                return localStoreImpl.mutationQueue.getAllMutationBatches(txn).next(function(promisedOldBatches) {
                  oldBatches = promisedOldBatches;
                  newMutationQueue = localStoreImpl.persistence.getMutationQueue(user2);
                  newLocalDocuments = new LocalDocumentsView(localStoreImpl.remoteDocuments, newMutationQueue, localStoreImpl.persistence.getIndexManager());
                  return newMutationQueue.getAllMutationBatches(txn);
                }).next(function(newBatches) {
                  var removedBatchIds = [];
                  var addedBatchIds = [];
                  var changedKeys = documentKeySet();
                  for (var _i = 0, oldBatches_1 = oldBatches; _i < oldBatches_1.length; _i++) {
                    var batch = oldBatches_1[_i];
                    removedBatchIds.push(batch.batchId);
                    for (var _d2 = 0, _e = batch.mutations; _d2 < _e.length; _d2++) {
                      var mutation = _e[_d2];
                      changedKeys = changedKeys.add(mutation.key);
                    }
                  }
                  for (var _f = 0, newBatches_1 = newBatches; _f < newBatches_1.length; _f++) {
                    var batch = newBatches_1[_f];
                    addedBatchIds.push(batch.batchId);
                    for (var _g = 0, _h = batch.mutations; _g < _h.length; _g++) {
                      var mutation = _h[_g];
                      changedKeys = changedKeys.add(mutation.key);
                    }
                  }
                  return newLocalDocuments.getDocuments(txn, changedKeys).next(function(affectedDocuments) {
                    return {
                      affectedDocuments,
                      removedBatchIds,
                      addedBatchIds
                    };
                  });
                });
              })];
            case 1:
              result = _d.sent();
              localStoreImpl.mutationQueue = newMutationQueue;
              localStoreImpl.localDocuments = newLocalDocuments;
              localStoreImpl.queryEngine.setLocalDocumentsView(localStoreImpl.localDocuments);
              return [2, result];
          }
        });
      });
    }
    function localStoreWriteLocally(localStore2, mutations) {
      var localStoreImpl = debugCast(localStore2);
      var localWriteTime = Timestamp.now();
      var keys = mutations.reduce(function(keys2, m) {
        return keys2.add(m.key);
      }, documentKeySet());
      var existingDocs;
      return localStoreImpl.persistence.runTransaction("Locally write mutations", "readwrite", function(txn) {
        return localStoreImpl.localDocuments.getDocuments(txn, keys).next(function(docs) {
          existingDocs = docs;
          var baseMutations = [];
          for (var _i = 0, mutations_2 = mutations; _i < mutations_2.length; _i++) {
            var mutation = mutations_2[_i];
            var baseValue = mutationExtractBaseValue(mutation, existingDocs.get(mutation.key));
            if (baseValue != null) {
              baseMutations.push(new PatchMutation(mutation.key, baseValue, extractFieldMask(baseValue.value.mapValue), Precondition.exists(true)));
            }
          }
          return localStoreImpl.mutationQueue.addMutationBatch(txn, localWriteTime, baseMutations, mutations);
        });
      }).then(function(batch) {
        batch.applyToLocalDocumentSet(existingDocs);
        return { batchId: batch.batchId, changes: existingDocs };
      });
    }
    function localStoreAcknowledgeBatch(localStore2, batchResult) {
      var localStoreImpl = debugCast(localStore2);
      return localStoreImpl.persistence.runTransaction("Acknowledge batch", "readwrite-primary", function(txn) {
        var affected = batchResult.batch.keys();
        var documentBuffer = localStoreImpl.remoteDocuments.newChangeBuffer({
          trackRemovals: true
        });
        return applyWriteToRemoteDocuments(localStoreImpl, txn, batchResult, documentBuffer).next(function() {
          return documentBuffer.apply(txn);
        }).next(function() {
          return localStoreImpl.mutationQueue.performConsistencyCheck(txn);
        }).next(function() {
          return localStoreImpl.localDocuments.getDocuments(txn, affected);
        });
      });
    }
    function localStoreRejectBatch(localStore2, batchId) {
      var localStoreImpl = debugCast(localStore2);
      return localStoreImpl.persistence.runTransaction("Reject batch", "readwrite-primary", function(txn) {
        var affectedKeys;
        return localStoreImpl.mutationQueue.lookupMutationBatch(txn, batchId).next(function(batch) {
          hardAssert(batch !== null);
          affectedKeys = batch.keys();
          return localStoreImpl.mutationQueue.removeMutationBatch(txn, batch);
        }).next(function() {
          return localStoreImpl.mutationQueue.performConsistencyCheck(txn);
        }).next(function() {
          return localStoreImpl.localDocuments.getDocuments(txn, affectedKeys);
        });
      });
    }
    function localStoreGetHighestUnacknowledgedBatchId(localStore2) {
      var localStoreImpl = debugCast(localStore2);
      return localStoreImpl.persistence.runTransaction("Get highest unacknowledged batch id", "readonly", function(txn) {
        return localStoreImpl.mutationQueue.getHighestUnacknowledgedBatchId(txn);
      });
    }
    function localStoreGetLastRemoteSnapshotVersion(localStore2) {
      var localStoreImpl = debugCast(localStore2);
      return localStoreImpl.persistence.runTransaction("Get last remote snapshot version", "readonly", function(txn) {
        return localStoreImpl.targetCache.getLastRemoteSnapshotVersion(txn);
      });
    }
    function localStoreApplyRemoteEventToLocalCache(localStore2, remoteEvent) {
      var localStoreImpl = debugCast(localStore2);
      var remoteVersion = remoteEvent.snapshotVersion;
      var newTargetDataByTargetMap = localStoreImpl.targetDataByTarget;
      return localStoreImpl.persistence.runTransaction("Apply remote event", "readwrite-primary", function(txn) {
        var documentBuffer = localStoreImpl.remoteDocuments.newChangeBuffer({
          trackRemovals: true
        });
        newTargetDataByTargetMap = localStoreImpl.targetDataByTarget;
        var promises = [];
        remoteEvent.targetChanges.forEach(function(change, targetId) {
          var oldTargetData = newTargetDataByTargetMap.get(targetId);
          if (!oldTargetData) {
            return;
          }
          promises.push(localStoreImpl.targetCache.removeMatchingKeys(txn, change.removedDocuments, targetId).next(function() {
            return localStoreImpl.targetCache.addMatchingKeys(txn, change.addedDocuments, targetId);
          }));
          var resumeToken = change.resumeToken;
          if (resumeToken.approximateByteSize() > 0) {
            var newTargetData = oldTargetData.withResumeToken(resumeToken, remoteVersion).withSequenceNumber(txn.currentSequenceNumber);
            newTargetDataByTargetMap = newTargetDataByTargetMap.insert(targetId, newTargetData);
            if (shouldPersistTargetData(oldTargetData, newTargetData, change)) {
              promises.push(localStoreImpl.targetCache.updateTargetData(txn, newTargetData));
            }
          }
        });
        var changedDocs = mutableDocumentMap();
        remoteEvent.documentUpdates.forEach(function(key, doc2) {
          if (remoteEvent.resolvedLimboDocuments.has(key)) {
            promises.push(localStoreImpl.persistence.referenceDelegate.updateLimboDocument(txn, key));
          }
        });
        promises.push(populateDocumentChangeBuffer(txn, documentBuffer, remoteEvent.documentUpdates, remoteVersion, void 0).next(function(result) {
          changedDocs = result;
        }));
        if (!remoteVersion.isEqual(SnapshotVersion.min())) {
          var updateRemoteVersion = localStoreImpl.targetCache.getLastRemoteSnapshotVersion(txn).next(function(lastRemoteSnapshotVersion) {
            return localStoreImpl.targetCache.setTargetsMetadata(txn, txn.currentSequenceNumber, remoteVersion);
          });
          promises.push(updateRemoteVersion);
        }
        return PersistencePromise.waitFor(promises).next(function() {
          return documentBuffer.apply(txn);
        }).next(function() {
          return localStoreImpl.localDocuments.applyLocalViewToDocuments(txn, changedDocs);
        }).next(function() {
          return changedDocs;
        });
      }).then(function(changedDocs) {
        localStoreImpl.targetDataByTarget = newTargetDataByTargetMap;
        return changedDocs;
      });
    }
    function populateDocumentChangeBuffer(txn, documentBuffer, documents, globalVersion, documentVersions) {
      var updatedKeys = documentKeySet();
      documents.forEach(function(k) {
        return updatedKeys = updatedKeys.add(k);
      });
      return documentBuffer.getEntries(txn, updatedKeys).next(function(existingDocs) {
        var changedDocs = mutableDocumentMap();
        documents.forEach(function(key, doc2) {
          var existingDoc = existingDocs.get(key);
          var docReadTime = (documentVersions === null || documentVersions === void 0 ? void 0 : documentVersions.get(key)) || globalVersion;
          if (doc2.isNoDocument() && doc2.version.isEqual(SnapshotVersion.min())) {
            documentBuffer.removeEntry(key, docReadTime);
            changedDocs = changedDocs.insert(key, doc2);
          } else if (!existingDoc.isValidDocument() || doc2.version.compareTo(existingDoc.version) > 0 || doc2.version.compareTo(existingDoc.version) === 0 && existingDoc.hasPendingWrites) {
            documentBuffer.addEntry(doc2, docReadTime);
            changedDocs = changedDocs.insert(key, doc2);
          } else {
            logDebug(LOG_TAG$c, "Ignoring outdated watch update for ", key, ". Current version:", existingDoc.version, " Watch version:", doc2.version);
          }
        });
        return changedDocs;
      });
    }
    function shouldPersistTargetData(oldTargetData, newTargetData, change) {
      hardAssert(newTargetData.resumeToken.approximateByteSize() > 0);
      if (oldTargetData.resumeToken.approximateByteSize() === 0) {
        return true;
      }
      var timeDelta = newTargetData.snapshotVersion.toMicroseconds() - oldTargetData.snapshotVersion.toMicroseconds();
      if (timeDelta >= RESUME_TOKEN_MAX_AGE_MICROS) {
        return true;
      }
      var changes = change.addedDocuments.size + change.modifiedDocuments.size + change.removedDocuments.size;
      return changes > 0;
    }
    function localStoreNotifyLocalViewChanges(localStore2, viewChanges) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var localStoreImpl, e_2, _i, viewChanges_1, viewChange, targetId, targetData, lastLimboFreeSnapshotVersion, updatedTargetData;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              localStoreImpl = debugCast(localStore2);
              _d.label = 1;
            case 1:
              _d.trys.push([1, 3, , 4]);
              return [4, localStoreImpl.persistence.runTransaction("notifyLocalViewChanges", "readwrite", function(txn) {
                return PersistencePromise.forEach(viewChanges, function(viewChange2) {
                  return PersistencePromise.forEach(viewChange2.addedKeys, function(key) {
                    return localStoreImpl.persistence.referenceDelegate.addReference(txn, viewChange2.targetId, key);
                  }).next(function() {
                    return PersistencePromise.forEach(viewChange2.removedKeys, function(key) {
                      return localStoreImpl.persistence.referenceDelegate.removeReference(txn, viewChange2.targetId, key);
                    });
                  });
                });
              })];
            case 2:
              _d.sent();
              return [3, 4];
            case 3:
              e_2 = _d.sent();
              if (isIndexedDbTransactionError(e_2)) {
                logDebug(LOG_TAG$c, "Failed to update sequence numbers: " + e_2);
              } else {
                throw e_2;
              }
              return [3, 4];
            case 4:
              for (_i = 0, viewChanges_1 = viewChanges; _i < viewChanges_1.length; _i++) {
                viewChange = viewChanges_1[_i];
                targetId = viewChange.targetId;
                if (!viewChange.fromCache) {
                  targetData = localStoreImpl.targetDataByTarget.get(targetId);
                  lastLimboFreeSnapshotVersion = targetData.snapshotVersion;
                  updatedTargetData = targetData.withLastLimboFreeSnapshotVersion(lastLimboFreeSnapshotVersion);
                  localStoreImpl.targetDataByTarget = localStoreImpl.targetDataByTarget.insert(targetId, updatedTargetData);
                }
              }
              return [2];
          }
        });
      });
    }
    function localStoreGetNextMutationBatch(localStore2, afterBatchId) {
      var localStoreImpl = debugCast(localStore2);
      return localStoreImpl.persistence.runTransaction("Get next mutation batch", "readonly", function(txn) {
        if (afterBatchId === void 0) {
          afterBatchId = BATCHID_UNKNOWN;
        }
        return localStoreImpl.mutationQueue.getNextMutationBatchAfterBatchId(txn, afterBatchId);
      });
    }
    function localStoreReadDocument(localStore2, key) {
      var localStoreImpl = debugCast(localStore2);
      return localStoreImpl.persistence.runTransaction("read document", "readonly", function(txn) {
        return localStoreImpl.localDocuments.getDocument(txn, key);
      });
    }
    function localStoreAllocateTarget(localStore2, target) {
      var localStoreImpl = debugCast(localStore2);
      return localStoreImpl.persistence.runTransaction("Allocate target", "readwrite", function(txn) {
        var targetData;
        return localStoreImpl.targetCache.getTargetData(txn, target).next(function(cached) {
          if (cached) {
            targetData = cached;
            return PersistencePromise.resolve(targetData);
          } else {
            return localStoreImpl.targetCache.allocateTargetId(txn).next(function(targetId) {
              targetData = new TargetData(target, targetId, 0, txn.currentSequenceNumber);
              return localStoreImpl.targetCache.addTargetData(txn, targetData).next(function() {
                return targetData;
              });
            });
          }
        });
      }).then(function(targetData) {
        var cachedTargetData = localStoreImpl.targetDataByTarget.get(targetData.targetId);
        if (cachedTargetData === null || targetData.snapshotVersion.compareTo(cachedTargetData.snapshotVersion) > 0) {
          localStoreImpl.targetDataByTarget = localStoreImpl.targetDataByTarget.insert(targetData.targetId, targetData);
          localStoreImpl.targetIdByTarget.set(target, targetData.targetId);
        }
        return targetData;
      });
    }
    function localStoreGetTargetData(localStore2, transaction, target) {
      var localStoreImpl = debugCast(localStore2);
      var targetId = localStoreImpl.targetIdByTarget.get(target);
      if (targetId !== void 0) {
        return PersistencePromise.resolve(localStoreImpl.targetDataByTarget.get(targetId));
      } else {
        return localStoreImpl.targetCache.getTargetData(transaction, target);
      }
    }
    function localStoreReleaseTarget(localStore2, targetId, keepPersistedTargetData) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var localStoreImpl, targetData, mode, e_3;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              localStoreImpl = debugCast(localStore2);
              targetData = localStoreImpl.targetDataByTarget.get(targetId);
              mode = keepPersistedTargetData ? "readwrite" : "readwrite-primary";
              _d.label = 1;
            case 1:
              _d.trys.push([1, 4, , 5]);
              if (!!keepPersistedTargetData)
                return [3, 3];
              return [4, localStoreImpl.persistence.runTransaction("Release target", mode, function(txn) {
                return localStoreImpl.persistence.referenceDelegate.removeTarget(txn, targetData);
              })];
            case 2:
              _d.sent();
              _d.label = 3;
            case 3:
              return [3, 5];
            case 4:
              e_3 = _d.sent();
              if (isIndexedDbTransactionError(e_3)) {
                logDebug(LOG_TAG$c, "Failed to update sequence numbers for target " + targetId + ": " + e_3);
              } else {
                throw e_3;
              }
              return [3, 5];
            case 5:
              localStoreImpl.targetDataByTarget = localStoreImpl.targetDataByTarget.remove(targetId);
              localStoreImpl.targetIdByTarget.delete(targetData.target);
              return [2];
          }
        });
      });
    }
    function localStoreExecuteQuery(localStore2, query2, usePreviousResults) {
      var localStoreImpl = debugCast(localStore2);
      var lastLimboFreeSnapshotVersion = SnapshotVersion.min();
      var remoteKeys = documentKeySet();
      return localStoreImpl.persistence.runTransaction("Execute query", "readonly", function(txn) {
        return localStoreGetTargetData(localStoreImpl, txn, queryToTarget(query2)).next(function(targetData) {
          if (targetData) {
            lastLimboFreeSnapshotVersion = targetData.lastLimboFreeSnapshotVersion;
            return localStoreImpl.targetCache.getMatchingKeysForTargetId(txn, targetData.targetId).next(function(result) {
              remoteKeys = result;
            });
          }
        }).next(function() {
          return localStoreImpl.queryEngine.getDocumentsMatchingQuery(txn, query2, usePreviousResults ? lastLimboFreeSnapshotVersion : SnapshotVersion.min(), usePreviousResults ? remoteKeys : documentKeySet());
        }).next(function(documents) {
          return { documents, remoteKeys };
        });
      });
    }
    function applyWriteToRemoteDocuments(localStoreImpl, txn, batchResult, documentBuffer) {
      var batch = batchResult.batch;
      var docKeys = batch.keys();
      var promiseChain = PersistencePromise.resolve();
      docKeys.forEach(function(docKey) {
        promiseChain = promiseChain.next(function() {
          return documentBuffer.getEntry(txn, docKey);
        }).next(function(doc2) {
          var ackVersion = batchResult.docVersions.get(docKey);
          hardAssert(ackVersion !== null);
          if (doc2.version.compareTo(ackVersion) < 0) {
            batch.applyToRemoteDocument(doc2, batchResult);
            if (doc2.isValidDocument()) {
              documentBuffer.addEntry(doc2, batchResult.commitVersion);
            }
          }
        });
      });
      return promiseChain.next(function() {
        return localStoreImpl.mutationQueue.removeMutationBatch(txn, batch);
      });
    }
    function localStoreLookupMutationDocuments(localStore2, batchId) {
      var localStoreImpl = debugCast(localStore2);
      var mutationQueueImpl = debugCast(localStoreImpl.mutationQueue);
      return localStoreImpl.persistence.runTransaction("Lookup mutation documents", "readonly", function(txn) {
        return mutationQueueImpl.lookupMutationKeys(txn, batchId).next(function(keys) {
          if (keys) {
            return localStoreImpl.localDocuments.getDocuments(txn, keys);
          } else {
            return PersistencePromise.resolve(null);
          }
        });
      });
    }
    function localStoreRemoveCachedMutationBatchMetadata(localStore2, batchId) {
      var mutationQueueImpl = debugCast(debugCast(localStore2, LocalStoreImpl).mutationQueue);
      mutationQueueImpl.removeCachedMutationKeys(batchId);
    }
    function localStoreGetActiveClients(localStore2) {
      var persistenceImpl = debugCast(debugCast(localStore2, LocalStoreImpl).persistence);
      return persistenceImpl.getActiveClients();
    }
    function localStoreGetCachedTarget(localStore2, targetId) {
      var localStoreImpl = debugCast(localStore2);
      var targetCacheImpl = debugCast(localStoreImpl.targetCache);
      var cachedTargetData = localStoreImpl.targetDataByTarget.get(targetId);
      if (cachedTargetData) {
        return Promise.resolve(cachedTargetData.target);
      } else {
        return localStoreImpl.persistence.runTransaction("Get target data", "readonly", function(txn) {
          return targetCacheImpl.getTargetDataForTarget(txn, targetId).next(function(targetData) {
            return targetData ? targetData.target : null;
          });
        });
      }
    }
    function localStoreGetNewDocumentChanges(localStore2) {
      var localStoreImpl = debugCast(localStore2);
      return localStoreImpl.persistence.runTransaction("Get new document changes", "readonly", function(txn) {
        return remoteDocumentCacheGetNewDocumentChanges(localStoreImpl.remoteDocuments, txn, localStoreImpl.lastDocumentChangeReadTime);
      }).then(function(_d) {
        var changedDocs = _d.changedDocs, readTime = _d.readTime;
        localStoreImpl.lastDocumentChangeReadTime = readTime;
        return changedDocs;
      });
    }
    function localStoreSynchronizeLastDocumentChangeReadTime(localStore2) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var localStoreImpl;
        return tslib2.__generator(this, function(_d) {
          localStoreImpl = debugCast(localStore2);
          return [2, localStoreImpl.persistence.runTransaction("Synchronize last document change read time", "readonly", function(txn) {
            return remoteDocumentCacheGetLastReadTime(txn);
          }).then(function(readTime) {
            localStoreImpl.lastDocumentChangeReadTime = readTime;
          })];
        });
      });
    }
    function umbrellaTarget(bundleName) {
      return queryToTarget(newQueryForPath(ResourcePath.fromString("__bundle__/docs/" + bundleName)));
    }
    function localStoreApplyBundledDocuments(localStore2, bundleConverter, documents, bundleName) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var localStoreImpl, documentKeys, documentMap2, versionMap, _i, documents_1, bundleDoc, documentKey, documentBuffer, umbrellaTargetData;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              localStoreImpl = debugCast(localStore2);
              documentKeys = documentKeySet();
              documentMap2 = mutableDocumentMap();
              versionMap = documentVersionMap();
              for (_i = 0, documents_1 = documents; _i < documents_1.length; _i++) {
                bundleDoc = documents_1[_i];
                documentKey = bundleConverter.toDocumentKey(bundleDoc.metadata.name);
                if (bundleDoc.document) {
                  documentKeys = documentKeys.add(documentKey);
                }
                documentMap2 = documentMap2.insert(documentKey, bundleConverter.toMutableDocument(bundleDoc));
                versionMap = versionMap.insert(documentKey, bundleConverter.toSnapshotVersion(bundleDoc.metadata.readTime));
              }
              documentBuffer = localStoreImpl.remoteDocuments.newChangeBuffer({
                trackRemovals: true
              });
              return [4, localStoreAllocateTarget(localStoreImpl, umbrellaTarget(bundleName))];
            case 1:
              umbrellaTargetData = _d.sent();
              return [2, localStoreImpl.persistence.runTransaction("Apply bundle documents", "readwrite", function(txn) {
                return populateDocumentChangeBuffer(txn, documentBuffer, documentMap2, SnapshotVersion.min(), versionMap).next(function(changedDocs) {
                  documentBuffer.apply(txn);
                  return changedDocs;
                }).next(function(changedDocs) {
                  return localStoreImpl.targetCache.removeMatchingKeysForTargetId(txn, umbrellaTargetData.targetId).next(function() {
                    return localStoreImpl.targetCache.addMatchingKeys(txn, documentKeys, umbrellaTargetData.targetId);
                  }).next(function() {
                    return localStoreImpl.localDocuments.applyLocalViewToDocuments(txn, changedDocs);
                  }).next(function() {
                    return changedDocs;
                  });
                });
              })];
          }
        });
      });
    }
    function localStoreHasNewerBundle(localStore2, bundleMetadata) {
      var localStoreImpl = debugCast(localStore2);
      var currentReadTime = fromVersion(bundleMetadata.createTime);
      return localStoreImpl.persistence.runTransaction("hasNewerBundle", "readonly", function(transaction) {
        return localStoreImpl.bundleCache.getBundleMetadata(transaction, bundleMetadata.id);
      }).then(function(cached) {
        return !!cached && cached.createTime.compareTo(currentReadTime) >= 0;
      });
    }
    function localStoreSaveBundle(localStore2, bundleMetadata) {
      var localStoreImpl = debugCast(localStore2);
      return localStoreImpl.persistence.runTransaction("Save bundle", "readwrite", function(transaction) {
        return localStoreImpl.bundleCache.saveBundleMetadata(transaction, bundleMetadata);
      });
    }
    function localStoreGetNamedQuery(localStore2, queryName) {
      var localStoreImpl = debugCast(localStore2);
      return localStoreImpl.persistence.runTransaction("Get named query", "readonly", function(transaction) {
        return localStoreImpl.bundleCache.getNamedQuery(transaction, queryName);
      });
    }
    function localStoreSaveNamedQuery(localStore2, query2, documents) {
      if (documents === void 0) {
        documents = documentKeySet();
      }
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var allocated, localStoreImpl;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              return [4, localStoreAllocateTarget(localStore2, queryToTarget(fromBundledQuery(query2.bundledQuery)))];
            case 1:
              allocated = _d.sent();
              localStoreImpl = debugCast(localStore2);
              return [2, localStoreImpl.persistence.runTransaction("Save named query", "readwrite", function(transaction) {
                var readTime = fromVersion(query2.readTime);
                if (allocated.snapshotVersion.compareTo(readTime) >= 0) {
                  return localStoreImpl.bundleCache.saveNamedQuery(transaction, query2);
                }
                var newTargetData = allocated.withResumeToken(ByteString.EMPTY_BYTE_STRING, readTime);
                localStoreImpl.targetDataByTarget = localStoreImpl.targetDataByTarget.insert(newTargetData.targetId, newTargetData);
                return localStoreImpl.targetCache.updateTargetData(transaction, newTargetData).next(function() {
                  return localStoreImpl.targetCache.removeMatchingKeysForTargetId(transaction, allocated.targetId);
                }).next(function() {
                  return localStoreImpl.targetCache.addMatchingKeys(transaction, documents, allocated.targetId);
                }).next(function() {
                  return localStoreImpl.bundleCache.saveNamedQuery(transaction, query2);
                });
              })];
          }
        });
      });
    }
    var MemoryBundleCache = function() {
      function MemoryBundleCache2(serializer) {
        this.serializer = serializer;
        this.bundles = new Map();
        this.namedQueries = new Map();
      }
      MemoryBundleCache2.prototype.getBundleMetadata = function(transaction, bundleId) {
        return PersistencePromise.resolve(this.bundles.get(bundleId));
      };
      MemoryBundleCache2.prototype.saveBundleMetadata = function(transaction, bundleMetadata) {
        this.bundles.set(bundleMetadata.id, fromBundleMetadata(bundleMetadata));
        return PersistencePromise.resolve();
      };
      MemoryBundleCache2.prototype.getNamedQuery = function(transaction, queryName) {
        return PersistencePromise.resolve(this.namedQueries.get(queryName));
      };
      MemoryBundleCache2.prototype.saveNamedQuery = function(transaction, query2) {
        this.namedQueries.set(query2.name, fromProtoNamedQuery(query2));
        return PersistencePromise.resolve();
      };
      return MemoryBundleCache2;
    }();
    var ReferenceSet = function() {
      function ReferenceSet2() {
        this.refsByKey = new SortedSet(DocReference.compareByKey);
        this.refsByTarget = new SortedSet(DocReference.compareByTargetId);
      }
      ReferenceSet2.prototype.isEmpty = function() {
        return this.refsByKey.isEmpty();
      };
      ReferenceSet2.prototype.addReference = function(key, id) {
        var ref2 = new DocReference(key, id);
        this.refsByKey = this.refsByKey.add(ref2);
        this.refsByTarget = this.refsByTarget.add(ref2);
      };
      ReferenceSet2.prototype.addReferences = function(keys, id) {
        var _this = this;
        keys.forEach(function(key) {
          return _this.addReference(key, id);
        });
      };
      ReferenceSet2.prototype.removeReference = function(key, id) {
        this.removeRef(new DocReference(key, id));
      };
      ReferenceSet2.prototype.removeReferences = function(keys, id) {
        var _this = this;
        keys.forEach(function(key) {
          return _this.removeReference(key, id);
        });
      };
      ReferenceSet2.prototype.removeReferencesForId = function(id) {
        var _this = this;
        var emptyKey = new DocumentKey(new ResourcePath([]));
        var startRef = new DocReference(emptyKey, id);
        var endRef = new DocReference(emptyKey, id + 1);
        var keys = [];
        this.refsByTarget.forEachInRange([startRef, endRef], function(ref2) {
          _this.removeRef(ref2);
          keys.push(ref2.key);
        });
        return keys;
      };
      ReferenceSet2.prototype.removeAllReferences = function() {
        var _this = this;
        this.refsByKey.forEach(function(ref2) {
          return _this.removeRef(ref2);
        });
      };
      ReferenceSet2.prototype.removeRef = function(ref2) {
        this.refsByKey = this.refsByKey.delete(ref2);
        this.refsByTarget = this.refsByTarget.delete(ref2);
      };
      ReferenceSet2.prototype.referencesForId = function(id) {
        var emptyKey = new DocumentKey(new ResourcePath([]));
        var startRef = new DocReference(emptyKey, id);
        var endRef = new DocReference(emptyKey, id + 1);
        var keys = documentKeySet();
        this.refsByTarget.forEachInRange([startRef, endRef], function(ref2) {
          keys = keys.add(ref2.key);
        });
        return keys;
      };
      ReferenceSet2.prototype.containsKey = function(key) {
        var ref2 = new DocReference(key, 0);
        var firstRef = this.refsByKey.firstAfterOrEqual(ref2);
        return firstRef !== null && key.isEqual(firstRef.key);
      };
      return ReferenceSet2;
    }();
    var DocReference = function() {
      function DocReference2(key, targetOrBatchId) {
        this.key = key;
        this.targetOrBatchId = targetOrBatchId;
      }
      DocReference2.compareByKey = function(left, right) {
        return DocumentKey.comparator(left.key, right.key) || primitiveComparator(left.targetOrBatchId, right.targetOrBatchId);
      };
      DocReference2.compareByTargetId = function(left, right) {
        return primitiveComparator(left.targetOrBatchId, right.targetOrBatchId) || DocumentKey.comparator(left.key, right.key);
      };
      return DocReference2;
    }();
    var MemoryMutationQueue = function() {
      function MemoryMutationQueue2(indexManager, referenceDelegate) {
        this.indexManager = indexManager;
        this.referenceDelegate = referenceDelegate;
        this.mutationQueue = [];
        this.nextBatchId = 1;
        this.batchesByDocumentKey = new SortedSet(DocReference.compareByKey);
      }
      MemoryMutationQueue2.prototype.checkEmpty = function(transaction) {
        return PersistencePromise.resolve(this.mutationQueue.length === 0);
      };
      MemoryMutationQueue2.prototype.addMutationBatch = function(transaction, localWriteTime, baseMutations, mutations) {
        var batchId = this.nextBatchId;
        this.nextBatchId++;
        if (this.mutationQueue.length > 0) {
          this.mutationQueue[this.mutationQueue.length - 1];
        }
        var batch = new MutationBatch(batchId, localWriteTime, baseMutations, mutations);
        this.mutationQueue.push(batch);
        for (var _i = 0, mutations_3 = mutations; _i < mutations_3.length; _i++) {
          var mutation = mutations_3[_i];
          this.batchesByDocumentKey = this.batchesByDocumentKey.add(new DocReference(mutation.key, batchId));
          this.indexManager.addToCollectionParentIndex(transaction, mutation.key.path.popLast());
        }
        return PersistencePromise.resolve(batch);
      };
      MemoryMutationQueue2.prototype.lookupMutationBatch = function(transaction, batchId) {
        return PersistencePromise.resolve(this.findMutationBatch(batchId));
      };
      MemoryMutationQueue2.prototype.getNextMutationBatchAfterBatchId = function(transaction, batchId) {
        var nextBatchId = batchId + 1;
        var rawIndex = this.indexOfBatchId(nextBatchId);
        var index2 = rawIndex < 0 ? 0 : rawIndex;
        return PersistencePromise.resolve(this.mutationQueue.length > index2 ? this.mutationQueue[index2] : null);
      };
      MemoryMutationQueue2.prototype.getHighestUnacknowledgedBatchId = function() {
        return PersistencePromise.resolve(this.mutationQueue.length === 0 ? BATCHID_UNKNOWN : this.nextBatchId - 1);
      };
      MemoryMutationQueue2.prototype.getAllMutationBatches = function(transaction) {
        return PersistencePromise.resolve(this.mutationQueue.slice());
      };
      MemoryMutationQueue2.prototype.getAllMutationBatchesAffectingDocumentKey = function(transaction, documentKey) {
        var _this = this;
        var start2 = new DocReference(documentKey, 0);
        var end = new DocReference(documentKey, Number.POSITIVE_INFINITY);
        var result = [];
        this.batchesByDocumentKey.forEachInRange([start2, end], function(ref2) {
          var batch = _this.findMutationBatch(ref2.targetOrBatchId);
          result.push(batch);
        });
        return PersistencePromise.resolve(result);
      };
      MemoryMutationQueue2.prototype.getAllMutationBatchesAffectingDocumentKeys = function(transaction, documentKeys) {
        var _this = this;
        var uniqueBatchIDs = new SortedSet(primitiveComparator);
        documentKeys.forEach(function(documentKey) {
          var start2 = new DocReference(documentKey, 0);
          var end = new DocReference(documentKey, Number.POSITIVE_INFINITY);
          _this.batchesByDocumentKey.forEachInRange([start2, end], function(ref2) {
            uniqueBatchIDs = uniqueBatchIDs.add(ref2.targetOrBatchId);
          });
        });
        return PersistencePromise.resolve(this.findMutationBatches(uniqueBatchIDs));
      };
      MemoryMutationQueue2.prototype.getAllMutationBatchesAffectingQuery = function(transaction, query2) {
        var prefix = query2.path;
        var immediateChildrenPathLength = prefix.length + 1;
        var startPath = prefix;
        if (!DocumentKey.isDocumentKey(startPath)) {
          startPath = startPath.child("");
        }
        var start2 = new DocReference(new DocumentKey(startPath), 0);
        var uniqueBatchIDs = new SortedSet(primitiveComparator);
        this.batchesByDocumentKey.forEachWhile(function(ref2) {
          var rowKeyPath = ref2.key.path;
          if (!prefix.isPrefixOf(rowKeyPath)) {
            return false;
          } else {
            if (rowKeyPath.length === immediateChildrenPathLength) {
              uniqueBatchIDs = uniqueBatchIDs.add(ref2.targetOrBatchId);
            }
            return true;
          }
        }, start2);
        return PersistencePromise.resolve(this.findMutationBatches(uniqueBatchIDs));
      };
      MemoryMutationQueue2.prototype.findMutationBatches = function(batchIDs) {
        var _this = this;
        var result = [];
        batchIDs.forEach(function(batchId) {
          var batch = _this.findMutationBatch(batchId);
          if (batch !== null) {
            result.push(batch);
          }
        });
        return result;
      };
      MemoryMutationQueue2.prototype.removeMutationBatch = function(transaction, batch) {
        var _this = this;
        var batchIndex = this.indexOfExistingBatchId(batch.batchId, "removed");
        hardAssert(batchIndex === 0);
        this.mutationQueue.shift();
        var references = this.batchesByDocumentKey;
        return PersistencePromise.forEach(batch.mutations, function(mutation) {
          var ref2 = new DocReference(mutation.key, batch.batchId);
          references = references.delete(ref2);
          return _this.referenceDelegate.markPotentiallyOrphaned(transaction, mutation.key);
        }).next(function() {
          _this.batchesByDocumentKey = references;
        });
      };
      MemoryMutationQueue2.prototype.removeCachedMutationKeys = function(batchId) {
      };
      MemoryMutationQueue2.prototype.containsKey = function(txn, key) {
        var ref2 = new DocReference(key, 0);
        var firstRef = this.batchesByDocumentKey.firstAfterOrEqual(ref2);
        return PersistencePromise.resolve(key.isEqual(firstRef && firstRef.key));
      };
      MemoryMutationQueue2.prototype.performConsistencyCheck = function(txn) {
        if (this.mutationQueue.length === 0)
          ;
        return PersistencePromise.resolve();
      };
      MemoryMutationQueue2.prototype.indexOfExistingBatchId = function(batchId, action) {
        var index2 = this.indexOfBatchId(batchId);
        return index2;
      };
      MemoryMutationQueue2.prototype.indexOfBatchId = function(batchId) {
        if (this.mutationQueue.length === 0) {
          return 0;
        }
        var firstBatchId = this.mutationQueue[0].batchId;
        return batchId - firstBatchId;
      };
      MemoryMutationQueue2.prototype.findMutationBatch = function(batchId) {
        var index2 = this.indexOfBatchId(batchId);
        if (index2 < 0 || index2 >= this.mutationQueue.length) {
          return null;
        }
        var batch = this.mutationQueue[index2];
        return batch;
      };
      return MemoryMutationQueue2;
    }();
    function documentEntryMap() {
      return new SortedMap(DocumentKey.comparator);
    }
    var MemoryRemoteDocumentCacheImpl = function() {
      function MemoryRemoteDocumentCacheImpl2(indexManager, sizer) {
        this.indexManager = indexManager;
        this.sizer = sizer;
        this.docs = documentEntryMap();
        this.size = 0;
      }
      MemoryRemoteDocumentCacheImpl2.prototype.addEntry = function(transaction, doc2, readTime) {
        var key = doc2.key;
        var entry = this.docs.get(key);
        var previousSize = entry ? entry.size : 0;
        var currentSize = this.sizer(doc2);
        this.docs = this.docs.insert(key, {
          document: doc2.clone(),
          size: currentSize,
          readTime
        });
        this.size += currentSize - previousSize;
        return this.indexManager.addToCollectionParentIndex(transaction, key.path.popLast());
      };
      MemoryRemoteDocumentCacheImpl2.prototype.removeEntry = function(documentKey) {
        var entry = this.docs.get(documentKey);
        if (entry) {
          this.docs = this.docs.remove(documentKey);
          this.size -= entry.size;
        }
      };
      MemoryRemoteDocumentCacheImpl2.prototype.getEntry = function(transaction, documentKey) {
        var entry = this.docs.get(documentKey);
        return PersistencePromise.resolve(entry ? entry.document.clone() : MutableDocument.newInvalidDocument(documentKey));
      };
      MemoryRemoteDocumentCacheImpl2.prototype.getEntries = function(transaction, documentKeys) {
        var _this = this;
        var results = mutableDocumentMap();
        documentKeys.forEach(function(documentKey) {
          var entry = _this.docs.get(documentKey);
          results = results.insert(documentKey, entry ? entry.document.clone() : MutableDocument.newInvalidDocument(documentKey));
        });
        return PersistencePromise.resolve(results);
      };
      MemoryRemoteDocumentCacheImpl2.prototype.getDocumentsMatchingQuery = function(transaction, query2, sinceReadTime) {
        var results = mutableDocumentMap();
        var prefix = new DocumentKey(query2.path.child(""));
        var iterator = this.docs.getIteratorFrom(prefix);
        while (iterator.hasNext()) {
          var _d = iterator.getNext(), key = _d.key, _e = _d.value, document_3 = _e.document, readTime = _e.readTime;
          if (!query2.path.isPrefixOf(key.path)) {
            break;
          }
          if (readTime.compareTo(sinceReadTime) <= 0) {
            continue;
          }
          if (!queryMatches(query2, document_3)) {
            continue;
          }
          results = results.insert(document_3.key, document_3.clone());
        }
        return PersistencePromise.resolve(results);
      };
      MemoryRemoteDocumentCacheImpl2.prototype.forEachDocumentKey = function(transaction, f) {
        return PersistencePromise.forEach(this.docs, function(key) {
          return f(key);
        });
      };
      MemoryRemoteDocumentCacheImpl2.prototype.newChangeBuffer = function(options2) {
        return new MemoryRemoteDocumentChangeBuffer(this);
      };
      MemoryRemoteDocumentCacheImpl2.prototype.getSize = function(txn) {
        return PersistencePromise.resolve(this.size);
      };
      return MemoryRemoteDocumentCacheImpl2;
    }();
    function newMemoryRemoteDocumentCache(indexManager, sizer) {
      return new MemoryRemoteDocumentCacheImpl(indexManager, sizer);
    }
    var MemoryRemoteDocumentChangeBuffer = function(_super) {
      tslib2.__extends(MemoryRemoteDocumentChangeBuffer2, _super);
      function MemoryRemoteDocumentChangeBuffer2(documentCache) {
        var _this = _super.call(this) || this;
        _this.documentCache = documentCache;
        return _this;
      }
      MemoryRemoteDocumentChangeBuffer2.prototype.applyChanges = function(transaction) {
        var _this = this;
        var promises = [];
        this.changes.forEach(function(key, doc2) {
          if (doc2.document.isValidDocument()) {
            promises.push(_this.documentCache.addEntry(transaction, doc2.document, _this.getReadTime(key)));
          } else {
            _this.documentCache.removeEntry(key);
          }
        });
        return PersistencePromise.waitFor(promises);
      };
      MemoryRemoteDocumentChangeBuffer2.prototype.getFromCache = function(transaction, documentKey) {
        return this.documentCache.getEntry(transaction, documentKey);
      };
      MemoryRemoteDocumentChangeBuffer2.prototype.getAllFromCache = function(transaction, documentKeys) {
        return this.documentCache.getEntries(transaction, documentKeys);
      };
      return MemoryRemoteDocumentChangeBuffer2;
    }(RemoteDocumentChangeBuffer);
    var MemoryTargetCache = function() {
      function MemoryTargetCache2(persistence) {
        this.persistence = persistence;
        this.targets = new ObjectMap(function(t) {
          return canonifyTarget(t);
        }, targetEquals);
        this.lastRemoteSnapshotVersion = SnapshotVersion.min();
        this.highestTargetId = 0;
        this.highestSequenceNumber = 0;
        this.references = new ReferenceSet();
        this.targetCount = 0;
        this.targetIdGenerator = TargetIdGenerator.forTargetCache();
      }
      MemoryTargetCache2.prototype.forEachTarget = function(txn, f) {
        this.targets.forEach(function(_, targetData) {
          return f(targetData);
        });
        return PersistencePromise.resolve();
      };
      MemoryTargetCache2.prototype.getLastRemoteSnapshotVersion = function(transaction) {
        return PersistencePromise.resolve(this.lastRemoteSnapshotVersion);
      };
      MemoryTargetCache2.prototype.getHighestSequenceNumber = function(transaction) {
        return PersistencePromise.resolve(this.highestSequenceNumber);
      };
      MemoryTargetCache2.prototype.allocateTargetId = function(transaction) {
        this.highestTargetId = this.targetIdGenerator.next();
        return PersistencePromise.resolve(this.highestTargetId);
      };
      MemoryTargetCache2.prototype.setTargetsMetadata = function(transaction, highestListenSequenceNumber, lastRemoteSnapshotVersion) {
        if (lastRemoteSnapshotVersion) {
          this.lastRemoteSnapshotVersion = lastRemoteSnapshotVersion;
        }
        if (highestListenSequenceNumber > this.highestSequenceNumber) {
          this.highestSequenceNumber = highestListenSequenceNumber;
        }
        return PersistencePromise.resolve();
      };
      MemoryTargetCache2.prototype.saveTargetData = function(targetData) {
        this.targets.set(targetData.target, targetData);
        var targetId = targetData.targetId;
        if (targetId > this.highestTargetId) {
          this.targetIdGenerator = new TargetIdGenerator(targetId);
          this.highestTargetId = targetId;
        }
        if (targetData.sequenceNumber > this.highestSequenceNumber) {
          this.highestSequenceNumber = targetData.sequenceNumber;
        }
      };
      MemoryTargetCache2.prototype.addTargetData = function(transaction, targetData) {
        this.saveTargetData(targetData);
        this.targetCount += 1;
        return PersistencePromise.resolve();
      };
      MemoryTargetCache2.prototype.updateTargetData = function(transaction, targetData) {
        this.saveTargetData(targetData);
        return PersistencePromise.resolve();
      };
      MemoryTargetCache2.prototype.removeTargetData = function(transaction, targetData) {
        this.targets.delete(targetData.target);
        this.references.removeReferencesForId(targetData.targetId);
        this.targetCount -= 1;
        return PersistencePromise.resolve();
      };
      MemoryTargetCache2.prototype.removeTargets = function(transaction, upperBound, activeTargetIds) {
        var _this = this;
        var count = 0;
        var removals = [];
        this.targets.forEach(function(key, targetData) {
          if (targetData.sequenceNumber <= upperBound && activeTargetIds.get(targetData.targetId) === null) {
            _this.targets.delete(key);
            removals.push(_this.removeMatchingKeysForTargetId(transaction, targetData.targetId));
            count++;
          }
        });
        return PersistencePromise.waitFor(removals).next(function() {
          return count;
        });
      };
      MemoryTargetCache2.prototype.getTargetCount = function(transaction) {
        return PersistencePromise.resolve(this.targetCount);
      };
      MemoryTargetCache2.prototype.getTargetData = function(transaction, target) {
        var targetData = this.targets.get(target) || null;
        return PersistencePromise.resolve(targetData);
      };
      MemoryTargetCache2.prototype.addMatchingKeys = function(txn, keys, targetId) {
        this.references.addReferences(keys, targetId);
        return PersistencePromise.resolve();
      };
      MemoryTargetCache2.prototype.removeMatchingKeys = function(txn, keys, targetId) {
        this.references.removeReferences(keys, targetId);
        var referenceDelegate = this.persistence.referenceDelegate;
        var promises = [];
        if (referenceDelegate) {
          keys.forEach(function(key) {
            promises.push(referenceDelegate.markPotentiallyOrphaned(txn, key));
          });
        }
        return PersistencePromise.waitFor(promises);
      };
      MemoryTargetCache2.prototype.removeMatchingKeysForTargetId = function(txn, targetId) {
        this.references.removeReferencesForId(targetId);
        return PersistencePromise.resolve();
      };
      MemoryTargetCache2.prototype.getMatchingKeysForTargetId = function(txn, targetId) {
        var matchingKeys = this.references.referencesForId(targetId);
        return PersistencePromise.resolve(matchingKeys);
      };
      MemoryTargetCache2.prototype.containsKey = function(txn, key) {
        return PersistencePromise.resolve(this.references.containsKey(key));
      };
      return MemoryTargetCache2;
    }();
    var LOG_TAG$b = "MemoryPersistence";
    var MemoryPersistence = function() {
      function MemoryPersistence2(referenceDelegateFactory, serializer) {
        var _this = this;
        this.mutationQueues = {};
        this.listenSequence = new ListenSequence(0);
        this._started = false;
        this._started = true;
        this.referenceDelegate = referenceDelegateFactory(this);
        this.targetCache = new MemoryTargetCache(this);
        var sizer = function(doc2) {
          return _this.referenceDelegate.documentSize(doc2);
        };
        this.indexManager = new MemoryIndexManager();
        this.remoteDocumentCache = newMemoryRemoteDocumentCache(this.indexManager, sizer);
        this.serializer = new LocalSerializer(serializer);
        this.bundleCache = new MemoryBundleCache(this.serializer);
      }
      MemoryPersistence2.prototype.start = function() {
        return Promise.resolve();
      };
      MemoryPersistence2.prototype.shutdown = function() {
        this._started = false;
        return Promise.resolve();
      };
      Object.defineProperty(MemoryPersistence2.prototype, "started", {
        get: function() {
          return this._started;
        },
        enumerable: false,
        configurable: true
      });
      MemoryPersistence2.prototype.setDatabaseDeletedListener = function() {
      };
      MemoryPersistence2.prototype.setNetworkEnabled = function() {
      };
      MemoryPersistence2.prototype.getIndexManager = function() {
        return this.indexManager;
      };
      MemoryPersistence2.prototype.getMutationQueue = function(user2) {
        var queue = this.mutationQueues[user2.toKey()];
        if (!queue) {
          queue = new MemoryMutationQueue(this.indexManager, this.referenceDelegate);
          this.mutationQueues[user2.toKey()] = queue;
        }
        return queue;
      };
      MemoryPersistence2.prototype.getTargetCache = function() {
        return this.targetCache;
      };
      MemoryPersistence2.prototype.getRemoteDocumentCache = function() {
        return this.remoteDocumentCache;
      };
      MemoryPersistence2.prototype.getBundleCache = function() {
        return this.bundleCache;
      };
      MemoryPersistence2.prototype.runTransaction = function(action, mode, transactionOperation) {
        var _this = this;
        logDebug(LOG_TAG$b, "Starting transaction:", action);
        var txn = new MemoryTransaction(this.listenSequence.next());
        this.referenceDelegate.onTransactionStarted();
        return transactionOperation(txn).next(function(result) {
          return _this.referenceDelegate.onTransactionCommitted(txn).next(function() {
            return result;
          });
        }).toPromise().then(function(result) {
          txn.raiseOnCommittedEvent();
          return result;
        });
      };
      MemoryPersistence2.prototype.mutationQueuesContainKey = function(transaction, key) {
        return PersistencePromise.or(Object.values(this.mutationQueues).map(function(queue) {
          return function() {
            return queue.containsKey(transaction, key);
          };
        }));
      };
      return MemoryPersistence2;
    }();
    var MemoryTransaction = function(_super) {
      tslib2.__extends(MemoryTransaction2, _super);
      function MemoryTransaction2(currentSequenceNumber) {
        var _this = _super.call(this) || this;
        _this.currentSequenceNumber = currentSequenceNumber;
        return _this;
      }
      return MemoryTransaction2;
    }(PersistenceTransaction);
    var MemoryEagerDelegate = function() {
      function MemoryEagerDelegate2(persistence) {
        this.persistence = persistence;
        this.localViewReferences = new ReferenceSet();
        this._orphanedDocuments = null;
      }
      MemoryEagerDelegate2.factory = function(persistence) {
        return new MemoryEagerDelegate2(persistence);
      };
      Object.defineProperty(MemoryEagerDelegate2.prototype, "orphanedDocuments", {
        get: function() {
          if (!this._orphanedDocuments) {
            throw fail();
          } else {
            return this._orphanedDocuments;
          }
        },
        enumerable: false,
        configurable: true
      });
      MemoryEagerDelegate2.prototype.addReference = function(txn, targetId, key) {
        this.localViewReferences.addReference(key, targetId);
        this.orphanedDocuments.delete(key.toString());
        return PersistencePromise.resolve();
      };
      MemoryEagerDelegate2.prototype.removeReference = function(txn, targetId, key) {
        this.localViewReferences.removeReference(key, targetId);
        this.orphanedDocuments.add(key.toString());
        return PersistencePromise.resolve();
      };
      MemoryEagerDelegate2.prototype.markPotentiallyOrphaned = function(txn, key) {
        this.orphanedDocuments.add(key.toString());
        return PersistencePromise.resolve();
      };
      MemoryEagerDelegate2.prototype.removeTarget = function(txn, targetData) {
        var _this = this;
        var orphaned = this.localViewReferences.removeReferencesForId(targetData.targetId);
        orphaned.forEach(function(key) {
          return _this.orphanedDocuments.add(key.toString());
        });
        var cache = this.persistence.getTargetCache();
        return cache.getMatchingKeysForTargetId(txn, targetData.targetId).next(function(keys) {
          keys.forEach(function(key) {
            return _this.orphanedDocuments.add(key.toString());
          });
        }).next(function() {
          return cache.removeTargetData(txn, targetData);
        });
      };
      MemoryEagerDelegate2.prototype.onTransactionStarted = function() {
        this._orphanedDocuments = new Set();
      };
      MemoryEagerDelegate2.prototype.onTransactionCommitted = function(txn) {
        var _this = this;
        var cache = this.persistence.getRemoteDocumentCache();
        var changeBuffer = cache.newChangeBuffer();
        return PersistencePromise.forEach(this.orphanedDocuments, function(path2) {
          var key = DocumentKey.fromPath(path2);
          return _this.isReferenced(txn, key).next(function(isReferenced) {
            if (!isReferenced) {
              changeBuffer.removeEntry(key);
            }
          });
        }).next(function() {
          _this._orphanedDocuments = null;
          return changeBuffer.apply(txn);
        });
      };
      MemoryEagerDelegate2.prototype.updateLimboDocument = function(txn, key) {
        var _this = this;
        return this.isReferenced(txn, key).next(function(isReferenced) {
          if (isReferenced) {
            _this.orphanedDocuments.delete(key.toString());
          } else {
            _this.orphanedDocuments.add(key.toString());
          }
        });
      };
      MemoryEagerDelegate2.prototype.documentSize = function(doc2) {
        return 0;
      };
      MemoryEagerDelegate2.prototype.isReferenced = function(txn, key) {
        var _this = this;
        return PersistencePromise.or([
          function() {
            return PersistencePromise.resolve(_this.localViewReferences.containsKey(key));
          },
          function() {
            return _this.persistence.getTargetCache().containsKey(txn, key);
          },
          function() {
            return _this.persistence.mutationQueuesContainKey(txn, key);
          }
        ]);
      };
      return MemoryEagerDelegate2;
    }();
    var QueryEngine = function() {
      function QueryEngine2() {
      }
      QueryEngine2.prototype.setLocalDocumentsView = function(localDocuments) {
        this.localDocumentsView = localDocuments;
      };
      QueryEngine2.prototype.getDocumentsMatchingQuery = function(transaction, query2, lastLimboFreeSnapshotVersion, remoteKeys) {
        var _this = this;
        if (matchesAllDocuments(query2)) {
          return this.executeFullCollectionScan(transaction, query2);
        }
        if (lastLimboFreeSnapshotVersion.isEqual(SnapshotVersion.min())) {
          return this.executeFullCollectionScan(transaction, query2);
        }
        return this.localDocumentsView.getDocuments(transaction, remoteKeys).next(function(documents) {
          var previousResults = _this.applyQuery(query2, documents);
          if ((hasLimitToFirst(query2) || hasLimitToLast(query2)) && _this.needsRefill(query2.limitType, previousResults, remoteKeys, lastLimboFreeSnapshotVersion)) {
            return _this.executeFullCollectionScan(transaction, query2);
          }
          if (getLogLevel() <= logger2.LogLevel.DEBUG) {
            logDebug("QueryEngine", "Re-using previous result from %s to execute query: %s", lastLimboFreeSnapshotVersion.toString(), stringifyQuery(query2));
          }
          return _this.localDocumentsView.getDocumentsMatchingQuery(transaction, query2, lastLimboFreeSnapshotVersion).next(function(updatedResults) {
            previousResults.forEach(function(doc2) {
              updatedResults = updatedResults.insert(doc2.key, doc2);
            });
            return updatedResults;
          });
        });
      };
      QueryEngine2.prototype.applyQuery = function(query2, documents) {
        var queryResults = new SortedSet(newQueryComparator(query2));
        documents.forEach(function(_, maybeDoc) {
          if (queryMatches(query2, maybeDoc)) {
            queryResults = queryResults.add(maybeDoc);
          }
        });
        return queryResults;
      };
      QueryEngine2.prototype.needsRefill = function(limitType, sortedPreviousResults, remoteKeys, limboFreeSnapshotVersion) {
        if (remoteKeys.size !== sortedPreviousResults.size) {
          return true;
        }
        var docAtLimitEdge = limitType === "F" ? sortedPreviousResults.last() : sortedPreviousResults.first();
        if (!docAtLimitEdge) {
          return false;
        }
        return docAtLimitEdge.hasPendingWrites || docAtLimitEdge.version.compareTo(limboFreeSnapshotVersion) > 0;
      };
      QueryEngine2.prototype.executeFullCollectionScan = function(transaction, query2) {
        if (getLogLevel() <= logger2.LogLevel.DEBUG) {
          logDebug("QueryEngine", "Using full collection scan to execute query:", stringifyQuery(query2));
        }
        return this.localDocumentsView.getDocumentsMatchingQuery(transaction, query2, SnapshotVersion.min());
      };
      return QueryEngine2;
    }();
    var CLIENT_STATE_KEY_PREFIX = "firestore_clients";
    function createWebStorageClientStateKey(persistenceKey, clientId) {
      return CLIENT_STATE_KEY_PREFIX + "_" + persistenceKey + "_" + clientId;
    }
    var MUTATION_BATCH_KEY_PREFIX = "firestore_mutations";
    function createWebStorageMutationBatchKey(persistenceKey, user2, batchId) {
      var mutationKey = MUTATION_BATCH_KEY_PREFIX + "_" + persistenceKey + "_" + batchId;
      if (user2.isAuthenticated()) {
        mutationKey += "_" + user2.uid;
      }
      return mutationKey;
    }
    var QUERY_TARGET_KEY_PREFIX = "firestore_targets";
    function createWebStorageQueryTargetMetadataKey(persistenceKey, targetId) {
      return QUERY_TARGET_KEY_PREFIX + "_" + persistenceKey + "_" + targetId;
    }
    var ONLINE_STATE_KEY_PREFIX = "firestore_online_state";
    function createWebStorageOnlineStateKey(persistenceKey) {
      return ONLINE_STATE_KEY_PREFIX + "_" + persistenceKey;
    }
    var BUNDLE_LOADED_KEY_PREFIX = "firestore_bundle_loaded";
    function createBundleLoadedKey(persistenceKey) {
      return BUNDLE_LOADED_KEY_PREFIX + "_" + persistenceKey;
    }
    var SEQUENCE_NUMBER_KEY_PREFIX = "firestore_sequence_number";
    function createWebStorageSequenceNumberKey(persistenceKey) {
      return SEQUENCE_NUMBER_KEY_PREFIX + "_" + persistenceKey;
    }
    var LOG_TAG$a = "SharedClientState";
    var MutationMetadata = function() {
      function MutationMetadata2(user2, batchId, state, error2) {
        this.user = user2;
        this.batchId = batchId;
        this.state = state;
        this.error = error2;
      }
      MutationMetadata2.fromWebStorageEntry = function(user2, batchId, value) {
        var mutationBatch = JSON.parse(value);
        var validData = typeof mutationBatch === "object" && ["pending", "acknowledged", "rejected"].indexOf(mutationBatch.state) !== -1 && (mutationBatch.error === void 0 || typeof mutationBatch.error === "object");
        var firestoreError = void 0;
        if (validData && mutationBatch.error) {
          validData = typeof mutationBatch.error.message === "string" && typeof mutationBatch.error.code === "string";
          if (validData) {
            firestoreError = new FirestoreError(mutationBatch.error.code, mutationBatch.error.message);
          }
        }
        if (validData) {
          return new MutationMetadata2(user2, batchId, mutationBatch.state, firestoreError);
        } else {
          logError(LOG_TAG$a, "Failed to parse mutation state for ID '" + batchId + "': " + value);
          return null;
        }
      };
      MutationMetadata2.prototype.toWebStorageJSON = function() {
        var batchMetadata = {
          state: this.state,
          updateTimeMs: Date.now()
        };
        if (this.error) {
          batchMetadata.error = {
            code: this.error.code,
            message: this.error.message
          };
        }
        return JSON.stringify(batchMetadata);
      };
      return MutationMetadata2;
    }();
    var QueryTargetMetadata = function() {
      function QueryTargetMetadata2(targetId, state, error2) {
        this.targetId = targetId;
        this.state = state;
        this.error = error2;
      }
      QueryTargetMetadata2.fromWebStorageEntry = function(targetId, value) {
        var targetState = JSON.parse(value);
        var validData = typeof targetState === "object" && ["not-current", "current", "rejected"].indexOf(targetState.state) !== -1 && (targetState.error === void 0 || typeof targetState.error === "object");
        var firestoreError = void 0;
        if (validData && targetState.error) {
          validData = typeof targetState.error.message === "string" && typeof targetState.error.code === "string";
          if (validData) {
            firestoreError = new FirestoreError(targetState.error.code, targetState.error.message);
          }
        }
        if (validData) {
          return new QueryTargetMetadata2(targetId, targetState.state, firestoreError);
        } else {
          logError(LOG_TAG$a, "Failed to parse target state for ID '" + targetId + "': " + value);
          return null;
        }
      };
      QueryTargetMetadata2.prototype.toWebStorageJSON = function() {
        var targetState = {
          state: this.state,
          updateTimeMs: Date.now()
        };
        if (this.error) {
          targetState.error = {
            code: this.error.code,
            message: this.error.message
          };
        }
        return JSON.stringify(targetState);
      };
      return QueryTargetMetadata2;
    }();
    var RemoteClientState = function() {
      function RemoteClientState2(clientId, activeTargetIds) {
        this.clientId = clientId;
        this.activeTargetIds = activeTargetIds;
      }
      RemoteClientState2.fromWebStorageEntry = function(clientId, value) {
        var clientState = JSON.parse(value);
        var validData = typeof clientState === "object" && clientState.activeTargetIds instanceof Array;
        var activeTargetIdsSet = targetIdSet();
        for (var i = 0; validData && i < clientState.activeTargetIds.length; ++i) {
          validData = isSafeInteger(clientState.activeTargetIds[i]);
          activeTargetIdsSet = activeTargetIdsSet.add(clientState.activeTargetIds[i]);
        }
        if (validData) {
          return new RemoteClientState2(clientId, activeTargetIdsSet);
        } else {
          logError(LOG_TAG$a, "Failed to parse client data for instance '" + clientId + "': " + value);
          return null;
        }
      };
      return RemoteClientState2;
    }();
    var SharedOnlineState = function() {
      function SharedOnlineState2(clientId, onlineState) {
        this.clientId = clientId;
        this.onlineState = onlineState;
      }
      SharedOnlineState2.fromWebStorageEntry = function(value) {
        var onlineState = JSON.parse(value);
        var validData = typeof onlineState === "object" && ["Unknown", "Online", "Offline"].indexOf(onlineState.onlineState) !== -1 && typeof onlineState.clientId === "string";
        if (validData) {
          return new SharedOnlineState2(onlineState.clientId, onlineState.onlineState);
        } else {
          logError(LOG_TAG$a, "Failed to parse online state: " + value);
          return null;
        }
      };
      return SharedOnlineState2;
    }();
    var LocalClientState = function() {
      function LocalClientState2() {
        this.activeTargetIds = targetIdSet();
      }
      LocalClientState2.prototype.addQueryTarget = function(targetId) {
        this.activeTargetIds = this.activeTargetIds.add(targetId);
      };
      LocalClientState2.prototype.removeQueryTarget = function(targetId) {
        this.activeTargetIds = this.activeTargetIds.delete(targetId);
      };
      LocalClientState2.prototype.toWebStorageJSON = function() {
        var data = {
          activeTargetIds: this.activeTargetIds.toArray(),
          updateTimeMs: Date.now()
        };
        return JSON.stringify(data);
      };
      return LocalClientState2;
    }();
    var WebStorageSharedClientState = function() {
      function WebStorageSharedClientState2(window2, queue, persistenceKey, localClientId, initialUser) {
        this.window = window2;
        this.queue = queue;
        this.persistenceKey = persistenceKey;
        this.localClientId = localClientId;
        this.syncEngine = null;
        this.onlineStateHandler = null;
        this.sequenceNumberHandler = null;
        this.storageListener = this.handleWebStorageEvent.bind(this);
        this.activeClients = new SortedMap(primitiveComparator);
        this.started = false;
        this.earlyEvents = [];
        var escapedPersistenceKey = persistenceKey.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        this.storage = this.window.localStorage;
        this.currentUser = initialUser;
        this.localClientStorageKey = createWebStorageClientStateKey(this.persistenceKey, this.localClientId);
        this.sequenceNumberKey = createWebStorageSequenceNumberKey(this.persistenceKey);
        this.activeClients = this.activeClients.insert(this.localClientId, new LocalClientState());
        this.clientStateKeyRe = new RegExp("^" + CLIENT_STATE_KEY_PREFIX + "_" + escapedPersistenceKey + "_([^_]*)$");
        this.mutationBatchKeyRe = new RegExp("^" + MUTATION_BATCH_KEY_PREFIX + "_" + escapedPersistenceKey + "_(\\d+)(?:_(.*))?$");
        this.queryTargetKeyRe = new RegExp("^" + QUERY_TARGET_KEY_PREFIX + "_" + escapedPersistenceKey + "_(\\d+)$");
        this.onlineStateKey = createWebStorageOnlineStateKey(this.persistenceKey);
        this.bundleLoadedKey = createBundleLoadedKey(this.persistenceKey);
        this.window.addEventListener("storage", this.storageListener);
      }
      WebStorageSharedClientState2.isAvailable = function(window2) {
        return !!(window2 && window2.localStorage);
      };
      WebStorageSharedClientState2.prototype.start = function() {
        return tslib2.__awaiter(this, void 0, void 0, function() {
          var existingClients, _i, existingClients_1, clientId, storageItem, clientState, onlineStateJSON, onlineState, _d, _e, event_1;
          var _this = this;
          return tslib2.__generator(this, function(_f) {
            switch (_f.label) {
              case 0:
                return [4, this.syncEngine.getActiveClients()];
              case 1:
                existingClients = _f.sent();
                for (_i = 0, existingClients_1 = existingClients; _i < existingClients_1.length; _i++) {
                  clientId = existingClients_1[_i];
                  if (clientId === this.localClientId) {
                    continue;
                  }
                  storageItem = this.getItem(createWebStorageClientStateKey(this.persistenceKey, clientId));
                  if (storageItem) {
                    clientState = RemoteClientState.fromWebStorageEntry(clientId, storageItem);
                    if (clientState) {
                      this.activeClients = this.activeClients.insert(clientState.clientId, clientState);
                    }
                  }
                }
                this.persistClientState();
                onlineStateJSON = this.storage.getItem(this.onlineStateKey);
                if (onlineStateJSON) {
                  onlineState = this.fromWebStorageOnlineState(onlineStateJSON);
                  if (onlineState) {
                    this.handleOnlineStateEvent(onlineState);
                  }
                }
                for (_d = 0, _e = this.earlyEvents; _d < _e.length; _d++) {
                  event_1 = _e[_d];
                  this.handleWebStorageEvent(event_1);
                }
                this.earlyEvents = [];
                this.window.addEventListener("pagehide", function() {
                  return _this.shutdown();
                });
                this.started = true;
                return [2];
            }
          });
        });
      };
      WebStorageSharedClientState2.prototype.writeSequenceNumber = function(sequenceNumber) {
        this.setItem(this.sequenceNumberKey, JSON.stringify(sequenceNumber));
      };
      WebStorageSharedClientState2.prototype.getAllActiveQueryTargets = function() {
        return this.extractActiveQueryTargets(this.activeClients);
      };
      WebStorageSharedClientState2.prototype.isActiveQueryTarget = function(targetId) {
        var found = false;
        this.activeClients.forEach(function(key, value) {
          if (value.activeTargetIds.has(targetId)) {
            found = true;
          }
        });
        return found;
      };
      WebStorageSharedClientState2.prototype.addPendingMutation = function(batchId) {
        this.persistMutationState(batchId, "pending");
      };
      WebStorageSharedClientState2.prototype.updateMutationState = function(batchId, state, error2) {
        this.persistMutationState(batchId, state, error2);
        this.removeMutationState(batchId);
      };
      WebStorageSharedClientState2.prototype.addLocalQueryTarget = function(targetId) {
        var queryState = "not-current";
        if (this.isActiveQueryTarget(targetId)) {
          var storageItem = this.storage.getItem(createWebStorageQueryTargetMetadataKey(this.persistenceKey, targetId));
          if (storageItem) {
            var metadata = QueryTargetMetadata.fromWebStorageEntry(targetId, storageItem);
            if (metadata) {
              queryState = metadata.state;
            }
          }
        }
        this.localClientState.addQueryTarget(targetId);
        this.persistClientState();
        return queryState;
      };
      WebStorageSharedClientState2.prototype.removeLocalQueryTarget = function(targetId) {
        this.localClientState.removeQueryTarget(targetId);
        this.persistClientState();
      };
      WebStorageSharedClientState2.prototype.isLocalQueryTarget = function(targetId) {
        return this.localClientState.activeTargetIds.has(targetId);
      };
      WebStorageSharedClientState2.prototype.clearQueryState = function(targetId) {
        this.removeItem(createWebStorageQueryTargetMetadataKey(this.persistenceKey, targetId));
      };
      WebStorageSharedClientState2.prototype.updateQueryState = function(targetId, state, error2) {
        this.persistQueryTargetState(targetId, state, error2);
      };
      WebStorageSharedClientState2.prototype.handleUserChange = function(user2, removedBatchIds, addedBatchIds) {
        var _this = this;
        removedBatchIds.forEach(function(batchId) {
          _this.removeMutationState(batchId);
        });
        this.currentUser = user2;
        addedBatchIds.forEach(function(batchId) {
          _this.addPendingMutation(batchId);
        });
      };
      WebStorageSharedClientState2.prototype.setOnlineState = function(onlineState) {
        this.persistOnlineState(onlineState);
      };
      WebStorageSharedClientState2.prototype.notifyBundleLoaded = function() {
        this.persistBundleLoadedState();
      };
      WebStorageSharedClientState2.prototype.shutdown = function() {
        if (this.started) {
          this.window.removeEventListener("storage", this.storageListener);
          this.removeItem(this.localClientStorageKey);
          this.started = false;
        }
      };
      WebStorageSharedClientState2.prototype.getItem = function(key) {
        var value = this.storage.getItem(key);
        logDebug(LOG_TAG$a, "READ", key, value);
        return value;
      };
      WebStorageSharedClientState2.prototype.setItem = function(key, value) {
        logDebug(LOG_TAG$a, "SET", key, value);
        this.storage.setItem(key, value);
      };
      WebStorageSharedClientState2.prototype.removeItem = function(key) {
        logDebug(LOG_TAG$a, "REMOVE", key);
        this.storage.removeItem(key);
      };
      WebStorageSharedClientState2.prototype.handleWebStorageEvent = function(event) {
        var _this = this;
        var storageEvent = event;
        if (storageEvent.storageArea === this.storage) {
          logDebug(LOG_TAG$a, "EVENT", storageEvent.key, storageEvent.newValue);
          if (storageEvent.key === this.localClientStorageKey) {
            logError("Received WebStorage notification for local change. Another client might have garbage-collected our state");
            return;
          }
          this.queue.enqueueRetryable(function() {
            return tslib2.__awaiter(_this, void 0, void 0, function() {
              var clientState, clientId, mutationMetadata, queryTargetMetadata, onlineState, sequenceNumber;
              return tslib2.__generator(this, function(_d) {
                if (!this.started) {
                  this.earlyEvents.push(storageEvent);
                  return [2];
                }
                if (storageEvent.key === null) {
                  return [2];
                }
                if (this.clientStateKeyRe.test(storageEvent.key)) {
                  if (storageEvent.newValue != null) {
                    clientState = this.fromWebStorageClientState(storageEvent.key, storageEvent.newValue);
                    if (clientState) {
                      return [2, this.handleClientStateEvent(clientState.clientId, clientState)];
                    }
                  } else {
                    clientId = this.fromWebStorageClientStateKey(storageEvent.key);
                    return [2, this.handleClientStateEvent(clientId, null)];
                  }
                } else if (this.mutationBatchKeyRe.test(storageEvent.key)) {
                  if (storageEvent.newValue !== null) {
                    mutationMetadata = this.fromWebStorageMutationMetadata(storageEvent.key, storageEvent.newValue);
                    if (mutationMetadata) {
                      return [2, this.handleMutationBatchEvent(mutationMetadata)];
                    }
                  }
                } else if (this.queryTargetKeyRe.test(storageEvent.key)) {
                  if (storageEvent.newValue !== null) {
                    queryTargetMetadata = this.fromWebStorageQueryTargetMetadata(storageEvent.key, storageEvent.newValue);
                    if (queryTargetMetadata) {
                      return [2, this.handleQueryTargetEvent(queryTargetMetadata)];
                    }
                  }
                } else if (storageEvent.key === this.onlineStateKey) {
                  if (storageEvent.newValue !== null) {
                    onlineState = this.fromWebStorageOnlineState(storageEvent.newValue);
                    if (onlineState) {
                      return [2, this.handleOnlineStateEvent(onlineState)];
                    }
                  }
                } else if (storageEvent.key === this.sequenceNumberKey) {
                  sequenceNumber = fromWebStorageSequenceNumber(storageEvent.newValue);
                  if (sequenceNumber !== ListenSequence.INVALID) {
                    this.sequenceNumberHandler(sequenceNumber);
                  }
                } else if (storageEvent.key === this.bundleLoadedKey) {
                  return [2, this.syncEngine.synchronizeWithChangedDocuments()];
                }
                return [2];
              });
            });
          });
        }
      };
      Object.defineProperty(WebStorageSharedClientState2.prototype, "localClientState", {
        get: function() {
          return this.activeClients.get(this.localClientId);
        },
        enumerable: false,
        configurable: true
      });
      WebStorageSharedClientState2.prototype.persistClientState = function() {
        this.setItem(this.localClientStorageKey, this.localClientState.toWebStorageJSON());
      };
      WebStorageSharedClientState2.prototype.persistMutationState = function(batchId, state, error2) {
        var mutationState = new MutationMetadata(this.currentUser, batchId, state, error2);
        var mutationKey = createWebStorageMutationBatchKey(this.persistenceKey, this.currentUser, batchId);
        this.setItem(mutationKey, mutationState.toWebStorageJSON());
      };
      WebStorageSharedClientState2.prototype.removeMutationState = function(batchId) {
        var mutationKey = createWebStorageMutationBatchKey(this.persistenceKey, this.currentUser, batchId);
        this.removeItem(mutationKey);
      };
      WebStorageSharedClientState2.prototype.persistOnlineState = function(onlineState) {
        var entry = {
          clientId: this.localClientId,
          onlineState
        };
        this.storage.setItem(this.onlineStateKey, JSON.stringify(entry));
      };
      WebStorageSharedClientState2.prototype.persistQueryTargetState = function(targetId, state, error2) {
        var targetKey = createWebStorageQueryTargetMetadataKey(this.persistenceKey, targetId);
        var targetMetadata = new QueryTargetMetadata(targetId, state, error2);
        this.setItem(targetKey, targetMetadata.toWebStorageJSON());
      };
      WebStorageSharedClientState2.prototype.persistBundleLoadedState = function() {
        this.setItem(this.bundleLoadedKey, "value-not-used");
      };
      WebStorageSharedClientState2.prototype.fromWebStorageClientStateKey = function(key) {
        var match = this.clientStateKeyRe.exec(key);
        return match ? match[1] : null;
      };
      WebStorageSharedClientState2.prototype.fromWebStorageClientState = function(key, value) {
        var clientId = this.fromWebStorageClientStateKey(key);
        return RemoteClientState.fromWebStorageEntry(clientId, value);
      };
      WebStorageSharedClientState2.prototype.fromWebStorageMutationMetadata = function(key, value) {
        var match = this.mutationBatchKeyRe.exec(key);
        var batchId = Number(match[1]);
        var userId = match[2] !== void 0 ? match[2] : null;
        return MutationMetadata.fromWebStorageEntry(new User(userId), batchId, value);
      };
      WebStorageSharedClientState2.prototype.fromWebStorageQueryTargetMetadata = function(key, value) {
        var match = this.queryTargetKeyRe.exec(key);
        var targetId = Number(match[1]);
        return QueryTargetMetadata.fromWebStorageEntry(targetId, value);
      };
      WebStorageSharedClientState2.prototype.fromWebStorageOnlineState = function(value) {
        return SharedOnlineState.fromWebStorageEntry(value);
      };
      WebStorageSharedClientState2.prototype.handleMutationBatchEvent = function(mutationBatch) {
        return tslib2.__awaiter(this, void 0, void 0, function() {
          return tslib2.__generator(this, function(_d) {
            if (mutationBatch.user.uid !== this.currentUser.uid) {
              logDebug(LOG_TAG$a, "Ignoring mutation for non-active user " + mutationBatch.user.uid);
              return [2];
            }
            return [2, this.syncEngine.applyBatchState(mutationBatch.batchId, mutationBatch.state, mutationBatch.error)];
          });
        });
      };
      WebStorageSharedClientState2.prototype.handleQueryTargetEvent = function(targetMetadata) {
        return this.syncEngine.applyTargetState(targetMetadata.targetId, targetMetadata.state, targetMetadata.error);
      };
      WebStorageSharedClientState2.prototype.handleClientStateEvent = function(clientId, clientState) {
        var _this = this;
        var updatedClients = clientState ? this.activeClients.insert(clientId, clientState) : this.activeClients.remove(clientId);
        var existingTargets = this.extractActiveQueryTargets(this.activeClients);
        var newTargets = this.extractActiveQueryTargets(updatedClients);
        var addedTargets = [];
        var removedTargets = [];
        newTargets.forEach(function(targetId) {
          if (!existingTargets.has(targetId)) {
            addedTargets.push(targetId);
          }
        });
        existingTargets.forEach(function(targetId) {
          if (!newTargets.has(targetId)) {
            removedTargets.push(targetId);
          }
        });
        return this.syncEngine.applyActiveTargetsChange(addedTargets, removedTargets).then(function() {
          _this.activeClients = updatedClients;
        });
      };
      WebStorageSharedClientState2.prototype.handleOnlineStateEvent = function(onlineState) {
        if (this.activeClients.get(onlineState.clientId)) {
          this.onlineStateHandler(onlineState.onlineState);
        }
      };
      WebStorageSharedClientState2.prototype.extractActiveQueryTargets = function(clients) {
        var activeTargets = targetIdSet();
        clients.forEach(function(kev, value) {
          activeTargets = activeTargets.unionWith(value.activeTargetIds);
        });
        return activeTargets;
      };
      return WebStorageSharedClientState2;
    }();
    function fromWebStorageSequenceNumber(seqString) {
      var sequenceNumber = ListenSequence.INVALID;
      if (seqString != null) {
        try {
          var parsed = JSON.parse(seqString);
          hardAssert(typeof parsed === "number");
          sequenceNumber = parsed;
        } catch (e) {
          logError(LOG_TAG$a, "Failed to read sequence number from WebStorage", e);
        }
      }
      return sequenceNumber;
    }
    var MemorySharedClientState = function() {
      function MemorySharedClientState2() {
        this.localState = new LocalClientState();
        this.queryState = {};
        this.onlineStateHandler = null;
        this.sequenceNumberHandler = null;
      }
      MemorySharedClientState2.prototype.addPendingMutation = function(batchId) {
      };
      MemorySharedClientState2.prototype.updateMutationState = function(batchId, state, error2) {
      };
      MemorySharedClientState2.prototype.addLocalQueryTarget = function(targetId) {
        this.localState.addQueryTarget(targetId);
        return this.queryState[targetId] || "not-current";
      };
      MemorySharedClientState2.prototype.updateQueryState = function(targetId, state, error2) {
        this.queryState[targetId] = state;
      };
      MemorySharedClientState2.prototype.removeLocalQueryTarget = function(targetId) {
        this.localState.removeQueryTarget(targetId);
      };
      MemorySharedClientState2.prototype.isLocalQueryTarget = function(targetId) {
        return this.localState.activeTargetIds.has(targetId);
      };
      MemorySharedClientState2.prototype.clearQueryState = function(targetId) {
        delete this.queryState[targetId];
      };
      MemorySharedClientState2.prototype.getAllActiveQueryTargets = function() {
        return this.localState.activeTargetIds;
      };
      MemorySharedClientState2.prototype.isActiveQueryTarget = function(targetId) {
        return this.localState.activeTargetIds.has(targetId);
      };
      MemorySharedClientState2.prototype.start = function() {
        this.localState = new LocalClientState();
        return Promise.resolve();
      };
      MemorySharedClientState2.prototype.handleUserChange = function(user2, removedBatchIds, addedBatchIds) {
      };
      MemorySharedClientState2.prototype.setOnlineState = function(onlineState) {
      };
      MemorySharedClientState2.prototype.shutdown = function() {
      };
      MemorySharedClientState2.prototype.writeSequenceNumber = function(sequenceNumber) {
      };
      MemorySharedClientState2.prototype.notifyBundleLoaded = function() {
      };
      return MemorySharedClientState2;
    }();
    var NoopConnectivityMonitor = function() {
      function NoopConnectivityMonitor2() {
      }
      NoopConnectivityMonitor2.prototype.addCallback = function(callback) {
      };
      NoopConnectivityMonitor2.prototype.shutdown = function() {
      };
      return NoopConnectivityMonitor2;
    }();
    var StreamBridge = function() {
      function StreamBridge2(args) {
        this.sendFn = args.sendFn;
        this.closeFn = args.closeFn;
      }
      StreamBridge2.prototype.onOpen = function(callback) {
        this.wrappedOnOpen = callback;
      };
      StreamBridge2.prototype.onClose = function(callback) {
        this.wrappedOnClose = callback;
      };
      StreamBridge2.prototype.onMessage = function(callback) {
        this.wrappedOnMessage = callback;
      };
      StreamBridge2.prototype.close = function() {
        this.closeFn();
      };
      StreamBridge2.prototype.send = function(msg) {
        this.sendFn(msg);
      };
      StreamBridge2.prototype.callOnOpen = function() {
        this.wrappedOnOpen();
      };
      StreamBridge2.prototype.callOnClose = function(err) {
        this.wrappedOnClose(err);
      };
      StreamBridge2.prototype.callOnMessage = function(msg) {
        this.wrappedOnMessage(msg);
      };
      return StreamBridge2;
    }();
    function nodePromise(action) {
      return new Promise(function(resolve2, reject) {
        action(function(error2, value) {
          if (error2) {
            reject(error2);
          } else {
            resolve2(value);
          }
        });
      });
    }
    var LOG_TAG$9 = "Connection";
    var X_GOOG_API_CLIENT_VALUE = "gl-node/" + process.versions.node + " fire/" + SDK_VERSION2 + " grpc/" + package_json.version;
    function createMetadata(databasePath, token, appId) {
      hardAssert(token === null || token.type === "OAuth");
      var metadata = new grpcJs.Metadata();
      if (token) {
        for (var header in token.authHeaders) {
          if (token.authHeaders.hasOwnProperty(header)) {
            metadata.set(header, token.authHeaders[header]);
          }
        }
      }
      if (appId) {
        metadata.set("X-Firebase-GMPID", appId);
      }
      metadata.set("X-Goog-Api-Client", X_GOOG_API_CLIENT_VALUE);
      metadata.set("Google-Cloud-Resource-Prefix", databasePath);
      return metadata;
    }
    var GrpcConnection = function() {
      function GrpcConnection2(protos, databaseInfo) {
        this.databaseInfo = databaseInfo;
        this.cachedStub = null;
        this.firestore = protos["google"]["firestore"]["v1"];
        this.databasePath = "projects/" + databaseInfo.databaseId.projectId + "/databases/" + databaseInfo.databaseId.database;
      }
      GrpcConnection2.prototype.ensureActiveStub = function() {
        if (!this.cachedStub) {
          logDebug(LOG_TAG$9, "Creating Firestore stub.");
          var credentials$1 = this.databaseInfo.ssl ? grpcJs.credentials.createSsl() : grpcJs.credentials.createInsecure();
          this.cachedStub = new this.firestore.Firestore(this.databaseInfo.host, credentials$1);
        }
        return this.cachedStub;
      };
      GrpcConnection2.prototype.invokeRPC = function(rpcName, path2, request, token) {
        var stub = this.ensureActiveStub();
        var metadata = createMetadata(this.databasePath, token, this.databaseInfo.appId);
        var jsonRequest = Object.assign({ database: this.databasePath }, request);
        return nodePromise(function(callback) {
          logDebug(LOG_TAG$9, "RPC '" + rpcName + "' invoked with request:", request);
          return stub[rpcName](jsonRequest, metadata, function(grpcError, value) {
            if (grpcError) {
              logDebug(LOG_TAG$9, "RPC '" + rpcName + "' failed with error:", grpcError);
              callback(new FirestoreError(mapCodeFromRpcCode(grpcError.code), grpcError.message));
            } else {
              logDebug(LOG_TAG$9, "RPC '" + rpcName + "' completed with response:", value);
              callback(void 0, value);
            }
          });
        });
      };
      GrpcConnection2.prototype.invokeStreamingRPC = function(rpcName, path2, request, token) {
        var results = [];
        var responseDeferred = new Deferred2();
        logDebug(LOG_TAG$9, "RPC '" + rpcName + "' invoked (streaming) with request:", request);
        var stub = this.ensureActiveStub();
        var metadata = createMetadata(this.databasePath, token, this.databaseInfo.appId);
        var jsonRequest = Object.assign(Object.assign({}, request), { database: this.databasePath });
        var stream = stub[rpcName](jsonRequest, metadata);
        stream.on("data", function(response) {
          logDebug(LOG_TAG$9, "RPC " + rpcName + " received result:", response);
          results.push(response);
        });
        stream.on("end", function() {
          logDebug(LOG_TAG$9, "RPC '" + rpcName + "' completed.");
          responseDeferred.resolve(results);
        });
        stream.on("error", function(grpcError) {
          logDebug(LOG_TAG$9, "RPC '" + rpcName + "' failed with error:", grpcError);
          var code = mapCodeFromRpcCode(grpcError.code);
          responseDeferred.reject(new FirestoreError(code, grpcError.message));
        });
        return responseDeferred.promise;
      };
      GrpcConnection2.prototype.openStream = function(rpcName, token) {
        var stub = this.ensureActiveStub();
        var metadata = createMetadata(this.databasePath, token, this.databaseInfo.appId);
        var grpcStream = stub[rpcName](metadata);
        var closed = false;
        var close = function(err) {
          if (!closed) {
            closed = true;
            stream.callOnClose(err);
            grpcStream.end();
          }
        };
        var stream = new StreamBridge({
          sendFn: function(msg) {
            if (!closed) {
              logDebug(LOG_TAG$9, "GRPC stream sending:", msg);
              try {
                grpcStream.write(msg);
              } catch (e) {
                logError("Failure sending:", msg);
                logError("Error:", e);
                throw e;
              }
            } else {
              logDebug(LOG_TAG$9, "Not sending because gRPC stream is closed:", msg);
            }
          },
          closeFn: function() {
            logDebug(LOG_TAG$9, "GRPC stream closed locally via close().");
            close();
          }
        });
        grpcStream.on("data", function(msg) {
          if (!closed) {
            logDebug(LOG_TAG$9, "GRPC stream received:", msg);
            stream.callOnMessage(msg);
          }
        });
        grpcStream.on("end", function() {
          logDebug(LOG_TAG$9, "GRPC stream ended.");
          close();
        });
        grpcStream.on("error", function(grpcError) {
          if (!closed) {
            logWarn(LOG_TAG$9, "GRPC stream error. Code:", grpcError.code, "Message:", grpcError.message);
            var code = mapCodeFromRpcCode(grpcError.code);
            close(new FirestoreError(code, grpcError.message));
          }
        });
        logDebug(LOG_TAG$9, "Opening GRPC stream");
        setTimeout(function() {
          stream.callOnOpen();
        }, 0);
        return stream;
      };
      return GrpcConnection2;
    }();
    var protoLoaderOptions = {
      longs: String,
      enums: String,
      defaults: true,
      oneofs: false
    };
    function loadProtos() {
      var root = path.resolve(__dirname, "src/protos");
      var firestoreProtoFile = path.join(root, "google/firestore/v1/firestore.proto");
      var packageDefinition = protoLoader.loadSync(firestoreProtoFile, Object.assign(Object.assign({}, protoLoaderOptions), { includeDirs: [root] }));
      return grpcJs.loadPackageDefinition(packageDefinition);
    }
    function newConnection2(databaseInfo) {
      var protos = loadProtos();
      return new GrpcConnection(protos, databaseInfo);
    }
    function newConnectivityMonitor() {
      return new NoopConnectivityMonitor();
    }
    function getWindow() {
      if (process.env.USE_MOCK_PERSISTENCE === "YES") {
        return window;
      }
      return null;
    }
    function getDocument() {
      return null;
    }
    function newSerializer(databaseId) {
      return new JsonProtoSerializer(databaseId, false);
    }
    function newTextEncoder() {
      return new util$1.TextEncoder();
    }
    function newTextDecoder() {
      return new util$1.TextDecoder("utf-8");
    }
    var LOG_TAG$8 = "ExponentialBackoff";
    var DEFAULT_BACKOFF_INITIAL_DELAY_MS = 1e3;
    var DEFAULT_BACKOFF_FACTOR2 = 1.5;
    var DEFAULT_BACKOFF_MAX_DELAY_MS = 60 * 1e3;
    var ExponentialBackoff = function() {
      function ExponentialBackoff2(queue, timerId, initialDelayMs, backoffFactor, maxDelayMs) {
        if (initialDelayMs === void 0) {
          initialDelayMs = DEFAULT_BACKOFF_INITIAL_DELAY_MS;
        }
        if (backoffFactor === void 0) {
          backoffFactor = DEFAULT_BACKOFF_FACTOR2;
        }
        if (maxDelayMs === void 0) {
          maxDelayMs = DEFAULT_BACKOFF_MAX_DELAY_MS;
        }
        this.queue = queue;
        this.timerId = timerId;
        this.initialDelayMs = initialDelayMs;
        this.backoffFactor = backoffFactor;
        this.maxDelayMs = maxDelayMs;
        this.currentBaseMs = 0;
        this.timerPromise = null;
        this.lastAttemptTime = Date.now();
        this.reset();
      }
      ExponentialBackoff2.prototype.reset = function() {
        this.currentBaseMs = 0;
      };
      ExponentialBackoff2.prototype.resetToMax = function() {
        this.currentBaseMs = this.maxDelayMs;
      };
      ExponentialBackoff2.prototype.backoffAndRun = function(op) {
        var _this = this;
        this.cancel();
        var desiredDelayWithJitterMs = Math.floor(this.currentBaseMs + this.jitterDelayMs());
        var delaySoFarMs = Math.max(0, Date.now() - this.lastAttemptTime);
        var remainingDelayMs = Math.max(0, desiredDelayWithJitterMs - delaySoFarMs);
        if (remainingDelayMs > 0) {
          logDebug(LOG_TAG$8, "Backing off for " + remainingDelayMs + " ms " + ("(base delay: " + this.currentBaseMs + " ms, ") + ("delay with jitter: " + desiredDelayWithJitterMs + " ms, ") + ("last attempt: " + delaySoFarMs + " ms ago)"));
        }
        this.timerPromise = this.queue.enqueueAfterDelay(this.timerId, remainingDelayMs, function() {
          _this.lastAttemptTime = Date.now();
          return op();
        });
        this.currentBaseMs *= this.backoffFactor;
        if (this.currentBaseMs < this.initialDelayMs) {
          this.currentBaseMs = this.initialDelayMs;
        }
        if (this.currentBaseMs > this.maxDelayMs) {
          this.currentBaseMs = this.maxDelayMs;
        }
      };
      ExponentialBackoff2.prototype.skipBackoff = function() {
        if (this.timerPromise !== null) {
          this.timerPromise.skipDelay();
          this.timerPromise = null;
        }
      };
      ExponentialBackoff2.prototype.cancel = function() {
        if (this.timerPromise !== null) {
          this.timerPromise.cancel();
          this.timerPromise = null;
        }
      };
      ExponentialBackoff2.prototype.jitterDelayMs = function() {
        return (Math.random() - 0.5) * this.currentBaseMs;
      };
      return ExponentialBackoff2;
    }();
    var LOG_TAG$7 = "PersistentStream";
    var IDLE_TIMEOUT_MS = 60 * 1e3;
    var PersistentStream = function() {
      function PersistentStream2(queue, connectionTimerId, idleTimerId, connection, credentialsProvider, listener) {
        this.queue = queue;
        this.idleTimerId = idleTimerId;
        this.connection = connection;
        this.credentialsProvider = credentialsProvider;
        this.listener = listener;
        this.state = 0;
        this.closeCount = 0;
        this.idleTimer = null;
        this.stream = null;
        this.backoff = new ExponentialBackoff(queue, connectionTimerId);
      }
      PersistentStream2.prototype.isStarted = function() {
        return this.state === 1 || this.state === 2 || this.state === 4;
      };
      PersistentStream2.prototype.isOpen = function() {
        return this.state === 2;
      };
      PersistentStream2.prototype.start = function() {
        if (this.state === 3) {
          this.performBackoff();
          return;
        }
        this.auth();
      };
      PersistentStream2.prototype.stop = function() {
        return tslib2.__awaiter(this, void 0, void 0, function() {
          return tslib2.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                if (!this.isStarted())
                  return [3, 2];
                return [4, this.close(0)];
              case 1:
                _d.sent();
                _d.label = 2;
              case 2:
                return [2];
            }
          });
        });
      };
      PersistentStream2.prototype.inhibitBackoff = function() {
        this.state = 0;
        this.backoff.reset();
      };
      PersistentStream2.prototype.markIdle = function() {
        var _this = this;
        if (this.isOpen() && this.idleTimer === null) {
          this.idleTimer = this.queue.enqueueAfterDelay(this.idleTimerId, IDLE_TIMEOUT_MS, function() {
            return _this.handleIdleCloseTimer();
          });
        }
      };
      PersistentStream2.prototype.sendRequest = function(msg) {
        this.cancelIdleCheck();
        this.stream.send(msg);
      };
      PersistentStream2.prototype.handleIdleCloseTimer = function() {
        return tslib2.__awaiter(this, void 0, void 0, function() {
          return tslib2.__generator(this, function(_d) {
            if (this.isOpen()) {
              return [2, this.close(0)];
            }
            return [2];
          });
        });
      };
      PersistentStream2.prototype.cancelIdleCheck = function() {
        if (this.idleTimer) {
          this.idleTimer.cancel();
          this.idleTimer = null;
        }
      };
      PersistentStream2.prototype.close = function(finalState, error2) {
        return tslib2.__awaiter(this, void 0, void 0, function() {
          return tslib2.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                this.cancelIdleCheck();
                this.backoff.cancel();
                this.closeCount++;
                if (finalState !== 3) {
                  this.backoff.reset();
                } else if (error2 && error2.code === Code.RESOURCE_EXHAUSTED) {
                  logError(error2.toString());
                  logError("Using maximum backoff delay to prevent overloading the backend.");
                  this.backoff.resetToMax();
                } else if (error2 && error2.code === Code.UNAUTHENTICATED) {
                  this.credentialsProvider.invalidateToken();
                }
                if (this.stream !== null) {
                  this.tearDown();
                  this.stream.close();
                  this.stream = null;
                }
                this.state = finalState;
                return [4, this.listener.onClose(error2)];
              case 1:
                _d.sent();
                return [2];
            }
          });
        });
      };
      PersistentStream2.prototype.tearDown = function() {
      };
      PersistentStream2.prototype.auth = function() {
        var _this = this;
        this.state = 1;
        var dispatchIfNotClosed = this.getCloseGuardedDispatcher(this.closeCount);
        var closeCount = this.closeCount;
        this.credentialsProvider.getToken().then(function(token) {
          if (_this.closeCount === closeCount) {
            _this.startStream(token);
          }
        }, function(error2) {
          dispatchIfNotClosed(function() {
            var rpcError = new FirestoreError(Code.UNKNOWN, "Fetching auth token failed: " + error2.message);
            return _this.handleStreamClose(rpcError);
          });
        });
      };
      PersistentStream2.prototype.startStream = function(token) {
        var _this = this;
        var dispatchIfNotClosed = this.getCloseGuardedDispatcher(this.closeCount);
        this.stream = this.startRpc(token);
        this.stream.onOpen(function() {
          dispatchIfNotClosed(function() {
            _this.state = 2;
            return _this.listener.onOpen();
          });
        });
        this.stream.onClose(function(error2) {
          dispatchIfNotClosed(function() {
            return _this.handleStreamClose(error2);
          });
        });
        this.stream.onMessage(function(msg) {
          dispatchIfNotClosed(function() {
            return _this.onMessage(msg);
          });
        });
      };
      PersistentStream2.prototype.performBackoff = function() {
        var _this = this;
        this.state = 4;
        this.backoff.backoffAndRun(function() {
          return tslib2.__awaiter(_this, void 0, void 0, function() {
            return tslib2.__generator(this, function(_d) {
              this.state = 0;
              this.start();
              return [2];
            });
          });
        });
      };
      PersistentStream2.prototype.handleStreamClose = function(error2) {
        logDebug(LOG_TAG$7, "close with error: " + error2);
        this.stream = null;
        return this.close(3, error2);
      };
      PersistentStream2.prototype.getCloseGuardedDispatcher = function(startCloseCount) {
        var _this = this;
        return function(fn) {
          _this.queue.enqueueAndForget(function() {
            if (_this.closeCount === startCloseCount) {
              return fn();
            } else {
              logDebug(LOG_TAG$7, "stream callback skipped by getCloseGuardedDispatcher.");
              return Promise.resolve();
            }
          });
        };
      };
      return PersistentStream2;
    }();
    var PersistentListenStream = function(_super) {
      tslib2.__extends(PersistentListenStream2, _super);
      function PersistentListenStream2(queue, connection, credentials, serializer, listener) {
        var _this = _super.call(this, queue, "listen_stream_connection_backoff", "listen_stream_idle", connection, credentials, listener) || this;
        _this.serializer = serializer;
        return _this;
      }
      PersistentListenStream2.prototype.startRpc = function(token) {
        return this.connection.openStream("Listen", token);
      };
      PersistentListenStream2.prototype.onMessage = function(watchChangeProto) {
        this.backoff.reset();
        var watchChange = fromWatchChange(this.serializer, watchChangeProto);
        var snapshot = versionFromListenResponse(watchChangeProto);
        return this.listener.onWatchChange(watchChange, snapshot);
      };
      PersistentListenStream2.prototype.watch = function(targetData) {
        var request = {};
        request.database = getEncodedDatabaseId(this.serializer);
        request.addTarget = toTarget(this.serializer, targetData);
        var labels = toListenRequestLabels(this.serializer, targetData);
        if (labels) {
          request.labels = labels;
        }
        this.sendRequest(request);
      };
      PersistentListenStream2.prototype.unwatch = function(targetId) {
        var request = {};
        request.database = getEncodedDatabaseId(this.serializer);
        request.removeTarget = targetId;
        this.sendRequest(request);
      };
      return PersistentListenStream2;
    }(PersistentStream);
    var PersistentWriteStream = function(_super) {
      tslib2.__extends(PersistentWriteStream2, _super);
      function PersistentWriteStream2(queue, connection, credentials, serializer, listener) {
        var _this = _super.call(this, queue, "write_stream_connection_backoff", "write_stream_idle", connection, credentials, listener) || this;
        _this.serializer = serializer;
        _this.handshakeComplete_ = false;
        return _this;
      }
      Object.defineProperty(PersistentWriteStream2.prototype, "handshakeComplete", {
        get: function() {
          return this.handshakeComplete_;
        },
        enumerable: false,
        configurable: true
      });
      PersistentWriteStream2.prototype.start = function() {
        this.handshakeComplete_ = false;
        this.lastStreamToken = void 0;
        _super.prototype.start.call(this);
      };
      PersistentWriteStream2.prototype.tearDown = function() {
        if (this.handshakeComplete_) {
          this.writeMutations([]);
        }
      };
      PersistentWriteStream2.prototype.startRpc = function(token) {
        return this.connection.openStream("Write", token);
      };
      PersistentWriteStream2.prototype.onMessage = function(responseProto) {
        hardAssert(!!responseProto.streamToken);
        this.lastStreamToken = responseProto.streamToken;
        if (!this.handshakeComplete_) {
          hardAssert(!responseProto.writeResults || responseProto.writeResults.length === 0);
          this.handshakeComplete_ = true;
          return this.listener.onHandshakeComplete();
        } else {
          this.backoff.reset();
          var results = fromWriteResults(responseProto.writeResults, responseProto.commitTime);
          var commitVersion = fromVersion(responseProto.commitTime);
          return this.listener.onMutationResult(commitVersion, results);
        }
      };
      PersistentWriteStream2.prototype.writeHandshake = function() {
        var request = {};
        request.database = getEncodedDatabaseId(this.serializer);
        this.sendRequest(request);
      };
      PersistentWriteStream2.prototype.writeMutations = function(mutations) {
        var _this = this;
        var request = {
          streamToken: this.lastStreamToken,
          writes: mutations.map(function(mutation) {
            return toMutation(_this.serializer, mutation);
          })
        };
        this.sendRequest(request);
      };
      return PersistentWriteStream2;
    }(PersistentStream);
    var Datastore = function() {
      function Datastore2() {
      }
      return Datastore2;
    }();
    var DatastoreImpl = function(_super) {
      tslib2.__extends(DatastoreImpl2, _super);
      function DatastoreImpl2(credentials, connection, serializer) {
        var _this = _super.call(this) || this;
        _this.credentials = credentials;
        _this.connection = connection;
        _this.serializer = serializer;
        _this.terminated = false;
        return _this;
      }
      DatastoreImpl2.prototype.verifyInitialized = function() {
        if (this.terminated) {
          throw new FirestoreError(Code.FAILED_PRECONDITION, "The client has already been terminated.");
        }
      };
      DatastoreImpl2.prototype.invokeRPC = function(rpcName, path2, request) {
        var _this = this;
        this.verifyInitialized();
        return this.credentials.getToken().then(function(token) {
          return _this.connection.invokeRPC(rpcName, path2, request, token);
        }).catch(function(error2) {
          if (error2.name === "FirebaseError") {
            if (error2.code === Code.UNAUTHENTICATED) {
              _this.credentials.invalidateToken();
            }
            throw error2;
          } else {
            throw new FirestoreError(Code.UNKNOWN, error2.toString());
          }
        });
      };
      DatastoreImpl2.prototype.invokeStreamingRPC = function(rpcName, path2, request) {
        var _this = this;
        this.verifyInitialized();
        return this.credentials.getToken().then(function(token) {
          return _this.connection.invokeStreamingRPC(rpcName, path2, request, token);
        }).catch(function(error2) {
          if (error2.name === "FirebaseError") {
            if (error2.code === Code.UNAUTHENTICATED) {
              _this.credentials.invalidateToken();
            }
            throw error2;
          } else {
            throw new FirestoreError(Code.UNKNOWN, error2.toString());
          }
        });
      };
      DatastoreImpl2.prototype.terminate = function() {
        this.terminated = true;
      };
      return DatastoreImpl2;
    }(Datastore);
    function newDatastore(credentials, connection, serializer) {
      return new DatastoreImpl(credentials, connection, serializer);
    }
    function invokeCommitRpc(datastore, mutations) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var datastoreImpl, path2, request;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              datastoreImpl = debugCast(datastore);
              path2 = getEncodedDatabaseId(datastoreImpl.serializer) + "/documents";
              request = {
                writes: mutations.map(function(m) {
                  return toMutation(datastoreImpl.serializer, m);
                })
              };
              return [4, datastoreImpl.invokeRPC("Commit", path2, request)];
            case 1:
              _d.sent();
              return [2];
          }
        });
      });
    }
    function invokeBatchGetDocumentsRpc(datastore, keys) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var datastoreImpl, path2, request, response, docs, result;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              datastoreImpl = debugCast(datastore);
              path2 = getEncodedDatabaseId(datastoreImpl.serializer) + "/documents";
              request = {
                documents: keys.map(function(k) {
                  return toName(datastoreImpl.serializer, k);
                })
              };
              return [4, datastoreImpl.invokeStreamingRPC("BatchGetDocuments", path2, request)];
            case 1:
              response = _d.sent();
              docs = new Map();
              response.forEach(function(proto) {
                var doc2 = fromBatchGetDocumentsResponse(datastoreImpl.serializer, proto);
                docs.set(doc2.key.toString(), doc2);
              });
              result = [];
              keys.forEach(function(key) {
                var doc2 = docs.get(key.toString());
                hardAssert(!!doc2);
                result.push(doc2);
              });
              return [2, result];
          }
        });
      });
    }
    function newPersistentWriteStream(datastore, queue, listener) {
      var datastoreImpl = debugCast(datastore);
      datastoreImpl.verifyInitialized();
      return new PersistentWriteStream(queue, datastoreImpl.connection, datastoreImpl.credentials, datastoreImpl.serializer, listener);
    }
    function newPersistentWatchStream(datastore, queue, listener) {
      var datastoreImpl = debugCast(datastore);
      datastoreImpl.verifyInitialized();
      return new PersistentListenStream(queue, datastoreImpl.connection, datastoreImpl.credentials, datastoreImpl.serializer, listener);
    }
    var LOG_TAG$6 = "OnlineStateTracker";
    var MAX_WATCH_STREAM_FAILURES = 1;
    var ONLINE_STATE_TIMEOUT_MS = 10 * 1e3;
    var OnlineStateTracker = function() {
      function OnlineStateTracker2(asyncQueue, onlineStateHandler) {
        this.asyncQueue = asyncQueue;
        this.onlineStateHandler = onlineStateHandler;
        this.state = "Unknown";
        this.watchStreamFailures = 0;
        this.onlineStateTimer = null;
        this.shouldWarnClientIsOffline = true;
      }
      OnlineStateTracker2.prototype.handleWatchStreamStart = function() {
        var _this = this;
        if (this.watchStreamFailures === 0) {
          this.setAndBroadcast("Unknown");
          this.onlineStateTimer = this.asyncQueue.enqueueAfterDelay("online_state_timeout", ONLINE_STATE_TIMEOUT_MS, function() {
            _this.onlineStateTimer = null;
            _this.logClientOfflineWarningIfNecessary("Backend didn't respond within " + ONLINE_STATE_TIMEOUT_MS / 1e3 + " seconds.");
            _this.setAndBroadcast("Offline");
            return Promise.resolve();
          });
        }
      };
      OnlineStateTracker2.prototype.handleWatchStreamFailure = function(error2) {
        if (this.state === "Online") {
          this.setAndBroadcast("Unknown");
        } else {
          this.watchStreamFailures++;
          if (this.watchStreamFailures >= MAX_WATCH_STREAM_FAILURES) {
            this.clearOnlineStateTimer();
            this.logClientOfflineWarningIfNecessary("Connection failed " + MAX_WATCH_STREAM_FAILURES + " " + ("times. Most recent error: " + error2.toString()));
            this.setAndBroadcast("Offline");
          }
        }
      };
      OnlineStateTracker2.prototype.set = function(newState) {
        this.clearOnlineStateTimer();
        this.watchStreamFailures = 0;
        if (newState === "Online") {
          this.shouldWarnClientIsOffline = false;
        }
        this.setAndBroadcast(newState);
      };
      OnlineStateTracker2.prototype.setAndBroadcast = function(newState) {
        if (newState !== this.state) {
          this.state = newState;
          this.onlineStateHandler(newState);
        }
      };
      OnlineStateTracker2.prototype.logClientOfflineWarningIfNecessary = function(details) {
        var message = "Could not reach Cloud Firestore backend. " + details + "\nThis typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.";
        if (this.shouldWarnClientIsOffline) {
          logError(message);
          this.shouldWarnClientIsOffline = false;
        } else {
          logDebug(LOG_TAG$6, message);
        }
      };
      OnlineStateTracker2.prototype.clearOnlineStateTimer = function() {
        if (this.onlineStateTimer !== null) {
          this.onlineStateTimer.cancel();
          this.onlineStateTimer = null;
        }
      };
      return OnlineStateTracker2;
    }();
    var LOG_TAG$5 = "RemoteStore";
    var MAX_PENDING_WRITES = 10;
    var RemoteStoreImpl = function() {
      function RemoteStoreImpl2(localStore2, datastore, asyncQueue, onlineStateHandler, connectivityMonitor) {
        var _this = this;
        this.localStore = localStore2;
        this.datastore = datastore;
        this.asyncQueue = asyncQueue;
        this.remoteSyncer = {};
        this.writePipeline = [];
        this.listenTargets = new Map();
        this.offlineCauses = new Set();
        this.onNetworkStatusChange = [];
        this.connectivityMonitor = connectivityMonitor;
        this.connectivityMonitor.addCallback(function(_) {
          asyncQueue.enqueueAndForget(function() {
            return tslib2.__awaiter(_this, void 0, void 0, function() {
              return tslib2.__generator(this, function(_d) {
                switch (_d.label) {
                  case 0:
                    if (!canUseNetwork(this))
                      return [3, 2];
                    logDebug(LOG_TAG$5, "Restarting streams for network reachability change.");
                    return [4, restartNetwork(this)];
                  case 1:
                    _d.sent();
                    _d.label = 2;
                  case 2:
                    return [2];
                }
              });
            });
          });
        });
        this.onlineStateTracker = new OnlineStateTracker(asyncQueue, onlineStateHandler);
      }
      return RemoteStoreImpl2;
    }();
    function newRemoteStore(localStore2, datastore, asyncQueue, onlineStateHandler, connectivityMonitor) {
      return new RemoteStoreImpl(localStore2, datastore, asyncQueue, onlineStateHandler, connectivityMonitor);
    }
    function remoteStoreEnableNetwork(remoteStore) {
      var remoteStoreImpl = debugCast(remoteStore);
      remoteStoreImpl.offlineCauses.delete(0);
      return enableNetworkInternal(remoteStoreImpl);
    }
    function enableNetworkInternal(remoteStoreImpl) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var _i, _d, networkStatusHandler;
        return tslib2.__generator(this, function(_e) {
          switch (_e.label) {
            case 0:
              if (!canUseNetwork(remoteStoreImpl))
                return [3, 4];
              _i = 0, _d = remoteStoreImpl.onNetworkStatusChange;
              _e.label = 1;
            case 1:
              if (!(_i < _d.length))
                return [3, 4];
              networkStatusHandler = _d[_i];
              return [4, networkStatusHandler(true)];
            case 2:
              _e.sent();
              _e.label = 3;
            case 3:
              _i++;
              return [3, 1];
            case 4:
              return [2];
          }
        });
      });
    }
    function remoteStoreDisableNetwork(remoteStore) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var remoteStoreImpl;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              remoteStoreImpl = debugCast(remoteStore);
              remoteStoreImpl.offlineCauses.add(0);
              return [4, disableNetworkInternal(remoteStoreImpl)];
            case 1:
              _d.sent();
              remoteStoreImpl.onlineStateTracker.set("Offline");
              return [2];
          }
        });
      });
    }
    function disableNetworkInternal(remoteStoreImpl) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var _i, _d, networkStatusHandler;
        return tslib2.__generator(this, function(_e) {
          switch (_e.label) {
            case 0:
              _i = 0, _d = remoteStoreImpl.onNetworkStatusChange;
              _e.label = 1;
            case 1:
              if (!(_i < _d.length))
                return [3, 4];
              networkStatusHandler = _d[_i];
              return [4, networkStatusHandler(false)];
            case 2:
              _e.sent();
              _e.label = 3;
            case 3:
              _i++;
              return [3, 1];
            case 4:
              return [2];
          }
        });
      });
    }
    function remoteStoreShutdown(remoteStore) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var remoteStoreImpl;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              remoteStoreImpl = debugCast(remoteStore);
              logDebug(LOG_TAG$5, "RemoteStore shutting down.");
              remoteStoreImpl.offlineCauses.add(5);
              return [4, disableNetworkInternal(remoteStoreImpl)];
            case 1:
              _d.sent();
              remoteStoreImpl.connectivityMonitor.shutdown();
              remoteStoreImpl.onlineStateTracker.set("Unknown");
              return [2];
          }
        });
      });
    }
    function remoteStoreListen(remoteStore, targetData) {
      var remoteStoreImpl = debugCast(remoteStore);
      if (remoteStoreImpl.listenTargets.has(targetData.targetId)) {
        return;
      }
      remoteStoreImpl.listenTargets.set(targetData.targetId, targetData);
      if (shouldStartWatchStream(remoteStoreImpl)) {
        startWatchStream(remoteStoreImpl);
      } else if (ensureWatchStream(remoteStoreImpl).isOpen()) {
        sendWatchRequest(remoteStoreImpl, targetData);
      }
    }
    function remoteStoreUnlisten(remoteStore, targetId) {
      var remoteStoreImpl = debugCast(remoteStore);
      var watchStream = ensureWatchStream(remoteStoreImpl);
      remoteStoreImpl.listenTargets.delete(targetId);
      if (watchStream.isOpen()) {
        sendUnwatchRequest(remoteStoreImpl, targetId);
      }
      if (remoteStoreImpl.listenTargets.size === 0) {
        if (watchStream.isOpen()) {
          watchStream.markIdle();
        } else if (canUseNetwork(remoteStoreImpl)) {
          remoteStoreImpl.onlineStateTracker.set("Unknown");
        }
      }
    }
    function sendWatchRequest(remoteStoreImpl, targetData) {
      remoteStoreImpl.watchChangeAggregator.recordPendingTargetRequest(targetData.targetId);
      ensureWatchStream(remoteStoreImpl).watch(targetData);
    }
    function sendUnwatchRequest(remoteStoreImpl, targetId) {
      remoteStoreImpl.watchChangeAggregator.recordPendingTargetRequest(targetId);
      ensureWatchStream(remoteStoreImpl).unwatch(targetId);
    }
    function startWatchStream(remoteStoreImpl) {
      remoteStoreImpl.watchChangeAggregator = new WatchChangeAggregator({
        getRemoteKeysForTarget: function(targetId) {
          return remoteStoreImpl.remoteSyncer.getRemoteKeysForTarget(targetId);
        },
        getTargetDataForTarget: function(targetId) {
          return remoteStoreImpl.listenTargets.get(targetId) || null;
        }
      });
      ensureWatchStream(remoteStoreImpl).start();
      remoteStoreImpl.onlineStateTracker.handleWatchStreamStart();
    }
    function shouldStartWatchStream(remoteStoreImpl) {
      return canUseNetwork(remoteStoreImpl) && !ensureWatchStream(remoteStoreImpl).isStarted() && remoteStoreImpl.listenTargets.size > 0;
    }
    function canUseNetwork(remoteStore) {
      var remoteStoreImpl = debugCast(remoteStore);
      return remoteStoreImpl.offlineCauses.size === 0;
    }
    function cleanUpWatchStreamState(remoteStoreImpl) {
      remoteStoreImpl.watchChangeAggregator = void 0;
    }
    function onWatchStreamOpen(remoteStoreImpl) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        return tslib2.__generator(this, function(_d) {
          remoteStoreImpl.listenTargets.forEach(function(targetData, targetId) {
            sendWatchRequest(remoteStoreImpl, targetData);
          });
          return [2];
        });
      });
    }
    function onWatchStreamClose(remoteStoreImpl, error2) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        return tslib2.__generator(this, function(_d) {
          cleanUpWatchStreamState(remoteStoreImpl);
          if (shouldStartWatchStream(remoteStoreImpl)) {
            remoteStoreImpl.onlineStateTracker.handleWatchStreamFailure(error2);
            startWatchStream(remoteStoreImpl);
          } else {
            remoteStoreImpl.onlineStateTracker.set("Unknown");
          }
          return [2];
        });
      });
    }
    function onWatchStreamChange(remoteStoreImpl, watchChange, snapshotVersion) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var e_4, lastRemoteSnapshotVersion, e_5;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              remoteStoreImpl.onlineStateTracker.set("Online");
              if (!(watchChange instanceof WatchTargetChange && watchChange.state === 2 && watchChange.cause))
                return [3, 6];
              _d.label = 1;
            case 1:
              _d.trys.push([1, 3, , 5]);
              return [4, handleTargetError(remoteStoreImpl, watchChange)];
            case 2:
              _d.sent();
              return [3, 5];
            case 3:
              e_4 = _d.sent();
              logDebug(LOG_TAG$5, "Failed to remove targets %s: %s ", watchChange.targetIds.join(","), e_4);
              return [4, disableNetworkUntilRecovery(remoteStoreImpl, e_4)];
            case 4:
              _d.sent();
              return [3, 5];
            case 5:
              return [2];
            case 6:
              if (watchChange instanceof DocumentWatchChange) {
                remoteStoreImpl.watchChangeAggregator.handleDocumentChange(watchChange);
              } else if (watchChange instanceof ExistenceFilterChange) {
                remoteStoreImpl.watchChangeAggregator.handleExistenceFilter(watchChange);
              } else {
                remoteStoreImpl.watchChangeAggregator.handleTargetChange(watchChange);
              }
              if (!!snapshotVersion.isEqual(SnapshotVersion.min()))
                return [3, 13];
              _d.label = 7;
            case 7:
              _d.trys.push([7, 11, , 13]);
              return [4, localStoreGetLastRemoteSnapshotVersion(remoteStoreImpl.localStore)];
            case 8:
              lastRemoteSnapshotVersion = _d.sent();
              if (!(snapshotVersion.compareTo(lastRemoteSnapshotVersion) >= 0))
                return [3, 10];
              return [4, raiseWatchSnapshot(remoteStoreImpl, snapshotVersion)];
            case 9:
              _d.sent();
              _d.label = 10;
            case 10:
              return [3, 13];
            case 11:
              e_5 = _d.sent();
              logDebug(LOG_TAG$5, "Failed to raise snapshot:", e_5);
              return [4, disableNetworkUntilRecovery(remoteStoreImpl, e_5)];
            case 12:
              _d.sent();
              return [3, 13];
            case 13:
              return [2];
          }
        });
      });
    }
    function disableNetworkUntilRecovery(remoteStoreImpl, e, op) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var _this = this;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              if (!isIndexedDbTransactionError(e))
                return [3, 2];
              remoteStoreImpl.offlineCauses.add(1);
              return [4, disableNetworkInternal(remoteStoreImpl)];
            case 1:
              _d.sent();
              remoteStoreImpl.onlineStateTracker.set("Offline");
              if (!op) {
                op = function() {
                  return localStoreGetLastRemoteSnapshotVersion(remoteStoreImpl.localStore);
                };
              }
              remoteStoreImpl.asyncQueue.enqueueRetryable(function() {
                return tslib2.__awaiter(_this, void 0, void 0, function() {
                  return tslib2.__generator(this, function(_d2) {
                    switch (_d2.label) {
                      case 0:
                        logDebug(LOG_TAG$5, "Retrying IndexedDB access");
                        return [4, op()];
                      case 1:
                        _d2.sent();
                        remoteStoreImpl.offlineCauses.delete(1);
                        return [4, enableNetworkInternal(remoteStoreImpl)];
                      case 2:
                        _d2.sent();
                        return [2];
                    }
                  });
                });
              });
              return [3, 3];
            case 2:
              throw e;
            case 3:
              return [2];
          }
        });
      });
    }
    function executeWithRecovery(remoteStoreImpl, op) {
      return op().catch(function(e) {
        return disableNetworkUntilRecovery(remoteStoreImpl, e, op);
      });
    }
    function raiseWatchSnapshot(remoteStoreImpl, snapshotVersion) {
      var remoteEvent = remoteStoreImpl.watchChangeAggregator.createRemoteEvent(snapshotVersion);
      remoteEvent.targetChanges.forEach(function(change, targetId) {
        if (change.resumeToken.approximateByteSize() > 0) {
          var targetData = remoteStoreImpl.listenTargets.get(targetId);
          if (targetData) {
            remoteStoreImpl.listenTargets.set(targetId, targetData.withResumeToken(change.resumeToken, snapshotVersion));
          }
        }
      });
      remoteEvent.targetMismatches.forEach(function(targetId) {
        var targetData = remoteStoreImpl.listenTargets.get(targetId);
        if (!targetData) {
          return;
        }
        remoteStoreImpl.listenTargets.set(targetId, targetData.withResumeToken(ByteString.EMPTY_BYTE_STRING, targetData.snapshotVersion));
        sendUnwatchRequest(remoteStoreImpl, targetId);
        var requestTargetData = new TargetData(targetData.target, targetId, 1, targetData.sequenceNumber);
        sendWatchRequest(remoteStoreImpl, requestTargetData);
      });
      return remoteStoreImpl.remoteSyncer.applyRemoteEvent(remoteEvent);
    }
    function handleTargetError(remoteStoreImpl, watchChange) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var error2, _i, _d, targetId;
        return tslib2.__generator(this, function(_e) {
          switch (_e.label) {
            case 0:
              error2 = watchChange.cause;
              _i = 0, _d = watchChange.targetIds;
              _e.label = 1;
            case 1:
              if (!(_i < _d.length))
                return [3, 4];
              targetId = _d[_i];
              if (!remoteStoreImpl.listenTargets.has(targetId))
                return [3, 3];
              return [4, remoteStoreImpl.remoteSyncer.rejectListen(targetId, error2)];
            case 2:
              _e.sent();
              remoteStoreImpl.listenTargets.delete(targetId);
              remoteStoreImpl.watchChangeAggregator.removeTarget(targetId);
              _e.label = 3;
            case 3:
              _i++;
              return [3, 1];
            case 4:
              return [2];
          }
        });
      });
    }
    function fillWritePipeline(remoteStore) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var remoteStoreImpl, writeStream, lastBatchIdRetrieved, batch, e_6;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              remoteStoreImpl = debugCast(remoteStore);
              writeStream = ensureWriteStream(remoteStoreImpl);
              lastBatchIdRetrieved = remoteStoreImpl.writePipeline.length > 0 ? remoteStoreImpl.writePipeline[remoteStoreImpl.writePipeline.length - 1].batchId : BATCHID_UNKNOWN;
              _d.label = 1;
            case 1:
              if (!canAddToWritePipeline(remoteStoreImpl))
                return [3, 7];
              _d.label = 2;
            case 2:
              _d.trys.push([2, 4, , 6]);
              return [4, localStoreGetNextMutationBatch(remoteStoreImpl.localStore, lastBatchIdRetrieved)];
            case 3:
              batch = _d.sent();
              if (batch === null) {
                if (remoteStoreImpl.writePipeline.length === 0) {
                  writeStream.markIdle();
                }
                return [3, 7];
              } else {
                lastBatchIdRetrieved = batch.batchId;
                addToWritePipeline(remoteStoreImpl, batch);
              }
              return [3, 6];
            case 4:
              e_6 = _d.sent();
              return [4, disableNetworkUntilRecovery(remoteStoreImpl, e_6)];
            case 5:
              _d.sent();
              return [3, 6];
            case 6:
              return [3, 1];
            case 7:
              if (shouldStartWriteStream(remoteStoreImpl)) {
                startWriteStream(remoteStoreImpl);
              }
              return [2];
          }
        });
      });
    }
    function canAddToWritePipeline(remoteStoreImpl) {
      return canUseNetwork(remoteStoreImpl) && remoteStoreImpl.writePipeline.length < MAX_PENDING_WRITES;
    }
    function addToWritePipeline(remoteStoreImpl, batch) {
      remoteStoreImpl.writePipeline.push(batch);
      var writeStream = ensureWriteStream(remoteStoreImpl);
      if (writeStream.isOpen() && writeStream.handshakeComplete) {
        writeStream.writeMutations(batch.mutations);
      }
    }
    function shouldStartWriteStream(remoteStoreImpl) {
      return canUseNetwork(remoteStoreImpl) && !ensureWriteStream(remoteStoreImpl).isStarted() && remoteStoreImpl.writePipeline.length > 0;
    }
    function startWriteStream(remoteStoreImpl) {
      ensureWriteStream(remoteStoreImpl).start();
    }
    function onWriteStreamOpen(remoteStoreImpl) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        return tslib2.__generator(this, function(_d) {
          ensureWriteStream(remoteStoreImpl).writeHandshake();
          return [2];
        });
      });
    }
    function onWriteHandshakeComplete(remoteStoreImpl) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var writeStream, _i, _d, batch;
        return tslib2.__generator(this, function(_e) {
          writeStream = ensureWriteStream(remoteStoreImpl);
          for (_i = 0, _d = remoteStoreImpl.writePipeline; _i < _d.length; _i++) {
            batch = _d[_i];
            writeStream.writeMutations(batch.mutations);
          }
          return [2];
        });
      });
    }
    function onMutationResult(remoteStoreImpl, commitVersion, results) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var batch, success;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              batch = remoteStoreImpl.writePipeline.shift();
              success = MutationBatchResult.from(batch, commitVersion, results);
              return [4, executeWithRecovery(remoteStoreImpl, function() {
                return remoteStoreImpl.remoteSyncer.applySuccessfulWrite(success);
              })];
            case 1:
              _d.sent();
              return [4, fillWritePipeline(remoteStoreImpl)];
            case 2:
              _d.sent();
              return [2];
          }
        });
      });
    }
    function onWriteStreamClose(remoteStoreImpl, error2) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              if (!(error2 && ensureWriteStream(remoteStoreImpl).handshakeComplete))
                return [3, 2];
              return [4, handleWriteError(remoteStoreImpl, error2)];
            case 1:
              _d.sent();
              _d.label = 2;
            case 2:
              if (shouldStartWriteStream(remoteStoreImpl)) {
                startWriteStream(remoteStoreImpl);
              }
              return [2];
          }
        });
      });
    }
    function handleWriteError(remoteStoreImpl, error2) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var batch_1;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              if (!isPermanentWriteError(error2.code))
                return [3, 3];
              batch_1 = remoteStoreImpl.writePipeline.shift();
              ensureWriteStream(remoteStoreImpl).inhibitBackoff();
              return [4, executeWithRecovery(remoteStoreImpl, function() {
                return remoteStoreImpl.remoteSyncer.rejectFailedWrite(batch_1.batchId, error2);
              })];
            case 1:
              _d.sent();
              return [4, fillWritePipeline(remoteStoreImpl)];
            case 2:
              _d.sent();
              _d.label = 3;
            case 3:
              return [2];
          }
        });
      });
    }
    function restartNetwork(remoteStore) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var remoteStoreImpl;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              remoteStoreImpl = debugCast(remoteStore);
              remoteStoreImpl.offlineCauses.add(4);
              return [4, disableNetworkInternal(remoteStoreImpl)];
            case 1:
              _d.sent();
              remoteStoreImpl.onlineStateTracker.set("Unknown");
              remoteStoreImpl.offlineCauses.delete(4);
              return [4, enableNetworkInternal(remoteStoreImpl)];
            case 2:
              _d.sent();
              return [2];
          }
        });
      });
    }
    function remoteStoreHandleCredentialChange(remoteStore, user2) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var remoteStoreImpl, usesNetwork;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              remoteStoreImpl = debugCast(remoteStore);
              remoteStoreImpl.asyncQueue.verifyOperationInProgress();
              logDebug(LOG_TAG$5, "RemoteStore received new credentials");
              usesNetwork = canUseNetwork(remoteStoreImpl);
              remoteStoreImpl.offlineCauses.add(3);
              return [4, disableNetworkInternal(remoteStoreImpl)];
            case 1:
              _d.sent();
              if (usesNetwork) {
                remoteStoreImpl.onlineStateTracker.set("Unknown");
              }
              return [4, remoteStoreImpl.remoteSyncer.handleCredentialChange(user2)];
            case 2:
              _d.sent();
              remoteStoreImpl.offlineCauses.delete(3);
              return [4, enableNetworkInternal(remoteStoreImpl)];
            case 3:
              _d.sent();
              return [2];
          }
        });
      });
    }
    function remoteStoreApplyPrimaryState(remoteStore, isPrimary) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var remoteStoreImpl;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              remoteStoreImpl = debugCast(remoteStore);
              if (!isPrimary)
                return [3, 2];
              remoteStoreImpl.offlineCauses.delete(2);
              return [4, enableNetworkInternal(remoteStoreImpl)];
            case 1:
              _d.sent();
              return [3, 4];
            case 2:
              if (!!isPrimary)
                return [3, 4];
              remoteStoreImpl.offlineCauses.add(2);
              return [4, disableNetworkInternal(remoteStoreImpl)];
            case 3:
              _d.sent();
              remoteStoreImpl.onlineStateTracker.set("Unknown");
              _d.label = 4;
            case 4:
              return [2];
          }
        });
      });
    }
    function ensureWatchStream(remoteStoreImpl) {
      var _this = this;
      if (!remoteStoreImpl.watchStream) {
        remoteStoreImpl.watchStream = newPersistentWatchStream(remoteStoreImpl.datastore, remoteStoreImpl.asyncQueue, {
          onOpen: onWatchStreamOpen.bind(null, remoteStoreImpl),
          onClose: onWatchStreamClose.bind(null, remoteStoreImpl),
          onWatchChange: onWatchStreamChange.bind(null, remoteStoreImpl)
        });
        remoteStoreImpl.onNetworkStatusChange.push(function(enabled) {
          return tslib2.__awaiter(_this, void 0, void 0, function() {
            return tslib2.__generator(this, function(_d) {
              switch (_d.label) {
                case 0:
                  if (!enabled)
                    return [3, 1];
                  remoteStoreImpl.watchStream.inhibitBackoff();
                  if (shouldStartWatchStream(remoteStoreImpl)) {
                    startWatchStream(remoteStoreImpl);
                  } else {
                    remoteStoreImpl.onlineStateTracker.set("Unknown");
                  }
                  return [3, 3];
                case 1:
                  return [4, remoteStoreImpl.watchStream.stop()];
                case 2:
                  _d.sent();
                  cleanUpWatchStreamState(remoteStoreImpl);
                  _d.label = 3;
                case 3:
                  return [2];
              }
            });
          });
        });
      }
      return remoteStoreImpl.watchStream;
    }
    function ensureWriteStream(remoteStoreImpl) {
      var _this = this;
      if (!remoteStoreImpl.writeStream) {
        remoteStoreImpl.writeStream = newPersistentWriteStream(remoteStoreImpl.datastore, remoteStoreImpl.asyncQueue, {
          onOpen: onWriteStreamOpen.bind(null, remoteStoreImpl),
          onClose: onWriteStreamClose.bind(null, remoteStoreImpl),
          onHandshakeComplete: onWriteHandshakeComplete.bind(null, remoteStoreImpl),
          onMutationResult: onMutationResult.bind(null, remoteStoreImpl)
        });
        remoteStoreImpl.onNetworkStatusChange.push(function(enabled) {
          return tslib2.__awaiter(_this, void 0, void 0, function() {
            return tslib2.__generator(this, function(_d) {
              switch (_d.label) {
                case 0:
                  if (!enabled)
                    return [3, 2];
                  remoteStoreImpl.writeStream.inhibitBackoff();
                  return [4, fillWritePipeline(remoteStoreImpl)];
                case 1:
                  _d.sent();
                  return [3, 4];
                case 2:
                  return [4, remoteStoreImpl.writeStream.stop()];
                case 3:
                  _d.sent();
                  if (remoteStoreImpl.writePipeline.length > 0) {
                    logDebug(LOG_TAG$5, "Stopping write stream with " + remoteStoreImpl.writePipeline.length + " pending writes");
                    remoteStoreImpl.writePipeline = [];
                  }
                  _d.label = 4;
                case 4:
                  return [2];
              }
            });
          });
        });
      }
      return remoteStoreImpl.writeStream;
    }
    var LOG_TAG$4 = "AsyncQueue";
    var DelayedOperation = function() {
      function DelayedOperation2(asyncQueue, timerId, targetTimeMs, op, removalCallback) {
        this.asyncQueue = asyncQueue;
        this.timerId = timerId;
        this.targetTimeMs = targetTimeMs;
        this.op = op;
        this.removalCallback = removalCallback;
        this.deferred = new Deferred2();
        this.then = this.deferred.promise.then.bind(this.deferred.promise);
        this.deferred.promise.catch(function(err) {
        });
      }
      DelayedOperation2.createAndSchedule = function(asyncQueue, timerId, delayMs, op, removalCallback) {
        var targetTime = Date.now() + delayMs;
        var delayedOp = new DelayedOperation2(asyncQueue, timerId, targetTime, op, removalCallback);
        delayedOp.start(delayMs);
        return delayedOp;
      };
      DelayedOperation2.prototype.start = function(delayMs) {
        var _this = this;
        this.timerHandle = setTimeout(function() {
          return _this.handleDelayElapsed();
        }, delayMs);
      };
      DelayedOperation2.prototype.skipDelay = function() {
        return this.handleDelayElapsed();
      };
      DelayedOperation2.prototype.cancel = function(reason) {
        if (this.timerHandle !== null) {
          this.clearTimeout();
          this.deferred.reject(new FirestoreError(Code.CANCELLED, "Operation cancelled" + (reason ? ": " + reason : "")));
        }
      };
      DelayedOperation2.prototype.handleDelayElapsed = function() {
        var _this = this;
        this.asyncQueue.enqueueAndForget(function() {
          if (_this.timerHandle !== null) {
            _this.clearTimeout();
            return _this.op().then(function(result) {
              return _this.deferred.resolve(result);
            });
          } else {
            return Promise.resolve();
          }
        });
      };
      DelayedOperation2.prototype.clearTimeout = function() {
        if (this.timerHandle !== null) {
          this.removalCallback(this);
          clearTimeout(this.timerHandle);
          this.timerHandle = null;
        }
      };
      return DelayedOperation2;
    }();
    function wrapInUserErrorIfRecoverable(e, msg) {
      logError(LOG_TAG$4, msg + ": " + e);
      if (isIndexedDbTransactionError(e)) {
        return new FirestoreError(Code.UNAVAILABLE, msg + ": " + e);
      } else {
        throw e;
      }
    }
    var DocumentSet = function() {
      function DocumentSet2(comp) {
        if (comp) {
          this.comparator = function(d1, d2) {
            return comp(d1, d2) || DocumentKey.comparator(d1.key, d2.key);
          };
        } else {
          this.comparator = function(d1, d2) {
            return DocumentKey.comparator(d1.key, d2.key);
          };
        }
        this.keyedMap = documentMap();
        this.sortedSet = new SortedMap(this.comparator);
      }
      DocumentSet2.emptySet = function(oldSet) {
        return new DocumentSet2(oldSet.comparator);
      };
      DocumentSet2.prototype.has = function(key) {
        return this.keyedMap.get(key) != null;
      };
      DocumentSet2.prototype.get = function(key) {
        return this.keyedMap.get(key);
      };
      DocumentSet2.prototype.first = function() {
        return this.sortedSet.minKey();
      };
      DocumentSet2.prototype.last = function() {
        return this.sortedSet.maxKey();
      };
      DocumentSet2.prototype.isEmpty = function() {
        return this.sortedSet.isEmpty();
      };
      DocumentSet2.prototype.indexOf = function(key) {
        var doc2 = this.keyedMap.get(key);
        return doc2 ? this.sortedSet.indexOf(doc2) : -1;
      };
      Object.defineProperty(DocumentSet2.prototype, "size", {
        get: function() {
          return this.sortedSet.size;
        },
        enumerable: false,
        configurable: true
      });
      DocumentSet2.prototype.forEach = function(cb) {
        this.sortedSet.inorderTraversal(function(k, v) {
          cb(k);
          return false;
        });
      };
      DocumentSet2.prototype.add = function(doc2) {
        var set2 = this.delete(doc2.key);
        return set2.copy(set2.keyedMap.insert(doc2.key, doc2), set2.sortedSet.insert(doc2, null));
      };
      DocumentSet2.prototype.delete = function(key) {
        var doc2 = this.get(key);
        if (!doc2) {
          return this;
        }
        return this.copy(this.keyedMap.remove(key), this.sortedSet.remove(doc2));
      };
      DocumentSet2.prototype.isEqual = function(other) {
        if (!(other instanceof DocumentSet2)) {
          return false;
        }
        if (this.size !== other.size) {
          return false;
        }
        var thisIt = this.sortedSet.getIterator();
        var otherIt = other.sortedSet.getIterator();
        while (thisIt.hasNext()) {
          var thisDoc = thisIt.getNext().key;
          var otherDoc = otherIt.getNext().key;
          if (!thisDoc.isEqual(otherDoc)) {
            return false;
          }
        }
        return true;
      };
      DocumentSet2.prototype.toString = function() {
        var docStrings = [];
        this.forEach(function(doc2) {
          docStrings.push(doc2.toString());
        });
        if (docStrings.length === 0) {
          return "DocumentSet ()";
        } else {
          return "DocumentSet (\n  " + docStrings.join("  \n") + "\n)";
        }
      };
      DocumentSet2.prototype.copy = function(keyedMap, sortedSet) {
        var newSet = new DocumentSet2();
        newSet.comparator = this.comparator;
        newSet.keyedMap = keyedMap;
        newSet.sortedSet = sortedSet;
        return newSet;
      };
      return DocumentSet2;
    }();
    var DocumentChangeSet = function() {
      function DocumentChangeSet2() {
        this.changeMap = new SortedMap(DocumentKey.comparator);
      }
      DocumentChangeSet2.prototype.track = function(change) {
        var key = change.doc.key;
        var oldChange = this.changeMap.get(key);
        if (!oldChange) {
          this.changeMap = this.changeMap.insert(key, change);
          return;
        }
        if (change.type !== 0 && oldChange.type === 3) {
          this.changeMap = this.changeMap.insert(key, change);
        } else if (change.type === 3 && oldChange.type !== 1) {
          this.changeMap = this.changeMap.insert(key, {
            type: oldChange.type,
            doc: change.doc
          });
        } else if (change.type === 2 && oldChange.type === 2) {
          this.changeMap = this.changeMap.insert(key, {
            type: 2,
            doc: change.doc
          });
        } else if (change.type === 2 && oldChange.type === 0) {
          this.changeMap = this.changeMap.insert(key, {
            type: 0,
            doc: change.doc
          });
        } else if (change.type === 1 && oldChange.type === 0) {
          this.changeMap = this.changeMap.remove(key);
        } else if (change.type === 1 && oldChange.type === 2) {
          this.changeMap = this.changeMap.insert(key, {
            type: 1,
            doc: oldChange.doc
          });
        } else if (change.type === 0 && oldChange.type === 1) {
          this.changeMap = this.changeMap.insert(key, {
            type: 2,
            doc: change.doc
          });
        } else {
          fail();
        }
      };
      DocumentChangeSet2.prototype.getChanges = function() {
        var changes = [];
        this.changeMap.inorderTraversal(function(key, change) {
          changes.push(change);
        });
        return changes;
      };
      return DocumentChangeSet2;
    }();
    var ViewSnapshot = function() {
      function ViewSnapshot2(query2, docs, oldDocs, docChanges, mutatedKeys, fromCache, syncStateChanged, excludesMetadataChanges) {
        this.query = query2;
        this.docs = docs;
        this.oldDocs = oldDocs;
        this.docChanges = docChanges;
        this.mutatedKeys = mutatedKeys;
        this.fromCache = fromCache;
        this.syncStateChanged = syncStateChanged;
        this.excludesMetadataChanges = excludesMetadataChanges;
      }
      ViewSnapshot2.fromInitialDocuments = function(query2, documents, mutatedKeys, fromCache) {
        var changes = [];
        documents.forEach(function(doc2) {
          changes.push({ type: 0, doc: doc2 });
        });
        return new ViewSnapshot2(query2, documents, DocumentSet.emptySet(documents), changes, mutatedKeys, fromCache, true, false);
      };
      Object.defineProperty(ViewSnapshot2.prototype, "hasPendingWrites", {
        get: function() {
          return !this.mutatedKeys.isEmpty();
        },
        enumerable: false,
        configurable: true
      });
      ViewSnapshot2.prototype.isEqual = function(other) {
        if (this.fromCache !== other.fromCache || this.syncStateChanged !== other.syncStateChanged || !this.mutatedKeys.isEqual(other.mutatedKeys) || !queryEquals(this.query, other.query) || !this.docs.isEqual(other.docs) || !this.oldDocs.isEqual(other.oldDocs)) {
          return false;
        }
        var changes = this.docChanges;
        var otherChanges = other.docChanges;
        if (changes.length !== otherChanges.length) {
          return false;
        }
        for (var i = 0; i < changes.length; i++) {
          if (changes[i].type !== otherChanges[i].type || !changes[i].doc.isEqual(otherChanges[i].doc)) {
            return false;
          }
        }
        return true;
      };
      return ViewSnapshot2;
    }();
    var QueryListenersInfo = function() {
      function QueryListenersInfo2() {
        this.viewSnap = void 0;
        this.listeners = [];
      }
      return QueryListenersInfo2;
    }();
    function newEventManager() {
      return new EventManagerImpl();
    }
    var EventManagerImpl = function() {
      function EventManagerImpl2() {
        this.queries = new ObjectMap(function(q) {
          return canonifyQuery(q);
        }, queryEquals);
        this.onlineState = "Unknown";
        this.snapshotsInSyncListeners = new Set();
      }
      return EventManagerImpl2;
    }();
    function eventManagerListen(eventManager, listener) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var eventManagerImpl, query2, firstListen, queryInfo, _d, e_7, firestoreError, raisedEvent;
        return tslib2.__generator(this, function(_e) {
          switch (_e.label) {
            case 0:
              eventManagerImpl = debugCast(eventManager);
              query2 = listener.query;
              firstListen = false;
              queryInfo = eventManagerImpl.queries.get(query2);
              if (!queryInfo) {
                firstListen = true;
                queryInfo = new QueryListenersInfo();
              }
              if (!firstListen)
                return [3, 4];
              _e.label = 1;
            case 1:
              _e.trys.push([1, 3, , 4]);
              _d = queryInfo;
              return [4, eventManagerImpl.onListen(query2)];
            case 2:
              _d.viewSnap = _e.sent();
              return [3, 4];
            case 3:
              e_7 = _e.sent();
              firestoreError = wrapInUserErrorIfRecoverable(e_7, "Initialization of query '" + stringifyQuery(listener.query) + "' failed");
              listener.onError(firestoreError);
              return [2];
            case 4:
              eventManagerImpl.queries.set(query2, queryInfo);
              queryInfo.listeners.push(listener);
              listener.applyOnlineStateChange(eventManagerImpl.onlineState);
              if (queryInfo.viewSnap) {
                raisedEvent = listener.onViewSnapshot(queryInfo.viewSnap);
                if (raisedEvent) {
                  raiseSnapshotsInSyncEvent(eventManagerImpl);
                }
              }
              return [2];
          }
        });
      });
    }
    function eventManagerUnlisten(eventManager, listener) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var eventManagerImpl, query2, lastListen, queryInfo, i;
        return tslib2.__generator(this, function(_d) {
          eventManagerImpl = debugCast(eventManager);
          query2 = listener.query;
          lastListen = false;
          queryInfo = eventManagerImpl.queries.get(query2);
          if (queryInfo) {
            i = queryInfo.listeners.indexOf(listener);
            if (i >= 0) {
              queryInfo.listeners.splice(i, 1);
              lastListen = queryInfo.listeners.length === 0;
            }
          }
          if (lastListen) {
            eventManagerImpl.queries.delete(query2);
            return [2, eventManagerImpl.onUnlisten(query2)];
          }
          return [2];
        });
      });
    }
    function eventManagerOnWatchChange(eventManager, viewSnaps) {
      var eventManagerImpl = debugCast(eventManager);
      var raisedEvent = false;
      for (var _i = 0, viewSnaps_1 = viewSnaps; _i < viewSnaps_1.length; _i++) {
        var viewSnap = viewSnaps_1[_i];
        var query_1 = viewSnap.query;
        var queryInfo = eventManagerImpl.queries.get(query_1);
        if (queryInfo) {
          for (var _d = 0, _e = queryInfo.listeners; _d < _e.length; _d++) {
            var listener = _e[_d];
            if (listener.onViewSnapshot(viewSnap)) {
              raisedEvent = true;
            }
          }
          queryInfo.viewSnap = viewSnap;
        }
      }
      if (raisedEvent) {
        raiseSnapshotsInSyncEvent(eventManagerImpl);
      }
    }
    function eventManagerOnWatchError(eventManager, query2, error2) {
      var eventManagerImpl = debugCast(eventManager);
      var queryInfo = eventManagerImpl.queries.get(query2);
      if (queryInfo) {
        for (var _i = 0, _d = queryInfo.listeners; _i < _d.length; _i++) {
          var listener = _d[_i];
          listener.onError(error2);
        }
      }
      eventManagerImpl.queries.delete(query2);
    }
    function eventManagerOnOnlineStateChange(eventManager, onlineState) {
      var eventManagerImpl = debugCast(eventManager);
      eventManagerImpl.onlineState = onlineState;
      var raisedEvent = false;
      eventManagerImpl.queries.forEach(function(_, queryInfo) {
        for (var _i = 0, _d = queryInfo.listeners; _i < _d.length; _i++) {
          var listener = _d[_i];
          if (listener.applyOnlineStateChange(onlineState)) {
            raisedEvent = true;
          }
        }
      });
      if (raisedEvent) {
        raiseSnapshotsInSyncEvent(eventManagerImpl);
      }
    }
    function addSnapshotsInSyncListener(eventManager, observer) {
      var eventManagerImpl = debugCast(eventManager);
      eventManagerImpl.snapshotsInSyncListeners.add(observer);
      observer.next();
    }
    function removeSnapshotsInSyncListener(eventManager, observer) {
      var eventManagerImpl = debugCast(eventManager);
      eventManagerImpl.snapshotsInSyncListeners.delete(observer);
    }
    function raiseSnapshotsInSyncEvent(eventManagerImpl) {
      eventManagerImpl.snapshotsInSyncListeners.forEach(function(observer) {
        observer.next();
      });
    }
    var QueryListener = function() {
      function QueryListener2(query2, queryObserver, options2) {
        this.query = query2;
        this.queryObserver = queryObserver;
        this.raisedInitialEvent = false;
        this.snap = null;
        this.onlineState = "Unknown";
        this.options = options2 || {};
      }
      QueryListener2.prototype.onViewSnapshot = function(snap) {
        if (!this.options.includeMetadataChanges) {
          var docChanges = [];
          for (var _i = 0, _d = snap.docChanges; _i < _d.length; _i++) {
            var docChange = _d[_i];
            if (docChange.type !== 3) {
              docChanges.push(docChange);
            }
          }
          snap = new ViewSnapshot(snap.query, snap.docs, snap.oldDocs, docChanges, snap.mutatedKeys, snap.fromCache, snap.syncStateChanged, true);
        }
        var raisedEvent = false;
        if (!this.raisedInitialEvent) {
          if (this.shouldRaiseInitialEvent(snap, this.onlineState)) {
            this.raiseInitialEvent(snap);
            raisedEvent = true;
          }
        } else if (this.shouldRaiseEvent(snap)) {
          this.queryObserver.next(snap);
          raisedEvent = true;
        }
        this.snap = snap;
        return raisedEvent;
      };
      QueryListener2.prototype.onError = function(error2) {
        this.queryObserver.error(error2);
      };
      QueryListener2.prototype.applyOnlineStateChange = function(onlineState) {
        this.onlineState = onlineState;
        var raisedEvent = false;
        if (this.snap && !this.raisedInitialEvent && this.shouldRaiseInitialEvent(this.snap, onlineState)) {
          this.raiseInitialEvent(this.snap);
          raisedEvent = true;
        }
        return raisedEvent;
      };
      QueryListener2.prototype.shouldRaiseInitialEvent = function(snap, onlineState) {
        if (!snap.fromCache) {
          return true;
        }
        var maybeOnline = onlineState !== "Offline";
        if (this.options.waitForSyncWhenOnline && maybeOnline) {
          return false;
        }
        return !snap.docs.isEmpty() || onlineState === "Offline";
      };
      QueryListener2.prototype.shouldRaiseEvent = function(snap) {
        if (snap.docChanges.length > 0) {
          return true;
        }
        var hasPendingWritesChanged = this.snap && this.snap.hasPendingWrites !== snap.hasPendingWrites;
        if (snap.syncStateChanged || hasPendingWritesChanged) {
          return this.options.includeMetadataChanges === true;
        }
        return false;
      };
      QueryListener2.prototype.raiseInitialEvent = function(snap) {
        snap = ViewSnapshot.fromInitialDocuments(snap.query, snap.docs, snap.mutatedKeys, snap.fromCache);
        this.raisedInitialEvent = true;
        this.queryObserver.next(snap);
      };
      return QueryListener2;
    }();
    var LocalViewChanges = function() {
      function LocalViewChanges2(targetId, fromCache, addedKeys, removedKeys) {
        this.targetId = targetId;
        this.fromCache = fromCache;
        this.addedKeys = addedKeys;
        this.removedKeys = removedKeys;
      }
      LocalViewChanges2.fromSnapshot = function(targetId, viewSnapshot) {
        var addedKeys = documentKeySet();
        var removedKeys = documentKeySet();
        for (var _i = 0, _d = viewSnapshot.docChanges; _i < _d.length; _i++) {
          var docChange = _d[_i];
          switch (docChange.type) {
            case 0:
              addedKeys = addedKeys.add(docChange.doc.key);
              break;
            case 1:
              removedKeys = removedKeys.add(docChange.doc.key);
              break;
          }
        }
        return new LocalViewChanges2(targetId, viewSnapshot.fromCache, addedKeys, removedKeys);
      };
      return LocalViewChanges2;
    }();
    var BundleLoadResult = function() {
      function BundleLoadResult2(progress, changedDocs) {
        this.progress = progress;
        this.changedDocs = changedDocs;
      }
      return BundleLoadResult2;
    }();
    var BundleConverterImpl = function() {
      function BundleConverterImpl2(serializer) {
        this.serializer = serializer;
      }
      BundleConverterImpl2.prototype.toDocumentKey = function(name3) {
        return fromName(this.serializer, name3);
      };
      BundleConverterImpl2.prototype.toMutableDocument = function(bundledDoc) {
        if (bundledDoc.metadata.exists) {
          return fromDocument(this.serializer, bundledDoc.document, false);
        } else {
          return MutableDocument.newNoDocument(this.toDocumentKey(bundledDoc.metadata.name), this.toSnapshotVersion(bundledDoc.metadata.readTime));
        }
      };
      BundleConverterImpl2.prototype.toSnapshotVersion = function(time) {
        return fromVersion(time);
      };
      return BundleConverterImpl2;
    }();
    var BundleLoader = function() {
      function BundleLoader2(bundleMetadata, localStore2, serializer) {
        this.bundleMetadata = bundleMetadata;
        this.localStore = localStore2;
        this.serializer = serializer;
        this.queries = [];
        this.documents = [];
        this.progress = bundleInitialProgress(bundleMetadata);
      }
      BundleLoader2.prototype.addSizedElement = function(element) {
        this.progress.bytesLoaded += element.byteLength;
        var documentsLoaded = this.progress.documentsLoaded;
        if (element.payload.namedQuery) {
          this.queries.push(element.payload.namedQuery);
        } else if (element.payload.documentMetadata) {
          this.documents.push({ metadata: element.payload.documentMetadata });
          if (!element.payload.documentMetadata.exists) {
            ++documentsLoaded;
          }
        } else if (element.payload.document) {
          this.documents[this.documents.length - 1].document = element.payload.document;
          ++documentsLoaded;
        }
        if (documentsLoaded !== this.progress.documentsLoaded) {
          this.progress.documentsLoaded = documentsLoaded;
          return Object.assign({}, this.progress);
        }
        return null;
      };
      BundleLoader2.prototype.getQueryDocumentMapping = function(documents) {
        var queryDocumentMap = new Map();
        var bundleConverter = new BundleConverterImpl(this.serializer);
        for (var _i = 0, documents_2 = documents; _i < documents_2.length; _i++) {
          var bundleDoc = documents_2[_i];
          if (bundleDoc.metadata.queries) {
            var documentKey = bundleConverter.toDocumentKey(bundleDoc.metadata.name);
            for (var _d = 0, _e = bundleDoc.metadata.queries; _d < _e.length; _d++) {
              var queryName = _e[_d];
              var documentKeys = (queryDocumentMap.get(queryName) || documentKeySet()).add(documentKey);
              queryDocumentMap.set(queryName, documentKeys);
            }
          }
        }
        return queryDocumentMap;
      };
      BundleLoader2.prototype.complete = function() {
        return tslib2.__awaiter(this, void 0, void 0, function() {
          var changedDocuments, queryDocumentMap, _i, _d, q;
          return tslib2.__generator(this, function(_e) {
            switch (_e.label) {
              case 0:
                return [4, localStoreApplyBundledDocuments(this.localStore, new BundleConverterImpl(this.serializer), this.documents, this.bundleMetadata.id)];
              case 1:
                changedDocuments = _e.sent();
                queryDocumentMap = this.getQueryDocumentMapping(this.documents);
                _i = 0, _d = this.queries;
                _e.label = 2;
              case 2:
                if (!(_i < _d.length))
                  return [3, 5];
                q = _d[_i];
                return [4, localStoreSaveNamedQuery(this.localStore, q, queryDocumentMap.get(q.name))];
              case 3:
                _e.sent();
                _e.label = 4;
              case 4:
                _i++;
                return [3, 2];
              case 5:
                this.progress.taskState = "Success";
                return [2, new BundleLoadResult(Object.assign({}, this.progress), changedDocuments)];
            }
          });
        });
      };
      return BundleLoader2;
    }();
    function bundleInitialProgress(metadata) {
      return {
        taskState: "Running",
        documentsLoaded: 0,
        bytesLoaded: 0,
        totalDocuments: metadata.totalDocuments,
        totalBytes: metadata.totalBytes
      };
    }
    function bundleSuccessProgress(metadata) {
      return {
        taskState: "Success",
        documentsLoaded: metadata.totalDocuments,
        bytesLoaded: metadata.totalBytes,
        totalDocuments: metadata.totalDocuments,
        totalBytes: metadata.totalBytes
      };
    }
    var AddedLimboDocument = function() {
      function AddedLimboDocument2(key) {
        this.key = key;
      }
      return AddedLimboDocument2;
    }();
    var RemovedLimboDocument = function() {
      function RemovedLimboDocument2(key) {
        this.key = key;
      }
      return RemovedLimboDocument2;
    }();
    var View = function() {
      function View2(query2, _syncedDocuments) {
        this.query = query2;
        this._syncedDocuments = _syncedDocuments;
        this.syncState = null;
        this.current = false;
        this.limboDocuments = documentKeySet();
        this.mutatedKeys = documentKeySet();
        this.docComparator = newQueryComparator(query2);
        this.documentSet = new DocumentSet(this.docComparator);
      }
      Object.defineProperty(View2.prototype, "syncedDocuments", {
        get: function() {
          return this._syncedDocuments;
        },
        enumerable: false,
        configurable: true
      });
      View2.prototype.computeDocChanges = function(docChanges, previousChanges) {
        var _this = this;
        var changeSet = previousChanges ? previousChanges.changeSet : new DocumentChangeSet();
        var oldDocumentSet = previousChanges ? previousChanges.documentSet : this.documentSet;
        var newMutatedKeys = previousChanges ? previousChanges.mutatedKeys : this.mutatedKeys;
        var newDocumentSet = oldDocumentSet;
        var needsRefill = false;
        var lastDocInLimit = hasLimitToFirst(this.query) && oldDocumentSet.size === this.query.limit ? oldDocumentSet.last() : null;
        var firstDocInLimit = hasLimitToLast(this.query) && oldDocumentSet.size === this.query.limit ? oldDocumentSet.first() : null;
        docChanges.inorderTraversal(function(key, entry) {
          var oldDoc2 = oldDocumentSet.get(key);
          var newDoc = queryMatches(_this.query, entry) ? entry : null;
          var oldDocHadPendingMutations = oldDoc2 ? _this.mutatedKeys.has(oldDoc2.key) : false;
          var newDocHasPendingMutations = newDoc ? newDoc.hasLocalMutations || _this.mutatedKeys.has(newDoc.key) && newDoc.hasCommittedMutations : false;
          var changeApplied = false;
          if (oldDoc2 && newDoc) {
            var docsEqual = oldDoc2.data.isEqual(newDoc.data);
            if (!docsEqual) {
              if (!_this.shouldWaitForSyncedDocument(oldDoc2, newDoc)) {
                changeSet.track({
                  type: 2,
                  doc: newDoc
                });
                changeApplied = true;
                if (lastDocInLimit && _this.docComparator(newDoc, lastDocInLimit) > 0 || firstDocInLimit && _this.docComparator(newDoc, firstDocInLimit) < 0) {
                  needsRefill = true;
                }
              }
            } else if (oldDocHadPendingMutations !== newDocHasPendingMutations) {
              changeSet.track({ type: 3, doc: newDoc });
              changeApplied = true;
            }
          } else if (!oldDoc2 && newDoc) {
            changeSet.track({ type: 0, doc: newDoc });
            changeApplied = true;
          } else if (oldDoc2 && !newDoc) {
            changeSet.track({ type: 1, doc: oldDoc2 });
            changeApplied = true;
            if (lastDocInLimit || firstDocInLimit) {
              needsRefill = true;
            }
          }
          if (changeApplied) {
            if (newDoc) {
              newDocumentSet = newDocumentSet.add(newDoc);
              if (newDocHasPendingMutations) {
                newMutatedKeys = newMutatedKeys.add(key);
              } else {
                newMutatedKeys = newMutatedKeys.delete(key);
              }
            } else {
              newDocumentSet = newDocumentSet.delete(key);
              newMutatedKeys = newMutatedKeys.delete(key);
            }
          }
        });
        if (hasLimitToFirst(this.query) || hasLimitToLast(this.query)) {
          while (newDocumentSet.size > this.query.limit) {
            var oldDoc = hasLimitToFirst(this.query) ? newDocumentSet.last() : newDocumentSet.first();
            newDocumentSet = newDocumentSet.delete(oldDoc.key);
            newMutatedKeys = newMutatedKeys.delete(oldDoc.key);
            changeSet.track({ type: 1, doc: oldDoc });
          }
        }
        return {
          documentSet: newDocumentSet,
          changeSet,
          needsRefill,
          mutatedKeys: newMutatedKeys
        };
      };
      View2.prototype.shouldWaitForSyncedDocument = function(oldDoc, newDoc) {
        return oldDoc.hasLocalMutations && newDoc.hasCommittedMutations && !newDoc.hasLocalMutations;
      };
      View2.prototype.applyChanges = function(docChanges, updateLimboDocuments, targetChange) {
        var _this = this;
        var oldDocs = this.documentSet;
        this.documentSet = docChanges.documentSet;
        this.mutatedKeys = docChanges.mutatedKeys;
        var changes = docChanges.changeSet.getChanges();
        changes.sort(function(c1, c2) {
          return compareChangeType(c1.type, c2.type) || _this.docComparator(c1.doc, c2.doc);
        });
        this.applyTargetChange(targetChange);
        var limboChanges = updateLimboDocuments ? this.updateLimboDocuments() : [];
        var synced = this.limboDocuments.size === 0 && this.current;
        var newSyncState = synced ? 1 : 0;
        var syncStateChanged = newSyncState !== this.syncState;
        this.syncState = newSyncState;
        if (changes.length === 0 && !syncStateChanged) {
          return { limboChanges };
        } else {
          var snap = new ViewSnapshot(this.query, docChanges.documentSet, oldDocs, changes, docChanges.mutatedKeys, newSyncState === 0, syncStateChanged, false);
          return {
            snapshot: snap,
            limboChanges
          };
        }
      };
      View2.prototype.applyOnlineStateChange = function(onlineState) {
        if (this.current && onlineState === "Offline") {
          this.current = false;
          return this.applyChanges({
            documentSet: this.documentSet,
            changeSet: new DocumentChangeSet(),
            mutatedKeys: this.mutatedKeys,
            needsRefill: false
          }, false);
        } else {
          return { limboChanges: [] };
        }
      };
      View2.prototype.shouldBeInLimbo = function(key) {
        if (this._syncedDocuments.has(key)) {
          return false;
        }
        if (!this.documentSet.has(key)) {
          return false;
        }
        if (this.documentSet.get(key).hasLocalMutations) {
          return false;
        }
        return true;
      };
      View2.prototype.applyTargetChange = function(targetChange) {
        var _this = this;
        if (targetChange) {
          targetChange.addedDocuments.forEach(function(key) {
            return _this._syncedDocuments = _this._syncedDocuments.add(key);
          });
          targetChange.modifiedDocuments.forEach(function(key) {
          });
          targetChange.removedDocuments.forEach(function(key) {
            return _this._syncedDocuments = _this._syncedDocuments.delete(key);
          });
          this.current = targetChange.current;
        }
      };
      View2.prototype.updateLimboDocuments = function() {
        var _this = this;
        if (!this.current) {
          return [];
        }
        var oldLimboDocuments = this.limboDocuments;
        this.limboDocuments = documentKeySet();
        this.documentSet.forEach(function(doc2) {
          if (_this.shouldBeInLimbo(doc2.key)) {
            _this.limboDocuments = _this.limboDocuments.add(doc2.key);
          }
        });
        var changes = [];
        oldLimboDocuments.forEach(function(key) {
          if (!_this.limboDocuments.has(key)) {
            changes.push(new RemovedLimboDocument(key));
          }
        });
        this.limboDocuments.forEach(function(key) {
          if (!oldLimboDocuments.has(key)) {
            changes.push(new AddedLimboDocument(key));
          }
        });
        return changes;
      };
      View2.prototype.synchronizeWithPersistedState = function(queryResult) {
        this._syncedDocuments = queryResult.remoteKeys;
        this.limboDocuments = documentKeySet();
        var docChanges = this.computeDocChanges(queryResult.documents);
        return this.applyChanges(docChanges, true);
      };
      View2.prototype.computeInitialSnapshot = function() {
        return ViewSnapshot.fromInitialDocuments(this.query, this.documentSet, this.mutatedKeys, this.syncState === 0);
      };
      return View2;
    }();
    function compareChangeType(c1, c2) {
      var order = function(change) {
        switch (change) {
          case 0:
            return 1;
          case 2:
            return 2;
          case 3:
            return 2;
          case 1:
            return 0;
          default:
            return fail();
        }
      };
      return order(c1) - order(c2);
    }
    var LOG_TAG$3 = "SyncEngine";
    var QueryView = function() {
      function QueryView2(query2, targetId, view) {
        this.query = query2;
        this.targetId = targetId;
        this.view = view;
      }
      return QueryView2;
    }();
    var LimboResolution = function() {
      function LimboResolution2(key) {
        this.key = key;
        this.receivedDocument = false;
      }
      return LimboResolution2;
    }();
    var SyncEngineImpl = function() {
      function SyncEngineImpl2(localStore2, remoteStore, eventManager, sharedClientState, currentUser, maxConcurrentLimboResolutions) {
        this.localStore = localStore2;
        this.remoteStore = remoteStore;
        this.eventManager = eventManager;
        this.sharedClientState = sharedClientState;
        this.currentUser = currentUser;
        this.maxConcurrentLimboResolutions = maxConcurrentLimboResolutions;
        this.syncEngineListener = {};
        this.queryViewsByQuery = new ObjectMap(function(q) {
          return canonifyQuery(q);
        }, queryEquals);
        this.queriesByTarget = new Map();
        this.enqueuedLimboResolutions = new Set();
        this.activeLimboTargetsByKey = new SortedMap(DocumentKey.comparator);
        this.activeLimboResolutionsByTarget = new Map();
        this.limboDocumentRefs = new ReferenceSet();
        this.mutationUserCallbacks = {};
        this.pendingWritesCallbacks = new Map();
        this.limboTargetIdGenerator = TargetIdGenerator.forSyncEngine();
        this.onlineState = "Unknown";
        this._isPrimaryClient = void 0;
      }
      Object.defineProperty(SyncEngineImpl2.prototype, "isPrimaryClient", {
        get: function() {
          return this._isPrimaryClient === true;
        },
        enumerable: false,
        configurable: true
      });
      return SyncEngineImpl2;
    }();
    function newSyncEngine(localStore2, remoteStore, eventManager, sharedClientState, currentUser, maxConcurrentLimboResolutions, isPrimary) {
      var syncEngine = new SyncEngineImpl(localStore2, remoteStore, eventManager, sharedClientState, currentUser, maxConcurrentLimboResolutions);
      if (isPrimary) {
        syncEngine._isPrimaryClient = true;
      }
      return syncEngine;
    }
    function syncEngineListen(syncEngine, query2) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var syncEngineImpl, targetId, viewSnapshot, queryView, targetData, status_1;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              syncEngineImpl = ensureWatchCallbacks(syncEngine);
              queryView = syncEngineImpl.queryViewsByQuery.get(query2);
              if (!queryView)
                return [3, 1];
              targetId = queryView.targetId;
              syncEngineImpl.sharedClientState.addLocalQueryTarget(targetId);
              viewSnapshot = queryView.view.computeInitialSnapshot();
              return [3, 4];
            case 1:
              return [4, localStoreAllocateTarget(syncEngineImpl.localStore, queryToTarget(query2))];
            case 2:
              targetData = _d.sent();
              status_1 = syncEngineImpl.sharedClientState.addLocalQueryTarget(targetData.targetId);
              targetId = targetData.targetId;
              return [4, initializeViewAndComputeSnapshot(syncEngineImpl, query2, targetId, status_1 === "current")];
            case 3:
              viewSnapshot = _d.sent();
              if (syncEngineImpl.isPrimaryClient) {
                remoteStoreListen(syncEngineImpl.remoteStore, targetData);
              }
              _d.label = 4;
            case 4:
              return [2, viewSnapshot];
          }
        });
      });
    }
    function initializeViewAndComputeSnapshot(syncEngineImpl, query2, targetId, current) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var queryResult, view, viewDocChanges, synthesizedTargetChange, viewChange, data;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              syncEngineImpl.applyDocChanges = function(queryView, changes, remoteEvent) {
                return applyDocChanges(syncEngineImpl, queryView, changes, remoteEvent);
              };
              return [4, localStoreExecuteQuery(syncEngineImpl.localStore, query2, true)];
            case 1:
              queryResult = _d.sent();
              view = new View(query2, queryResult.remoteKeys);
              viewDocChanges = view.computeDocChanges(queryResult.documents);
              synthesizedTargetChange = TargetChange.createSynthesizedTargetChangeForCurrentChange(targetId, current && syncEngineImpl.onlineState !== "Offline");
              viewChange = view.applyChanges(viewDocChanges, syncEngineImpl.isPrimaryClient, synthesizedTargetChange);
              updateTrackedLimbos(syncEngineImpl, targetId, viewChange.limboChanges);
              data = new QueryView(query2, targetId, view);
              syncEngineImpl.queryViewsByQuery.set(query2, data);
              if (syncEngineImpl.queriesByTarget.has(targetId)) {
                syncEngineImpl.queriesByTarget.get(targetId).push(query2);
              } else {
                syncEngineImpl.queriesByTarget.set(targetId, [query2]);
              }
              return [2, viewChange.snapshot];
          }
        });
      });
    }
    function syncEngineUnlisten(syncEngine, query2) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var syncEngineImpl, queryView, queries, targetRemainsActive;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              syncEngineImpl = debugCast(syncEngine);
              queryView = syncEngineImpl.queryViewsByQuery.get(query2);
              queries = syncEngineImpl.queriesByTarget.get(queryView.targetId);
              if (queries.length > 1) {
                syncEngineImpl.queriesByTarget.set(queryView.targetId, queries.filter(function(q) {
                  return !queryEquals(q, query2);
                }));
                syncEngineImpl.queryViewsByQuery.delete(query2);
                return [2];
              }
              if (!syncEngineImpl.isPrimaryClient)
                return [3, 3];
              syncEngineImpl.sharedClientState.removeLocalQueryTarget(queryView.targetId);
              targetRemainsActive = syncEngineImpl.sharedClientState.isActiveQueryTarget(queryView.targetId);
              if (!!targetRemainsActive)
                return [3, 2];
              return [4, localStoreReleaseTarget(syncEngineImpl.localStore, queryView.targetId, false).then(function() {
                syncEngineImpl.sharedClientState.clearQueryState(queryView.targetId);
                remoteStoreUnlisten(syncEngineImpl.remoteStore, queryView.targetId);
                removeAndCleanupTarget(syncEngineImpl, queryView.targetId);
              }).catch(ignoreIfPrimaryLeaseLoss)];
            case 1:
              _d.sent();
              _d.label = 2;
            case 2:
              return [3, 5];
            case 3:
              removeAndCleanupTarget(syncEngineImpl, queryView.targetId);
              return [4, localStoreReleaseTarget(syncEngineImpl.localStore, queryView.targetId, true)];
            case 4:
              _d.sent();
              _d.label = 5;
            case 5:
              return [2];
          }
        });
      });
    }
    function syncEngineWrite(syncEngine, batch, userCallback) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var syncEngineImpl, result, e_8, error2;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              syncEngineImpl = syncEngineEnsureWriteCallbacks(syncEngine);
              _d.label = 1;
            case 1:
              _d.trys.push([1, 5, , 6]);
              return [4, localStoreWriteLocally(syncEngineImpl.localStore, batch)];
            case 2:
              result = _d.sent();
              syncEngineImpl.sharedClientState.addPendingMutation(result.batchId);
              addMutationCallback(syncEngineImpl, result.batchId, userCallback);
              return [4, syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, result.changes)];
            case 3:
              _d.sent();
              return [4, fillWritePipeline(syncEngineImpl.remoteStore)];
            case 4:
              _d.sent();
              return [3, 6];
            case 5:
              e_8 = _d.sent();
              error2 = wrapInUserErrorIfRecoverable(e_8, "Failed to persist write");
              userCallback.reject(error2);
              return [3, 6];
            case 6:
              return [2];
          }
        });
      });
    }
    function syncEngineApplyRemoteEvent(syncEngine, remoteEvent) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var syncEngineImpl, changes, error_2;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              syncEngineImpl = debugCast(syncEngine);
              _d.label = 1;
            case 1:
              _d.trys.push([1, 4, , 6]);
              return [4, localStoreApplyRemoteEventToLocalCache(syncEngineImpl.localStore, remoteEvent)];
            case 2:
              changes = _d.sent();
              remoteEvent.targetChanges.forEach(function(targetChange, targetId) {
                var limboResolution = syncEngineImpl.activeLimboResolutionsByTarget.get(targetId);
                if (limboResolution) {
                  hardAssert(targetChange.addedDocuments.size + targetChange.modifiedDocuments.size + targetChange.removedDocuments.size <= 1);
                  if (targetChange.addedDocuments.size > 0) {
                    limboResolution.receivedDocument = true;
                  } else if (targetChange.modifiedDocuments.size > 0) {
                    hardAssert(limboResolution.receivedDocument);
                  } else if (targetChange.removedDocuments.size > 0) {
                    hardAssert(limboResolution.receivedDocument);
                    limboResolution.receivedDocument = false;
                  } else
                    ;
                }
              });
              return [4, syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes, remoteEvent)];
            case 3:
              _d.sent();
              return [3, 6];
            case 4:
              error_2 = _d.sent();
              return [4, ignoreIfPrimaryLeaseLoss(error_2)];
            case 5:
              _d.sent();
              return [3, 6];
            case 6:
              return [2];
          }
        });
      });
    }
    function syncEngineApplyOnlineStateChange(syncEngine, onlineState, source) {
      var syncEngineImpl = debugCast(syncEngine);
      if (syncEngineImpl.isPrimaryClient && source === 0 || !syncEngineImpl.isPrimaryClient && source === 1) {
        var newViewSnapshots_1 = [];
        syncEngineImpl.queryViewsByQuery.forEach(function(query2, queryView) {
          var viewChange = queryView.view.applyOnlineStateChange(onlineState);
          if (viewChange.snapshot) {
            newViewSnapshots_1.push(viewChange.snapshot);
          }
        });
        eventManagerOnOnlineStateChange(syncEngineImpl.eventManager, onlineState);
        if (newViewSnapshots_1.length) {
          syncEngineImpl.syncEngineListener.onWatchChange(newViewSnapshots_1);
        }
        syncEngineImpl.onlineState = onlineState;
        if (syncEngineImpl.isPrimaryClient) {
          syncEngineImpl.sharedClientState.setOnlineState(onlineState);
        }
      }
    }
    function syncEngineRejectListen(syncEngine, targetId, err) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var syncEngineImpl, limboResolution, limboKey, documentUpdates, resolvedLimboDocuments, event_2;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              syncEngineImpl = debugCast(syncEngine);
              syncEngineImpl.sharedClientState.updateQueryState(targetId, "rejected", err);
              limboResolution = syncEngineImpl.activeLimboResolutionsByTarget.get(targetId);
              limboKey = limboResolution && limboResolution.key;
              if (!limboKey)
                return [3, 2];
              documentUpdates = new SortedMap(DocumentKey.comparator);
              documentUpdates = documentUpdates.insert(limboKey, MutableDocument.newNoDocument(limboKey, SnapshotVersion.min()));
              resolvedLimboDocuments = documentKeySet().add(limboKey);
              event_2 = new RemoteEvent(SnapshotVersion.min(), new Map(), new SortedSet(primitiveComparator), documentUpdates, resolvedLimboDocuments);
              return [4, syncEngineApplyRemoteEvent(syncEngineImpl, event_2)];
            case 1:
              _d.sent();
              syncEngineImpl.activeLimboTargetsByKey = syncEngineImpl.activeLimboTargetsByKey.remove(limboKey);
              syncEngineImpl.activeLimboResolutionsByTarget.delete(targetId);
              pumpEnqueuedLimboResolutions(syncEngineImpl);
              return [3, 4];
            case 2:
              return [4, localStoreReleaseTarget(syncEngineImpl.localStore, targetId, false).then(function() {
                return removeAndCleanupTarget(syncEngineImpl, targetId, err);
              }).catch(ignoreIfPrimaryLeaseLoss)];
            case 3:
              _d.sent();
              _d.label = 4;
            case 4:
              return [2];
          }
        });
      });
    }
    function syncEngineApplySuccessfulWrite(syncEngine, mutationBatchResult) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var syncEngineImpl, batchId, changes, error_3;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              syncEngineImpl = debugCast(syncEngine);
              batchId = mutationBatchResult.batch.batchId;
              _d.label = 1;
            case 1:
              _d.trys.push([1, 4, , 6]);
              return [4, localStoreAcknowledgeBatch(syncEngineImpl.localStore, mutationBatchResult)];
            case 2:
              changes = _d.sent();
              processUserCallback(syncEngineImpl, batchId, null);
              triggerPendingWritesCallbacks(syncEngineImpl, batchId);
              syncEngineImpl.sharedClientState.updateMutationState(batchId, "acknowledged");
              return [4, syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes)];
            case 3:
              _d.sent();
              return [3, 6];
            case 4:
              error_3 = _d.sent();
              return [4, ignoreIfPrimaryLeaseLoss(error_3)];
            case 5:
              _d.sent();
              return [3, 6];
            case 6:
              return [2];
          }
        });
      });
    }
    function syncEngineRejectFailedWrite(syncEngine, batchId, error2) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var syncEngineImpl, changes, error_4;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              syncEngineImpl = debugCast(syncEngine);
              _d.label = 1;
            case 1:
              _d.trys.push([1, 4, , 6]);
              return [4, localStoreRejectBatch(syncEngineImpl.localStore, batchId)];
            case 2:
              changes = _d.sent();
              processUserCallback(syncEngineImpl, batchId, error2);
              triggerPendingWritesCallbacks(syncEngineImpl, batchId);
              syncEngineImpl.sharedClientState.updateMutationState(batchId, "rejected", error2);
              return [4, syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes)];
            case 3:
              _d.sent();
              return [3, 6];
            case 4:
              error_4 = _d.sent();
              return [4, ignoreIfPrimaryLeaseLoss(error_4)];
            case 5:
              _d.sent();
              return [3, 6];
            case 6:
              return [2];
          }
        });
      });
    }
    function syncEngineRegisterPendingWritesCallback(syncEngine, callback) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var syncEngineImpl, highestBatchId, callbacks, e_9, firestoreError;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              syncEngineImpl = debugCast(syncEngine);
              if (!canUseNetwork(syncEngineImpl.remoteStore)) {
                logDebug(LOG_TAG$3, "The network is disabled. The task returned by 'awaitPendingWrites()' will not complete until the network is enabled.");
              }
              _d.label = 1;
            case 1:
              _d.trys.push([1, 3, , 4]);
              return [4, localStoreGetHighestUnacknowledgedBatchId(syncEngineImpl.localStore)];
            case 2:
              highestBatchId = _d.sent();
              if (highestBatchId === BATCHID_UNKNOWN) {
                callback.resolve();
                return [2];
              }
              callbacks = syncEngineImpl.pendingWritesCallbacks.get(highestBatchId) || [];
              callbacks.push(callback);
              syncEngineImpl.pendingWritesCallbacks.set(highestBatchId, callbacks);
              return [3, 4];
            case 3:
              e_9 = _d.sent();
              firestoreError = wrapInUserErrorIfRecoverable(e_9, "Initialization of waitForPendingWrites() operation failed");
              callback.reject(firestoreError);
              return [3, 4];
            case 4:
              return [2];
          }
        });
      });
    }
    function triggerPendingWritesCallbacks(syncEngineImpl, batchId) {
      (syncEngineImpl.pendingWritesCallbacks.get(batchId) || []).forEach(function(callback) {
        callback.resolve();
      });
      syncEngineImpl.pendingWritesCallbacks.delete(batchId);
    }
    function rejectOutstandingPendingWritesCallbacks(syncEngineImpl, errorMessage) {
      syncEngineImpl.pendingWritesCallbacks.forEach(function(callbacks) {
        callbacks.forEach(function(callback) {
          callback.reject(new FirestoreError(Code.CANCELLED, errorMessage));
        });
      });
      syncEngineImpl.pendingWritesCallbacks.clear();
    }
    function addMutationCallback(syncEngineImpl, batchId, callback) {
      var newCallbacks = syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()];
      if (!newCallbacks) {
        newCallbacks = new SortedMap(primitiveComparator);
      }
      newCallbacks = newCallbacks.insert(batchId, callback);
      syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()] = newCallbacks;
    }
    function processUserCallback(syncEngine, batchId, error2) {
      var syncEngineImpl = debugCast(syncEngine);
      var newCallbacks = syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()];
      if (newCallbacks) {
        var callback = newCallbacks.get(batchId);
        if (callback) {
          if (error2) {
            callback.reject(error2);
          } else {
            callback.resolve();
          }
          newCallbacks = newCallbacks.remove(batchId);
        }
        syncEngineImpl.mutationUserCallbacks[syncEngineImpl.currentUser.toKey()] = newCallbacks;
      }
    }
    function removeAndCleanupTarget(syncEngineImpl, targetId, error2) {
      if (error2 === void 0) {
        error2 = null;
      }
      syncEngineImpl.sharedClientState.removeLocalQueryTarget(targetId);
      for (var _i = 0, _d = syncEngineImpl.queriesByTarget.get(targetId); _i < _d.length; _i++) {
        var query_2 = _d[_i];
        syncEngineImpl.queryViewsByQuery.delete(query_2);
        if (error2) {
          syncEngineImpl.syncEngineListener.onWatchError(query_2, error2);
        }
      }
      syncEngineImpl.queriesByTarget.delete(targetId);
      if (syncEngineImpl.isPrimaryClient) {
        var limboKeys = syncEngineImpl.limboDocumentRefs.removeReferencesForId(targetId);
        limboKeys.forEach(function(limboKey) {
          var isReferenced = syncEngineImpl.limboDocumentRefs.containsKey(limboKey);
          if (!isReferenced) {
            removeLimboTarget(syncEngineImpl, limboKey);
          }
        });
      }
    }
    function removeLimboTarget(syncEngineImpl, key) {
      syncEngineImpl.enqueuedLimboResolutions.delete(key.path.canonicalString());
      var limboTargetId = syncEngineImpl.activeLimboTargetsByKey.get(key);
      if (limboTargetId === null) {
        return;
      }
      remoteStoreUnlisten(syncEngineImpl.remoteStore, limboTargetId);
      syncEngineImpl.activeLimboTargetsByKey = syncEngineImpl.activeLimboTargetsByKey.remove(key);
      syncEngineImpl.activeLimboResolutionsByTarget.delete(limboTargetId);
      pumpEnqueuedLimboResolutions(syncEngineImpl);
    }
    function updateTrackedLimbos(syncEngineImpl, targetId, limboChanges) {
      for (var _i = 0, limboChanges_1 = limboChanges; _i < limboChanges_1.length; _i++) {
        var limboChange = limboChanges_1[_i];
        if (limboChange instanceof AddedLimboDocument) {
          syncEngineImpl.limboDocumentRefs.addReference(limboChange.key, targetId);
          trackLimboChange(syncEngineImpl, limboChange);
        } else if (limboChange instanceof RemovedLimboDocument) {
          logDebug(LOG_TAG$3, "Document no longer in limbo: " + limboChange.key);
          syncEngineImpl.limboDocumentRefs.removeReference(limboChange.key, targetId);
          var isReferenced = syncEngineImpl.limboDocumentRefs.containsKey(limboChange.key);
          if (!isReferenced) {
            removeLimboTarget(syncEngineImpl, limboChange.key);
          }
        } else {
          fail();
        }
      }
    }
    function trackLimboChange(syncEngineImpl, limboChange) {
      var key = limboChange.key;
      var keyString = key.path.canonicalString();
      if (!syncEngineImpl.activeLimboTargetsByKey.get(key) && !syncEngineImpl.enqueuedLimboResolutions.has(keyString)) {
        logDebug(LOG_TAG$3, "New document in limbo: " + key);
        syncEngineImpl.enqueuedLimboResolutions.add(keyString);
        pumpEnqueuedLimboResolutions(syncEngineImpl);
      }
    }
    function pumpEnqueuedLimboResolutions(syncEngineImpl) {
      while (syncEngineImpl.enqueuedLimboResolutions.size > 0 && syncEngineImpl.activeLimboTargetsByKey.size < syncEngineImpl.maxConcurrentLimboResolutions) {
        var keyString = syncEngineImpl.enqueuedLimboResolutions.values().next().value;
        syncEngineImpl.enqueuedLimboResolutions.delete(keyString);
        var key = new DocumentKey(ResourcePath.fromString(keyString));
        var limboTargetId = syncEngineImpl.limboTargetIdGenerator.next();
        syncEngineImpl.activeLimboResolutionsByTarget.set(limboTargetId, new LimboResolution(key));
        syncEngineImpl.activeLimboTargetsByKey = syncEngineImpl.activeLimboTargetsByKey.insert(key, limboTargetId);
        remoteStoreListen(syncEngineImpl.remoteStore, new TargetData(queryToTarget(newQueryForPath(key.path)), limboTargetId, 2, ListenSequence.INVALID));
      }
    }
    function syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngine, changes, remoteEvent) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var syncEngineImpl, newSnaps, docChangesInAllViews, queriesProcessed;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              syncEngineImpl = debugCast(syncEngine);
              newSnaps = [];
              docChangesInAllViews = [];
              queriesProcessed = [];
              if (syncEngineImpl.queryViewsByQuery.isEmpty()) {
                return [2];
              }
              syncEngineImpl.queryViewsByQuery.forEach(function(_, queryView) {
                queriesProcessed.push(syncEngineImpl.applyDocChanges(queryView, changes, remoteEvent).then(function(viewSnapshot) {
                  if (viewSnapshot) {
                    if (syncEngineImpl.isPrimaryClient) {
                      syncEngineImpl.sharedClientState.updateQueryState(queryView.targetId, viewSnapshot.fromCache ? "not-current" : "current");
                    }
                    newSnaps.push(viewSnapshot);
                    var docChanges = LocalViewChanges.fromSnapshot(queryView.targetId, viewSnapshot);
                    docChangesInAllViews.push(docChanges);
                  }
                }));
              });
              return [4, Promise.all(queriesProcessed)];
            case 1:
              _d.sent();
              syncEngineImpl.syncEngineListener.onWatchChange(newSnaps);
              return [4, localStoreNotifyLocalViewChanges(syncEngineImpl.localStore, docChangesInAllViews)];
            case 2:
              _d.sent();
              return [2];
          }
        });
      });
    }
    function applyDocChanges(syncEngineImpl, queryView, changes, remoteEvent) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var viewDocChanges, targetChange, viewChange;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              viewDocChanges = queryView.view.computeDocChanges(changes);
              if (!viewDocChanges.needsRefill)
                return [3, 2];
              return [4, localStoreExecuteQuery(syncEngineImpl.localStore, queryView.query, false).then(function(_d2) {
                var documents = _d2.documents;
                return queryView.view.computeDocChanges(documents, viewDocChanges);
              })];
            case 1:
              viewDocChanges = _d.sent();
              _d.label = 2;
            case 2:
              targetChange = remoteEvent && remoteEvent.targetChanges.get(queryView.targetId);
              viewChange = queryView.view.applyChanges(viewDocChanges, syncEngineImpl.isPrimaryClient, targetChange);
              updateTrackedLimbos(syncEngineImpl, queryView.targetId, viewChange.limboChanges);
              return [2, viewChange.snapshot];
          }
        });
      });
    }
    function syncEngineHandleCredentialChange(syncEngine, user2) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var syncEngineImpl, userChanged, result;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              syncEngineImpl = debugCast(syncEngine);
              userChanged = !syncEngineImpl.currentUser.isEqual(user2);
              if (!userChanged)
                return [3, 3];
              logDebug(LOG_TAG$3, "User change. New user:", user2.toKey());
              return [4, localStoreHandleUserChange(syncEngineImpl.localStore, user2)];
            case 1:
              result = _d.sent();
              syncEngineImpl.currentUser = user2;
              rejectOutstandingPendingWritesCallbacks(syncEngineImpl, "'waitForPendingWrites' promise is rejected due to a user change.");
              syncEngineImpl.sharedClientState.handleUserChange(user2, result.removedBatchIds, result.addedBatchIds);
              return [4, syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, result.affectedDocuments)];
            case 2:
              _d.sent();
              _d.label = 3;
            case 3:
              return [2];
          }
        });
      });
    }
    function syncEngineGetRemoteKeysForTarget(syncEngine, targetId) {
      var syncEngineImpl = debugCast(syncEngine);
      var limboResolution = syncEngineImpl.activeLimboResolutionsByTarget.get(targetId);
      if (limboResolution && limboResolution.receivedDocument) {
        return documentKeySet().add(limboResolution.key);
      } else {
        var keySet = documentKeySet();
        var queries = syncEngineImpl.queriesByTarget.get(targetId);
        if (!queries) {
          return keySet;
        }
        for (var _i = 0, queries_1 = queries; _i < queries_1.length; _i++) {
          var query_3 = queries_1[_i];
          var queryView = syncEngineImpl.queryViewsByQuery.get(query_3);
          keySet = keySet.unionWith(queryView.view.syncedDocuments);
        }
        return keySet;
      }
    }
    function synchronizeViewAndComputeSnapshot(syncEngine, queryView) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var syncEngineImpl, queryResult, viewSnapshot;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              syncEngineImpl = debugCast(syncEngine);
              return [4, localStoreExecuteQuery(syncEngineImpl.localStore, queryView.query, true)];
            case 1:
              queryResult = _d.sent();
              viewSnapshot = queryView.view.synchronizeWithPersistedState(queryResult);
              if (syncEngineImpl.isPrimaryClient) {
                updateTrackedLimbos(syncEngineImpl, queryView.targetId, viewSnapshot.limboChanges);
              }
              return [2, viewSnapshot];
          }
        });
      });
    }
    function syncEngineSynchronizeWithChangedDocuments(syncEngine) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var syncEngineImpl;
        return tslib2.__generator(this, function(_d) {
          syncEngineImpl = debugCast(syncEngine);
          return [2, localStoreGetNewDocumentChanges(syncEngineImpl.localStore).then(function(changes) {
            return syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes);
          })];
        });
      });
    }
    function syncEngineApplyBatchState(syncEngine, batchId, batchState, error2) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var syncEngineImpl, documents;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              syncEngineImpl = debugCast(syncEngine);
              return [4, localStoreLookupMutationDocuments(syncEngineImpl.localStore, batchId)];
            case 1:
              documents = _d.sent();
              if (documents === null) {
                logDebug(LOG_TAG$3, "Cannot apply mutation batch with id: " + batchId);
                return [2];
              }
              if (!(batchState === "pending"))
                return [3, 3];
              return [4, fillWritePipeline(syncEngineImpl.remoteStore)];
            case 2:
              _d.sent();
              return [3, 4];
            case 3:
              if (batchState === "acknowledged" || batchState === "rejected") {
                processUserCallback(syncEngineImpl, batchId, error2 ? error2 : null);
                triggerPendingWritesCallbacks(syncEngineImpl, batchId);
                localStoreRemoveCachedMutationBatchMetadata(syncEngineImpl.localStore, batchId);
              } else {
                fail();
              }
              _d.label = 4;
            case 4:
              return [4, syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, documents)];
            case 5:
              _d.sent();
              return [2];
          }
        });
      });
    }
    function syncEngineApplyPrimaryState(syncEngine, isPrimary) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var syncEngineImpl, activeTargets, activeQueries, _i, activeQueries_1, targetData, activeTargets_1, p_1;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              syncEngineImpl = debugCast(syncEngine);
              ensureWatchCallbacks(syncEngineImpl);
              syncEngineEnsureWriteCallbacks(syncEngineImpl);
              if (!(isPrimary === true && syncEngineImpl._isPrimaryClient !== true))
                return [3, 3];
              activeTargets = syncEngineImpl.sharedClientState.getAllActiveQueryTargets();
              return [4, synchronizeQueryViewsAndRaiseSnapshots(syncEngineImpl, activeTargets.toArray())];
            case 1:
              activeQueries = _d.sent();
              syncEngineImpl._isPrimaryClient = true;
              return [4, remoteStoreApplyPrimaryState(syncEngineImpl.remoteStore, true)];
            case 2:
              _d.sent();
              for (_i = 0, activeQueries_1 = activeQueries; _i < activeQueries_1.length; _i++) {
                targetData = activeQueries_1[_i];
                remoteStoreListen(syncEngineImpl.remoteStore, targetData);
              }
              return [3, 7];
            case 3:
              if (!(isPrimary === false && syncEngineImpl._isPrimaryClient !== false))
                return [3, 7];
              activeTargets_1 = [];
              p_1 = Promise.resolve();
              syncEngineImpl.queriesByTarget.forEach(function(_, targetId) {
                if (syncEngineImpl.sharedClientState.isLocalQueryTarget(targetId)) {
                  activeTargets_1.push(targetId);
                } else {
                  p_1 = p_1.then(function() {
                    removeAndCleanupTarget(syncEngineImpl, targetId);
                    return localStoreReleaseTarget(syncEngineImpl.localStore, targetId, true);
                  });
                }
                remoteStoreUnlisten(syncEngineImpl.remoteStore, targetId);
              });
              return [4, p_1];
            case 4:
              _d.sent();
              return [4, synchronizeQueryViewsAndRaiseSnapshots(syncEngineImpl, activeTargets_1)];
            case 5:
              _d.sent();
              resetLimboDocuments(syncEngineImpl);
              syncEngineImpl._isPrimaryClient = false;
              return [4, remoteStoreApplyPrimaryState(syncEngineImpl.remoteStore, false)];
            case 6:
              _d.sent();
              _d.label = 7;
            case 7:
              return [2];
          }
        });
      });
    }
    function resetLimboDocuments(syncEngine) {
      var syncEngineImpl = debugCast(syncEngine);
      syncEngineImpl.activeLimboResolutionsByTarget.forEach(function(_, targetId) {
        remoteStoreUnlisten(syncEngineImpl.remoteStore, targetId);
      });
      syncEngineImpl.limboDocumentRefs.removeAllReferences();
      syncEngineImpl.activeLimboResolutionsByTarget = new Map();
      syncEngineImpl.activeLimboTargetsByKey = new SortedMap(DocumentKey.comparator);
    }
    function synchronizeQueryViewsAndRaiseSnapshots(syncEngine, targets, transitionToPrimary) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var syncEngineImpl, activeQueries, newViewSnapshots, _i, targets_1, targetId, targetData, queries, _d, queries_2, query_4, queryView, viewChange, target;
        return tslib2.__generator(this, function(_e) {
          switch (_e.label) {
            case 0:
              syncEngineImpl = debugCast(syncEngine);
              activeQueries = [];
              newViewSnapshots = [];
              _i = 0, targets_1 = targets;
              _e.label = 1;
            case 1:
              if (!(_i < targets_1.length))
                return [3, 13];
              targetId = targets_1[_i];
              targetData = void 0;
              queries = syncEngineImpl.queriesByTarget.get(targetId);
              if (!(queries && queries.length !== 0))
                return [3, 7];
              return [4, localStoreAllocateTarget(syncEngineImpl.localStore, queryToTarget(queries[0]))];
            case 2:
              targetData = _e.sent();
              _d = 0, queries_2 = queries;
              _e.label = 3;
            case 3:
              if (!(_d < queries_2.length))
                return [3, 6];
              query_4 = queries_2[_d];
              queryView = syncEngineImpl.queryViewsByQuery.get(query_4);
              return [4, synchronizeViewAndComputeSnapshot(syncEngineImpl, queryView)];
            case 4:
              viewChange = _e.sent();
              if (viewChange.snapshot) {
                newViewSnapshots.push(viewChange.snapshot);
              }
              _e.label = 5;
            case 5:
              _d++;
              return [3, 3];
            case 6:
              return [3, 11];
            case 7:
              return [4, localStoreGetCachedTarget(syncEngineImpl.localStore, targetId)];
            case 8:
              target = _e.sent();
              return [4, localStoreAllocateTarget(syncEngineImpl.localStore, target)];
            case 9:
              targetData = _e.sent();
              return [4, initializeViewAndComputeSnapshot(syncEngineImpl, synthesizeTargetToQuery(target), targetId, false)];
            case 10:
              _e.sent();
              _e.label = 11;
            case 11:
              activeQueries.push(targetData);
              _e.label = 12;
            case 12:
              _i++;
              return [3, 1];
            case 13:
              syncEngineImpl.syncEngineListener.onWatchChange(newViewSnapshots);
              return [2, activeQueries];
          }
        });
      });
    }
    function synthesizeTargetToQuery(target) {
      return newQuery(target.path, target.collectionGroup, target.orderBy, target.filters, target.limit, "F", target.startAt, target.endAt);
    }
    function syncEngineGetActiveClients(syncEngine) {
      var syncEngineImpl = debugCast(syncEngine);
      return localStoreGetActiveClients(syncEngineImpl.localStore);
    }
    function syncEngineApplyTargetState(syncEngine, targetId, state, error2) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var syncEngineImpl, _d, changes, synthesizedRemoteEvent;
        return tslib2.__generator(this, function(_e) {
          switch (_e.label) {
            case 0:
              syncEngineImpl = debugCast(syncEngine);
              if (syncEngineImpl._isPrimaryClient) {
                logDebug(LOG_TAG$3, "Ignoring unexpected query state notification.");
                return [2];
              }
              if (!syncEngineImpl.queriesByTarget.has(targetId))
                return [3, 7];
              _d = state;
              switch (_d) {
                case "current":
                  return [3, 1];
                case "not-current":
                  return [3, 1];
                case "rejected":
                  return [3, 4];
              }
              return [3, 6];
            case 1:
              return [4, localStoreGetNewDocumentChanges(syncEngineImpl.localStore)];
            case 2:
              changes = _e.sent();
              synthesizedRemoteEvent = RemoteEvent.createSynthesizedRemoteEventForCurrentChange(targetId, state === "current");
              return [4, syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngineImpl, changes, synthesizedRemoteEvent)];
            case 3:
              _e.sent();
              return [3, 7];
            case 4:
              return [4, localStoreReleaseTarget(syncEngineImpl.localStore, targetId, true)];
            case 5:
              _e.sent();
              removeAndCleanupTarget(syncEngineImpl, targetId, error2);
              return [3, 7];
            case 6:
              fail();
              _e.label = 7;
            case 7:
              return [2];
          }
        });
      });
    }
    function syncEngineApplyActiveTargetsChange(syncEngine, added, removed) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var syncEngineImpl, _i, added_1, targetId, target, targetData, _loop_5, _d, removed_1, targetId;
        return tslib2.__generator(this, function(_e) {
          switch (_e.label) {
            case 0:
              syncEngineImpl = ensureWatchCallbacks(syncEngine);
              if (!syncEngineImpl._isPrimaryClient) {
                return [2];
              }
              _i = 0, added_1 = added;
              _e.label = 1;
            case 1:
              if (!(_i < added_1.length))
                return [3, 6];
              targetId = added_1[_i];
              if (syncEngineImpl.queriesByTarget.has(targetId)) {
                logDebug(LOG_TAG$3, "Adding an already active target " + targetId);
                return [3, 5];
              }
              return [4, localStoreGetCachedTarget(syncEngineImpl.localStore, targetId)];
            case 2:
              target = _e.sent();
              return [4, localStoreAllocateTarget(syncEngineImpl.localStore, target)];
            case 3:
              targetData = _e.sent();
              return [4, initializeViewAndComputeSnapshot(syncEngineImpl, synthesizeTargetToQuery(target), targetData.targetId, false)];
            case 4:
              _e.sent();
              remoteStoreListen(syncEngineImpl.remoteStore, targetData);
              _e.label = 5;
            case 5:
              _i++;
              return [3, 1];
            case 6:
              _loop_5 = function(targetId2) {
                return tslib2.__generator(this, function(_f) {
                  switch (_f.label) {
                    case 0:
                      if (!syncEngineImpl.queriesByTarget.has(targetId2)) {
                        return [2, "continue"];
                      }
                      return [4, localStoreReleaseTarget(syncEngineImpl.localStore, targetId2, false).then(function() {
                        remoteStoreUnlisten(syncEngineImpl.remoteStore, targetId2);
                        removeAndCleanupTarget(syncEngineImpl, targetId2);
                      }).catch(ignoreIfPrimaryLeaseLoss)];
                    case 1:
                      _f.sent();
                      return [2];
                  }
                });
              };
              _d = 0, removed_1 = removed;
              _e.label = 7;
            case 7:
              if (!(_d < removed_1.length))
                return [3, 10];
              targetId = removed_1[_d];
              return [5, _loop_5(targetId)];
            case 8:
              _e.sent();
              _e.label = 9;
            case 9:
              _d++;
              return [3, 7];
            case 10:
              return [2];
          }
        });
      });
    }
    function ensureWatchCallbacks(syncEngine) {
      var syncEngineImpl = debugCast(syncEngine);
      syncEngineImpl.remoteStore.remoteSyncer.applyRemoteEvent = syncEngineApplyRemoteEvent.bind(null, syncEngineImpl);
      syncEngineImpl.remoteStore.remoteSyncer.getRemoteKeysForTarget = syncEngineGetRemoteKeysForTarget.bind(null, syncEngineImpl);
      syncEngineImpl.remoteStore.remoteSyncer.rejectListen = syncEngineRejectListen.bind(null, syncEngineImpl);
      syncEngineImpl.syncEngineListener.onWatchChange = eventManagerOnWatchChange.bind(null, syncEngineImpl.eventManager);
      syncEngineImpl.syncEngineListener.onWatchError = eventManagerOnWatchError.bind(null, syncEngineImpl.eventManager);
      return syncEngineImpl;
    }
    function syncEngineEnsureWriteCallbacks(syncEngine) {
      var syncEngineImpl = debugCast(syncEngine);
      syncEngineImpl.remoteStore.remoteSyncer.applySuccessfulWrite = syncEngineApplySuccessfulWrite.bind(null, syncEngineImpl);
      syncEngineImpl.remoteStore.remoteSyncer.rejectFailedWrite = syncEngineRejectFailedWrite.bind(null, syncEngineImpl);
      return syncEngineImpl;
    }
    function syncEngineLoadBundle(syncEngine, bundleReader, task) {
      var syncEngineImpl = debugCast(syncEngine);
      loadBundleImpl(syncEngineImpl, bundleReader, task).then(function() {
        syncEngineImpl.sharedClientState.notifyBundleLoaded();
      });
    }
    function loadBundleImpl(syncEngine, reader, task) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var metadata, skip, loader, element, progress, result, e_10;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              _d.trys.push([0, 13, , 14]);
              return [4, reader.getMetadata()];
            case 1:
              metadata = _d.sent();
              return [4, localStoreHasNewerBundle(syncEngine.localStore, metadata)];
            case 2:
              skip = _d.sent();
              if (!skip)
                return [3, 4];
              return [4, reader.close()];
            case 3:
              _d.sent();
              task._completeWith(bundleSuccessProgress(metadata));
              return [2];
            case 4:
              task._updateProgress(bundleInitialProgress(metadata));
              loader = new BundleLoader(metadata, syncEngine.localStore, reader.serializer);
              return [4, reader.nextElement()];
            case 5:
              element = _d.sent();
              _d.label = 6;
            case 6:
              if (!element)
                return [3, 9];
              return [4, loader.addSizedElement(element)];
            case 7:
              progress = _d.sent();
              if (progress) {
                task._updateProgress(progress);
              }
              return [4, reader.nextElement()];
            case 8:
              element = _d.sent();
              return [3, 6];
            case 9:
              return [4, loader.complete()];
            case 10:
              result = _d.sent();
              return [4, syncEngineEmitNewSnapsAndNotifyLocalStore(syncEngine, result.changedDocs, void 0)];
            case 11:
              _d.sent();
              return [4, localStoreSaveBundle(syncEngine.localStore, metadata)];
            case 12:
              _d.sent();
              task._completeWith(result.progress);
              return [3, 14];
            case 13:
              e_10 = _d.sent();
              logWarn(LOG_TAG$3, "Loading bundle failed with " + e_10);
              task._failWith(e_10);
              return [3, 14];
            case 14:
              return [2];
          }
        });
      });
    }
    var MemoryOfflineComponentProvider = function() {
      function MemoryOfflineComponentProvider2() {
        this.synchronizeTabs = false;
      }
      MemoryOfflineComponentProvider2.prototype.initialize = function(cfg) {
        return tslib2.__awaiter(this, void 0, void 0, function() {
          return tslib2.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                this.serializer = newSerializer(cfg.databaseInfo.databaseId);
                this.sharedClientState = this.createSharedClientState(cfg);
                this.persistence = this.createPersistence(cfg);
                return [4, this.persistence.start()];
              case 1:
                _d.sent();
                this.gcScheduler = this.createGarbageCollectionScheduler(cfg);
                this.localStore = this.createLocalStore(cfg);
                return [2];
            }
          });
        });
      };
      MemoryOfflineComponentProvider2.prototype.createGarbageCollectionScheduler = function(cfg) {
        return null;
      };
      MemoryOfflineComponentProvider2.prototype.createLocalStore = function(cfg) {
        return newLocalStore(this.persistence, new QueryEngine(), cfg.initialUser, this.serializer);
      };
      MemoryOfflineComponentProvider2.prototype.createPersistence = function(cfg) {
        return new MemoryPersistence(MemoryEagerDelegate.factory, this.serializer);
      };
      MemoryOfflineComponentProvider2.prototype.createSharedClientState = function(cfg) {
        return new MemorySharedClientState();
      };
      MemoryOfflineComponentProvider2.prototype.terminate = function() {
        return tslib2.__awaiter(this, void 0, void 0, function() {
          return tslib2.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                if (this.gcScheduler) {
                  this.gcScheduler.stop();
                }
                return [4, this.sharedClientState.shutdown()];
              case 1:
                _d.sent();
                return [4, this.persistence.shutdown()];
              case 2:
                _d.sent();
                return [2];
            }
          });
        });
      };
      return MemoryOfflineComponentProvider2;
    }();
    var IndexedDbOfflineComponentProvider = function(_super) {
      tslib2.__extends(IndexedDbOfflineComponentProvider2, _super);
      function IndexedDbOfflineComponentProvider2(onlineComponentProvider, cacheSizeBytes, forceOwnership) {
        var _this = _super.call(this) || this;
        _this.onlineComponentProvider = onlineComponentProvider;
        _this.cacheSizeBytes = cacheSizeBytes;
        _this.forceOwnership = forceOwnership;
        _this.synchronizeTabs = false;
        return _this;
      }
      IndexedDbOfflineComponentProvider2.prototype.initialize = function(cfg) {
        return tslib2.__awaiter(this, void 0, void 0, function() {
          var _this = this;
          return tslib2.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                return [4, _super.prototype.initialize.call(this, cfg)];
              case 1:
                _d.sent();
                return [4, localStoreSynchronizeLastDocumentChangeReadTime(this.localStore)];
              case 2:
                _d.sent();
                return [4, this.onlineComponentProvider.initialize(this, cfg)];
              case 3:
                _d.sent();
                return [4, syncEngineEnsureWriteCallbacks(this.onlineComponentProvider.syncEngine)];
              case 4:
                _d.sent();
                return [4, fillWritePipeline(this.onlineComponentProvider.remoteStore)];
              case 5:
                _d.sent();
                return [4, this.persistence.setPrimaryStateListener(function() {
                  if (_this.gcScheduler && !_this.gcScheduler.started) {
                    _this.gcScheduler.start(_this.localStore);
                  }
                  return Promise.resolve();
                })];
              case 6:
                _d.sent();
                return [2];
            }
          });
        });
      };
      IndexedDbOfflineComponentProvider2.prototype.createLocalStore = function(cfg) {
        return newLocalStore(this.persistence, new QueryEngine(), cfg.initialUser, this.serializer);
      };
      IndexedDbOfflineComponentProvider2.prototype.createGarbageCollectionScheduler = function(cfg) {
        var garbageCollector = this.persistence.referenceDelegate.garbageCollector;
        return new LruScheduler(garbageCollector, cfg.asyncQueue);
      };
      IndexedDbOfflineComponentProvider2.prototype.createPersistence = function(cfg) {
        var persistenceKey = indexedDbStoragePrefix(cfg.databaseInfo.databaseId, cfg.databaseInfo.persistenceKey);
        var lruParams = this.cacheSizeBytes !== void 0 ? LruParams.withCacheSize(this.cacheSizeBytes) : LruParams.DEFAULT;
        return new IndexedDbPersistence(this.synchronizeTabs, persistenceKey, cfg.clientId, lruParams, cfg.asyncQueue, getWindow(), getDocument(), this.serializer, this.sharedClientState, !!this.forceOwnership);
      };
      IndexedDbOfflineComponentProvider2.prototype.createSharedClientState = function(cfg) {
        return new MemorySharedClientState();
      };
      return IndexedDbOfflineComponentProvider2;
    }(MemoryOfflineComponentProvider);
    var MultiTabOfflineComponentProvider = function(_super) {
      tslib2.__extends(MultiTabOfflineComponentProvider2, _super);
      function MultiTabOfflineComponentProvider2(onlineComponentProvider, cacheSizeBytes) {
        var _this = _super.call(this, onlineComponentProvider, cacheSizeBytes, false) || this;
        _this.onlineComponentProvider = onlineComponentProvider;
        _this.cacheSizeBytes = cacheSizeBytes;
        _this.synchronizeTabs = true;
        return _this;
      }
      MultiTabOfflineComponentProvider2.prototype.initialize = function(cfg) {
        return tslib2.__awaiter(this, void 0, void 0, function() {
          var syncEngine;
          var _this = this;
          return tslib2.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                return [4, _super.prototype.initialize.call(this, cfg)];
              case 1:
                _d.sent();
                syncEngine = this.onlineComponentProvider.syncEngine;
                if (!(this.sharedClientState instanceof WebStorageSharedClientState))
                  return [3, 3];
                this.sharedClientState.syncEngine = {
                  applyBatchState: syncEngineApplyBatchState.bind(null, syncEngine),
                  applyTargetState: syncEngineApplyTargetState.bind(null, syncEngine),
                  applyActiveTargetsChange: syncEngineApplyActiveTargetsChange.bind(null, syncEngine),
                  getActiveClients: syncEngineGetActiveClients.bind(null, syncEngine),
                  synchronizeWithChangedDocuments: syncEngineSynchronizeWithChangedDocuments.bind(null, syncEngine)
                };
                return [4, this.sharedClientState.start()];
              case 2:
                _d.sent();
                _d.label = 3;
              case 3:
                return [4, this.persistence.setPrimaryStateListener(function(isPrimary) {
                  return tslib2.__awaiter(_this, void 0, void 0, function() {
                    return tslib2.__generator(this, function(_d2) {
                      switch (_d2.label) {
                        case 0:
                          return [4, syncEngineApplyPrimaryState(this.onlineComponentProvider.syncEngine, isPrimary)];
                        case 1:
                          _d2.sent();
                          if (this.gcScheduler) {
                            if (isPrimary && !this.gcScheduler.started) {
                              this.gcScheduler.start(this.localStore);
                            } else if (!isPrimary) {
                              this.gcScheduler.stop();
                            }
                          }
                          return [2];
                      }
                    });
                  });
                })];
              case 4:
                _d.sent();
                return [2];
            }
          });
        });
      };
      MultiTabOfflineComponentProvider2.prototype.createSharedClientState = function(cfg) {
        var window2 = getWindow();
        if (!WebStorageSharedClientState.isAvailable(window2)) {
          throw new FirestoreError(Code.UNIMPLEMENTED, "IndexedDB persistence is only available on platforms that support LocalStorage.");
        }
        var persistenceKey = indexedDbStoragePrefix(cfg.databaseInfo.databaseId, cfg.databaseInfo.persistenceKey);
        return new WebStorageSharedClientState(window2, cfg.asyncQueue, persistenceKey, cfg.clientId, cfg.initialUser);
      };
      return MultiTabOfflineComponentProvider2;
    }(IndexedDbOfflineComponentProvider);
    var OnlineComponentProvider = function() {
      function OnlineComponentProvider2() {
      }
      OnlineComponentProvider2.prototype.initialize = function(offlineComponentProvider, cfg) {
        return tslib2.__awaiter(this, void 0, void 0, function() {
          var _this = this;
          return tslib2.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                if (this.localStore) {
                  return [2];
                }
                this.localStore = offlineComponentProvider.localStore;
                this.sharedClientState = offlineComponentProvider.sharedClientState;
                this.datastore = this.createDatastore(cfg);
                this.remoteStore = this.createRemoteStore(cfg);
                this.eventManager = this.createEventManager(cfg);
                this.syncEngine = this.createSyncEngine(cfg, !offlineComponentProvider.synchronizeTabs);
                this.sharedClientState.onlineStateHandler = function(onlineState) {
                  return syncEngineApplyOnlineStateChange(_this.syncEngine, onlineState, 1);
                };
                this.remoteStore.remoteSyncer.handleCredentialChange = syncEngineHandleCredentialChange.bind(null, this.syncEngine);
                return [4, remoteStoreApplyPrimaryState(this.remoteStore, this.syncEngine.isPrimaryClient)];
              case 1:
                _d.sent();
                return [2];
            }
          });
        });
      };
      OnlineComponentProvider2.prototype.createEventManager = function(cfg) {
        return newEventManager();
      };
      OnlineComponentProvider2.prototype.createDatastore = function(cfg) {
        var serializer = newSerializer(cfg.databaseInfo.databaseId);
        var connection = newConnection2(cfg.databaseInfo);
        return newDatastore(cfg.credentials, connection, serializer);
      };
      OnlineComponentProvider2.prototype.createRemoteStore = function(cfg) {
        var _this = this;
        return newRemoteStore(this.localStore, this.datastore, cfg.asyncQueue, function(onlineState) {
          return syncEngineApplyOnlineStateChange(_this.syncEngine, onlineState, 0);
        }, newConnectivityMonitor());
      };
      OnlineComponentProvider2.prototype.createSyncEngine = function(cfg, startAsPrimary) {
        return newSyncEngine(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, cfg.initialUser, cfg.maxConcurrentLimboResolutions, startAsPrimary);
      };
      OnlineComponentProvider2.prototype.terminate = function() {
        return remoteStoreShutdown(this.remoteStore);
      };
      return OnlineComponentProvider2;
    }();
    var DEFAULT_BYTES_PER_READ = 10240;
    function toByteStreamReaderHelper(source, bytesPerRead) {
      if (bytesPerRead === void 0) {
        bytesPerRead = DEFAULT_BYTES_PER_READ;
      }
      var readFrom = 0;
      var reader = {
        read: function() {
          return tslib2.__awaiter(this, void 0, void 0, function() {
            var result;
            return tslib2.__generator(this, function(_d) {
              if (readFrom < source.byteLength) {
                result = {
                  value: source.slice(readFrom, readFrom + bytesPerRead),
                  done: false
                };
                readFrom += bytesPerRead;
                return [2, result];
              }
              return [2, { done: true }];
            });
          });
        },
        cancel: function() {
          return tslib2.__awaiter(this, void 0, void 0, function() {
            return tslib2.__generator(this, function(_d) {
              return [2];
            });
          });
        },
        releaseLock: function() {
        },
        closed: Promise.reject("unimplemented")
      };
      return reader;
    }
    function validateNonEmptyArgument(functionName, argumentName, argument) {
      if (!argument) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + functionName + "() cannot be called with an empty " + argumentName + ".");
      }
    }
    function validateIsNotUsedTogether(optionName1, argument1, optionName2, argument2) {
      if (argument1 === true && argument2 === true) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, optionName1 + " and " + optionName2 + " cannot be used together.");
      }
    }
    function validateDocumentPath(path2) {
      if (!DocumentKey.isDocumentKey(path2)) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid document reference. Document references must have an even number of segments, but " + path2 + " has " + path2.length + ".");
      }
    }
    function validateCollectionPath(path2) {
      if (DocumentKey.isDocumentKey(path2)) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid collection reference. Collection references must have an odd number of segments, but " + path2 + " has " + path2.length + ".");
      }
    }
    function isPlainObject(input) {
      return typeof input === "object" && input !== null && (Object.getPrototypeOf(input) === Object.prototype || Object.getPrototypeOf(input) === null);
    }
    function valueDescription(input) {
      if (input === void 0) {
        return "undefined";
      } else if (input === null) {
        return "null";
      } else if (typeof input === "string") {
        if (input.length > 20) {
          input = input.substring(0, 20) + "...";
        }
        return JSON.stringify(input);
      } else if (typeof input === "number" || typeof input === "boolean") {
        return "" + input;
      } else if (typeof input === "object") {
        if (input instanceof Array) {
          return "an array";
        } else {
          var customObjectName = tryGetCustomObjectType(input);
          if (customObjectName) {
            return "a custom " + customObjectName + " object";
          } else {
            return "an object";
          }
        }
      } else if (typeof input === "function") {
        return "a function";
      } else {
        return fail();
      }
    }
    function tryGetCustomObjectType(input) {
      if (input.constructor) {
        return input.constructor.name;
      }
      return null;
    }
    function cast(obj, constructor) {
      if ("_delegate" in obj) {
        obj = obj._delegate;
      }
      if (!(obj instanceof constructor)) {
        if (constructor.name === obj.constructor.name) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
        } else {
          var description = valueDescription(obj);
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Expected type '" + constructor.name + "', but it was: " + description);
        }
      }
      return obj;
    }
    function validatePositiveNumber(functionName, n) {
      if (n <= 0) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + functionName + "() requires a positive number, but it was: " + n + ".");
      }
    }
    function toByteStreamReader(source, bytesPerRead) {
      if (!(source instanceof Uint8Array)) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "NodePlatform.toByteStreamReader expects source to be Uint8Array, got " + valueDescription(source));
      }
      return toByteStreamReaderHelper(source, bytesPerRead);
    }
    var AsyncObserver = function() {
      function AsyncObserver2(observer) {
        this.observer = observer;
        this.muted = false;
      }
      AsyncObserver2.prototype.next = function(value) {
        if (this.observer.next) {
          this.scheduleEvent(this.observer.next, value);
        }
      };
      AsyncObserver2.prototype.error = function(error2) {
        if (this.observer.error) {
          this.scheduleEvent(this.observer.error, error2);
        } else {
          console.error("Uncaught Error in snapshot listener:", error2);
        }
      };
      AsyncObserver2.prototype.mute = function() {
        this.muted = true;
      };
      AsyncObserver2.prototype.scheduleEvent = function(eventHandler, event) {
        var _this = this;
        if (!this.muted) {
          setTimeout(function() {
            if (!_this.muted) {
              eventHandler(event);
            }
          }, 0);
        }
      };
      return AsyncObserver2;
    }();
    var SizedBundleElement = function() {
      function SizedBundleElement2(payload, byteLength) {
        this.payload = payload;
        this.byteLength = byteLength;
      }
      SizedBundleElement2.prototype.isBundleMetadata = function() {
        return "metadata" in this.payload;
      };
      return SizedBundleElement2;
    }();
    var BundleReaderImpl = function() {
      function BundleReaderImpl2(reader, serializer) {
        var _this = this;
        this.reader = reader;
        this.serializer = serializer;
        this.metadata = new Deferred2();
        this.buffer = new Uint8Array();
        this.textDecoder = newTextDecoder();
        this.nextElementImpl().then(function(element) {
          if (element && element.isBundleMetadata()) {
            _this.metadata.resolve(element.payload.metadata);
          } else {
            _this.metadata.reject(new Error("The first element of the bundle is not a metadata, it is\n             " + JSON.stringify(element === null || element === void 0 ? void 0 : element.payload)));
          }
        }, function(error2) {
          return _this.metadata.reject(error2);
        });
      }
      BundleReaderImpl2.prototype.close = function() {
        return this.reader.cancel();
      };
      BundleReaderImpl2.prototype.getMetadata = function() {
        return tslib2.__awaiter(this, void 0, void 0, function() {
          return tslib2.__generator(this, function(_d) {
            return [2, this.metadata.promise];
          });
        });
      };
      BundleReaderImpl2.prototype.nextElement = function() {
        return tslib2.__awaiter(this, void 0, void 0, function() {
          return tslib2.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                return [4, this.getMetadata()];
              case 1:
                _d.sent();
                return [2, this.nextElementImpl()];
            }
          });
        });
      };
      BundleReaderImpl2.prototype.nextElementImpl = function() {
        return tslib2.__awaiter(this, void 0, void 0, function() {
          var lengthBuffer, lengthString, length, jsonString;
          return tslib2.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                return [4, this.readLength()];
              case 1:
                lengthBuffer = _d.sent();
                if (lengthBuffer === null) {
                  return [2, null];
                }
                lengthString = this.textDecoder.decode(lengthBuffer);
                length = Number(lengthString);
                if (isNaN(length)) {
                  this.raiseError("length string (" + lengthString + ") is not valid number");
                }
                return [4, this.readJsonString(length)];
              case 2:
                jsonString = _d.sent();
                return [2, new SizedBundleElement(JSON.parse(jsonString), lengthBuffer.length + length)];
            }
          });
        });
      };
      BundleReaderImpl2.prototype.indexOfOpenBracket = function() {
        return this.buffer.findIndex(function(v) {
          return v === "{".charCodeAt(0);
        });
      };
      BundleReaderImpl2.prototype.readLength = function() {
        return tslib2.__awaiter(this, void 0, void 0, function() {
          var done, position, result;
          return tslib2.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                if (!(this.indexOfOpenBracket() < 0))
                  return [3, 2];
                return [4, this.pullMoreDataToBuffer()];
              case 1:
                done = _d.sent();
                if (done) {
                  return [3, 2];
                }
                return [3, 0];
              case 2:
                if (this.buffer.length === 0) {
                  return [2, null];
                }
                position = this.indexOfOpenBracket();
                if (position < 0) {
                  this.raiseError("Reached the end of bundle when a length string is expected.");
                }
                result = this.buffer.slice(0, position);
                this.buffer = this.buffer.slice(position);
                return [2, result];
            }
          });
        });
      };
      BundleReaderImpl2.prototype.readJsonString = function(length) {
        return tslib2.__awaiter(this, void 0, void 0, function() {
          var done, result;
          return tslib2.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                if (!(this.buffer.length < length))
                  return [3, 2];
                return [4, this.pullMoreDataToBuffer()];
              case 1:
                done = _d.sent();
                if (done) {
                  this.raiseError("Reached the end of bundle when more is expected.");
                }
                return [3, 0];
              case 2:
                result = this.textDecoder.decode(this.buffer.slice(0, length));
                this.buffer = this.buffer.slice(length);
                return [2, result];
            }
          });
        });
      };
      BundleReaderImpl2.prototype.raiseError = function(message) {
        this.reader.cancel();
        throw new Error("Invalid bundle format: " + message);
      };
      BundleReaderImpl2.prototype.pullMoreDataToBuffer = function() {
        return tslib2.__awaiter(this, void 0, void 0, function() {
          var result, newBuffer;
          return tslib2.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                return [4, this.reader.read()];
              case 1:
                result = _d.sent();
                if (!result.done) {
                  newBuffer = new Uint8Array(this.buffer.length + result.value.length);
                  newBuffer.set(this.buffer);
                  newBuffer.set(result.value, this.buffer.length);
                  this.buffer = newBuffer;
                }
                return [2, result.done];
            }
          });
        });
      };
      return BundleReaderImpl2;
    }();
    function newBundleReader(reader, serializer) {
      return new BundleReaderImpl(reader, serializer);
    }
    var Transaction$2 = function() {
      function Transaction$22(datastore) {
        this.datastore = datastore;
        this.readVersions = new Map();
        this.mutations = [];
        this.committed = false;
        this.lastWriteError = null;
        this.writtenDocs = new Set();
      }
      Transaction$22.prototype.lookup = function(keys) {
        return tslib2.__awaiter(this, void 0, void 0, function() {
          var docs;
          var _this = this;
          return tslib2.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                this.ensureCommitNotCalled();
                if (this.mutations.length > 0) {
                  throw new FirestoreError(Code.INVALID_ARGUMENT, "Firestore transactions require all reads to be executed before all writes.");
                }
                return [4, invokeBatchGetDocumentsRpc(this.datastore, keys)];
              case 1:
                docs = _d.sent();
                docs.forEach(function(doc2) {
                  return _this.recordVersion(doc2);
                });
                return [2, docs];
            }
          });
        });
      };
      Transaction$22.prototype.set = function(key, data) {
        this.write(data.toMutation(key, this.precondition(key)));
        this.writtenDocs.add(key.toString());
      };
      Transaction$22.prototype.update = function(key, data) {
        try {
          this.write(data.toMutation(key, this.preconditionForUpdate(key)));
        } catch (e) {
          this.lastWriteError = e;
        }
        this.writtenDocs.add(key.toString());
      };
      Transaction$22.prototype.delete = function(key) {
        this.write(new DeleteMutation(key, this.precondition(key)));
        this.writtenDocs.add(key.toString());
      };
      Transaction$22.prototype.commit = function() {
        return tslib2.__awaiter(this, void 0, void 0, function() {
          var unwritten;
          var _this = this;
          return tslib2.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                this.ensureCommitNotCalled();
                if (this.lastWriteError) {
                  throw this.lastWriteError;
                }
                unwritten = this.readVersions;
                this.mutations.forEach(function(mutation) {
                  unwritten.delete(mutation.key.toString());
                });
                unwritten.forEach(function(_, path2) {
                  var key = DocumentKey.fromPath(path2);
                  _this.mutations.push(new VerifyMutation(key, _this.precondition(key)));
                });
                return [4, invokeCommitRpc(this.datastore, this.mutations)];
              case 1:
                _d.sent();
                this.committed = true;
                return [2];
            }
          });
        });
      };
      Transaction$22.prototype.recordVersion = function(doc2) {
        var docVersion;
        if (doc2.isFoundDocument()) {
          docVersion = doc2.version;
        } else if (doc2.isNoDocument()) {
          docVersion = SnapshotVersion.min();
        } else {
          throw fail();
        }
        var existingVersion = this.readVersions.get(doc2.key.toString());
        if (existingVersion) {
          if (!docVersion.isEqual(existingVersion)) {
            throw new FirestoreError(Code.ABORTED, "Document version changed between two reads.");
          }
        } else {
          this.readVersions.set(doc2.key.toString(), docVersion);
        }
      };
      Transaction$22.prototype.precondition = function(key) {
        var version3 = this.readVersions.get(key.toString());
        if (!this.writtenDocs.has(key.toString()) && version3) {
          return Precondition.updateTime(version3);
        } else {
          return Precondition.none();
        }
      };
      Transaction$22.prototype.preconditionForUpdate = function(key) {
        var version3 = this.readVersions.get(key.toString());
        if (!this.writtenDocs.has(key.toString()) && version3) {
          if (version3.isEqual(SnapshotVersion.min())) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Can't update a document that doesn't exist.");
          }
          return Precondition.updateTime(version3);
        } else {
          return Precondition.exists(true);
        }
      };
      Transaction$22.prototype.write = function(mutation) {
        this.ensureCommitNotCalled();
        this.mutations.push(mutation);
      };
      Transaction$22.prototype.ensureCommitNotCalled = function() {
      };
      return Transaction$22;
    }();
    var DEFAULT_MAX_ATTEMPTS_COUNT = 5;
    var TransactionRunner = function() {
      function TransactionRunner2(asyncQueue, datastore, updateFunction, deferred) {
        this.asyncQueue = asyncQueue;
        this.datastore = datastore;
        this.updateFunction = updateFunction;
        this.deferred = deferred;
        this.attemptsRemaining = DEFAULT_MAX_ATTEMPTS_COUNT;
        this.backoff = new ExponentialBackoff(this.asyncQueue, "transaction_retry");
      }
      TransactionRunner2.prototype.run = function() {
        this.attemptsRemaining -= 1;
        this.runWithBackOff();
      };
      TransactionRunner2.prototype.runWithBackOff = function() {
        var _this = this;
        this.backoff.backoffAndRun(function() {
          return tslib2.__awaiter(_this, void 0, void 0, function() {
            var transaction, userPromise;
            var _this2 = this;
            return tslib2.__generator(this, function(_d) {
              transaction = new Transaction$2(this.datastore);
              userPromise = this.tryRunUpdateFunction(transaction);
              if (userPromise) {
                userPromise.then(function(result) {
                  _this2.asyncQueue.enqueueAndForget(function() {
                    return transaction.commit().then(function() {
                      _this2.deferred.resolve(result);
                    }).catch(function(commitError) {
                      _this2.handleTransactionError(commitError);
                    });
                  });
                }).catch(function(userPromiseError) {
                  _this2.handleTransactionError(userPromiseError);
                });
              }
              return [2];
            });
          });
        });
      };
      TransactionRunner2.prototype.tryRunUpdateFunction = function(transaction) {
        try {
          var userPromise = this.updateFunction(transaction);
          if (isNullOrUndefined(userPromise) || !userPromise.catch || !userPromise.then) {
            this.deferred.reject(Error("Transaction callback must return a Promise"));
            return null;
          }
          return userPromise;
        } catch (error2) {
          this.deferred.reject(error2);
          return null;
        }
      };
      TransactionRunner2.prototype.handleTransactionError = function(error2) {
        var _this = this;
        if (this.attemptsRemaining > 0 && this.isRetryableTransactionError(error2)) {
          this.attemptsRemaining -= 1;
          this.asyncQueue.enqueueAndForget(function() {
            _this.runWithBackOff();
            return Promise.resolve();
          });
        } else {
          this.deferred.reject(error2);
        }
      };
      TransactionRunner2.prototype.isRetryableTransactionError = function(error2) {
        if (error2.name === "FirebaseError") {
          var code = error2.code;
          return code === "aborted" || code === "failed-precondition" || !isPermanentError(code);
        }
        return false;
      };
      return TransactionRunner2;
    }();
    var LOG_TAG$2 = "FirestoreClient";
    var MAX_CONCURRENT_LIMBO_RESOLUTIONS = 100;
    var FirestoreClient = function() {
      function FirestoreClient2(credentials, asyncQueue, databaseInfo) {
        var _this = this;
        this.credentials = credentials;
        this.asyncQueue = asyncQueue;
        this.databaseInfo = databaseInfo;
        this.user = User.UNAUTHENTICATED;
        this.clientId = AutoId.newId();
        this.credentialListener = function() {
          return Promise.resolve();
        };
        this.credentials.start(asyncQueue, function(user2) {
          return tslib2.__awaiter(_this, void 0, void 0, function() {
            return tslib2.__generator(this, function(_d) {
              switch (_d.label) {
                case 0:
                  logDebug(LOG_TAG$2, "Received user=", user2.uid);
                  return [4, this.credentialListener(user2)];
                case 1:
                  _d.sent();
                  this.user = user2;
                  return [2];
              }
            });
          });
        });
      }
      FirestoreClient2.prototype.getConfiguration = function() {
        return tslib2.__awaiter(this, void 0, void 0, function() {
          return tslib2.__generator(this, function(_d) {
            return [2, {
              asyncQueue: this.asyncQueue,
              databaseInfo: this.databaseInfo,
              clientId: this.clientId,
              credentials: this.credentials,
              initialUser: this.user,
              maxConcurrentLimboResolutions: MAX_CONCURRENT_LIMBO_RESOLUTIONS
            }];
          });
        });
      };
      FirestoreClient2.prototype.setCredentialChangeListener = function(listener) {
        this.credentialListener = listener;
      };
      FirestoreClient2.prototype.verifyNotTerminated = function() {
        if (this.asyncQueue.isShuttingDown) {
          throw new FirestoreError(Code.FAILED_PRECONDITION, "The client has already been terminated.");
        }
      };
      FirestoreClient2.prototype.terminate = function() {
        var _this = this;
        this.asyncQueue.enterRestrictedMode();
        var deferred = new Deferred2();
        this.asyncQueue.enqueueAndForgetEvenWhileRestricted(function() {
          return tslib2.__awaiter(_this, void 0, void 0, function() {
            var e_11, firestoreError;
            return tslib2.__generator(this, function(_d) {
              switch (_d.label) {
                case 0:
                  _d.trys.push([0, 5, , 6]);
                  if (!this.onlineComponents)
                    return [3, 2];
                  return [4, this.onlineComponents.terminate()];
                case 1:
                  _d.sent();
                  _d.label = 2;
                case 2:
                  if (!this.offlineComponents)
                    return [3, 4];
                  return [4, this.offlineComponents.terminate()];
                case 3:
                  _d.sent();
                  _d.label = 4;
                case 4:
                  this.credentials.shutdown();
                  deferred.resolve();
                  return [3, 6];
                case 5:
                  e_11 = _d.sent();
                  firestoreError = wrapInUserErrorIfRecoverable(e_11, "Failed to shutdown persistence");
                  deferred.reject(firestoreError);
                  return [3, 6];
                case 6:
                  return [2];
              }
            });
          });
        });
        return deferred.promise;
      };
      return FirestoreClient2;
    }();
    function setOfflineComponentProvider(client, offlineComponentProvider) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var configuration, currentUser;
        var _this = this;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              client.asyncQueue.verifyOperationInProgress();
              logDebug(LOG_TAG$2, "Initializing OfflineComponentProvider");
              return [4, client.getConfiguration()];
            case 1:
              configuration = _d.sent();
              return [4, offlineComponentProvider.initialize(configuration)];
            case 2:
              _d.sent();
              currentUser = configuration.initialUser;
              client.setCredentialChangeListener(function(user2) {
                return tslib2.__awaiter(_this, void 0, void 0, function() {
                  return tslib2.__generator(this, function(_d2) {
                    switch (_d2.label) {
                      case 0:
                        if (!!currentUser.isEqual(user2))
                          return [3, 2];
                        return [4, localStoreHandleUserChange(offlineComponentProvider.localStore, user2)];
                      case 1:
                        _d2.sent();
                        currentUser = user2;
                        _d2.label = 2;
                      case 2:
                        return [2];
                    }
                  });
                });
              });
              offlineComponentProvider.persistence.setDatabaseDeletedListener(function() {
                return client.terminate();
              });
              client.offlineComponents = offlineComponentProvider;
              return [2];
          }
        });
      });
    }
    function setOnlineComponentProvider(client, onlineComponentProvider) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var offlineComponentProvider, configuration;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              client.asyncQueue.verifyOperationInProgress();
              return [4, ensureOfflineComponents(client)];
            case 1:
              offlineComponentProvider = _d.sent();
              logDebug(LOG_TAG$2, "Initializing OnlineComponentProvider");
              return [4, client.getConfiguration()];
            case 2:
              configuration = _d.sent();
              return [4, onlineComponentProvider.initialize(offlineComponentProvider, configuration)];
            case 3:
              _d.sent();
              client.setCredentialChangeListener(function(user2) {
                return remoteStoreHandleCredentialChange(onlineComponentProvider.remoteStore, user2);
              });
              client.onlineComponents = onlineComponentProvider;
              return [2];
          }
        });
      });
    }
    function ensureOfflineComponents(client) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              if (!!client.offlineComponents)
                return [3, 2];
              logDebug(LOG_TAG$2, "Using default OfflineComponentProvider");
              return [4, setOfflineComponentProvider(client, new MemoryOfflineComponentProvider())];
            case 1:
              _d.sent();
              _d.label = 2;
            case 2:
              return [2, client.offlineComponents];
          }
        });
      });
    }
    function ensureOnlineComponents(client) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              if (!!client.onlineComponents)
                return [3, 2];
              logDebug(LOG_TAG$2, "Using default OnlineComponentProvider");
              return [4, setOnlineComponentProvider(client, new OnlineComponentProvider())];
            case 1:
              _d.sent();
              _d.label = 2;
            case 2:
              return [2, client.onlineComponents];
          }
        });
      });
    }
    function getPersistence(client) {
      return ensureOfflineComponents(client).then(function(c) {
        return c.persistence;
      });
    }
    function getLocalStore(client) {
      return ensureOfflineComponents(client).then(function(c) {
        return c.localStore;
      });
    }
    function getRemoteStore(client) {
      return ensureOnlineComponents(client).then(function(c) {
        return c.remoteStore;
      });
    }
    function getSyncEngine(client) {
      return ensureOnlineComponents(client).then(function(c) {
        return c.syncEngine;
      });
    }
    function getDatastore(client) {
      return ensureOnlineComponents(client).then(function(c) {
        return c.datastore;
      });
    }
    function getEventManager(client) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var onlineComponentProvider, eventManager;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              return [4, ensureOnlineComponents(client)];
            case 1:
              onlineComponentProvider = _d.sent();
              eventManager = onlineComponentProvider.eventManager;
              eventManager.onListen = syncEngineListen.bind(null, onlineComponentProvider.syncEngine);
              eventManager.onUnlisten = syncEngineUnlisten.bind(null, onlineComponentProvider.syncEngine);
              return [2, eventManager];
          }
        });
      });
    }
    function firestoreClientEnableNetwork(client) {
      var _this = this;
      return client.asyncQueue.enqueue(function() {
        return tslib2.__awaiter(_this, void 0, void 0, function() {
          var persistence, remoteStore;
          return tslib2.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                return [4, getPersistence(client)];
              case 1:
                persistence = _d.sent();
                return [4, getRemoteStore(client)];
              case 2:
                remoteStore = _d.sent();
                persistence.setNetworkEnabled(true);
                return [2, remoteStoreEnableNetwork(remoteStore)];
            }
          });
        });
      });
    }
    function firestoreClientDisableNetwork(client) {
      var _this = this;
      return client.asyncQueue.enqueue(function() {
        return tslib2.__awaiter(_this, void 0, void 0, function() {
          var persistence, remoteStore;
          return tslib2.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                return [4, getPersistence(client)];
              case 1:
                persistence = _d.sent();
                return [4, getRemoteStore(client)];
              case 2:
                remoteStore = _d.sent();
                persistence.setNetworkEnabled(false);
                return [2, remoteStoreDisableNetwork(remoteStore)];
            }
          });
        });
      });
    }
    function firestoreClientWaitForPendingWrites(client) {
      var _this = this;
      var deferred = new Deferred2();
      client.asyncQueue.enqueueAndForget(function() {
        return tslib2.__awaiter(_this, void 0, void 0, function() {
          var syncEngine;
          return tslib2.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                return [4, getSyncEngine(client)];
              case 1:
                syncEngine = _d.sent();
                return [2, syncEngineRegisterPendingWritesCallback(syncEngine, deferred)];
            }
          });
        });
      });
      return deferred.promise;
    }
    function firestoreClientListen(client, query2, options2, observer) {
      var _this = this;
      var wrappedObserver = new AsyncObserver(observer);
      var listener = new QueryListener(query2, wrappedObserver, options2);
      client.asyncQueue.enqueueAndForget(function() {
        return tslib2.__awaiter(_this, void 0, void 0, function() {
          var eventManager;
          return tslib2.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                return [4, getEventManager(client)];
              case 1:
                eventManager = _d.sent();
                return [2, eventManagerListen(eventManager, listener)];
            }
          });
        });
      });
      return function() {
        wrappedObserver.mute();
        client.asyncQueue.enqueueAndForget(function() {
          return tslib2.__awaiter(_this, void 0, void 0, function() {
            var eventManager;
            return tslib2.__generator(this, function(_d) {
              switch (_d.label) {
                case 0:
                  return [4, getEventManager(client)];
                case 1:
                  eventManager = _d.sent();
                  return [2, eventManagerUnlisten(eventManager, listener)];
              }
            });
          });
        });
      };
    }
    function firestoreClientGetDocumentFromLocalCache(client, docKey) {
      var _this = this;
      var deferred = new Deferred2();
      client.asyncQueue.enqueueAndForget(function() {
        return tslib2.__awaiter(_this, void 0, void 0, function() {
          var localStore2;
          return tslib2.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                return [4, getLocalStore(client)];
              case 1:
                localStore2 = _d.sent();
                return [2, readDocumentFromCache(localStore2, docKey, deferred)];
            }
          });
        });
      });
      return deferred.promise;
    }
    function firestoreClientGetDocumentViaSnapshotListener(client, key, options2) {
      var _this = this;
      if (options2 === void 0) {
        options2 = {};
      }
      var deferred = new Deferred2();
      client.asyncQueue.enqueueAndForget(function() {
        return tslib2.__awaiter(_this, void 0, void 0, function() {
          var eventManager;
          return tslib2.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                return [4, getEventManager(client)];
              case 1:
                eventManager = _d.sent();
                return [2, readDocumentViaSnapshotListener(eventManager, client.asyncQueue, key, options2, deferred)];
            }
          });
        });
      });
      return deferred.promise;
    }
    function firestoreClientGetDocumentsFromLocalCache(client, query2) {
      var _this = this;
      var deferred = new Deferred2();
      client.asyncQueue.enqueueAndForget(function() {
        return tslib2.__awaiter(_this, void 0, void 0, function() {
          var localStore2;
          return tslib2.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                return [4, getLocalStore(client)];
              case 1:
                localStore2 = _d.sent();
                return [2, executeQueryFromCache(localStore2, query2, deferred)];
            }
          });
        });
      });
      return deferred.promise;
    }
    function firestoreClientGetDocumentsViaSnapshotListener(client, query2, options2) {
      var _this = this;
      if (options2 === void 0) {
        options2 = {};
      }
      var deferred = new Deferred2();
      client.asyncQueue.enqueueAndForget(function() {
        return tslib2.__awaiter(_this, void 0, void 0, function() {
          var eventManager;
          return tslib2.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                return [4, getEventManager(client)];
              case 1:
                eventManager = _d.sent();
                return [2, executeQueryViaSnapshotListener(eventManager, client.asyncQueue, query2, options2, deferred)];
            }
          });
        });
      });
      return deferred.promise;
    }
    function firestoreClientWrite(client, mutations) {
      var _this = this;
      var deferred = new Deferred2();
      client.asyncQueue.enqueueAndForget(function() {
        return tslib2.__awaiter(_this, void 0, void 0, function() {
          var syncEngine;
          return tslib2.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                return [4, getSyncEngine(client)];
              case 1:
                syncEngine = _d.sent();
                return [2, syncEngineWrite(syncEngine, mutations, deferred)];
            }
          });
        });
      });
      return deferred.promise;
    }
    function firestoreClientAddSnapshotsInSyncListener(client, observer) {
      var _this = this;
      var wrappedObserver = new AsyncObserver(observer);
      client.asyncQueue.enqueueAndForget(function() {
        return tslib2.__awaiter(_this, void 0, void 0, function() {
          var eventManager;
          return tslib2.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                return [4, getEventManager(client)];
              case 1:
                eventManager = _d.sent();
                return [2, addSnapshotsInSyncListener(eventManager, wrappedObserver)];
            }
          });
        });
      });
      return function() {
        wrappedObserver.mute();
        client.asyncQueue.enqueueAndForget(function() {
          return tslib2.__awaiter(_this, void 0, void 0, function() {
            var eventManager;
            return tslib2.__generator(this, function(_d) {
              switch (_d.label) {
                case 0:
                  return [4, getEventManager(client)];
                case 1:
                  eventManager = _d.sent();
                  return [2, removeSnapshotsInSyncListener(eventManager, wrappedObserver)];
              }
            });
          });
        });
      };
    }
    function firestoreClientTransaction(client, updateFunction) {
      var _this = this;
      var deferred = new Deferred2();
      client.asyncQueue.enqueueAndForget(function() {
        return tslib2.__awaiter(_this, void 0, void 0, function() {
          var datastore;
          return tslib2.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                return [4, getDatastore(client)];
              case 1:
                datastore = _d.sent();
                new TransactionRunner(client.asyncQueue, datastore, updateFunction, deferred).run();
                return [2];
            }
          });
        });
      });
      return deferred.promise;
    }
    function readDocumentFromCache(localStore2, docKey, result) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var document_4, e_12, firestoreError;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              _d.trys.push([0, 2, , 3]);
              return [4, localStoreReadDocument(localStore2, docKey)];
            case 1:
              document_4 = _d.sent();
              if (document_4.isFoundDocument()) {
                result.resolve(document_4);
              } else if (document_4.isNoDocument()) {
                result.resolve(null);
              } else {
                result.reject(new FirestoreError(Code.UNAVAILABLE, "Failed to get document from cache. (However, this document may exist on the server. Run again without setting 'source' in the GetOptions to attempt to retrieve the document from the server.)"));
              }
              return [3, 3];
            case 2:
              e_12 = _d.sent();
              firestoreError = wrapInUserErrorIfRecoverable(e_12, "Failed to get document '" + docKey + " from cache");
              result.reject(firestoreError);
              return [3, 3];
            case 3:
              return [2];
          }
        });
      });
    }
    function readDocumentViaSnapshotListener(eventManager, asyncQueue, key, options2, result) {
      var wrappedObserver = new AsyncObserver({
        next: function(snap) {
          asyncQueue.enqueueAndForget(function() {
            return eventManagerUnlisten(eventManager, listener);
          });
          var exists = snap.docs.has(key);
          if (!exists && snap.fromCache) {
            result.reject(new FirestoreError(Code.UNAVAILABLE, "Failed to get document because the client is offline."));
          } else if (exists && snap.fromCache && options2 && options2.source === "server") {
            result.reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)'));
          } else {
            result.resolve(snap);
          }
        },
        error: function(e) {
          return result.reject(e);
        }
      });
      var listener = new QueryListener(newQueryForPath(key.path), wrappedObserver, {
        includeMetadataChanges: true,
        waitForSyncWhenOnline: true
      });
      return eventManagerListen(eventManager, listener);
    }
    function executeQueryFromCache(localStore2, query2, result) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var queryResult, view, viewDocChanges, viewChange, e_13, firestoreError;
        return tslib2.__generator(this, function(_d) {
          switch (_d.label) {
            case 0:
              _d.trys.push([0, 2, , 3]);
              return [4, localStoreExecuteQuery(localStore2, query2, true)];
            case 1:
              queryResult = _d.sent();
              view = new View(query2, queryResult.remoteKeys);
              viewDocChanges = view.computeDocChanges(queryResult.documents);
              viewChange = view.applyChanges(viewDocChanges, false);
              result.resolve(viewChange.snapshot);
              return [3, 3];
            case 2:
              e_13 = _d.sent();
              firestoreError = wrapInUserErrorIfRecoverable(e_13, "Failed to execute query '" + query2 + " against cache");
              result.reject(firestoreError);
              return [3, 3];
            case 3:
              return [2];
          }
        });
      });
    }
    function executeQueryViaSnapshotListener(eventManager, asyncQueue, query2, options2, result) {
      var wrappedObserver = new AsyncObserver({
        next: function(snapshot) {
          asyncQueue.enqueueAndForget(function() {
            return eventManagerUnlisten(eventManager, listener);
          });
          if (snapshot.fromCache && options2.source === "server") {
            result.reject(new FirestoreError(Code.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)'));
          } else {
            result.resolve(snapshot);
          }
        },
        error: function(e) {
          return result.reject(e);
        }
      });
      var listener = new QueryListener(query2, wrappedObserver, {
        includeMetadataChanges: true,
        waitForSyncWhenOnline: true
      });
      return eventManagerListen(eventManager, listener);
    }
    function firestoreClientLoadBundle(client, databaseId, data, resultTask) {
      var _this = this;
      var reader = createBundleReader(data, newSerializer(databaseId));
      client.asyncQueue.enqueueAndForget(function() {
        return tslib2.__awaiter(_this, void 0, void 0, function() {
          var _d;
          return tslib2.__generator(this, function(_e) {
            switch (_e.label) {
              case 0:
                _d = syncEngineLoadBundle;
                return [4, getSyncEngine(client)];
              case 1:
                _d.apply(void 0, [_e.sent(), reader, resultTask]);
                return [2];
            }
          });
        });
      });
    }
    function firestoreClientGetNamedQuery(client, queryName) {
      var _this = this;
      return client.asyncQueue.enqueue(function() {
        return tslib2.__awaiter(_this, void 0, void 0, function() {
          var _d;
          return tslib2.__generator(this, function(_e) {
            switch (_e.label) {
              case 0:
                _d = localStoreGetNamedQuery;
                return [4, getLocalStore(client)];
              case 1:
                return [2, _d.apply(void 0, [_e.sent(), queryName])];
            }
          });
        });
      });
    }
    function createBundleReader(data, serializer) {
      var content;
      if (typeof data === "string") {
        content = newTextEncoder().encode(data);
      } else {
        content = data;
      }
      return newBundleReader(toByteStreamReader(content), serializer);
    }
    var DatabaseInfo = function() {
      function DatabaseInfo2(databaseId, appId, persistenceKey, host, ssl, forceLongPolling, autoDetectLongPolling, useFetchStreams) {
        this.databaseId = databaseId;
        this.appId = appId;
        this.persistenceKey = persistenceKey;
        this.host = host;
        this.ssl = ssl;
        this.forceLongPolling = forceLongPolling;
        this.autoDetectLongPolling = autoDetectLongPolling;
        this.useFetchStreams = useFetchStreams;
      }
      return DatabaseInfo2;
    }();
    var DEFAULT_DATABASE_NAME = "(default)";
    var DatabaseId = function() {
      function DatabaseId2(projectId, database) {
        this.projectId = projectId;
        this.database = database ? database : DEFAULT_DATABASE_NAME;
      }
      Object.defineProperty(DatabaseId2.prototype, "isDefaultDatabase", {
        get: function() {
          return this.database === DEFAULT_DATABASE_NAME;
        },
        enumerable: false,
        configurable: true
      });
      DatabaseId2.prototype.isEqual = function(other) {
        return other instanceof DatabaseId2 && other.projectId === this.projectId && other.database === this.database;
      };
      return DatabaseId2;
    }();
    var LOG_TAG$1 = "ComponentProvider";
    var datastoreInstances = new Map();
    function removeComponents(firestore) {
      var datastore = datastoreInstances.get(firestore);
      if (datastore) {
        logDebug(LOG_TAG$1, "Removing Datastore");
        datastoreInstances.delete(firestore);
        datastore.terminate();
      }
    }
    function makeDatabaseInfo(databaseId, appId, persistenceKey, settings2) {
      return new DatabaseInfo(databaseId, appId, persistenceKey, settings2.host, settings2.ssl, settings2.experimentalForceLongPolling, settings2.experimentalAutoDetectLongPolling, settings2.useFetchStreams);
    }
    var DEFAULT_HOST2 = "firestore.googleapis.com";
    var DEFAULT_SSL = true;
    var FirestoreSettingsImpl = function() {
      function FirestoreSettingsImpl2(settings2) {
        var _a;
        if (settings2.host === void 0) {
          if (settings2.ssl !== void 0) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
          }
          this.host = DEFAULT_HOST2;
          this.ssl = DEFAULT_SSL;
        } else {
          this.host = settings2.host;
          this.ssl = (_a = settings2.ssl) !== null && _a !== void 0 ? _a : DEFAULT_SSL;
        }
        this.credentials = settings2.credentials;
        this.ignoreUndefinedProperties = !!settings2.ignoreUndefinedProperties;
        if (settings2.cacheSizeBytes === void 0) {
          this.cacheSizeBytes = LRU_DEFAULT_CACHE_SIZE_BYTES;
        } else {
          if (settings2.cacheSizeBytes !== LRU_COLLECTION_DISABLED && settings2.cacheSizeBytes < LRU_MINIMUM_CACHE_SIZE_BYTES) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "cacheSizeBytes must be at least " + LRU_MINIMUM_CACHE_SIZE_BYTES);
          } else {
            this.cacheSizeBytes = settings2.cacheSizeBytes;
          }
        }
        this.experimentalForceLongPolling = !!settings2.experimentalForceLongPolling;
        this.experimentalAutoDetectLongPolling = !!settings2.experimentalAutoDetectLongPolling;
        this.useFetchStreams = !!settings2.useFetchStreams;
        validateIsNotUsedTogether("experimentalForceLongPolling", settings2.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", settings2.experimentalAutoDetectLongPolling);
      }
      FirestoreSettingsImpl2.prototype.isEqual = function(other) {
        return this.host === other.host && this.ssl === other.ssl && this.credentials === other.credentials && this.cacheSizeBytes === other.cacheSizeBytes && this.experimentalForceLongPolling === other.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === other.experimentalAutoDetectLongPolling && this.ignoreUndefinedProperties === other.ignoreUndefinedProperties && this.useFetchStreams === other.useFetchStreams;
      };
      return FirestoreSettingsImpl2;
    }();
    var Firestore$1 = function() {
      function Firestore$12(databaseIdOrApp, _credentials) {
        this._credentials = _credentials;
        this.type = "firestore-lite";
        this._persistenceKey = "(lite)";
        this._settings = new FirestoreSettingsImpl({});
        this._settingsFrozen = false;
        if (databaseIdOrApp instanceof DatabaseId) {
          this._databaseId = databaseIdOrApp;
        } else {
          this._app = databaseIdOrApp;
          this._databaseId = databaseIdFromApp(databaseIdOrApp);
        }
      }
      Object.defineProperty(Firestore$12.prototype, "app", {
        get: function() {
          if (!this._app) {
            throw new FirestoreError(Code.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
          }
          return this._app;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Firestore$12.prototype, "_initialized", {
        get: function() {
          return this._settingsFrozen;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Firestore$12.prototype, "_terminated", {
        get: function() {
          return this._terminateTask !== void 0;
        },
        enumerable: false,
        configurable: true
      });
      Firestore$12.prototype._setSettings = function(settings2) {
        if (this._settingsFrozen) {
          throw new FirestoreError(Code.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
        }
        this._settings = new FirestoreSettingsImpl(settings2);
        if (settings2.credentials !== void 0) {
          this._credentials = makeCredentialsProvider(settings2.credentials);
        }
      };
      Firestore$12.prototype._getSettings = function() {
        return this._settings;
      };
      Firestore$12.prototype._freezeSettings = function() {
        this._settingsFrozen = true;
        return this._settings;
      };
      Firestore$12.prototype._delete = function() {
        if (!this._terminateTask) {
          this._terminateTask = this._terminate();
        }
        return this._terminateTask;
      };
      Firestore$12.prototype.toJSON = function() {
        return {
          app: this._app,
          databaseId: this._databaseId,
          settings: this._settings
        };
      };
      Firestore$12.prototype._terminate = function() {
        removeComponents(this);
        return Promise.resolve();
      };
      return Firestore$12;
    }();
    function databaseIdFromApp(app2) {
      if (!Object.prototype.hasOwnProperty.apply(app2.options, ["projectId"])) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
      }
      return new DatabaseId(app2.options.projectId);
    }
    function connectFirestoreEmulator(firestore, host, port, options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      var _a;
      firestore = cast(firestore, Firestore$1);
      var settings2 = firestore._getSettings();
      if (settings2.host !== DEFAULT_HOST2 && settings2.host !== host) {
        logWarn("Host has been set in both settings() and useEmulator(), emulator host will be used");
      }
      firestore._setSettings(Object.assign(Object.assign({}, settings2), { host: host + ":" + port, ssl: false }));
      if (options2.mockUserToken) {
        var token = void 0;
        var user2 = void 0;
        if (typeof options2.mockUserToken === "string") {
          token = options2.mockUserToken;
          user2 = User.MOCK_USER;
        } else {
          token = util.createMockUserToken(options2.mockUserToken, (_a = firestore._app) === null || _a === void 0 ? void 0 : _a.options.projectId);
          var uid = options2.mockUserToken.sub || options2.mockUserToken.user_id;
          if (!uid) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!");
          }
          user2 = new User(uid);
        }
        firestore._credentials = new EmulatorCredentialsProvider(new OAuthToken(token, user2));
      }
    }
    var DocumentReference = function() {
      function DocumentReference2(firestore, converter, _key) {
        this.converter = converter;
        this._key = _key;
        this.type = "document";
        this.firestore = firestore;
      }
      Object.defineProperty(DocumentReference2.prototype, "_path", {
        get: function() {
          return this._key.path;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocumentReference2.prototype, "id", {
        get: function() {
          return this._key.path.lastSegment();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocumentReference2.prototype, "path", {
        get: function() {
          return this._key.path.canonicalString();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocumentReference2.prototype, "parent", {
        get: function() {
          return new CollectionReference(this.firestore, this.converter, this._key.path.popLast());
        },
        enumerable: false,
        configurable: true
      });
      DocumentReference2.prototype.withConverter = function(converter) {
        return new DocumentReference2(this.firestore, converter, this._key);
      };
      return DocumentReference2;
    }();
    var Query = function() {
      function Query2(firestore, converter, _query) {
        this.converter = converter;
        this._query = _query;
        this.type = "query";
        this.firestore = firestore;
      }
      Query2.prototype.withConverter = function(converter) {
        return new Query2(this.firestore, converter, this._query);
      };
      return Query2;
    }();
    var CollectionReference = function(_super) {
      tslib2.__extends(CollectionReference2, _super);
      function CollectionReference2(firestore, converter, _path) {
        var _this = _super.call(this, firestore, converter, newQueryForPath(_path)) || this;
        _this._path = _path;
        _this.type = "collection";
        return _this;
      }
      Object.defineProperty(CollectionReference2.prototype, "id", {
        get: function() {
          return this._query.path.lastSegment();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CollectionReference2.prototype, "path", {
        get: function() {
          return this._query.path.canonicalString();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CollectionReference2.prototype, "parent", {
        get: function() {
          var parentPath = this._path.popLast();
          if (parentPath.isEmpty()) {
            return null;
          } else {
            return new DocumentReference(this.firestore, null, new DocumentKey(parentPath));
          }
        },
        enumerable: false,
        configurable: true
      });
      CollectionReference2.prototype.withConverter = function(converter) {
        return new CollectionReference2(this.firestore, converter, this._path);
      };
      return CollectionReference2;
    }(Query);
    function collection2(parent2, path2) {
      var pathSegments = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        pathSegments[_i - 2] = arguments[_i];
      }
      parent2 = util.getModularInstance(parent2);
      validateNonEmptyArgument("collection", "path", path2);
      if (parent2 instanceof Firestore$1) {
        var absolutePath = ResourcePath.fromString.apply(ResourcePath, tslib2.__spreadArray([path2], pathSegments));
        validateCollectionPath(absolutePath);
        return new CollectionReference(parent2, null, absolutePath);
      } else {
        if (!(parent2 instanceof DocumentReference) && !(parent2 instanceof CollectionReference)) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
        }
        var absolutePath = parent2._path.child(ResourcePath.fromString.apply(ResourcePath, tslib2.__spreadArray([path2], pathSegments)));
        validateCollectionPath(absolutePath);
        return new CollectionReference(parent2.firestore, null, absolutePath);
      }
    }
    function collectionGroup(firestore, collectionId) {
      firestore = cast(firestore, Firestore$1);
      validateNonEmptyArgument("collectionGroup", "collection id", collectionId);
      if (collectionId.indexOf("/") >= 0) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid collection ID '" + collectionId + "' passed to function collectionGroup(). Collection IDs must not contain '/'.");
      }
      return new Query(firestore, null, newQueryForCollectionGroup(collectionId));
    }
    function doc(parent2, path2) {
      var pathSegments = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        pathSegments[_i - 2] = arguments[_i];
      }
      parent2 = util.getModularInstance(parent2);
      if (arguments.length === 1) {
        path2 = AutoId.newId();
      }
      validateNonEmptyArgument("doc", "path", path2);
      if (parent2 instanceof Firestore$1) {
        var absolutePath = ResourcePath.fromString.apply(ResourcePath, tslib2.__spreadArray([path2], pathSegments));
        validateDocumentPath(absolutePath);
        return new DocumentReference(parent2, null, new DocumentKey(absolutePath));
      } else {
        if (!(parent2 instanceof DocumentReference) && !(parent2 instanceof CollectionReference)) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
        }
        var absolutePath = parent2._path.child(ResourcePath.fromString.apply(ResourcePath, tslib2.__spreadArray([path2], pathSegments)));
        validateDocumentPath(absolutePath);
        return new DocumentReference(parent2.firestore, parent2 instanceof CollectionReference ? parent2.converter : null, new DocumentKey(absolutePath));
      }
    }
    function refEqual(left, right) {
      left = util.getModularInstance(left);
      right = util.getModularInstance(right);
      if ((left instanceof DocumentReference || left instanceof CollectionReference) && (right instanceof DocumentReference || right instanceof CollectionReference)) {
        return left.firestore === right.firestore && left.path === right.path && left.converter === right.converter;
      }
      return false;
    }
    function queryEqual(left, right) {
      left = util.getModularInstance(left);
      right = util.getModularInstance(right);
      if (left instanceof Query && right instanceof Query) {
        return left.firestore === right.firestore && queryEquals(left._query, right._query) && left.converter === right.converter;
      }
      return false;
    }
    var LOG_TAG = "AsyncQueue";
    var AsyncQueueImpl = function() {
      function AsyncQueueImpl2() {
        var _this = this;
        this.tail = Promise.resolve();
        this.retryableOps = [];
        this._isShuttingDown = false;
        this.delayedOperations = [];
        this.failure = null;
        this.operationInProgress = false;
        this.skipNonRestrictedTasks = false;
        this.timerIdsToSkip = [];
        this.backoff = new ExponentialBackoff(this, "async_queue_retry");
        this.visibilityHandler = function() {
          _this.backoff.skipBackoff();
        };
      }
      Object.defineProperty(AsyncQueueImpl2.prototype, "isShuttingDown", {
        get: function() {
          return this._isShuttingDown;
        },
        enumerable: false,
        configurable: true
      });
      AsyncQueueImpl2.prototype.enqueueAndForget = function(op) {
        this.enqueue(op);
      };
      AsyncQueueImpl2.prototype.enqueueAndForgetEvenWhileRestricted = function(op) {
        this.verifyNotFailed();
        this.enqueueInternal(op);
      };
      AsyncQueueImpl2.prototype.enterRestrictedMode = function(purgeExistingTasks) {
        if (!this._isShuttingDown) {
          this._isShuttingDown = true;
          this.skipNonRestrictedTasks = purgeExistingTasks || false;
        }
      };
      AsyncQueueImpl2.prototype.enqueue = function(op) {
        var _this = this;
        this.verifyNotFailed();
        if (this._isShuttingDown) {
          return new Promise(function() {
          });
        }
        var task = new Deferred2();
        return this.enqueueInternal(function() {
          if (_this._isShuttingDown && _this.skipNonRestrictedTasks) {
            return Promise.resolve();
          }
          op().then(task.resolve, task.reject);
          return task.promise;
        }).then(function() {
          return task.promise;
        });
      };
      AsyncQueueImpl2.prototype.enqueueRetryable = function(op) {
        var _this = this;
        this.enqueueAndForget(function() {
          _this.retryableOps.push(op);
          return _this.retryNextOp();
        });
      };
      AsyncQueueImpl2.prototype.retryNextOp = function() {
        return tslib2.__awaiter(this, void 0, void 0, function() {
          var e_14;
          var _this = this;
          return tslib2.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                if (this.retryableOps.length === 0) {
                  return [2];
                }
                _d.label = 1;
              case 1:
                _d.trys.push([1, 3, , 4]);
                return [4, this.retryableOps[0]()];
              case 2:
                _d.sent();
                this.retryableOps.shift();
                this.backoff.reset();
                return [3, 4];
              case 3:
                e_14 = _d.sent();
                if (isIndexedDbTransactionError(e_14)) {
                  logDebug(LOG_TAG, "Operation failed with retryable error: " + e_14);
                } else {
                  throw e_14;
                }
                return [3, 4];
              case 4:
                if (this.retryableOps.length > 0) {
                  this.backoff.backoffAndRun(function() {
                    return _this.retryNextOp();
                  });
                }
                return [2];
            }
          });
        });
      };
      AsyncQueueImpl2.prototype.enqueueInternal = function(op) {
        var _this = this;
        var newTail = this.tail.then(function() {
          _this.operationInProgress = true;
          return op().catch(function(error2) {
            _this.failure = error2;
            _this.operationInProgress = false;
            var message = getMessageOrStack(error2);
            logError("INTERNAL UNHANDLED ERROR: ", message);
            throw error2;
          }).then(function(result) {
            _this.operationInProgress = false;
            return result;
          });
        });
        this.tail = newTail;
        return newTail;
      };
      AsyncQueueImpl2.prototype.enqueueAfterDelay = function(timerId, delayMs, op) {
        var _this = this;
        this.verifyNotFailed();
        if (this.timerIdsToSkip.indexOf(timerId) > -1) {
          delayMs = 0;
        }
        var delayedOp = DelayedOperation.createAndSchedule(this, timerId, delayMs, op, function(removedOp) {
          return _this.removeDelayedOperation(removedOp);
        });
        this.delayedOperations.push(delayedOp);
        return delayedOp;
      };
      AsyncQueueImpl2.prototype.verifyNotFailed = function() {
        if (this.failure) {
          fail();
        }
      };
      AsyncQueueImpl2.prototype.verifyOperationInProgress = function() {
      };
      AsyncQueueImpl2.prototype.drain = function() {
        return tslib2.__awaiter(this, void 0, void 0, function() {
          var currentTail;
          return tslib2.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                currentTail = this.tail;
                return [4, currentTail];
              case 1:
                _d.sent();
                _d.label = 2;
              case 2:
                if (currentTail !== this.tail)
                  return [3, 0];
                _d.label = 3;
              case 3:
                return [2];
            }
          });
        });
      };
      AsyncQueueImpl2.prototype.containsDelayedOperation = function(timerId) {
        for (var _i = 0, _d = this.delayedOperations; _i < _d.length; _i++) {
          var op = _d[_i];
          if (op.timerId === timerId) {
            return true;
          }
        }
        return false;
      };
      AsyncQueueImpl2.prototype.runAllDelayedOperationsUntil = function(lastTimerId) {
        var _this = this;
        return this.drain().then(function() {
          _this.delayedOperations.sort(function(a, b) {
            return a.targetTimeMs - b.targetTimeMs;
          });
          for (var _i = 0, _d = _this.delayedOperations; _i < _d.length; _i++) {
            var op = _d[_i];
            op.skipDelay();
            if (lastTimerId !== "all" && op.timerId === lastTimerId) {
              break;
            }
          }
          return _this.drain();
        });
      };
      AsyncQueueImpl2.prototype.skipDelaysForTimerId = function(timerId) {
        this.timerIdsToSkip.push(timerId);
      };
      AsyncQueueImpl2.prototype.removeDelayedOperation = function(op) {
        var index2 = this.delayedOperations.indexOf(op);
        this.delayedOperations.splice(index2, 1);
      };
      return AsyncQueueImpl2;
    }();
    function newAsyncQueue() {
      return new AsyncQueueImpl();
    }
    function getMessageOrStack(error2) {
      var message = error2.message || "";
      if (error2.stack) {
        if (error2.stack.includes(error2.message)) {
          message = error2.stack;
        } else {
          message = error2.message + "\n" + error2.stack;
        }
      }
      return message;
    }
    var LoadBundleTask = function() {
      function LoadBundleTask2() {
        this._progressObserver = {};
        this._taskCompletionResolver = new Deferred2();
        this._lastProgress = {
          taskState: "Running",
          totalBytes: 0,
          totalDocuments: 0,
          bytesLoaded: 0,
          documentsLoaded: 0
        };
      }
      LoadBundleTask2.prototype.onProgress = function(next, error2, complete) {
        this._progressObserver = {
          next,
          error: error2,
          complete
        };
      };
      LoadBundleTask2.prototype.catch = function(onRejected) {
        return this._taskCompletionResolver.promise.catch(onRejected);
      };
      LoadBundleTask2.prototype.then = function(onFulfilled, onRejected) {
        return this._taskCompletionResolver.promise.then(onFulfilled, onRejected);
      };
      LoadBundleTask2.prototype._completeWith = function(progress) {
        this._updateProgress(progress);
        if (this._progressObserver.complete) {
          this._progressObserver.complete();
        }
        this._taskCompletionResolver.resolve(progress);
      };
      LoadBundleTask2.prototype._failWith = function(error2) {
        this._lastProgress.taskState = "Error";
        if (this._progressObserver.next) {
          this._progressObserver.next(this._lastProgress);
        }
        if (this._progressObserver.error) {
          this._progressObserver.error(error2);
        }
        this._taskCompletionResolver.reject(error2);
      };
      LoadBundleTask2.prototype._updateProgress = function(progress) {
        this._lastProgress = progress;
        if (this._progressObserver.next) {
          this._progressObserver.next(progress);
        }
      };
      return LoadBundleTask2;
    }();
    var DOM_EXCEPTION_INVALID_STATE = 11;
    var DOM_EXCEPTION_ABORTED = 20;
    var DOM_EXCEPTION_QUOTA_EXCEEDED = 22;
    var CACHE_SIZE_UNLIMITED = LRU_COLLECTION_DISABLED;
    var Firestore = function(_super) {
      tslib2.__extends(Firestore2, _super);
      function Firestore2(databaseIdOrApp, credentialsProvider) {
        var _this = _super.call(this, databaseIdOrApp, credentialsProvider) || this;
        _this.type = "firestore";
        _this._queue = newAsyncQueue();
        _this._persistenceKey = "name" in databaseIdOrApp ? databaseIdOrApp.name : "[DEFAULT]";
        return _this;
      }
      Firestore2.prototype._terminate = function() {
        if (!this._firestoreClient) {
          configureFirestore(this);
        }
        return this._firestoreClient.terminate();
      };
      return Firestore2;
    }(Firestore$1);
    function initializeFirestore(app$1, settings2) {
      var provider = app._getProvider(app$1, "firestore");
      if (provider.isInitialized()) {
        var existingInstance = provider.getImmediate();
        var initialSettings = provider.getOptions();
        if (util.deepEqual(initialSettings, settings2)) {
          return existingInstance;
        } else {
          throw new FirestoreError(Code.FAILED_PRECONDITION, "initializeFirestore() has already been called with different options. To avoid this error, call initializeFirestore() with the same options as when it was originally called, or call getFirestore() to return the already initialized instance.");
        }
      }
      if (settings2.cacheSizeBytes !== void 0 && settings2.cacheSizeBytes !== CACHE_SIZE_UNLIMITED && settings2.cacheSizeBytes < LRU_MINIMUM_CACHE_SIZE_BYTES) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "cacheSizeBytes must be at least " + LRU_MINIMUM_CACHE_SIZE_BYTES);
      }
      return provider.initialize({ options: settings2 });
    }
    function getFirestore2(app$1) {
      if (app$1 === void 0) {
        app$1 = app.getApp();
      }
      return app._getProvider(app$1, "firestore").getImmediate();
    }
    function ensureFirestoreConfigured(firestore) {
      if (!firestore._firestoreClient) {
        configureFirestore(firestore);
      }
      firestore._firestoreClient.verifyNotTerminated();
      return firestore._firestoreClient;
    }
    function configureFirestore(firestore) {
      var _a;
      var settings2 = firestore._freezeSettings();
      var databaseInfo = makeDatabaseInfo(firestore._databaseId, ((_a = firestore._app) === null || _a === void 0 ? void 0 : _a.options.appId) || "", firestore._persistenceKey, settings2);
      firestore._firestoreClient = new FirestoreClient(firestore._credentials, firestore._queue, databaseInfo);
    }
    function enableIndexedDbPersistence(firestore, persistenceSettings) {
      firestore = cast(firestore, Firestore);
      verifyNotInitialized(firestore);
      var client = ensureFirestoreConfigured(firestore);
      var settings2 = firestore._freezeSettings();
      var onlineComponentProvider = new OnlineComponentProvider();
      var offlineComponentProvider = new IndexedDbOfflineComponentProvider(onlineComponentProvider, settings2.cacheSizeBytes, persistenceSettings === null || persistenceSettings === void 0 ? void 0 : persistenceSettings.forceOwnership);
      return setPersistenceProviders(client, onlineComponentProvider, offlineComponentProvider);
    }
    function enableMultiTabIndexedDbPersistence(firestore) {
      firestore = cast(firestore, Firestore);
      verifyNotInitialized(firestore);
      var client = ensureFirestoreConfigured(firestore);
      var settings2 = firestore._freezeSettings();
      var onlineComponentProvider = new OnlineComponentProvider();
      var offlineComponentProvider = new MultiTabOfflineComponentProvider(onlineComponentProvider, settings2.cacheSizeBytes);
      return setPersistenceProviders(client, onlineComponentProvider, offlineComponentProvider);
    }
    function setPersistenceProviders(client, onlineComponentProvider, offlineComponentProvider) {
      var _this = this;
      var persistenceResult = new Deferred2();
      return client.asyncQueue.enqueue(function() {
        return tslib2.__awaiter(_this, void 0, void 0, function() {
          var e_15;
          return tslib2.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                _d.trys.push([0, 3, , 4]);
                return [4, setOfflineComponentProvider(client, offlineComponentProvider)];
              case 1:
                _d.sent();
                return [4, setOnlineComponentProvider(client, onlineComponentProvider)];
              case 2:
                _d.sent();
                persistenceResult.resolve();
                return [3, 4];
              case 3:
                e_15 = _d.sent();
                if (!canFallbackFromIndexedDbError(e_15)) {
                  throw e_15;
                }
                console.warn("Error enabling offline persistence. Falling back to persistence disabled: " + e_15);
                persistenceResult.reject(e_15);
                return [3, 4];
              case 4:
                return [2];
            }
          });
        });
      }).then(function() {
        return persistenceResult.promise;
      });
    }
    function canFallbackFromIndexedDbError(error2) {
      if (error2.name === "FirebaseError") {
        return error2.code === Code.FAILED_PRECONDITION || error2.code === Code.UNIMPLEMENTED;
      } else if (typeof DOMException !== "undefined" && error2 instanceof DOMException) {
        return error2.code === DOM_EXCEPTION_QUOTA_EXCEEDED || error2.code === DOM_EXCEPTION_ABORTED || error2.code === DOM_EXCEPTION_INVALID_STATE;
      }
      return true;
    }
    function clearIndexedDbPersistence(firestore) {
      var _this = this;
      if (firestore._initialized && !firestore._terminated) {
        throw new FirestoreError(Code.FAILED_PRECONDITION, "Persistence can only be cleared before a Firestore instance is initialized or after it is terminated.");
      }
      var deferred = new Deferred2();
      firestore._queue.enqueueAndForgetEvenWhileRestricted(function() {
        return tslib2.__awaiter(_this, void 0, void 0, function() {
          var e_16;
          return tslib2.__generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                _d.trys.push([0, 2, , 3]);
                return [4, indexedDbClearPersistence(indexedDbStoragePrefix(firestore._databaseId, firestore._persistenceKey))];
              case 1:
                _d.sent();
                deferred.resolve();
                return [3, 3];
              case 2:
                e_16 = _d.sent();
                deferred.reject(e_16);
                return [3, 3];
              case 3:
                return [2];
            }
          });
        });
      });
      return deferred.promise;
    }
    function waitForPendingWrites(firestore) {
      firestore = cast(firestore, Firestore);
      var client = ensureFirestoreConfigured(firestore);
      return firestoreClientWaitForPendingWrites(client);
    }
    function enableNetwork(firestore) {
      firestore = cast(firestore, Firestore);
      var client = ensureFirestoreConfigured(firestore);
      return firestoreClientEnableNetwork(client);
    }
    function disableNetwork(firestore) {
      firestore = cast(firestore, Firestore);
      var client = ensureFirestoreConfigured(firestore);
      return firestoreClientDisableNetwork(client);
    }
    function terminate(firestore) {
      app._removeServiceInstance(firestore.app, "firestore");
      return firestore._delete();
    }
    function loadBundle(firestore, bundleData) {
      firestore = cast(firestore, Firestore);
      var client = ensureFirestoreConfigured(firestore);
      var resultTask = new LoadBundleTask();
      firestoreClientLoadBundle(client, firestore._databaseId, bundleData, resultTask);
      return resultTask;
    }
    function namedQuery(firestore, name3) {
      firestore = cast(firestore, Firestore);
      var client = ensureFirestoreConfigured(firestore);
      return firestoreClientGetNamedQuery(client, name3).then(function(namedQuery2) {
        if (!namedQuery2) {
          return null;
        }
        return new Query(firestore, null, namedQuery2.query);
      });
    }
    function verifyNotInitialized(firestore) {
      if (firestore._initialized || firestore._terminated) {
        throw new FirestoreError(Code.FAILED_PRECONDITION, "Firestore has already been started and persistence can no longer be enabled. You can only enable persistence before calling any other methods on a Firestore object.");
      }
    }
    function registerFirestore(variant) {
      setSDKVersion(app.SDK_VERSION);
      app._registerComponent(new component.Component("firestore", function(container, _d) {
        var settings2 = _d.options;
        var app2 = container.getProvider("app").getImmediate();
        var firestoreInstance = new Firestore(app2, new FirebaseCredentialsProvider(container.getProvider("auth-internal")));
        settings2 = Object.assign({ useFetchStreams: true }, settings2);
        firestoreInstance._setSettings(settings2);
        return firestoreInstance;
      }, "PUBLIC"));
      app.registerVersion(name2, version$12, variant);
    }
    var FieldPath = function() {
      function FieldPath2() {
        var fieldNames = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          fieldNames[_i] = arguments[_i];
        }
        for (var i = 0; i < fieldNames.length; ++i) {
          if (fieldNames[i].length === 0) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty.");
          }
        }
        this._internalPath = new FieldPath$1(fieldNames);
      }
      FieldPath2.prototype.isEqual = function(other) {
        return this._internalPath.isEqual(other._internalPath);
      };
      return FieldPath2;
    }();
    function documentId() {
      return new FieldPath(DOCUMENT_KEY_NAME);
    }
    var Bytes = function() {
      function Bytes2(byteString) {
        this._byteString = byteString;
      }
      Bytes2.fromBase64String = function(base642) {
        try {
          return new Bytes2(ByteString.fromBase64String(base642));
        } catch (e) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + e);
        }
      };
      Bytes2.fromUint8Array = function(array) {
        return new Bytes2(ByteString.fromUint8Array(array));
      };
      Bytes2.prototype.toBase64 = function() {
        return this._byteString.toBase64();
      };
      Bytes2.prototype.toUint8Array = function() {
        return this._byteString.toUint8Array();
      };
      Bytes2.prototype.toString = function() {
        return "Bytes(base64: " + this.toBase64() + ")";
      };
      Bytes2.prototype.isEqual = function(other) {
        return this._byteString.isEqual(other._byteString);
      };
      return Bytes2;
    }();
    var FieldValue = function() {
      function FieldValue2(_methodName) {
        this._methodName = _methodName;
      }
      return FieldValue2;
    }();
    var GeoPoint = function() {
      function GeoPoint2(latitude, longitude) {
        if (!isFinite(latitude) || latitude < -90 || latitude > 90) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + latitude);
        }
        if (!isFinite(longitude) || longitude < -180 || longitude > 180) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + longitude);
        }
        this._lat = latitude;
        this._long = longitude;
      }
      Object.defineProperty(GeoPoint2.prototype, "latitude", {
        get: function() {
          return this._lat;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(GeoPoint2.prototype, "longitude", {
        get: function() {
          return this._long;
        },
        enumerable: false,
        configurable: true
      });
      GeoPoint2.prototype.isEqual = function(other) {
        return this._lat === other._lat && this._long === other._long;
      };
      GeoPoint2.prototype.toJSON = function() {
        return { latitude: this._lat, longitude: this._long };
      };
      GeoPoint2.prototype._compareTo = function(other) {
        return primitiveComparator(this._lat, other._lat) || primitiveComparator(this._long, other._long);
      };
      return GeoPoint2;
    }();
    var RESERVED_FIELD_REGEX = /^__.*__$/;
    var ParsedSetData = function() {
      function ParsedSetData2(data, fieldMask, fieldTransforms) {
        this.data = data;
        this.fieldMask = fieldMask;
        this.fieldTransforms = fieldTransforms;
      }
      ParsedSetData2.prototype.toMutation = function(key, precondition) {
        if (this.fieldMask !== null) {
          return new PatchMutation(key, this.data, this.fieldMask, precondition, this.fieldTransforms);
        } else {
          return new SetMutation(key, this.data, precondition, this.fieldTransforms);
        }
      };
      return ParsedSetData2;
    }();
    var ParsedUpdateData = function() {
      function ParsedUpdateData2(data, fieldMask, fieldTransforms) {
        this.data = data;
        this.fieldMask = fieldMask;
        this.fieldTransforms = fieldTransforms;
      }
      ParsedUpdateData2.prototype.toMutation = function(key, precondition) {
        return new PatchMutation(key, this.data, this.fieldMask, precondition, this.fieldTransforms);
      };
      return ParsedUpdateData2;
    }();
    function isWrite(dataSource) {
      switch (dataSource) {
        case 0:
        case 2:
        case 1:
          return true;
        case 3:
        case 4:
          return false;
        default:
          throw fail();
      }
    }
    var ParseContextImpl = function() {
      function ParseContextImpl2(settings2, databaseId, serializer, ignoreUndefinedProperties, fieldTransforms, fieldMask) {
        this.settings = settings2;
        this.databaseId = databaseId;
        this.serializer = serializer;
        this.ignoreUndefinedProperties = ignoreUndefinedProperties;
        if (fieldTransforms === void 0) {
          this.validatePath();
        }
        this.fieldTransforms = fieldTransforms || [];
        this.fieldMask = fieldMask || [];
      }
      Object.defineProperty(ParseContextImpl2.prototype, "path", {
        get: function() {
          return this.settings.path;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ParseContextImpl2.prototype, "dataSource", {
        get: function() {
          return this.settings.dataSource;
        },
        enumerable: false,
        configurable: true
      });
      ParseContextImpl2.prototype.contextWith = function(configuration) {
        return new ParseContextImpl2(Object.assign(Object.assign({}, this.settings), configuration), this.databaseId, this.serializer, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);
      };
      ParseContextImpl2.prototype.childContextForField = function(field) {
        var _a;
        var childPath = (_a = this.path) === null || _a === void 0 ? void 0 : _a.child(field);
        var context = this.contextWith({ path: childPath, arrayElement: false });
        context.validatePathSegment(field);
        return context;
      };
      ParseContextImpl2.prototype.childContextForFieldPath = function(field) {
        var _a;
        var childPath = (_a = this.path) === null || _a === void 0 ? void 0 : _a.child(field);
        var context = this.contextWith({ path: childPath, arrayElement: false });
        context.validatePath();
        return context;
      };
      ParseContextImpl2.prototype.childContextForArray = function(index2) {
        return this.contextWith({ path: void 0, arrayElement: true });
      };
      ParseContextImpl2.prototype.createError = function(reason) {
        return createError(reason, this.settings.methodName, this.settings.hasConverter || false, this.path, this.settings.targetDoc);
      };
      ParseContextImpl2.prototype.contains = function(fieldPath) {
        return this.fieldMask.find(function(field) {
          return fieldPath.isPrefixOf(field);
        }) !== void 0 || this.fieldTransforms.find(function(transform) {
          return fieldPath.isPrefixOf(transform.field);
        }) !== void 0;
      };
      ParseContextImpl2.prototype.validatePath = function() {
        if (!this.path) {
          return;
        }
        for (var i = 0; i < this.path.length; i++) {
          this.validatePathSegment(this.path.get(i));
        }
      };
      ParseContextImpl2.prototype.validatePathSegment = function(segment) {
        if (segment.length === 0) {
          throw this.createError("Document fields must not be empty");
        }
        if (isWrite(this.dataSource) && RESERVED_FIELD_REGEX.test(segment)) {
          throw this.createError('Document fields cannot begin and end with "__"');
        }
      };
      return ParseContextImpl2;
    }();
    var UserDataReader = function() {
      function UserDataReader2(databaseId, ignoreUndefinedProperties, serializer) {
        this.databaseId = databaseId;
        this.ignoreUndefinedProperties = ignoreUndefinedProperties;
        this.serializer = serializer || newSerializer(databaseId);
      }
      UserDataReader2.prototype.createContext = function(dataSource, methodName, targetDoc, hasConverter) {
        if (hasConverter === void 0) {
          hasConverter = false;
        }
        return new ParseContextImpl({
          dataSource,
          methodName,
          targetDoc,
          path: FieldPath$1.emptyPath(),
          arrayElement: false,
          hasConverter
        }, this.databaseId, this.serializer, this.ignoreUndefinedProperties);
      };
      return UserDataReader2;
    }();
    function newUserDataReader(firestore) {
      var settings2 = firestore._freezeSettings();
      var serializer = newSerializer(firestore._databaseId);
      return new UserDataReader(firestore._databaseId, !!settings2.ignoreUndefinedProperties, serializer);
    }
    function parseSetData(userDataReader, methodName, targetDoc, input, hasConverter, options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      var context = userDataReader.createContext(options2.merge || options2.mergeFields ? 2 : 0, methodName, targetDoc, hasConverter);
      validatePlainObject("Data must be an object, but it was:", context, input);
      var updateData = parseObject(input, context);
      var fieldMask;
      var fieldTransforms;
      if (options2.merge) {
        fieldMask = new FieldMask(context.fieldMask);
        fieldTransforms = context.fieldTransforms;
      } else if (options2.mergeFields) {
        var validatedFieldPaths = [];
        for (var _i = 0, _d = options2.mergeFields; _i < _d.length; _i++) {
          var stringOrFieldPath = _d[_i];
          var fieldPath = fieldPathFromArgument$1(methodName, stringOrFieldPath, targetDoc);
          if (!context.contains(fieldPath)) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Field '" + fieldPath + "' is specified in your field mask but missing from your input data.");
          }
          if (!fieldMaskContains(validatedFieldPaths, fieldPath)) {
            validatedFieldPaths.push(fieldPath);
          }
        }
        fieldMask = new FieldMask(validatedFieldPaths);
        fieldTransforms = context.fieldTransforms.filter(function(transform) {
          return fieldMask.covers(transform.field);
        });
      } else {
        fieldMask = null;
        fieldTransforms = context.fieldTransforms;
      }
      return new ParsedSetData(new ObjectValue(updateData), fieldMask, fieldTransforms);
    }
    var DeleteFieldValueImpl = function(_super) {
      tslib2.__extends(DeleteFieldValueImpl2, _super);
      function DeleteFieldValueImpl2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      DeleteFieldValueImpl2.prototype._toFieldTransform = function(context) {
        if (context.dataSource === 2) {
          context.fieldMask.push(context.path);
        } else if (context.dataSource === 1) {
          throw context.createError(this._methodName + "() can only appear at the top level of your update data");
        } else {
          throw context.createError(this._methodName + "() cannot be used with set() unless you pass {merge:true}");
        }
        return null;
      };
      DeleteFieldValueImpl2.prototype.isEqual = function(other) {
        return other instanceof DeleteFieldValueImpl2;
      };
      return DeleteFieldValueImpl2;
    }(FieldValue);
    function createSentinelChildContext(fieldValue, context, arrayElement) {
      return new ParseContextImpl({
        dataSource: 3,
        targetDoc: context.settings.targetDoc,
        methodName: fieldValue._methodName,
        arrayElement
      }, context.databaseId, context.serializer, context.ignoreUndefinedProperties);
    }
    var ServerTimestampFieldValueImpl = function(_super) {
      tslib2.__extends(ServerTimestampFieldValueImpl2, _super);
      function ServerTimestampFieldValueImpl2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      ServerTimestampFieldValueImpl2.prototype._toFieldTransform = function(context) {
        return new FieldTransform(context.path, new ServerTimestampTransform());
      };
      ServerTimestampFieldValueImpl2.prototype.isEqual = function(other) {
        return other instanceof ServerTimestampFieldValueImpl2;
      };
      return ServerTimestampFieldValueImpl2;
    }(FieldValue);
    var ArrayUnionFieldValueImpl = function(_super) {
      tslib2.__extends(ArrayUnionFieldValueImpl2, _super);
      function ArrayUnionFieldValueImpl2(methodName, _elements) {
        var _this = _super.call(this, methodName) || this;
        _this._elements = _elements;
        return _this;
      }
      ArrayUnionFieldValueImpl2.prototype._toFieldTransform = function(context) {
        var parseContext = createSentinelChildContext(this, context, true);
        var parsedElements = this._elements.map(function(element) {
          return parseData(element, parseContext);
        });
        var arrayUnion2 = new ArrayUnionTransformOperation(parsedElements);
        return new FieldTransform(context.path, arrayUnion2);
      };
      ArrayUnionFieldValueImpl2.prototype.isEqual = function(other) {
        return this === other;
      };
      return ArrayUnionFieldValueImpl2;
    }(FieldValue);
    var ArrayRemoveFieldValueImpl = function(_super) {
      tslib2.__extends(ArrayRemoveFieldValueImpl2, _super);
      function ArrayRemoveFieldValueImpl2(methodName, _elements) {
        var _this = _super.call(this, methodName) || this;
        _this._elements = _elements;
        return _this;
      }
      ArrayRemoveFieldValueImpl2.prototype._toFieldTransform = function(context) {
        var parseContext = createSentinelChildContext(this, context, true);
        var parsedElements = this._elements.map(function(element) {
          return parseData(element, parseContext);
        });
        var arrayUnion2 = new ArrayRemoveTransformOperation(parsedElements);
        return new FieldTransform(context.path, arrayUnion2);
      };
      ArrayRemoveFieldValueImpl2.prototype.isEqual = function(other) {
        return this === other;
      };
      return ArrayRemoveFieldValueImpl2;
    }(FieldValue);
    var NumericIncrementFieldValueImpl = function(_super) {
      tslib2.__extends(NumericIncrementFieldValueImpl2, _super);
      function NumericIncrementFieldValueImpl2(methodName, _operand) {
        var _this = _super.call(this, methodName) || this;
        _this._operand = _operand;
        return _this;
      }
      NumericIncrementFieldValueImpl2.prototype._toFieldTransform = function(context) {
        var numericIncrement = new NumericIncrementTransformOperation(context.serializer, toNumber(context.serializer, this._operand));
        return new FieldTransform(context.path, numericIncrement);
      };
      NumericIncrementFieldValueImpl2.prototype.isEqual = function(other) {
        return this === other;
      };
      return NumericIncrementFieldValueImpl2;
    }(FieldValue);
    function parseUpdateData(userDataReader, methodName, targetDoc, input) {
      var context = userDataReader.createContext(1, methodName, targetDoc);
      validatePlainObject("Data must be an object, but it was:", context, input);
      var fieldMaskPaths = [];
      var updateData = ObjectValue.empty();
      forEach(input, function(key, value) {
        var path2 = fieldPathFromDotSeparatedString(methodName, key, targetDoc);
        value = util.getModularInstance(value);
        var childContext = context.childContextForFieldPath(path2);
        if (value instanceof DeleteFieldValueImpl) {
          fieldMaskPaths.push(path2);
        } else {
          var parsedValue = parseData(value, childContext);
          if (parsedValue != null) {
            fieldMaskPaths.push(path2);
            updateData.set(path2, parsedValue);
          }
        }
      });
      var mask = new FieldMask(fieldMaskPaths);
      return new ParsedUpdateData(updateData, mask, context.fieldTransforms);
    }
    function parseUpdateVarargs(userDataReader, methodName, targetDoc, field, value, moreFieldsAndValues) {
      var context = userDataReader.createContext(1, methodName, targetDoc);
      var keys = [fieldPathFromArgument$1(methodName, field, targetDoc)];
      var values = [value];
      if (moreFieldsAndValues.length % 2 !== 0) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + methodName + "() needs to be called with an even number of arguments that alternate between field names and values.");
      }
      for (var i = 0; i < moreFieldsAndValues.length; i += 2) {
        keys.push(fieldPathFromArgument$1(methodName, moreFieldsAndValues[i]));
        values.push(moreFieldsAndValues[i + 1]);
      }
      var fieldMaskPaths = [];
      var updateData = ObjectValue.empty();
      for (var i = keys.length - 1; i >= 0; --i) {
        if (!fieldMaskContains(fieldMaskPaths, keys[i])) {
          var path2 = keys[i];
          var value_1 = values[i];
          value_1 = util.getModularInstance(value_1);
          var childContext = context.childContextForFieldPath(path2);
          if (value_1 instanceof DeleteFieldValueImpl) {
            fieldMaskPaths.push(path2);
          } else {
            var parsedValue = parseData(value_1, childContext);
            if (parsedValue != null) {
              fieldMaskPaths.push(path2);
              updateData.set(path2, parsedValue);
            }
          }
        }
      }
      var mask = new FieldMask(fieldMaskPaths);
      return new ParsedUpdateData(updateData, mask, context.fieldTransforms);
    }
    function parseQueryValue(userDataReader, methodName, input, allowArrays) {
      if (allowArrays === void 0) {
        allowArrays = false;
      }
      var context = userDataReader.createContext(allowArrays ? 4 : 3, methodName);
      var parsed = parseData(input, context);
      return parsed;
    }
    function parseData(input, context) {
      input = util.getModularInstance(input);
      if (looksLikeJsonObject(input)) {
        validatePlainObject("Unsupported field value:", context, input);
        return parseObject(input, context);
      } else if (input instanceof FieldValue) {
        parseSentinelFieldValue(input, context);
        return null;
      } else if (input === void 0 && context.ignoreUndefinedProperties) {
        return null;
      } else {
        if (context.path) {
          context.fieldMask.push(context.path);
        }
        if (input instanceof Array) {
          if (context.settings.arrayElement && context.dataSource !== 4) {
            throw context.createError("Nested arrays are not supported");
          }
          return parseArray(input, context);
        } else {
          return parseScalarValue(input, context);
        }
      }
    }
    function parseObject(obj, context) {
      var fields = {};
      if (isEmpty2(obj)) {
        if (context.path && context.path.length > 0) {
          context.fieldMask.push(context.path);
        }
      } else {
        forEach(obj, function(key, val) {
          var parsedValue = parseData(val, context.childContextForField(key));
          if (parsedValue != null) {
            fields[key] = parsedValue;
          }
        });
      }
      return { mapValue: { fields } };
    }
    function parseArray(array, context) {
      var values = [];
      var entryIndex = 0;
      for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
        var entry = array_1[_i];
        var parsedEntry = parseData(entry, context.childContextForArray(entryIndex));
        if (parsedEntry == null) {
          parsedEntry = { nullValue: "NULL_VALUE" };
        }
        values.push(parsedEntry);
        entryIndex++;
      }
      return { arrayValue: { values } };
    }
    function parseSentinelFieldValue(value, context) {
      if (!isWrite(context.dataSource)) {
        throw context.createError(value._methodName + "() can only be used with update() and set()");
      }
      if (!context.path) {
        throw context.createError(value._methodName + "() is not currently supported inside arrays");
      }
      var fieldTransform = value._toFieldTransform(context);
      if (fieldTransform) {
        context.fieldTransforms.push(fieldTransform);
      }
    }
    function parseScalarValue(value, context) {
      value = util.getModularInstance(value);
      if (value === null) {
        return { nullValue: "NULL_VALUE" };
      } else if (typeof value === "number") {
        return toNumber(context.serializer, value);
      } else if (typeof value === "boolean") {
        return { booleanValue: value };
      } else if (typeof value === "string") {
        return { stringValue: value };
      } else if (value instanceof Date) {
        var timestamp = Timestamp.fromDate(value);
        return {
          timestampValue: toTimestamp(context.serializer, timestamp)
        };
      } else if (value instanceof Timestamp) {
        var timestamp = new Timestamp(value.seconds, Math.floor(value.nanoseconds / 1e3) * 1e3);
        return {
          timestampValue: toTimestamp(context.serializer, timestamp)
        };
      } else if (value instanceof GeoPoint) {
        return {
          geoPointValue: {
            latitude: value.latitude,
            longitude: value.longitude
          }
        };
      } else if (value instanceof Bytes) {
        return { bytesValue: toBytes(context.serializer, value._byteString) };
      } else if (value instanceof DocumentReference) {
        var thisDb = context.databaseId;
        var otherDb = value.firestore._databaseId;
        if (!otherDb.isEqual(thisDb)) {
          throw context.createError("Document reference is for database " + (otherDb.projectId + "/" + otherDb.database + " but should be ") + ("for database " + thisDb.projectId + "/" + thisDb.database));
        }
        return {
          referenceValue: toResourceName(value.firestore._databaseId || context.databaseId, value._key.path)
        };
      } else {
        throw context.createError("Unsupported field value: " + valueDescription(value));
      }
    }
    function looksLikeJsonObject(input) {
      return typeof input === "object" && input !== null && !(input instanceof Array) && !(input instanceof Date) && !(input instanceof Timestamp) && !(input instanceof GeoPoint) && !(input instanceof Bytes) && !(input instanceof DocumentReference) && !(input instanceof FieldValue);
    }
    function validatePlainObject(message, context, input) {
      if (!looksLikeJsonObject(input) || !isPlainObject(input)) {
        var description = valueDescription(input);
        if (description === "an object") {
          throw context.createError(message + " a custom object");
        } else {
          throw context.createError(message + " " + description);
        }
      }
    }
    function fieldPathFromArgument$1(methodName, path2, targetDoc) {
      path2 = util.getModularInstance(path2);
      if (path2 instanceof FieldPath) {
        return path2._internalPath;
      } else if (typeof path2 === "string") {
        return fieldPathFromDotSeparatedString(methodName, path2);
      } else {
        var message = "Field path arguments must be of type string or FieldPath.";
        throw createError(message, methodName, false, void 0, targetDoc);
      }
    }
    var FIELD_PATH_RESERVED = new RegExp("[~\\*/\\[\\]]");
    function fieldPathFromDotSeparatedString(methodName, path2, targetDoc) {
      var found = path2.search(FIELD_PATH_RESERVED);
      if (found >= 0) {
        throw createError("Invalid field path (" + path2 + "). Paths must not contain '~', '*', '/', '[', or ']'", methodName, false, void 0, targetDoc);
      }
      try {
        return new (FieldPath.bind.apply(FieldPath, tslib2.__spreadArray([void 0], path2.split("."))))()._internalPath;
      } catch (e) {
        throw createError("Invalid field path (" + path2 + "). Paths must not be empty, begin with '.', end with '.', or contain '..'", methodName, false, void 0, targetDoc);
      }
    }
    function createError(reason, methodName, hasConverter, path2, targetDoc) {
      var hasPath = path2 && !path2.isEmpty();
      var hasDocument = targetDoc !== void 0;
      var message = "Function " + methodName + "() called with invalid data";
      if (hasConverter) {
        message += " (via `toFirestore()`)";
      }
      message += ". ";
      var description = "";
      if (hasPath || hasDocument) {
        description += " (found";
        if (hasPath) {
          description += " in field " + path2;
        }
        if (hasDocument) {
          description += " in document " + targetDoc;
        }
        description += ")";
      }
      return new FirestoreError(Code.INVALID_ARGUMENT, message + reason + description);
    }
    function fieldMaskContains(haystack, needle) {
      return haystack.some(function(v) {
        return v.isEqual(needle);
      });
    }
    var DocumentSnapshot$1 = function() {
      function DocumentSnapshot$12(_firestore, _userDataWriter, _key, _document, _converter) {
        this._firestore = _firestore;
        this._userDataWriter = _userDataWriter;
        this._key = _key;
        this._document = _document;
        this._converter = _converter;
      }
      Object.defineProperty(DocumentSnapshot$12.prototype, "id", {
        get: function() {
          return this._key.path.lastSegment();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DocumentSnapshot$12.prototype, "ref", {
        get: function() {
          return new DocumentReference(this._firestore, this._converter, this._key);
        },
        enumerable: false,
        configurable: true
      });
      DocumentSnapshot$12.prototype.exists = function() {
        return this._document !== null;
      };
      DocumentSnapshot$12.prototype.data = function() {
        if (!this._document) {
          return void 0;
        } else if (this._converter) {
          var snapshot = new QueryDocumentSnapshot$1(this._firestore, this._userDataWriter, this._key, this._document, null);
          return this._converter.fromFirestore(snapshot);
        } else {
          return this._userDataWriter.convertValue(this._document.data.value);
        }
      };
      DocumentSnapshot$12.prototype.get = function(fieldPath) {
        if (this._document) {
          var value = this._document.data.field(fieldPathFromArgument("DocumentSnapshot.get", fieldPath));
          if (value !== null) {
            return this._userDataWriter.convertValue(value);
          }
        }
        return void 0;
      };
      return DocumentSnapshot$12;
    }();
    var QueryDocumentSnapshot$1 = function(_super) {
      tslib2.__extends(QueryDocumentSnapshot$12, _super);
      function QueryDocumentSnapshot$12() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      QueryDocumentSnapshot$12.prototype.data = function() {
        return _super.prototype.data.call(this);
      };
      return QueryDocumentSnapshot$12;
    }(DocumentSnapshot$1);
    function fieldPathFromArgument(methodName, arg) {
      if (typeof arg === "string") {
        return fieldPathFromDotSeparatedString(methodName, arg);
      } else if (arg instanceof FieldPath) {
        return arg._internalPath;
      } else {
        return arg._delegate._internalPath;
      }
    }
    var SnapshotMetadata = function() {
      function SnapshotMetadata2(hasPendingWrites, fromCache) {
        this.hasPendingWrites = hasPendingWrites;
        this.fromCache = fromCache;
      }
      SnapshotMetadata2.prototype.isEqual = function(other) {
        return this.hasPendingWrites === other.hasPendingWrites && this.fromCache === other.fromCache;
      };
      return SnapshotMetadata2;
    }();
    var DocumentSnapshot = function(_super) {
      tslib2.__extends(DocumentSnapshot2, _super);
      function DocumentSnapshot2(_firestore, userDataWriter, key, document2, metadata, converter) {
        var _this = _super.call(this, _firestore, userDataWriter, key, document2, converter) || this;
        _this._firestore = _firestore;
        _this._firestoreImpl = _firestore;
        _this.metadata = metadata;
        return _this;
      }
      DocumentSnapshot2.prototype.exists = function() {
        return _super.prototype.exists.call(this);
      };
      DocumentSnapshot2.prototype.data = function(options2) {
        if (options2 === void 0) {
          options2 = {};
        }
        if (!this._document) {
          return void 0;
        } else if (this._converter) {
          var snapshot = new QueryDocumentSnapshot(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, null);
          return this._converter.fromFirestore(snapshot, options2);
        } else {
          return this._userDataWriter.convertValue(this._document.data.value, options2.serverTimestamps);
        }
      };
      DocumentSnapshot2.prototype.get = function(fieldPath, options2) {
        if (options2 === void 0) {
          options2 = {};
        }
        if (this._document) {
          var value = this._document.data.field(fieldPathFromArgument("DocumentSnapshot.get", fieldPath));
          if (value !== null) {
            return this._userDataWriter.convertValue(value, options2.serverTimestamps);
          }
        }
        return void 0;
      };
      return DocumentSnapshot2;
    }(DocumentSnapshot$1);
    var QueryDocumentSnapshot = function(_super) {
      tslib2.__extends(QueryDocumentSnapshot2, _super);
      function QueryDocumentSnapshot2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      QueryDocumentSnapshot2.prototype.data = function(options2) {
        if (options2 === void 0) {
          options2 = {};
        }
        return _super.prototype.data.call(this, options2);
      };
      return QueryDocumentSnapshot2;
    }(DocumentSnapshot);
    var QuerySnapshot = function() {
      function QuerySnapshot2(_firestore, _userDataWriter, query2, _snapshot) {
        this._firestore = _firestore;
        this._userDataWriter = _userDataWriter;
        this._snapshot = _snapshot;
        this.metadata = new SnapshotMetadata(_snapshot.hasPendingWrites, _snapshot.fromCache);
        this.query = query2;
      }
      Object.defineProperty(QuerySnapshot2.prototype, "docs", {
        get: function() {
          var result = [];
          this.forEach(function(doc2) {
            return result.push(doc2);
          });
          return result;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(QuerySnapshot2.prototype, "size", {
        get: function() {
          return this._snapshot.docs.size;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(QuerySnapshot2.prototype, "empty", {
        get: function() {
          return this.size === 0;
        },
        enumerable: false,
        configurable: true
      });
      QuerySnapshot2.prototype.forEach = function(callback, thisArg) {
        var _this = this;
        this._snapshot.docs.forEach(function(doc2) {
          callback.call(thisArg, new QueryDocumentSnapshot(_this._firestore, _this._userDataWriter, doc2.key, doc2, new SnapshotMetadata(_this._snapshot.mutatedKeys.has(doc2.key), _this._snapshot.fromCache), _this.query.converter));
        });
      };
      QuerySnapshot2.prototype.docChanges = function(options2) {
        if (options2 === void 0) {
          options2 = {};
        }
        var includeMetadataChanges = !!options2.includeMetadataChanges;
        if (includeMetadataChanges && this._snapshot.excludesMetadataChanges) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().");
        }
        if (!this._cachedChanges || this._cachedChangesIncludeMetadataChanges !== includeMetadataChanges) {
          this._cachedChanges = changesFromSnapshot(this, includeMetadataChanges);
          this._cachedChangesIncludeMetadataChanges = includeMetadataChanges;
        }
        return this._cachedChanges;
      };
      return QuerySnapshot2;
    }();
    function changesFromSnapshot(querySnapshot, includeMetadataChanges) {
      if (querySnapshot._snapshot.oldDocs.isEmpty()) {
        var index_1 = 0;
        return querySnapshot._snapshot.docChanges.map(function(change) {
          var doc2 = new QueryDocumentSnapshot(querySnapshot._firestore, querySnapshot._userDataWriter, change.doc.key, change.doc, new SnapshotMetadata(querySnapshot._snapshot.mutatedKeys.has(change.doc.key), querySnapshot._snapshot.fromCache), querySnapshot.query.converter);
          return {
            type: "added",
            doc: doc2,
            oldIndex: -1,
            newIndex: index_1++
          };
        });
      } else {
        var indexTracker_1 = querySnapshot._snapshot.oldDocs;
        return querySnapshot._snapshot.docChanges.filter(function(change) {
          return includeMetadataChanges || change.type !== 3;
        }).map(function(change) {
          var doc2 = new QueryDocumentSnapshot(querySnapshot._firestore, querySnapshot._userDataWriter, change.doc.key, change.doc, new SnapshotMetadata(querySnapshot._snapshot.mutatedKeys.has(change.doc.key), querySnapshot._snapshot.fromCache), querySnapshot.query.converter);
          var oldIndex = -1;
          var newIndex = -1;
          if (change.type !== 0) {
            oldIndex = indexTracker_1.indexOf(change.doc.key);
            indexTracker_1 = indexTracker_1.delete(change.doc.key);
          }
          if (change.type !== 1) {
            indexTracker_1 = indexTracker_1.add(change.doc);
            newIndex = indexTracker_1.indexOf(change.doc.key);
          }
          return {
            type: resultChangeType(change.type),
            doc: doc2,
            oldIndex,
            newIndex
          };
        });
      }
    }
    function resultChangeType(type) {
      switch (type) {
        case 0:
          return "added";
        case 2:
        case 3:
          return "modified";
        case 1:
          return "removed";
        default:
          return fail();
      }
    }
    function snapshotEqual(left, right) {
      if (left instanceof DocumentSnapshot && right instanceof DocumentSnapshot) {
        return left._firestore === right._firestore && left._key.isEqual(right._key) && (left._document === null ? right._document === null : left._document.isEqual(right._document)) && left._converter === right._converter;
      } else if (left instanceof QuerySnapshot && right instanceof QuerySnapshot) {
        return left._firestore === right._firestore && queryEqual(left.query, right.query) && left.metadata.isEqual(right.metadata) && left._snapshot.isEqual(right._snapshot);
      }
      return false;
    }
    function validateHasExplicitOrderByForLimitToLast(query2) {
      if (hasLimitToLast(query2) && query2.explicitOrderBy.length === 0) {
        throw new FirestoreError(Code.UNIMPLEMENTED, "limitToLast() queries require specifying at least one orderBy() clause");
      }
    }
    var QueryConstraint = function() {
      function QueryConstraint2() {
      }
      return QueryConstraint2;
    }();
    function query(query2) {
      var queryConstraints = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        queryConstraints[_i - 1] = arguments[_i];
      }
      for (var _d = 0, queryConstraints_1 = queryConstraints; _d < queryConstraints_1.length; _d++) {
        var constraint = queryConstraints_1[_d];
        query2 = constraint._apply(query2);
      }
      return query2;
    }
    var QueryFilterConstraint = function(_super) {
      tslib2.__extends(QueryFilterConstraint2, _super);
      function QueryFilterConstraint2(_field, _op, _value) {
        var _this = _super.call(this) || this;
        _this._field = _field;
        _this._op = _op;
        _this._value = _value;
        _this.type = "where";
        return _this;
      }
      QueryFilterConstraint2.prototype._apply = function(query2) {
        var reader = newUserDataReader(query2.firestore);
        var filter2 = newQueryFilter(query2._query, "where", reader, query2.firestore._databaseId, this._field, this._op, this._value);
        return new Query(query2.firestore, query2.converter, queryWithAddedFilter(query2._query, filter2));
      };
      return QueryFilterConstraint2;
    }(QueryConstraint);
    function where(fieldPath, opStr, value) {
      var op = opStr;
      var field = fieldPathFromArgument("where", fieldPath);
      return new QueryFilterConstraint(field, op, value);
    }
    var QueryOrderByConstraint = function(_super) {
      tslib2.__extends(QueryOrderByConstraint2, _super);
      function QueryOrderByConstraint2(_field, _direction) {
        var _this = _super.call(this) || this;
        _this._field = _field;
        _this._direction = _direction;
        _this.type = "orderBy";
        return _this;
      }
      QueryOrderByConstraint2.prototype._apply = function(query2) {
        var orderBy2 = newQueryOrderBy(query2._query, this._field, this._direction);
        return new Query(query2.firestore, query2.converter, queryWithAddedOrderBy(query2._query, orderBy2));
      };
      return QueryOrderByConstraint2;
    }(QueryConstraint);
    function orderBy(fieldPath, directionStr) {
      if (directionStr === void 0) {
        directionStr = "asc";
      }
      var direction = directionStr;
      var path2 = fieldPathFromArgument("orderBy", fieldPath);
      return new QueryOrderByConstraint(path2, direction);
    }
    var QueryLimitConstraint = function(_super) {
      tslib2.__extends(QueryLimitConstraint2, _super);
      function QueryLimitConstraint2(type, _limit, _limitType) {
        var _this = _super.call(this) || this;
        _this.type = type;
        _this._limit = _limit;
        _this._limitType = _limitType;
        return _this;
      }
      QueryLimitConstraint2.prototype._apply = function(query2) {
        return new Query(query2.firestore, query2.converter, queryWithLimit(query2._query, this._limit, this._limitType));
      };
      return QueryLimitConstraint2;
    }(QueryConstraint);
    function limit(limit2) {
      validatePositiveNumber("limit", limit2);
      return new QueryLimitConstraint("limit", limit2, "F");
    }
    function limitToLast(limit2) {
      validatePositiveNumber("limitToLast", limit2);
      return new QueryLimitConstraint("limitToLast", limit2, "L");
    }
    var QueryStartAtConstraint = function(_super) {
      tslib2.__extends(QueryStartAtConstraint2, _super);
      function QueryStartAtConstraint2(type, _docOrFields, _before) {
        var _this = _super.call(this) || this;
        _this.type = type;
        _this._docOrFields = _docOrFields;
        _this._before = _before;
        return _this;
      }
      QueryStartAtConstraint2.prototype._apply = function(query2) {
        var bound = newQueryBoundFromDocOrFields(query2, this.type, this._docOrFields, this._before);
        return new Query(query2.firestore, query2.converter, queryWithStartAt(query2._query, bound));
      };
      return QueryStartAtConstraint2;
    }(QueryConstraint);
    function startAt() {
      var docOrFields = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        docOrFields[_i] = arguments[_i];
      }
      return new QueryStartAtConstraint("startAt", docOrFields, true);
    }
    function startAfter() {
      var docOrFields = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        docOrFields[_i] = arguments[_i];
      }
      return new QueryStartAtConstraint("startAfter", docOrFields, false);
    }
    var QueryEndAtConstraint = function(_super) {
      tslib2.__extends(QueryEndAtConstraint2, _super);
      function QueryEndAtConstraint2(type, _docOrFields, _before) {
        var _this = _super.call(this) || this;
        _this.type = type;
        _this._docOrFields = _docOrFields;
        _this._before = _before;
        return _this;
      }
      QueryEndAtConstraint2.prototype._apply = function(query2) {
        var bound = newQueryBoundFromDocOrFields(query2, this.type, this._docOrFields, this._before);
        return new Query(query2.firestore, query2.converter, queryWithEndAt(query2._query, bound));
      };
      return QueryEndAtConstraint2;
    }(QueryConstraint);
    function endBefore() {
      var docOrFields = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        docOrFields[_i] = arguments[_i];
      }
      return new QueryEndAtConstraint("endBefore", docOrFields, true);
    }
    function endAt() {
      var docOrFields = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        docOrFields[_i] = arguments[_i];
      }
      return new QueryEndAtConstraint("endAt", docOrFields, false);
    }
    function newQueryBoundFromDocOrFields(query2, methodName, docOrFields, before) {
      docOrFields[0] = util.getModularInstance(docOrFields[0]);
      if (docOrFields[0] instanceof DocumentSnapshot$1) {
        return newQueryBoundFromDocument(query2._query, query2.firestore._databaseId, methodName, docOrFields[0]._document, before);
      } else {
        var reader = newUserDataReader(query2.firestore);
        return newQueryBoundFromFields(query2._query, query2.firestore._databaseId, reader, methodName, docOrFields, before);
      }
    }
    function newQueryFilter(query2, methodName, dataReader, databaseId, fieldPath, op, value) {
      var fieldValue;
      if (fieldPath.isKeyField()) {
        if (op === "array-contains" || op === "array-contains-any") {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid Query. You can't perform '" + op + "' queries on FieldPath.documentId().");
        } else if (op === "in" || op === "not-in") {
          validateDisjunctiveFilterElements(value, op);
          var referenceList = [];
          for (var _i = 0, value_2 = value; _i < value_2.length; _i++) {
            var arrayValue = value_2[_i];
            referenceList.push(parseDocumentIdValue(databaseId, query2, arrayValue));
          }
          fieldValue = { arrayValue: { values: referenceList } };
        } else {
          fieldValue = parseDocumentIdValue(databaseId, query2, value);
        }
      } else {
        if (op === "in" || op === "not-in" || op === "array-contains-any") {
          validateDisjunctiveFilterElements(value, op);
        }
        fieldValue = parseQueryValue(dataReader, methodName, value, op === "in" || op === "not-in");
      }
      var filter2 = FieldFilter.create(fieldPath, op, fieldValue);
      validateNewFilter(query2, filter2);
      return filter2;
    }
    function newQueryOrderBy(query2, fieldPath, direction) {
      if (query2.startAt !== null) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. You must not call startAt() or startAfter() before calling orderBy().");
      }
      if (query2.endAt !== null) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. You must not call endAt() or endBefore() before calling orderBy().");
      }
      var orderBy2 = new OrderBy(fieldPath, direction);
      validateNewOrderBy(query2, orderBy2);
      return orderBy2;
    }
    function newQueryBoundFromDocument(query2, databaseId, methodName, doc2, before) {
      if (!doc2) {
        throw new FirestoreError(Code.NOT_FOUND, "Can't use a DocumentSnapshot that doesn't exist for " + (methodName + "()."));
      }
      var components = [];
      for (var _i = 0, _d = queryOrderBy(query2); _i < _d.length; _i++) {
        var orderBy_5 = _d[_i];
        if (orderBy_5.field.isKeyField()) {
          components.push(refValue(databaseId, doc2.key));
        } else {
          var value = doc2.data.field(orderBy_5.field);
          if (isServerTimestamp(value)) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a document for which the field "' + orderBy_5.field + '" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)');
          } else if (value !== null) {
            components.push(value);
          } else {
            var field = orderBy_5.field.canonicalString();
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. You are trying to start or end a query using a " + ("document for which the field '" + field + "' (used as the ") + "orderBy) does not exist.");
          }
        }
      }
      return new Bound(components, before);
    }
    function newQueryBoundFromFields(query2, databaseId, dataReader, methodName, values, before) {
      var orderBy2 = query2.explicitOrderBy;
      if (values.length > orderBy2.length) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Too many arguments provided to " + methodName + "(). The number of arguments must be less than or equal to the number of orderBy() clauses");
      }
      var components = [];
      for (var i = 0; i < values.length; i++) {
        var rawValue = values[i];
        var orderByComponent = orderBy2[i];
        if (orderByComponent.field.isKeyField()) {
          if (typeof rawValue !== "string") {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. Expected a string for document ID in " + (methodName + "(), but got a " + typeof rawValue));
          }
          if (!isCollectionGroupQuery(query2) && rawValue.indexOf("/") !== -1) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. When querying a collection and ordering by FieldPath.documentId(), " + ("the value passed to " + methodName + "() must be a plain document ID, but ") + ("'" + rawValue + "' contains a slash."));
          }
          var path2 = query2.path.child(ResourcePath.fromString(rawValue));
          if (!DocumentKey.isDocumentKey(path2)) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. When querying a collection group and ordering by " + ("FieldPath.documentId(), the value passed to " + methodName + "() must result in a ") + ("valid document path, but '" + path2 + "' is not because it contains an odd number ") + "of segments.");
          }
          var key = new DocumentKey(path2);
          components.push(refValue(databaseId, key));
        } else {
          var wrapped = parseQueryValue(dataReader, methodName, rawValue);
          components.push(wrapped);
        }
      }
      return new Bound(components, before);
    }
    function parseDocumentIdValue(databaseId, query2, documentIdValue) {
      documentIdValue = util.getModularInstance(documentIdValue);
      if (typeof documentIdValue === "string") {
        if (documentIdValue === "") {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. When querying with FieldPath.documentId(), you must provide a valid document ID, but it was an empty string.");
        }
        if (!isCollectionGroupQuery(query2) && documentIdValue.indexOf("/") !== -1) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. When querying a collection by FieldPath.documentId(), you must provide a plain document ID, but " + ("'" + documentIdValue + "' contains a '/' character."));
        }
        var path2 = query2.path.child(ResourcePath.fromString(documentIdValue));
        if (!DocumentKey.isDocumentKey(path2)) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. When querying a collection group by FieldPath.documentId(), the value provided must result in a valid document path, " + ("but '" + path2 + "' is not because it has an odd number of segments (" + path2.length + ")."));
        }
        return refValue(databaseId, new DocumentKey(path2));
      } else if (documentIdValue instanceof DocumentReference) {
        return refValue(databaseId, documentIdValue._key);
      } else {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. When querying with FieldPath.documentId(), you must provide a valid string or a DocumentReference, but it was: " + (valueDescription(documentIdValue) + "."));
      }
    }
    function validateDisjunctiveFilterElements(value, operator) {
      if (!Array.isArray(value) || value.length === 0) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid Query. A non-empty array is required for " + ("'" + operator.toString() + "' filters."));
      }
      if (value.length > 10) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid Query. '" + operator.toString() + "' filters support a maximum of 10 elements in the value array.");
      }
    }
    function conflictingOps(op) {
      switch (op) {
        case "!=":
          return ["!=", "not-in"];
        case "array-contains":
          return [
            "array-contains",
            "array-contains-any",
            "not-in"
          ];
        case "in":
          return ["array-contains-any", "in", "not-in"];
        case "array-contains-any":
          return [
            "array-contains",
            "array-contains-any",
            "in",
            "not-in"
          ];
        case "not-in":
          return [
            "array-contains",
            "array-contains-any",
            "in",
            "not-in",
            "!="
          ];
        default:
          return [];
      }
    }
    function validateNewFilter(query2, filter2) {
      if (filter2.isInequality()) {
        var existingField = getInequalityFilterField(query2);
        if (existingField !== null && !existingField.isEqual(filter2.field)) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have" + (" inequality filters on '" + existingField.toString() + "'") + (" and '" + filter2.field.toString() + "'"));
        }
        var firstOrderByField = getFirstOrderByField(query2);
        if (firstOrderByField !== null) {
          validateOrderByAndInequalityMatch(query2, filter2.field, firstOrderByField);
        }
      }
      var conflictingOp = findFilterOperator(query2, conflictingOps(filter2.op));
      if (conflictingOp !== null) {
        if (conflictingOp === filter2.op) {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. You cannot use more than one " + ("'" + filter2.op.toString() + "' filter."));
        } else {
          throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. You cannot use '" + filter2.op.toString() + "' filters " + ("with '" + conflictingOp.toString() + "' filters."));
        }
      }
    }
    function validateNewOrderBy(query2, orderBy2) {
      if (getFirstOrderByField(query2) === null) {
        var inequalityField = getInequalityFilterField(query2);
        if (inequalityField !== null) {
          validateOrderByAndInequalityMatch(query2, inequalityField, orderBy2.field);
        }
      }
    }
    function validateOrderByAndInequalityMatch(baseQuery, inequality, orderBy2) {
      if (!orderBy2.isEqual(inequality)) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. You have a where filter with an inequality " + ("(<, <=, !=, not-in, >, or >=) on field '" + inequality.toString() + "' ") + ("and so you must also use '" + inequality.toString() + "' ") + "as your first argument to orderBy(), but your first orderBy() " + ("is on field '" + orderBy2.toString() + "' instead."));
      }
    }
    var AbstractUserDataWriter = function() {
      function AbstractUserDataWriter2() {
      }
      AbstractUserDataWriter2.prototype.convertValue = function(value, serverTimestampBehavior) {
        if (serverTimestampBehavior === void 0) {
          serverTimestampBehavior = "none";
        }
        switch (typeOrder(value)) {
          case 0:
            return null;
          case 1:
            return value.booleanValue;
          case 2:
            return normalizeNumber(value.integerValue || value.doubleValue);
          case 3:
            return this.convertTimestamp(value.timestampValue);
          case 4:
            return this.convertServerTimestamp(value, serverTimestampBehavior);
          case 5:
            return value.stringValue;
          case 6:
            return this.convertBytes(normalizeByteString(value.bytesValue));
          case 7:
            return this.convertReference(value.referenceValue);
          case 8:
            return this.convertGeoPoint(value.geoPointValue);
          case 9:
            return this.convertArray(value.arrayValue, serverTimestampBehavior);
          case 10:
            return this.convertObject(value.mapValue, serverTimestampBehavior);
          default:
            throw fail();
        }
      };
      AbstractUserDataWriter2.prototype.convertObject = function(mapValue, serverTimestampBehavior) {
        var _this = this;
        var result = {};
        forEach(mapValue.fields, function(key, value) {
          result[key] = _this.convertValue(value, serverTimestampBehavior);
        });
        return result;
      };
      AbstractUserDataWriter2.prototype.convertGeoPoint = function(value) {
        return new GeoPoint(normalizeNumber(value.latitude), normalizeNumber(value.longitude));
      };
      AbstractUserDataWriter2.prototype.convertArray = function(arrayValue, serverTimestampBehavior) {
        var _this = this;
        return (arrayValue.values || []).map(function(value) {
          return _this.convertValue(value, serverTimestampBehavior);
        });
      };
      AbstractUserDataWriter2.prototype.convertServerTimestamp = function(value, serverTimestampBehavior) {
        switch (serverTimestampBehavior) {
          case "previous":
            var previousValue = getPreviousValue(value);
            if (previousValue == null) {
              return null;
            }
            return this.convertValue(previousValue, serverTimestampBehavior);
          case "estimate":
            return this.convertTimestamp(getLocalWriteTime(value));
          default:
            return null;
        }
      };
      AbstractUserDataWriter2.prototype.convertTimestamp = function(value) {
        var normalizedValue = normalizeTimestamp(value);
        return new Timestamp(normalizedValue.seconds, normalizedValue.nanos);
      };
      AbstractUserDataWriter2.prototype.convertDocumentKey = function(name3, expectedDatabaseId) {
        var resourcePath = ResourcePath.fromString(name3);
        hardAssert(isValidResourceName(resourcePath));
        var databaseId = new DatabaseId(resourcePath.get(1), resourcePath.get(3));
        var key = new DocumentKey(resourcePath.popFirst(5));
        if (!databaseId.isEqual(expectedDatabaseId)) {
          logError("Document " + key + " contains a document reference within a different database (" + (databaseId.projectId + "/" + databaseId.database + ") which is not ") + "supported. It will be treated as a reference in the current " + ("database (" + expectedDatabaseId.projectId + "/" + expectedDatabaseId.database + ") ") + "instead.");
        }
        return key;
      };
      return AbstractUserDataWriter2;
    }();
    function applyFirestoreDataConverter(converter, value, options2) {
      var convertedValue;
      if (converter) {
        if (options2 && (options2.merge || options2.mergeFields)) {
          convertedValue = converter.toFirestore(value, options2);
        } else {
          convertedValue = converter.toFirestore(value);
        }
      } else {
        convertedValue = value;
      }
      return convertedValue;
    }
    var LiteUserDataWriter = function(_super) {
      tslib2.__extends(LiteUserDataWriter2, _super);
      function LiteUserDataWriter2(firestore) {
        var _this = _super.call(this) || this;
        _this.firestore = firestore;
        return _this;
      }
      LiteUserDataWriter2.prototype.convertBytes = function(bytes) {
        return new Bytes(bytes);
      };
      LiteUserDataWriter2.prototype.convertReference = function(name3) {
        var key = this.convertDocumentKey(name3, this.firestore._databaseId);
        return new DocumentReference(this.firestore, null, key);
      };
      return LiteUserDataWriter2;
    }(AbstractUserDataWriter);
    var WriteBatch = function() {
      function WriteBatch2(_firestore, _commitHandler) {
        this._firestore = _firestore;
        this._commitHandler = _commitHandler;
        this._mutations = [];
        this._committed = false;
        this._dataReader = newUserDataReader(_firestore);
      }
      WriteBatch2.prototype.set = function(documentRef, data, options2) {
        this._verifyNotCommitted();
        var ref2 = validateReference(documentRef, this._firestore);
        var convertedValue = applyFirestoreDataConverter(ref2.converter, data, options2);
        var parsed = parseSetData(this._dataReader, "WriteBatch.set", ref2._key, convertedValue, ref2.converter !== null, options2);
        this._mutations.push(parsed.toMutation(ref2._key, Precondition.none()));
        return this;
      };
      WriteBatch2.prototype.update = function(documentRef, fieldOrUpdateData, value) {
        var moreFieldsAndValues = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          moreFieldsAndValues[_i - 3] = arguments[_i];
        }
        this._verifyNotCommitted();
        var ref2 = validateReference(documentRef, this._firestore);
        fieldOrUpdateData = util.getModularInstance(fieldOrUpdateData);
        var parsed;
        if (typeof fieldOrUpdateData === "string" || fieldOrUpdateData instanceof FieldPath) {
          parsed = parseUpdateVarargs(this._dataReader, "WriteBatch.update", ref2._key, fieldOrUpdateData, value, moreFieldsAndValues);
        } else {
          parsed = parseUpdateData(this._dataReader, "WriteBatch.update", ref2._key, fieldOrUpdateData);
        }
        this._mutations.push(parsed.toMutation(ref2._key, Precondition.exists(true)));
        return this;
      };
      WriteBatch2.prototype.delete = function(documentRef) {
        this._verifyNotCommitted();
        var ref2 = validateReference(documentRef, this._firestore);
        this._mutations = this._mutations.concat(new DeleteMutation(ref2._key, Precondition.none()));
        return this;
      };
      WriteBatch2.prototype.commit = function() {
        this._verifyNotCommitted();
        this._committed = true;
        if (this._mutations.length > 0) {
          return this._commitHandler(this._mutations);
        }
        return Promise.resolve();
      };
      WriteBatch2.prototype._verifyNotCommitted = function() {
        if (this._committed) {
          throw new FirestoreError(Code.FAILED_PRECONDITION, "A write batch can no longer be used after commit() has been called.");
        }
      };
      return WriteBatch2;
    }();
    function validateReference(documentRef, firestore) {
      documentRef = util.getModularInstance(documentRef);
      if (documentRef.firestore !== firestore) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Provided document reference is from a different Firestore instance.");
      } else {
        return documentRef;
      }
    }
    var Transaction$1 = function() {
      function Transaction$12(_firestore, _transaction) {
        this._firestore = _firestore;
        this._transaction = _transaction;
        this._dataReader = newUserDataReader(_firestore);
      }
      Transaction$12.prototype.get = function(documentRef) {
        var _this = this;
        var ref2 = validateReference(documentRef, this._firestore);
        var userDataWriter = new LiteUserDataWriter(this._firestore);
        return this._transaction.lookup([ref2._key]).then(function(docs) {
          if (!docs || docs.length !== 1) {
            return fail();
          }
          var doc2 = docs[0];
          if (doc2.isFoundDocument()) {
            return new DocumentSnapshot$1(_this._firestore, userDataWriter, doc2.key, doc2, ref2.converter);
          } else if (doc2.isNoDocument()) {
            return new DocumentSnapshot$1(_this._firestore, userDataWriter, ref2._key, null, ref2.converter);
          } else {
            throw fail();
          }
        });
      };
      Transaction$12.prototype.set = function(documentRef, value, options2) {
        var ref2 = validateReference(documentRef, this._firestore);
        var convertedValue = applyFirestoreDataConverter(ref2.converter, value, options2);
        var parsed = parseSetData(this._dataReader, "Transaction.set", ref2._key, convertedValue, ref2.converter !== null, options2);
        this._transaction.set(ref2._key, parsed);
        return this;
      };
      Transaction$12.prototype.update = function(documentRef, fieldOrUpdateData, value) {
        var moreFieldsAndValues = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          moreFieldsAndValues[_i - 3] = arguments[_i];
        }
        var ref2 = validateReference(documentRef, this._firestore);
        fieldOrUpdateData = util.getModularInstance(fieldOrUpdateData);
        var parsed;
        if (typeof fieldOrUpdateData === "string" || fieldOrUpdateData instanceof FieldPath) {
          parsed = parseUpdateVarargs(this._dataReader, "Transaction.update", ref2._key, fieldOrUpdateData, value, moreFieldsAndValues);
        } else {
          parsed = parseUpdateData(this._dataReader, "Transaction.update", ref2._key, fieldOrUpdateData);
        }
        this._transaction.update(ref2._key, parsed);
        return this;
      };
      Transaction$12.prototype.delete = function(documentRef) {
        var ref2 = validateReference(documentRef, this._firestore);
        this._transaction.delete(ref2._key);
        return this;
      };
      return Transaction$12;
    }();
    function isPartialObserver(obj) {
      return implementsAnyMethods2(obj, ["next", "error", "complete"]);
    }
    function implementsAnyMethods2(obj, methods) {
      if (typeof obj !== "object" || obj === null) {
        return false;
      }
      var object = obj;
      for (var _i = 0, methods_1 = methods; _i < methods_1.length; _i++) {
        var method = methods_1[_i];
        if (method in object && typeof object[method] === "function") {
          return true;
        }
      }
      return false;
    }
    function getDoc(reference) {
      reference = cast(reference, DocumentReference);
      var firestore = cast(reference.firestore, Firestore);
      var client = ensureFirestoreConfigured(firestore);
      return firestoreClientGetDocumentViaSnapshotListener(client, reference._key).then(function(snapshot) {
        return convertToDocSnapshot(firestore, reference, snapshot);
      });
    }
    var ExpUserDataWriter = function(_super) {
      tslib2.__extends(ExpUserDataWriter2, _super);
      function ExpUserDataWriter2(firestore) {
        var _this = _super.call(this) || this;
        _this.firestore = firestore;
        return _this;
      }
      ExpUserDataWriter2.prototype.convertBytes = function(bytes) {
        return new Bytes(bytes);
      };
      ExpUserDataWriter2.prototype.convertReference = function(name3) {
        var key = this.convertDocumentKey(name3, this.firestore._databaseId);
        return new DocumentReference(this.firestore, null, key);
      };
      return ExpUserDataWriter2;
    }(AbstractUserDataWriter);
    function getDocFromCache(reference) {
      reference = cast(reference, DocumentReference);
      var firestore = cast(reference.firestore, Firestore);
      var client = ensureFirestoreConfigured(firestore);
      var userDataWriter = new ExpUserDataWriter(firestore);
      return firestoreClientGetDocumentFromLocalCache(client, reference._key).then(function(doc2) {
        return new DocumentSnapshot(firestore, userDataWriter, reference._key, doc2, new SnapshotMetadata(doc2 !== null && doc2.hasLocalMutations, true), reference.converter);
      });
    }
    function getDocFromServer(reference) {
      reference = cast(reference, DocumentReference);
      var firestore = cast(reference.firestore, Firestore);
      var client = ensureFirestoreConfigured(firestore);
      return firestoreClientGetDocumentViaSnapshotListener(client, reference._key, {
        source: "server"
      }).then(function(snapshot) {
        return convertToDocSnapshot(firestore, reference, snapshot);
      });
    }
    function getDocs2(query2) {
      query2 = cast(query2, Query);
      var firestore = cast(query2.firestore, Firestore);
      var client = ensureFirestoreConfigured(firestore);
      var userDataWriter = new ExpUserDataWriter(firestore);
      validateHasExplicitOrderByForLimitToLast(query2._query);
      return firestoreClientGetDocumentsViaSnapshotListener(client, query2._query).then(function(snapshot) {
        return new QuerySnapshot(firestore, userDataWriter, query2, snapshot);
      });
    }
    function getDocsFromCache(query2) {
      query2 = cast(query2, Query);
      var firestore = cast(query2.firestore, Firestore);
      var client = ensureFirestoreConfigured(firestore);
      var userDataWriter = new ExpUserDataWriter(firestore);
      return firestoreClientGetDocumentsFromLocalCache(client, query2._query).then(function(snapshot) {
        return new QuerySnapshot(firestore, userDataWriter, query2, snapshot);
      });
    }
    function getDocsFromServer(query2) {
      query2 = cast(query2, Query);
      var firestore = cast(query2.firestore, Firestore);
      var client = ensureFirestoreConfigured(firestore);
      var userDataWriter = new ExpUserDataWriter(firestore);
      return firestoreClientGetDocumentsViaSnapshotListener(client, query2._query, {
        source: "server"
      }).then(function(snapshot) {
        return new QuerySnapshot(firestore, userDataWriter, query2, snapshot);
      });
    }
    function setDoc(reference, data, options2) {
      reference = cast(reference, DocumentReference);
      var firestore = cast(reference.firestore, Firestore);
      var convertedValue = applyFirestoreDataConverter(reference.converter, data, options2);
      var dataReader = newUserDataReader(firestore);
      var parsed = parseSetData(dataReader, "setDoc", reference._key, convertedValue, reference.converter !== null, options2);
      var mutation = parsed.toMutation(reference._key, Precondition.none());
      return executeWrite(firestore, [mutation]);
    }
    function updateDoc(reference, fieldOrUpdateData, value) {
      var moreFieldsAndValues = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        moreFieldsAndValues[_i - 3] = arguments[_i];
      }
      reference = cast(reference, DocumentReference);
      var firestore = cast(reference.firestore, Firestore);
      var dataReader = newUserDataReader(firestore);
      fieldOrUpdateData = util.getModularInstance(fieldOrUpdateData);
      var parsed;
      if (typeof fieldOrUpdateData === "string" || fieldOrUpdateData instanceof FieldPath) {
        parsed = parseUpdateVarargs(dataReader, "updateDoc", reference._key, fieldOrUpdateData, value, moreFieldsAndValues);
      } else {
        parsed = parseUpdateData(dataReader, "updateDoc", reference._key, fieldOrUpdateData);
      }
      var mutation = parsed.toMutation(reference._key, Precondition.exists(true));
      return executeWrite(firestore, [mutation]);
    }
    function deleteDoc(reference) {
      var firestore = cast(reference.firestore, Firestore);
      var mutations = [new DeleteMutation(reference._key, Precondition.none())];
      return executeWrite(firestore, mutations);
    }
    function addDoc(reference, data) {
      var firestore = cast(reference.firestore, Firestore);
      var docRef = doc(reference);
      var convertedValue = applyFirestoreDataConverter(reference.converter, data);
      var dataReader = newUserDataReader(reference.firestore);
      var parsed = parseSetData(dataReader, "addDoc", docRef._key, convertedValue, reference.converter !== null, {});
      var mutation = parsed.toMutation(docRef._key, Precondition.exists(false));
      return executeWrite(firestore, [mutation]).then(function() {
        return docRef;
      });
    }
    function onSnapshot(reference) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var _a, _b, _c;
      reference = util.getModularInstance(reference);
      var options2 = {
        includeMetadataChanges: false
      };
      var currArg = 0;
      if (typeof args[currArg] === "object" && !isPartialObserver(args[currArg])) {
        options2 = args[currArg];
        currArg++;
      }
      var internalOptions = {
        includeMetadataChanges: options2.includeMetadataChanges
      };
      if (isPartialObserver(args[currArg])) {
        var userObserver = args[currArg];
        args[currArg] = (_a = userObserver.next) === null || _a === void 0 ? void 0 : _a.bind(userObserver);
        args[currArg + 1] = (_b = userObserver.error) === null || _b === void 0 ? void 0 : _b.bind(userObserver);
        args[currArg + 2] = (_c = userObserver.complete) === null || _c === void 0 ? void 0 : _c.bind(userObserver);
      }
      var observer;
      var firestore;
      var internalQuery;
      if (reference instanceof DocumentReference) {
        firestore = cast(reference.firestore, Firestore);
        internalQuery = newQueryForPath(reference._key.path);
        observer = {
          next: function(snapshot) {
            if (args[currArg]) {
              args[currArg](convertToDocSnapshot(firestore, reference, snapshot));
            }
          },
          error: args[currArg + 1],
          complete: args[currArg + 2]
        };
      } else {
        var query_5 = cast(reference, Query);
        firestore = cast(query_5.firestore, Firestore);
        internalQuery = query_5._query;
        var userDataWriter_1 = new ExpUserDataWriter(firestore);
        observer = {
          next: function(snapshot) {
            if (args[currArg]) {
              args[currArg](new QuerySnapshot(firestore, userDataWriter_1, query_5, snapshot));
            }
          },
          error: args[currArg + 1],
          complete: args[currArg + 2]
        };
        validateHasExplicitOrderByForLimitToLast(reference._query);
      }
      var client = ensureFirestoreConfigured(firestore);
      return firestoreClientListen(client, internalQuery, internalOptions, observer);
    }
    function onSnapshotsInSync(firestore, arg) {
      firestore = cast(firestore, Firestore);
      var client = ensureFirestoreConfigured(firestore);
      var observer = isPartialObserver(arg) ? arg : {
        next: arg
      };
      return firestoreClientAddSnapshotsInSyncListener(client, observer);
    }
    function executeWrite(firestore, mutations) {
      var client = ensureFirestoreConfigured(firestore);
      return firestoreClientWrite(client, mutations);
    }
    function convertToDocSnapshot(firestore, ref2, snapshot) {
      var doc2 = snapshot.docs.get(ref2._key);
      var userDataWriter = new ExpUserDataWriter(firestore);
      return new DocumentSnapshot(firestore, userDataWriter, ref2._key, doc2, new SnapshotMetadata(snapshot.hasPendingWrites, snapshot.fromCache), ref2.converter);
    }
    var Transaction2 = function(_super) {
      tslib2.__extends(Transaction3, _super);
      function Transaction3(_firestore, _transaction) {
        var _this = _super.call(this, _firestore, _transaction) || this;
        _this._firestore = _firestore;
        return _this;
      }
      Transaction3.prototype.get = function(documentRef) {
        var _this = this;
        var ref2 = validateReference(documentRef, this._firestore);
        var userDataWriter = new ExpUserDataWriter(this._firestore);
        return _super.prototype.get.call(this, documentRef).then(function(liteDocumentSnapshot) {
          return new DocumentSnapshot(_this._firestore, userDataWriter, ref2._key, liteDocumentSnapshot._document, new SnapshotMetadata(false, false), ref2.converter);
        });
      };
      return Transaction3;
    }(Transaction$1);
    function runTransaction(firestore, updateFunction) {
      var client = ensureFirestoreConfigured(firestore);
      return firestoreClientTransaction(client, function(internalTransaction) {
        return updateFunction(new Transaction2(firestore, internalTransaction));
      });
    }
    function deleteField() {
      return new DeleteFieldValueImpl("deleteField");
    }
    function serverTimestamp() {
      return new ServerTimestampFieldValueImpl("serverTimestamp");
    }
    function arrayUnion() {
      var elements = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        elements[_i] = arguments[_i];
      }
      return new ArrayUnionFieldValueImpl("arrayUnion", elements);
    }
    function arrayRemove() {
      var elements = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        elements[_i] = arguments[_i];
      }
      return new ArrayRemoveFieldValueImpl("arrayRemove", elements);
    }
    function increment(n) {
      return new NumericIncrementFieldValueImpl("increment", n);
    }
    function writeBatch(firestore) {
      firestore = cast(firestore, Firestore);
      ensureFirestoreConfigured(firestore);
      return new WriteBatch(firestore, function(mutations) {
        return executeWrite(firestore, mutations);
      });
    }
    registerFirestore("node");
    exports2.AbstractUserDataWriter = AbstractUserDataWriter;
    exports2.Bytes = Bytes;
    exports2.CACHE_SIZE_UNLIMITED = CACHE_SIZE_UNLIMITED;
    exports2.CollectionReference = CollectionReference;
    exports2.DocumentReference = DocumentReference;
    exports2.DocumentSnapshot = DocumentSnapshot;
    exports2.FieldPath = FieldPath;
    exports2.FieldValue = FieldValue;
    exports2.Firestore = Firestore;
    exports2.FirestoreError = FirestoreError;
    exports2.GeoPoint = GeoPoint;
    exports2.LoadBundleTask = LoadBundleTask;
    exports2.Query = Query;
    exports2.QueryConstraint = QueryConstraint;
    exports2.QueryDocumentSnapshot = QueryDocumentSnapshot;
    exports2.QuerySnapshot = QuerySnapshot;
    exports2.SnapshotMetadata = SnapshotMetadata;
    exports2.Timestamp = Timestamp;
    exports2.Transaction = Transaction2;
    exports2.WriteBatch = WriteBatch;
    exports2._DatabaseId = DatabaseId;
    exports2._DocumentKey = DocumentKey;
    exports2._EmptyCredentialsProvider = EmptyCredentialsProvider;
    exports2._FieldPath = FieldPath$1;
    exports2._cast = cast;
    exports2._debugAssert = debugAssert2;
    exports2._isBase64Available = isBase64Available;
    exports2._logWarn = logWarn;
    exports2._validateIsNotUsedTogether = validateIsNotUsedTogether;
    exports2.addDoc = addDoc;
    exports2.arrayRemove = arrayRemove;
    exports2.arrayUnion = arrayUnion;
    exports2.clearIndexedDbPersistence = clearIndexedDbPersistence;
    exports2.collection = collection2;
    exports2.collectionGroup = collectionGroup;
    exports2.connectFirestoreEmulator = connectFirestoreEmulator;
    exports2.deleteDoc = deleteDoc;
    exports2.deleteField = deleteField;
    exports2.disableNetwork = disableNetwork;
    exports2.doc = doc;
    exports2.documentId = documentId;
    exports2.enableIndexedDbPersistence = enableIndexedDbPersistence;
    exports2.enableMultiTabIndexedDbPersistence = enableMultiTabIndexedDbPersistence;
    exports2.enableNetwork = enableNetwork;
    exports2.endAt = endAt;
    exports2.endBefore = endBefore;
    exports2.ensureFirestoreConfigured = ensureFirestoreConfigured;
    exports2.executeWrite = executeWrite;
    exports2.getDoc = getDoc;
    exports2.getDocFromCache = getDocFromCache;
    exports2.getDocFromServer = getDocFromServer;
    exports2.getDocs = getDocs2;
    exports2.getDocsFromCache = getDocsFromCache;
    exports2.getDocsFromServer = getDocsFromServer;
    exports2.getFirestore = getFirestore2;
    exports2.increment = increment;
    exports2.initializeFirestore = initializeFirestore;
    exports2.limit = limit;
    exports2.limitToLast = limitToLast;
    exports2.loadBundle = loadBundle;
    exports2.namedQuery = namedQuery;
    exports2.onSnapshot = onSnapshot;
    exports2.onSnapshotsInSync = onSnapshotsInSync;
    exports2.orderBy = orderBy;
    exports2.query = query;
    exports2.queryEqual = queryEqual;
    exports2.refEqual = refEqual;
    exports2.runTransaction = runTransaction;
    exports2.serverTimestamp = serverTimestamp;
    exports2.setDoc = setDoc;
    exports2.setLogLevel = setLogLevel;
    exports2.snapshotEqual = snapshotEqual;
    exports2.startAfter = startAfter;
    exports2.startAt = startAt;
    exports2.terminate = terminate;
    exports2.updateDoc = updateDoc;
    exports2.waitForPendingWrites = waitForPendingWrites;
    exports2.where = where;
    exports2.writeBatch = writeBatch;
  }
});

// node_modules/chart.js/dist/chart.js
var require_chart = __commonJS({
  "node_modules/chart.js/dist/chart.js"(exports2, module2) {
    init_shims();
    (function(global2, factory2) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory2() : typeof define === "function" && define.amd ? define(factory2) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.Chart = factory2());
    })(exports2, function() {
      "use strict";
      function fontString(pixelSize, fontStyle, fontFamily) {
        return fontStyle + " " + pixelSize + "px " + fontFamily;
      }
      const requestAnimFrame = function() {
        if (typeof window === "undefined") {
          return function(callback2) {
            return callback2();
          };
        }
        return window.requestAnimationFrame;
      }();
      function throttled(fn, thisArg, updateFn) {
        const updateArgs = updateFn || ((args2) => Array.prototype.slice.call(args2));
        let ticking = false;
        let args = [];
        return function(...rest) {
          args = updateArgs(rest);
          if (!ticking) {
            ticking = true;
            requestAnimFrame.call(window, () => {
              ticking = false;
              fn.apply(thisArg, args);
            });
          }
        };
      }
      function debounce(fn, delay) {
        let timeout;
        return function() {
          if (delay) {
            clearTimeout(timeout);
            timeout = setTimeout(fn, delay);
          } else {
            fn();
          }
          return delay;
        };
      }
      const _toLeftRightCenter = (align) => align === "start" ? "left" : align === "end" ? "right" : "center";
      const _alignStartEnd = (align, start2, end) => align === "start" ? start2 : align === "end" ? end : (start2 + end) / 2;
      const _textX = (align, left, right, rtl) => {
        const check = rtl ? "left" : "right";
        return align === check ? right : align === "center" ? (left + right) / 2 : left;
      };
      class Animator {
        constructor() {
          this._request = null;
          this._charts = new Map();
          this._running = false;
          this._lastDate = void 0;
        }
        _notify(chart, anims, date, type) {
          const callbacks = anims.listeners[type];
          const numSteps = anims.duration;
          callbacks.forEach((fn) => fn({
            chart,
            initial: anims.initial,
            numSteps,
            currentStep: Math.min(date - anims.start, numSteps)
          }));
        }
        _refresh() {
          const me = this;
          if (me._request) {
            return;
          }
          me._running = true;
          me._request = requestAnimFrame.call(window, () => {
            me._update();
            me._request = null;
            if (me._running) {
              me._refresh();
            }
          });
        }
        _update(date = Date.now()) {
          const me = this;
          let remaining = 0;
          me._charts.forEach((anims, chart) => {
            if (!anims.running || !anims.items.length) {
              return;
            }
            const items = anims.items;
            let i = items.length - 1;
            let draw2 = false;
            let item;
            for (; i >= 0; --i) {
              item = items[i];
              if (item._active) {
                if (item._total > anims.duration) {
                  anims.duration = item._total;
                }
                item.tick(date);
                draw2 = true;
              } else {
                items[i] = items[items.length - 1];
                items.pop();
              }
            }
            if (draw2) {
              chart.draw();
              me._notify(chart, anims, date, "progress");
            }
            if (!items.length) {
              anims.running = false;
              me._notify(chart, anims, date, "complete");
              anims.initial = false;
            }
            remaining += items.length;
          });
          me._lastDate = date;
          if (remaining === 0) {
            me._running = false;
          }
        }
        _getAnims(chart) {
          const charts = this._charts;
          let anims = charts.get(chart);
          if (!anims) {
            anims = {
              running: false,
              initial: true,
              items: [],
              listeners: {
                complete: [],
                progress: []
              }
            };
            charts.set(chart, anims);
          }
          return anims;
        }
        listen(chart, event, cb) {
          this._getAnims(chart).listeners[event].push(cb);
        }
        add(chart, items) {
          if (!items || !items.length) {
            return;
          }
          this._getAnims(chart).items.push(...items);
        }
        has(chart) {
          return this._getAnims(chart).items.length > 0;
        }
        start(chart) {
          const anims = this._charts.get(chart);
          if (!anims) {
            return;
          }
          anims.running = true;
          anims.start = Date.now();
          anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);
          this._refresh();
        }
        running(chart) {
          if (!this._running) {
            return false;
          }
          const anims = this._charts.get(chart);
          if (!anims || !anims.running || !anims.items.length) {
            return false;
          }
          return true;
        }
        stop(chart) {
          const anims = this._charts.get(chart);
          if (!anims || !anims.items.length) {
            return;
          }
          const items = anims.items;
          let i = items.length - 1;
          for (; i >= 0; --i) {
            items[i].cancel();
          }
          anims.items = [];
          this._notify(chart, anims, Date.now(), "complete");
        }
        remove(chart) {
          return this._charts.delete(chart);
        }
      }
      var animator = new Animator();
      const map$1 = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 };
      const hex = "0123456789ABCDEF";
      const h1 = (b) => hex[b & 15];
      const h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];
      const eq = (b) => (b & 240) >> 4 === (b & 15);
      function isShort(v) {
        return eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
      }
      function hexParse(str) {
        var len = str.length;
        var ret;
        if (str[0] === "#") {
          if (len === 4 || len === 5) {
            ret = {
              r: 255 & map$1[str[1]] * 17,
              g: 255 & map$1[str[2]] * 17,
              b: 255 & map$1[str[3]] * 17,
              a: len === 5 ? map$1[str[4]] * 17 : 255
            };
          } else if (len === 7 || len === 9) {
            ret = {
              r: map$1[str[1]] << 4 | map$1[str[2]],
              g: map$1[str[3]] << 4 | map$1[str[4]],
              b: map$1[str[5]] << 4 | map$1[str[6]],
              a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
            };
          }
        }
        return ret;
      }
      function hexString(v) {
        var f = isShort(v) ? h1 : h2;
        return v ? "#" + f(v.r) + f(v.g) + f(v.b) + (v.a < 255 ? f(v.a) : "") : v;
      }
      function round(v) {
        return v + 0.5 | 0;
      }
      const lim = (v, l, h) => Math.max(Math.min(v, h), l);
      function p2b(v) {
        return lim(round(v * 2.55), 0, 255);
      }
      function n2b(v) {
        return lim(round(v * 255), 0, 255);
      }
      function b2n(v) {
        return lim(round(v / 2.55) / 100, 0, 1);
      }
      function n2p(v) {
        return lim(round(v * 100), 0, 100);
      }
      const RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
      function rgbParse(str) {
        const m = RGB_RE.exec(str);
        let a = 255;
        let r, g, b;
        if (!m) {
          return;
        }
        if (m[7] !== r) {
          const v = +m[7];
          a = 255 & (m[8] ? p2b(v) : v * 255);
        }
        r = +m[1];
        g = +m[3];
        b = +m[5];
        r = 255 & (m[2] ? p2b(r) : r);
        g = 255 & (m[4] ? p2b(g) : g);
        b = 255 & (m[6] ? p2b(b) : b);
        return {
          r,
          g,
          b,
          a
        };
      }
      function rgbString(v) {
        return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
      }
      const HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
      function hsl2rgbn(h, s2, l) {
        const a = s2 * Math.min(l, 1 - l);
        const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
        return [f(0), f(8), f(4)];
      }
      function hsv2rgbn(h, s2, v) {
        const f = (n, k = (n + h / 60) % 6) => v - v * s2 * Math.max(Math.min(k, 4 - k, 1), 0);
        return [f(5), f(3), f(1)];
      }
      function hwb2rgbn(h, w, b) {
        const rgb = hsl2rgbn(h, 1, 0.5);
        let i;
        if (w + b > 1) {
          i = 1 / (w + b);
          w *= i;
          b *= i;
        }
        for (i = 0; i < 3; i++) {
          rgb[i] *= 1 - w - b;
          rgb[i] += w;
        }
        return rgb;
      }
      function rgb2hsl(v) {
        const range = 255;
        const r = v.r / range;
        const g = v.g / range;
        const b = v.b / range;
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        const l = (max + min) / 2;
        let h, s2, d2;
        if (max !== min) {
          d2 = max - min;
          s2 = l > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
          h = max === r ? (g - b) / d2 + (g < b ? 6 : 0) : max === g ? (b - r) / d2 + 2 : (r - g) / d2 + 4;
          h = h * 60 + 0.5;
        }
        return [h | 0, s2 || 0, l];
      }
      function calln(f, a, b, c) {
        return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
      }
      function hsl2rgb(h, s2, l) {
        return calln(hsl2rgbn, h, s2, l);
      }
      function hwb2rgb(h, w, b) {
        return calln(hwb2rgbn, h, w, b);
      }
      function hsv2rgb(h, s2, v) {
        return calln(hsv2rgbn, h, s2, v);
      }
      function hue(h) {
        return (h % 360 + 360) % 360;
      }
      function hueParse(str) {
        const m = HUE_RE.exec(str);
        let a = 255;
        let v;
        if (!m) {
          return;
        }
        if (m[5] !== v) {
          a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
        }
        const h = hue(+m[2]);
        const p1 = +m[3] / 100;
        const p2 = +m[4] / 100;
        if (m[1] === "hwb") {
          v = hwb2rgb(h, p1, p2);
        } else if (m[1] === "hsv") {
          v = hsv2rgb(h, p1, p2);
        } else {
          v = hsl2rgb(h, p1, p2);
        }
        return {
          r: v[0],
          g: v[1],
          b: v[2],
          a
        };
      }
      function rotate(v, deg) {
        var h = rgb2hsl(v);
        h[0] = hue(h[0] + deg);
        h = hsl2rgb(h);
        v.r = h[0];
        v.g = h[1];
        v.b = h[2];
      }
      function hslString(v) {
        if (!v) {
          return;
        }
        const a = rgb2hsl(v);
        const h = a[0];
        const s2 = n2p(a[1]);
        const l = n2p(a[2]);
        return v.a < 255 ? `hsla(${h}, ${s2}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s2}%, ${l}%)`;
      }
      const map$1$1 = {
        x: "dark",
        Z: "light",
        Y: "re",
        X: "blu",
        W: "gr",
        V: "medium",
        U: "slate",
        A: "ee",
        T: "ol",
        S: "or",
        B: "ra",
        C: "lateg",
        D: "ights",
        R: "in",
        Q: "turquois",
        E: "hi",
        P: "ro",
        O: "al",
        N: "le",
        M: "de",
        L: "yello",
        F: "en",
        K: "ch",
        G: "arks",
        H: "ea",
        I: "ightg",
        J: "wh"
      };
      const names = {
        OiceXe: "f0f8ff",
        antiquewEte: "faebd7",
        aqua: "ffff",
        aquamarRe: "7fffd4",
        azuY: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "0",
        blanKedOmond: "ffebcd",
        Xe: "ff",
        XeviTet: "8a2be2",
        bPwn: "a52a2a",
        burlywood: "deb887",
        caMtXe: "5f9ea0",
        KartYuse: "7fff00",
        KocTate: "d2691e",
        cSO: "ff7f50",
        cSnflowerXe: "6495ed",
        cSnsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "ffff",
        xXe: "8b",
        xcyan: "8b8b",
        xgTMnPd: "b8860b",
        xWay: "a9a9a9",
        xgYF: "6400",
        xgYy: "a9a9a9",
        xkhaki: "bdb76b",
        xmagFta: "8b008b",
        xTivegYF: "556b2f",
        xSange: "ff8c00",
        xScEd: "9932cc",
        xYd: "8b0000",
        xsOmon: "e9967a",
        xsHgYF: "8fbc8f",
        xUXe: "483d8b",
        xUWay: "2f4f4f",
        xUgYy: "2f4f4f",
        xQe: "ced1",
        xviTet: "9400d3",
        dAppRk: "ff1493",
        dApskyXe: "bfff",
        dimWay: "696969",
        dimgYy: "696969",
        dodgerXe: "1e90ff",
        fiYbrick: "b22222",
        flSOwEte: "fffaf0",
        foYstWAn: "228b22",
        fuKsia: "ff00ff",
        gaRsbSo: "dcdcdc",
        ghostwEte: "f8f8ff",
        gTd: "ffd700",
        gTMnPd: "daa520",
        Way: "808080",
        gYF: "8000",
        gYFLw: "adff2f",
        gYy: "808080",
        honeyMw: "f0fff0",
        hotpRk: "ff69b4",
        RdianYd: "cd5c5c",
        Rdigo: "4b0082",
        ivSy: "fffff0",
        khaki: "f0e68c",
        lavFMr: "e6e6fa",
        lavFMrXsh: "fff0f5",
        lawngYF: "7cfc00",
        NmoncEffon: "fffacd",
        ZXe: "add8e6",
        ZcSO: "f08080",
        Zcyan: "e0ffff",
        ZgTMnPdLw: "fafad2",
        ZWay: "d3d3d3",
        ZgYF: "90ee90",
        ZgYy: "d3d3d3",
        ZpRk: "ffb6c1",
        ZsOmon: "ffa07a",
        ZsHgYF: "20b2aa",
        ZskyXe: "87cefa",
        ZUWay: "778899",
        ZUgYy: "778899",
        ZstAlXe: "b0c4de",
        ZLw: "ffffe0",
        lime: "ff00",
        limegYF: "32cd32",
        lRF: "faf0e6",
        magFta: "ff00ff",
        maPon: "800000",
        VaquamarRe: "66cdaa",
        VXe: "cd",
        VScEd: "ba55d3",
        VpurpN: "9370db",
        VsHgYF: "3cb371",
        VUXe: "7b68ee",
        VsprRggYF: "fa9a",
        VQe: "48d1cc",
        VviTetYd: "c71585",
        midnightXe: "191970",
        mRtcYam: "f5fffa",
        mistyPse: "ffe4e1",
        moccasR: "ffe4b5",
        navajowEte: "ffdead",
        navy: "80",
        Tdlace: "fdf5e6",
        Tive: "808000",
        TivedBb: "6b8e23",
        Sange: "ffa500",
        SangeYd: "ff4500",
        ScEd: "da70d6",
        pOegTMnPd: "eee8aa",
        pOegYF: "98fb98",
        pOeQe: "afeeee",
        pOeviTetYd: "db7093",
        papayawEp: "ffefd5",
        pHKpuff: "ffdab9",
        peru: "cd853f",
        pRk: "ffc0cb",
        plum: "dda0dd",
        powMrXe: "b0e0e6",
        purpN: "800080",
        YbeccapurpN: "663399",
        Yd: "ff0000",
        Psybrown: "bc8f8f",
        PyOXe: "4169e1",
        saddNbPwn: "8b4513",
        sOmon: "fa8072",
        sandybPwn: "f4a460",
        sHgYF: "2e8b57",
        sHshell: "fff5ee",
        siFna: "a0522d",
        silver: "c0c0c0",
        skyXe: "87ceeb",
        UXe: "6a5acd",
        UWay: "708090",
        UgYy: "708090",
        snow: "fffafa",
        sprRggYF: "ff7f",
        stAlXe: "4682b4",
        tan: "d2b48c",
        teO: "8080",
        tEstN: "d8bfd8",
        tomato: "ff6347",
        Qe: "40e0d0",
        viTet: "ee82ee",
        JHt: "f5deb3",
        wEte: "ffffff",
        wEtesmoke: "f5f5f5",
        Lw: "ffff00",
        LwgYF: "9acd32"
      };
      function unpack() {
        const unpacked = {};
        const keys = Object.keys(names);
        const tkeys = Object.keys(map$1$1);
        let i, j, k, ok, nk;
        for (i = 0; i < keys.length; i++) {
          ok = nk = keys[i];
          for (j = 0; j < tkeys.length; j++) {
            k = tkeys[j];
            nk = nk.replace(k, map$1$1[k]);
          }
          k = parseInt(names[ok], 16);
          unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];
        }
        return unpacked;
      }
      let names$1;
      function nameParse(str) {
        if (!names$1) {
          names$1 = unpack();
          names$1.transparent = [0, 0, 0, 0];
        }
        const a = names$1[str.toLowerCase()];
        return a && {
          r: a[0],
          g: a[1],
          b: a[2],
          a: a.length === 4 ? a[3] : 255
        };
      }
      function modHSL(v, i, ratio) {
        if (v) {
          let tmp = rgb2hsl(v);
          tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
          tmp = hsl2rgb(tmp);
          v.r = tmp[0];
          v.g = tmp[1];
          v.b = tmp[2];
        }
      }
      function clone$1(v, proto) {
        return v ? Object.assign(proto || {}, v) : v;
      }
      function fromObject(input) {
        var v = { r: 0, g: 0, b: 0, a: 255 };
        if (Array.isArray(input)) {
          if (input.length >= 3) {
            v = { r: input[0], g: input[1], b: input[2], a: 255 };
            if (input.length > 3) {
              v.a = n2b(input[3]);
            }
          }
        } else {
          v = clone$1(input, { r: 0, g: 0, b: 0, a: 1 });
          v.a = n2b(v.a);
        }
        return v;
      }
      function functionParse(str) {
        if (str.charAt(0) === "r") {
          return rgbParse(str);
        }
        return hueParse(str);
      }
      class Color {
        constructor(input) {
          if (input instanceof Color) {
            return input;
          }
          const type = typeof input;
          let v;
          if (type === "object") {
            v = fromObject(input);
          } else if (type === "string") {
            v = hexParse(input) || nameParse(input) || functionParse(input);
          }
          this._rgb = v;
          this._valid = !!v;
        }
        get valid() {
          return this._valid;
        }
        get rgb() {
          var v = clone$1(this._rgb);
          if (v) {
            v.a = b2n(v.a);
          }
          return v;
        }
        set rgb(obj) {
          this._rgb = fromObject(obj);
        }
        rgbString() {
          return this._valid ? rgbString(this._rgb) : this._rgb;
        }
        hexString() {
          return this._valid ? hexString(this._rgb) : this._rgb;
        }
        hslString() {
          return this._valid ? hslString(this._rgb) : this._rgb;
        }
        mix(color2, weight) {
          const me = this;
          if (color2) {
            const c1 = me.rgb;
            const c2 = color2.rgb;
            let w2;
            const p = weight === w2 ? 0.5 : weight;
            const w = 2 * p - 1;
            const a = c1.a - c2.a;
            const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
            w2 = 1 - w1;
            c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;
            c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;
            c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;
            c1.a = p * c1.a + (1 - p) * c2.a;
            me.rgb = c1;
          }
          return me;
        }
        clone() {
          return new Color(this.rgb);
        }
        alpha(a) {
          this._rgb.a = n2b(a);
          return this;
        }
        clearer(ratio) {
          const rgb = this._rgb;
          rgb.a *= 1 - ratio;
          return this;
        }
        greyscale() {
          const rgb = this._rgb;
          const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
          rgb.r = rgb.g = rgb.b = val;
          return this;
        }
        opaquer(ratio) {
          const rgb = this._rgb;
          rgb.a *= 1 + ratio;
          return this;
        }
        negate() {
          const v = this._rgb;
          v.r = 255 - v.r;
          v.g = 255 - v.g;
          v.b = 255 - v.b;
          return this;
        }
        lighten(ratio) {
          modHSL(this._rgb, 2, ratio);
          return this;
        }
        darken(ratio) {
          modHSL(this._rgb, 2, -ratio);
          return this;
        }
        saturate(ratio) {
          modHSL(this._rgb, 1, ratio);
          return this;
        }
        desaturate(ratio) {
          modHSL(this._rgb, 1, -ratio);
          return this;
        }
        rotate(deg) {
          rotate(this._rgb, deg);
          return this;
        }
      }
      function index_esm(input) {
        return new Color(input);
      }
      const isPatternOrGradient = (value) => value instanceof CanvasGradient || value instanceof CanvasPattern;
      function color(value) {
        return isPatternOrGradient(value) ? value : index_esm(value);
      }
      function getHoverColor(value) {
        return isPatternOrGradient(value) ? value : index_esm(value).saturate(0.5).darken(0.1).hexString();
      }
      function noop2() {
      }
      const uid = function() {
        let id = 0;
        return function() {
          return id++;
        };
      }();
      function isNullOrUndef(value) {
        return value === null || typeof value === "undefined";
      }
      function isArray(value) {
        if (Array.isArray && Array.isArray(value)) {
          return true;
        }
        const type = Object.prototype.toString.call(value);
        if (type.substr(0, 7) === "[object" && type.substr(-6) === "Array]") {
          return true;
        }
        return false;
      }
      function isObject2(value) {
        return value !== null && Object.prototype.toString.call(value) === "[object Object]";
      }
      const isNumberFinite = (value) => (typeof value === "number" || value instanceof Number) && isFinite(+value);
      function finiteOrDefault(value, defaultValue) {
        return isNumberFinite(value) ? value : defaultValue;
      }
      function valueOrDefault(value, defaultValue) {
        return typeof value === "undefined" ? defaultValue : value;
      }
      const toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : value / dimension;
      const toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
      function callback(fn, args, thisArg) {
        if (fn && typeof fn.call === "function") {
          return fn.apply(thisArg, args);
        }
      }
      function each2(loopable, fn, thisArg, reverse) {
        let i, len, keys;
        if (isArray(loopable)) {
          len = loopable.length;
          if (reverse) {
            for (i = len - 1; i >= 0; i--) {
              fn.call(thisArg, loopable[i], i);
            }
          } else {
            for (i = 0; i < len; i++) {
              fn.call(thisArg, loopable[i], i);
            }
          }
        } else if (isObject2(loopable)) {
          keys = Object.keys(loopable);
          len = keys.length;
          for (i = 0; i < len; i++) {
            fn.call(thisArg, loopable[keys[i]], keys[i]);
          }
        }
      }
      function _elementsEqual(a0, a1) {
        let i, ilen, v0, v1;
        if (!a0 || !a1 || a0.length !== a1.length) {
          return false;
        }
        for (i = 0, ilen = a0.length; i < ilen; ++i) {
          v0 = a0[i];
          v1 = a1[i];
          if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
            return false;
          }
        }
        return true;
      }
      function clone2(source) {
        if (isArray(source)) {
          return source.map(clone2);
        }
        if (isObject2(source)) {
          const target = Object.create(null);
          const keys = Object.keys(source);
          const klen = keys.length;
          let k = 0;
          for (; k < klen; ++k) {
            target[keys[k]] = clone2(source[keys[k]]);
          }
          return target;
        }
        return source;
      }
      function isValidKey(key) {
        return ["__proto__", "prototype", "constructor"].indexOf(key) === -1;
      }
      function _merger(key, target, source, options2) {
        if (!isValidKey(key)) {
          return;
        }
        const tval = target[key];
        const sval = source[key];
        if (isObject2(tval) && isObject2(sval)) {
          merge(tval, sval, options2);
        } else {
          target[key] = clone2(sval);
        }
      }
      function merge(target, source, options2) {
        const sources = isArray(source) ? source : [source];
        const ilen = sources.length;
        if (!isObject2(target)) {
          return target;
        }
        options2 = options2 || {};
        const merger = options2.merger || _merger;
        for (let i = 0; i < ilen; ++i) {
          source = sources[i];
          if (!isObject2(source)) {
            continue;
          }
          const keys = Object.keys(source);
          for (let k = 0, klen = keys.length; k < klen; ++k) {
            merger(keys[k], target, source, options2);
          }
        }
        return target;
      }
      function mergeIf(target, source) {
        return merge(target, source, { merger: _mergerIf });
      }
      function _mergerIf(key, target, source) {
        if (!isValidKey(key)) {
          return;
        }
        const tval = target[key];
        const sval = source[key];
        if (isObject2(tval) && isObject2(sval)) {
          mergeIf(tval, sval);
        } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
          target[key] = clone2(sval);
        }
      }
      function _deprecated(scope, value, previous, current) {
        if (value !== void 0) {
          console.warn(scope + ': "' + previous + '" is deprecated. Please use "' + current + '" instead');
        }
      }
      const emptyString = "";
      const dot = ".";
      function indexOfDotOrLength(key, start2) {
        const idx = key.indexOf(dot, start2);
        return idx === -1 ? key.length : idx;
      }
      function resolveObjectKey(obj, key) {
        if (key === emptyString) {
          return obj;
        }
        let pos = 0;
        let idx = indexOfDotOrLength(key, pos);
        while (obj && idx > pos) {
          obj = obj[key.substr(pos, idx - pos)];
          pos = idx + 1;
          idx = indexOfDotOrLength(key, pos);
        }
        return obj;
      }
      function _capitalize(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
      }
      const defined = (value) => typeof value !== "undefined";
      const isFunction = (value) => typeof value === "function";
      const setsEqual = (a, b) => {
        if (a.size !== b.size) {
          return false;
        }
        for (const item of a) {
          if (!b.has(item)) {
            return false;
          }
        }
        return true;
      };
      const overrides = Object.create(null);
      const descriptors = Object.create(null);
      function getScope$1(node, key) {
        if (!key) {
          return node;
        }
        const keys = key.split(".");
        for (let i = 0, n = keys.length; i < n; ++i) {
          const k = keys[i];
          node = node[k] || (node[k] = Object.create(null));
        }
        return node;
      }
      function set2(root, scope, values) {
        if (typeof scope === "string") {
          return merge(getScope$1(root, scope), values);
        }
        return merge(getScope$1(root, ""), scope);
      }
      class Defaults {
        constructor(_descriptors2) {
          this.animation = void 0;
          this.backgroundColor = "rgba(0,0,0,0.1)";
          this.borderColor = "rgba(0,0,0,0.1)";
          this.color = "#666";
          this.datasets = {};
          this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();
          this.elements = {};
          this.events = [
            "mousemove",
            "mouseout",
            "click",
            "touchstart",
            "touchmove"
          ];
          this.font = {
            family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
            size: 12,
            style: "normal",
            lineHeight: 1.2,
            weight: null
          };
          this.hover = {};
          this.hoverBackgroundColor = (ctx, options2) => getHoverColor(options2.backgroundColor);
          this.hoverBorderColor = (ctx, options2) => getHoverColor(options2.borderColor);
          this.hoverColor = (ctx, options2) => getHoverColor(options2.color);
          this.indexAxis = "x";
          this.interaction = {
            mode: "nearest",
            intersect: true
          };
          this.maintainAspectRatio = true;
          this.onHover = null;
          this.onClick = null;
          this.parsing = true;
          this.plugins = {};
          this.responsive = true;
          this.scale = void 0;
          this.scales = {};
          this.showLine = true;
          this.describe(_descriptors2);
        }
        set(scope, values) {
          return set2(this, scope, values);
        }
        get(scope) {
          return getScope$1(this, scope);
        }
        describe(scope, values) {
          return set2(descriptors, scope, values);
        }
        override(scope, values) {
          return set2(overrides, scope, values);
        }
        route(scope, name2, targetScope, targetName) {
          const scopeObject = getScope$1(this, scope);
          const targetScopeObject = getScope$1(this, targetScope);
          const privateName = "_" + name2;
          Object.defineProperties(scopeObject, {
            [privateName]: {
              value: scopeObject[name2],
              writable: true
            },
            [name2]: {
              enumerable: true,
              get() {
                const local = this[privateName];
                const target = targetScopeObject[targetName];
                if (isObject2(local)) {
                  return Object.assign({}, target, local);
                }
                return valueOrDefault(local, target);
              },
              set(value) {
                this[privateName] = value;
              }
            }
          });
        }
      }
      var defaults = new Defaults({
        _scriptable: (name2) => !name2.startsWith("on"),
        _indexable: (name2) => name2 !== "events",
        hover: {
          _fallback: "interaction"
        },
        interaction: {
          _scriptable: false,
          _indexable: false
        }
      });
      const PI = Math.PI;
      const TAU = 2 * PI;
      const PITAU = TAU + PI;
      const INFINITY = Number.POSITIVE_INFINITY;
      const RAD_PER_DEG = PI / 180;
      const HALF_PI = PI / 2;
      const QUARTER_PI = PI / 4;
      const TWO_THIRDS_PI = PI * 2 / 3;
      const log10 = Math.log10;
      const sign = Math.sign;
      function niceNum(range) {
        const roundedRange = Math.round(range);
        range = almostEquals(range, roundedRange, range / 1e3) ? roundedRange : range;
        const niceRange = Math.pow(10, Math.floor(log10(range)));
        const fraction = range / niceRange;
        const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
        return niceFraction * niceRange;
      }
      function _factorize(value) {
        const result = [];
        const sqrt = Math.sqrt(value);
        let i;
        for (i = 1; i < sqrt; i++) {
          if (value % i === 0) {
            result.push(i);
            result.push(value / i);
          }
        }
        if (sqrt === (sqrt | 0)) {
          result.push(sqrt);
        }
        result.sort((a, b) => a - b).pop();
        return result;
      }
      function isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
      }
      function almostEquals(x, y, epsilon) {
        return Math.abs(x - y) < epsilon;
      }
      function almostWhole(x, epsilon) {
        const rounded = Math.round(x);
        return rounded - epsilon <= x && rounded + epsilon >= x;
      }
      function _setMinAndMaxByKey(array, target, property) {
        let i, ilen, value;
        for (i = 0, ilen = array.length; i < ilen; i++) {
          value = array[i][property];
          if (!isNaN(value)) {
            target.min = Math.min(target.min, value);
            target.max = Math.max(target.max, value);
          }
        }
      }
      function toRadians(degrees) {
        return degrees * (PI / 180);
      }
      function toDegrees(radians) {
        return radians * (180 / PI);
      }
      function _decimalPlaces(x) {
        if (!isNumberFinite(x)) {
          return;
        }
        let e = 1;
        let p = 0;
        while (Math.round(x * e) / e !== x) {
          e *= 10;
          p++;
        }
        return p;
      }
      function getAngleFromPoint(centrePoint, anglePoint) {
        const distanceFromXCenter = anglePoint.x - centrePoint.x;
        const distanceFromYCenter = anglePoint.y - centrePoint.y;
        const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
        let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
        if (angle < -0.5 * PI) {
          angle += TAU;
        }
        return {
          angle,
          distance: radialDistanceFromCenter
        };
      }
      function distanceBetweenPoints(pt1, pt2) {
        return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
      }
      function _angleDiff(a, b) {
        return (a - b + PITAU) % TAU - PI;
      }
      function _normalizeAngle(a) {
        return (a % TAU + TAU) % TAU;
      }
      function _angleBetween(angle, start2, end, sameAngleIsFullCircle) {
        const a = _normalizeAngle(angle);
        const s2 = _normalizeAngle(start2);
        const e = _normalizeAngle(end);
        const angleToStart = _normalizeAngle(s2 - a);
        const angleToEnd = _normalizeAngle(e - a);
        const startToAngle = _normalizeAngle(a - s2);
        const endToAngle = _normalizeAngle(a - e);
        return a === s2 || a === e || sameAngleIsFullCircle && s2 === e || angleToStart > angleToEnd && startToAngle < endToAngle;
      }
      function _limitValue(value, min, max) {
        return Math.max(min, Math.min(max, value));
      }
      function _int16Range(value) {
        return _limitValue(value, -32768, 32767);
      }
      function toFontString(font) {
        if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
          return null;
        }
        return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
      }
      function _measureText(ctx, data, gc, longest, string) {
        let textWidth = data[string];
        if (!textWidth) {
          textWidth = data[string] = ctx.measureText(string).width;
          gc.push(string);
        }
        if (textWidth > longest) {
          longest = textWidth;
        }
        return longest;
      }
      function _longestText(ctx, font, arrayOfThings, cache) {
        cache = cache || {};
        let data = cache.data = cache.data || {};
        let gc = cache.garbageCollect = cache.garbageCollect || [];
        if (cache.font !== font) {
          data = cache.data = {};
          gc = cache.garbageCollect = [];
          cache.font = font;
        }
        ctx.save();
        ctx.font = font;
        let longest = 0;
        const ilen = arrayOfThings.length;
        let i, j, jlen, thing, nestedThing;
        for (i = 0; i < ilen; i++) {
          thing = arrayOfThings[i];
          if (thing !== void 0 && thing !== null && isArray(thing) !== true) {
            longest = _measureText(ctx, data, gc, longest, thing);
          } else if (isArray(thing)) {
            for (j = 0, jlen = thing.length; j < jlen; j++) {
              nestedThing = thing[j];
              if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {
                longest = _measureText(ctx, data, gc, longest, nestedThing);
              }
            }
          }
        }
        ctx.restore();
        const gcLen = gc.length / 2;
        if (gcLen > arrayOfThings.length) {
          for (i = 0; i < gcLen; i++) {
            delete data[gc[i]];
          }
          gc.splice(0, gcLen);
        }
        return longest;
      }
      function _alignPixel(chart, pixel, width) {
        const devicePixelRatio = chart.currentDevicePixelRatio;
        const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
        return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
      }
      function clearCanvas(canvas, ctx) {
        ctx = ctx || canvas.getContext("2d");
        ctx.save();
        ctx.resetTransform();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
      }
      function drawPoint(ctx, options2, x, y) {
        let type, xOffset, yOffset, size, cornerRadius;
        const style = options2.pointStyle;
        const rotation = options2.rotation;
        const radius = options2.radius;
        let rad = (rotation || 0) * RAD_PER_DEG;
        if (style && typeof style === "object") {
          type = style.toString();
          if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rad);
            ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
            ctx.restore();
            return;
          }
        }
        if (isNaN(radius) || radius <= 0) {
          return;
        }
        ctx.beginPath();
        switch (style) {
          default:
            ctx.arc(x, y, radius, 0, TAU);
            ctx.closePath();
            break;
          case "triangle":
            ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
            rad += TWO_THIRDS_PI;
            ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
            rad += TWO_THIRDS_PI;
            ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
            ctx.closePath();
            break;
          case "rectRounded":
            cornerRadius = radius * 0.516;
            size = radius - cornerRadius;
            xOffset = Math.cos(rad + QUARTER_PI) * size;
            yOffset = Math.sin(rad + QUARTER_PI) * size;
            ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
            ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
            ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
            ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
            ctx.closePath();
            break;
          case "rect":
            if (!rotation) {
              size = Math.SQRT1_2 * radius;
              ctx.rect(x - size, y - size, 2 * size, 2 * size);
              break;
            }
            rad += QUARTER_PI;
          case "rectRot":
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + yOffset, y - xOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            ctx.closePath();
            break;
          case "crossRot":
            rad += QUARTER_PI;
          case "cross":
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.moveTo(x + yOffset, y - xOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            break;
          case "star":
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.moveTo(x + yOffset, y - xOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            rad += QUARTER_PI;
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            ctx.moveTo(x + yOffset, y - xOffset);
            ctx.lineTo(x - yOffset, y + xOffset);
            break;
          case "line":
            xOffset = Math.cos(rad) * radius;
            yOffset = Math.sin(rad) * radius;
            ctx.moveTo(x - xOffset, y - yOffset);
            ctx.lineTo(x + xOffset, y + yOffset);
            break;
          case "dash":
            ctx.moveTo(x, y);
            ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
            break;
        }
        ctx.fill();
        if (options2.borderWidth > 0) {
          ctx.stroke();
        }
      }
      function _isPointInArea(point, area, margin) {
        margin = margin || 0.5;
        return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
      }
      function clipArea(ctx, area) {
        ctx.save();
        ctx.beginPath();
        ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
        ctx.clip();
      }
      function unclipArea(ctx) {
        ctx.restore();
      }
      function _steppedLineTo(ctx, previous, target, flip, mode) {
        if (!previous) {
          return ctx.lineTo(target.x, target.y);
        }
        if (mode === "middle") {
          const midpoint = (previous.x + target.x) / 2;
          ctx.lineTo(midpoint, previous.y);
          ctx.lineTo(midpoint, target.y);
        } else if (mode === "after" !== !!flip) {
          ctx.lineTo(previous.x, target.y);
        } else {
          ctx.lineTo(target.x, previous.y);
        }
        ctx.lineTo(target.x, target.y);
      }
      function _bezierCurveTo(ctx, previous, target, flip) {
        if (!previous) {
          return ctx.lineTo(target.x, target.y);
        }
        ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
      }
      function renderText(ctx, text, x, y, font, opts = {}) {
        const lines = isArray(text) ? text : [text];
        const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
        let i, line;
        ctx.save();
        ctx.font = font.string;
        setRenderOpts(ctx, opts);
        for (i = 0; i < lines.length; ++i) {
          line = lines[i];
          if (stroke) {
            if (opts.strokeColor) {
              ctx.strokeStyle = opts.strokeColor;
            }
            if (!isNullOrUndef(opts.strokeWidth)) {
              ctx.lineWidth = opts.strokeWidth;
            }
            ctx.strokeText(line, x, y, opts.maxWidth);
          }
          ctx.fillText(line, x, y, opts.maxWidth);
          decorateText(ctx, x, y, line, opts);
          y += font.lineHeight;
        }
        ctx.restore();
      }
      function setRenderOpts(ctx, opts) {
        if (opts.translation) {
          ctx.translate(opts.translation[0], opts.translation[1]);
        }
        if (!isNullOrUndef(opts.rotation)) {
          ctx.rotate(opts.rotation);
        }
        if (opts.color) {
          ctx.fillStyle = opts.color;
        }
        if (opts.textAlign) {
          ctx.textAlign = opts.textAlign;
        }
        if (opts.textBaseline) {
          ctx.textBaseline = opts.textBaseline;
        }
      }
      function decorateText(ctx, x, y, line, opts) {
        if (opts.strikethrough || opts.underline) {
          const metrics = ctx.measureText(line);
          const left = x - metrics.actualBoundingBoxLeft;
          const right = x + metrics.actualBoundingBoxRight;
          const top = y - metrics.actualBoundingBoxAscent;
          const bottom = y + metrics.actualBoundingBoxDescent;
          const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
          ctx.strokeStyle = ctx.fillStyle;
          ctx.beginPath();
          ctx.lineWidth = opts.decorationWidth || 2;
          ctx.moveTo(left, yDecoration);
          ctx.lineTo(right, yDecoration);
          ctx.stroke();
        }
      }
      function addRoundedRectPath(ctx, rect) {
        const { x, y, w, h, radius } = rect;
        ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);
        ctx.lineTo(x, y + h - radius.bottomLeft);
        ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
        ctx.lineTo(x + w - radius.bottomRight, y + h);
        ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
        ctx.lineTo(x + w, y + radius.topRight);
        ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
        ctx.lineTo(x + radius.topLeft, y);
      }
      function _lookup(table, value, cmp) {
        cmp = cmp || ((index2) => table[index2] < value);
        let hi = table.length - 1;
        let lo = 0;
        let mid;
        while (hi - lo > 1) {
          mid = lo + hi >> 1;
          if (cmp(mid)) {
            lo = mid;
          } else {
            hi = mid;
          }
        }
        return { lo, hi };
      }
      const _lookupByKey = (table, key, value) => _lookup(table, value, (index2) => table[index2][key] < value);
      const _rlookupByKey = (table, key, value) => _lookup(table, value, (index2) => table[index2][key] >= value);
      function _filterBetween(values, min, max) {
        let start2 = 0;
        let end = values.length;
        while (start2 < end && values[start2] < min) {
          start2++;
        }
        while (end > start2 && values[end - 1] > max) {
          end--;
        }
        return start2 > 0 || end < values.length ? values.slice(start2, end) : values;
      }
      const arrayEvents = ["push", "pop", "shift", "splice", "unshift"];
      function listenArrayEvents(array, listener) {
        if (array._chartjs) {
          array._chartjs.listeners.push(listener);
          return;
        }
        Object.defineProperty(array, "_chartjs", {
          configurable: true,
          enumerable: false,
          value: {
            listeners: [listener]
          }
        });
        arrayEvents.forEach((key) => {
          const method = "_onData" + _capitalize(key);
          const base2 = array[key];
          Object.defineProperty(array, key, {
            configurable: true,
            enumerable: false,
            value(...args) {
              const res = base2.apply(this, args);
              array._chartjs.listeners.forEach((object) => {
                if (typeof object[method] === "function") {
                  object[method](...args);
                }
              });
              return res;
            }
          });
        });
      }
      function unlistenArrayEvents(array, listener) {
        const stub = array._chartjs;
        if (!stub) {
          return;
        }
        const listeners = stub.listeners;
        const index2 = listeners.indexOf(listener);
        if (index2 !== -1) {
          listeners.splice(index2, 1);
        }
        if (listeners.length > 0) {
          return;
        }
        arrayEvents.forEach((key) => {
          delete array[key];
        });
        delete array._chartjs;
      }
      function _arrayUnique(items) {
        const set3 = new Set();
        let i, ilen;
        for (i = 0, ilen = items.length; i < ilen; ++i) {
          set3.add(items[i]);
        }
        if (set3.size === ilen) {
          return items;
        }
        return Array.from(set3);
      }
      function _isDomSupported() {
        return typeof window !== "undefined" && typeof document !== "undefined";
      }
      function _getParentNode(domNode) {
        let parent2 = domNode.parentNode;
        if (parent2 && parent2.toString() === "[object ShadowRoot]") {
          parent2 = parent2.host;
        }
        return parent2;
      }
      function parseMaxStyle(styleValue, node, parentProperty) {
        let valueInPixels;
        if (typeof styleValue === "string") {
          valueInPixels = parseInt(styleValue, 10);
          if (styleValue.indexOf("%") !== -1) {
            valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
          }
        } else {
          valueInPixels = styleValue;
        }
        return valueInPixels;
      }
      const getComputedStyle = (element) => window.getComputedStyle(element, null);
      function getStyle(el, property) {
        return getComputedStyle(el).getPropertyValue(property);
      }
      const positions = ["top", "right", "bottom", "left"];
      function getPositionedStyle(styles, style, suffix) {
        const result = {};
        suffix = suffix ? "-" + suffix : "";
        for (let i = 0; i < 4; i++) {
          const pos = positions[i];
          result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
        }
        result.width = result.left + result.right;
        result.height = result.top + result.bottom;
        return result;
      }
      const useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
      function getCanvasPosition(evt, canvas) {
        const e = evt.native || evt;
        const touches = e.touches;
        const source = touches && touches.length ? touches[0] : e;
        const { offsetX, offsetY } = source;
        let box = false;
        let x, y;
        if (useOffsetPos(offsetX, offsetY, e.target)) {
          x = offsetX;
          y = offsetY;
        } else {
          const rect = canvas.getBoundingClientRect();
          x = source.clientX - rect.left;
          y = source.clientY - rect.top;
          box = true;
        }
        return { x, y, box };
      }
      function getRelativePosition$1(evt, chart) {
        const { canvas, currentDevicePixelRatio } = chart;
        const style = getComputedStyle(canvas);
        const borderBox = style.boxSizing === "border-box";
        const paddings = getPositionedStyle(style, "padding");
        const borders = getPositionedStyle(style, "border", "width");
        const { x, y, box } = getCanvasPosition(evt, canvas);
        const xOffset = paddings.left + (box && borders.left);
        const yOffset = paddings.top + (box && borders.top);
        let { width, height } = chart;
        if (borderBox) {
          width -= paddings.width + borders.width;
          height -= paddings.height + borders.height;
        }
        return {
          x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
          y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
        };
      }
      function getContainerSize(canvas, width, height) {
        let maxWidth, maxHeight;
        if (width === void 0 || height === void 0) {
          const container = _getParentNode(canvas);
          if (!container) {
            width = canvas.clientWidth;
            height = canvas.clientHeight;
          } else {
            const rect = container.getBoundingClientRect();
            const containerStyle = getComputedStyle(container);
            const containerBorder = getPositionedStyle(containerStyle, "border", "width");
            const containerPadding = getPositionedStyle(containerStyle, "padding");
            width = rect.width - containerPadding.width - containerBorder.width;
            height = rect.height - containerPadding.height - containerBorder.height;
            maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
            maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
          }
        }
        return {
          width,
          height,
          maxWidth: maxWidth || INFINITY,
          maxHeight: maxHeight || INFINITY
        };
      }
      const round1 = (v) => Math.round(v * 10) / 10;
      function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
        const style = getComputedStyle(canvas);
        const margins = getPositionedStyle(style, "margin");
        const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
        const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
        const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
        let { width, height } = containerSize;
        if (style.boxSizing === "content-box") {
          const borders = getPositionedStyle(style, "border", "width");
          const paddings = getPositionedStyle(style, "padding");
          width -= paddings.width + borders.width;
          height -= paddings.height + borders.height;
        }
        width = Math.max(0, width - margins.width);
        height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);
        width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
        height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
        if (width && !height) {
          height = round1(width / 2);
        }
        return {
          width,
          height
        };
      }
      function retinaScale(chart, forceRatio, forceStyle) {
        const pixelRatio = forceRatio || 1;
        const deviceHeight = Math.floor(chart.height * pixelRatio);
        const deviceWidth = Math.floor(chart.width * pixelRatio);
        chart.height = deviceHeight / pixelRatio;
        chart.width = deviceWidth / pixelRatio;
        const canvas = chart.canvas;
        if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
          canvas.style.height = `${chart.height}px`;
          canvas.style.width = `${chart.width}px`;
        }
        if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
          chart.currentDevicePixelRatio = pixelRatio;
          canvas.height = deviceHeight;
          canvas.width = deviceWidth;
          chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
          return true;
        }
        return false;
      }
      const supportsEventListenerOptions = function() {
        let passiveSupported = false;
        try {
          const options2 = {
            get passive() {
              passiveSupported = true;
              return false;
            }
          };
          window.addEventListener("test", null, options2);
          window.removeEventListener("test", null, options2);
        } catch (e) {
        }
        return passiveSupported;
      }();
      function readUsedSize(element, property) {
        const value = getStyle(element, property);
        const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
        return matches ? +matches[1] : void 0;
      }
      function getRelativePosition(e, chart) {
        if ("native" in e) {
          return {
            x: e.x,
            y: e.y
          };
        }
        return getRelativePosition$1(e, chart);
      }
      function evaluateAllVisibleItems(chart, handler2) {
        const metasets = chart.getSortedVisibleDatasetMetas();
        let index2, data, element;
        for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
          ({ index: index2, data } = metasets[i]);
          for (let j = 0, jlen = data.length; j < jlen; ++j) {
            element = data[j];
            if (!element.skip) {
              handler2(element, index2, j);
            }
          }
        }
      }
      function binarySearch(metaset, axis, value, intersect) {
        const { controller, data, _sorted } = metaset;
        const iScale = controller._cachedMeta.iScale;
        if (iScale && axis === iScale.axis && _sorted && data.length) {
          const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
          if (!intersect) {
            return lookupMethod(data, axis, value);
          } else if (controller._sharedOptions) {
            const el = data[0];
            const range = typeof el.getRange === "function" && el.getRange(axis);
            if (range) {
              const start2 = lookupMethod(data, axis, value - range);
              const end = lookupMethod(data, axis, value + range);
              return { lo: start2.lo, hi: end.hi };
            }
          }
        }
        return { lo: 0, hi: data.length - 1 };
      }
      function optimizedEvaluateItems(chart, axis, position, handler2, intersect) {
        const metasets = chart.getSortedVisibleDatasetMetas();
        const value = position[axis];
        for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
          const { index: index2, data } = metasets[i];
          const { lo, hi } = binarySearch(metasets[i], axis, value, intersect);
          for (let j = lo; j <= hi; ++j) {
            const element = data[j];
            if (!element.skip) {
              handler2(element, index2, j);
            }
          }
        }
      }
      function getDistanceMetricForAxis(axis) {
        const useX = axis.indexOf("x") !== -1;
        const useY = axis.indexOf("y") !== -1;
        return function(pt1, pt2) {
          const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
          const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
          return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
        };
      }
      function getIntersectItems(chart, position, axis, useFinalPosition) {
        const items = [];
        if (!_isPointInArea(position, chart.chartArea, chart._minPadding)) {
          return items;
        }
        const evaluationFunc = function(element, datasetIndex, index2) {
          if (element.inRange(position.x, position.y, useFinalPosition)) {
            items.push({ element, datasetIndex, index: index2 });
          }
        };
        optimizedEvaluateItems(chart, axis, position, evaluationFunc, true);
        return items;
      }
      function getNearestItems(chart, position, axis, intersect, useFinalPosition) {
        const distanceMetric = getDistanceMetricForAxis(axis);
        let minDistance = Number.POSITIVE_INFINITY;
        let items = [];
        if (!_isPointInArea(position, chart.chartArea, chart._minPadding)) {
          return items;
        }
        const evaluationFunc = function(element, datasetIndex, index2) {
          if (intersect && !element.inRange(position.x, position.y, useFinalPosition)) {
            return;
          }
          const center = element.getCenterPoint(useFinalPosition);
          if (!_isPointInArea(center, chart.chartArea, chart._minPadding) && !element.inRange(position.x, position.y, useFinalPosition)) {
            return;
          }
          const distance = distanceMetric(position, center);
          if (distance < minDistance) {
            items = [{ element, datasetIndex, index: index2 }];
            minDistance = distance;
          } else if (distance === minDistance) {
            items.push({ element, datasetIndex, index: index2 });
          }
        };
        optimizedEvaluateItems(chart, axis, position, evaluationFunc);
        return items;
      }
      function getAxisItems(chart, e, options2, useFinalPosition) {
        const position = getRelativePosition(e, chart);
        const items = [];
        const axis = options2.axis;
        const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
        let intersectsItem = false;
        evaluateAllVisibleItems(chart, (element, datasetIndex, index2) => {
          if (element[rangeMethod](position[axis], useFinalPosition)) {
            items.push({ element, datasetIndex, index: index2 });
          }
          if (element.inRange(position.x, position.y, useFinalPosition)) {
            intersectsItem = true;
          }
        });
        if (options2.intersect && !intersectsItem) {
          return [];
        }
        return items;
      }
      var Interaction = {
        modes: {
          index(chart, e, options2, useFinalPosition) {
            const position = getRelativePosition(e, chart);
            const axis = options2.axis || "x";
            const items = options2.intersect ? getIntersectItems(chart, position, axis, useFinalPosition) : getNearestItems(chart, position, axis, false, useFinalPosition);
            const elements2 = [];
            if (!items.length) {
              return [];
            }
            chart.getSortedVisibleDatasetMetas().forEach((meta) => {
              const index2 = items[0].index;
              const element = meta.data[index2];
              if (element && !element.skip) {
                elements2.push({ element, datasetIndex: meta.index, index: index2 });
              }
            });
            return elements2;
          },
          dataset(chart, e, options2, useFinalPosition) {
            const position = getRelativePosition(e, chart);
            const axis = options2.axis || "xy";
            let items = options2.intersect ? getIntersectItems(chart, position, axis, useFinalPosition) : getNearestItems(chart, position, axis, false, useFinalPosition);
            if (items.length > 0) {
              const datasetIndex = items[0].datasetIndex;
              const data = chart.getDatasetMeta(datasetIndex).data;
              items = [];
              for (let i = 0; i < data.length; ++i) {
                items.push({ element: data[i], datasetIndex, index: i });
              }
            }
            return items;
          },
          point(chart, e, options2, useFinalPosition) {
            const position = getRelativePosition(e, chart);
            const axis = options2.axis || "xy";
            return getIntersectItems(chart, position, axis, useFinalPosition);
          },
          nearest(chart, e, options2, useFinalPosition) {
            const position = getRelativePosition(e, chart);
            const axis = options2.axis || "xy";
            return getNearestItems(chart, position, axis, options2.intersect, useFinalPosition);
          },
          x(chart, e, options2, useFinalPosition) {
            options2.axis = "x";
            return getAxisItems(chart, e, options2, useFinalPosition);
          },
          y(chart, e, options2, useFinalPosition) {
            options2.axis = "y";
            return getAxisItems(chart, e, options2, useFinalPosition);
          }
        }
      };
      const LINE_HEIGHT = new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
      const FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);
      function toLineHeight(value, size) {
        const matches = ("" + value).match(LINE_HEIGHT);
        if (!matches || matches[1] === "normal") {
          return size * 1.2;
        }
        value = +matches[2];
        switch (matches[3]) {
          case "px":
            return value;
          case "%":
            value /= 100;
            break;
        }
        return size * value;
      }
      const numberOrZero$1 = (v) => +v || 0;
      function _readValueToProps(value, props) {
        const ret = {};
        const objProps = isObject2(props);
        const keys = objProps ? Object.keys(props) : props;
        const read = isObject2(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;
        for (const prop of keys) {
          ret[prop] = numberOrZero$1(read(prop));
        }
        return ret;
      }
      function toTRBL(value) {
        return _readValueToProps(value, { top: "y", right: "x", bottom: "y", left: "x" });
      }
      function toTRBLCorners(value) {
        return _readValueToProps(value, ["topLeft", "topRight", "bottomLeft", "bottomRight"]);
      }
      function toPadding(value) {
        const obj = toTRBL(value);
        obj.width = obj.left + obj.right;
        obj.height = obj.top + obj.bottom;
        return obj;
      }
      function toFont(options2, fallback) {
        options2 = options2 || {};
        fallback = fallback || defaults.font;
        let size = valueOrDefault(options2.size, fallback.size);
        if (typeof size === "string") {
          size = parseInt(size, 10);
        }
        let style = valueOrDefault(options2.style, fallback.style);
        if (style && !("" + style).match(FONT_STYLE)) {
          console.warn('Invalid font style specified: "' + style + '"');
          style = "";
        }
        const font = {
          family: valueOrDefault(options2.family, fallback.family),
          lineHeight: toLineHeight(valueOrDefault(options2.lineHeight, fallback.lineHeight), size),
          size,
          style,
          weight: valueOrDefault(options2.weight, fallback.weight),
          string: ""
        };
        font.string = toFontString(font);
        return font;
      }
      function resolve2(inputs, context, index2, info) {
        let cacheable = true;
        let i, ilen, value;
        for (i = 0, ilen = inputs.length; i < ilen; ++i) {
          value = inputs[i];
          if (value === void 0) {
            continue;
          }
          if (context !== void 0 && typeof value === "function") {
            value = value(context);
            cacheable = false;
          }
          if (index2 !== void 0 && isArray(value)) {
            value = value[index2 % value.length];
            cacheable = false;
          }
          if (value !== void 0) {
            if (info && !cacheable) {
              info.cacheable = false;
            }
            return value;
          }
        }
      }
      function _addGrace(minmax, grace) {
        const { min, max } = minmax;
        return {
          min: min - Math.abs(toDimension(grace, min)),
          max: max + toDimension(grace, max)
        };
      }
      const STATIC_POSITIONS = ["left", "top", "right", "bottom"];
      function filterByPosition(array, position) {
        return array.filter((v) => v.pos === position);
      }
      function filterDynamicPositionByAxis(array, axis) {
        return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);
      }
      function sortByWeight(array, reverse) {
        return array.sort((a, b) => {
          const v0 = reverse ? b : a;
          const v1 = reverse ? a : b;
          return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
        });
      }
      function wrapBoxes(boxes) {
        const layoutBoxes = [];
        let i, ilen, box, pos, stack, stackWeight;
        for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
          box = boxes[i];
          ({ position: pos, options: { stack, stackWeight = 1 } } = box);
          layoutBoxes.push({
            index: i,
            box,
            pos,
            horizontal: box.isHorizontal(),
            weight: box.weight,
            stack: stack && pos + stack,
            stackWeight
          });
        }
        return layoutBoxes;
      }
      function buildStacks(layouts2) {
        const stacks = {};
        for (const wrap of layouts2) {
          const { stack, pos, stackWeight } = wrap;
          if (!stack || !STATIC_POSITIONS.includes(pos)) {
            continue;
          }
          const _stack = stacks[stack] || (stacks[stack] = { count: 0, placed: 0, weight: 0, size: 0 });
          _stack.count++;
          _stack.weight += stackWeight;
        }
        return stacks;
      }
      function setLayoutDims(layouts2, params) {
        const stacks = buildStacks(layouts2);
        const { vBoxMaxWidth, hBoxMaxHeight } = params;
        let i, ilen, layout;
        for (i = 0, ilen = layouts2.length; i < ilen; ++i) {
          layout = layouts2[i];
          const { fullSize } = layout.box;
          const stack = stacks[layout.stack];
          const factor = stack && layout.stackWeight / stack.weight;
          if (layout.horizontal) {
            layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
            layout.height = hBoxMaxHeight;
          } else {
            layout.width = vBoxMaxWidth;
            layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
          }
        }
        return stacks;
      }
      function buildLayoutBoxes(boxes) {
        const layoutBoxes = wrapBoxes(boxes);
        const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);
        const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
        const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
        const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
        const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
        const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
        const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
        return {
          fullSize,
          leftAndTop: left.concat(top),
          rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
          chartArea: filterByPosition(layoutBoxes, "chartArea"),
          vertical: left.concat(right).concat(centerVertical),
          horizontal: top.concat(bottom).concat(centerHorizontal)
        };
      }
      function getCombinedMax(maxPadding, chartArea, a, b) {
        return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
      }
      function updateMaxPadding(maxPadding, boxPadding) {
        maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
        maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
        maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
        maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
      }
      function updateDims(chartArea, params, layout, stacks) {
        const { pos, box } = layout;
        const maxPadding = chartArea.maxPadding;
        if (!isObject2(pos)) {
          if (layout.size) {
            chartArea[pos] -= layout.size;
          }
          const stack = stacks[layout.stack] || { size: 0, count: 1 };
          stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
          layout.size = stack.size / stack.count;
          chartArea[pos] += layout.size;
        }
        if (box.getPadding) {
          updateMaxPadding(maxPadding, box.getPadding());
        }
        const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
        const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
        const widthChanged = newWidth !== chartArea.w;
        const heightChanged = newHeight !== chartArea.h;
        chartArea.w = newWidth;
        chartArea.h = newHeight;
        return layout.horizontal ? { same: widthChanged, other: heightChanged } : { same: heightChanged, other: widthChanged };
      }
      function handleMaxPadding(chartArea) {
        const maxPadding = chartArea.maxPadding;
        function updatePos(pos) {
          const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
          chartArea[pos] += change;
          return change;
        }
        chartArea.y += updatePos("top");
        chartArea.x += updatePos("left");
        updatePos("right");
        updatePos("bottom");
      }
      function getMargins(horizontal, chartArea) {
        const maxPadding = chartArea.maxPadding;
        function marginForPositions(positions2) {
          const margin = { left: 0, top: 0, right: 0, bottom: 0 };
          positions2.forEach((pos) => {
            margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
          });
          return margin;
        }
        return horizontal ? marginForPositions(["left", "right"]) : marginForPositions(["top", "bottom"]);
      }
      function fitBoxes(boxes, chartArea, params, stacks) {
        const refitBoxes = [];
        let i, ilen, layout, box, refit, changed;
        for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
          layout = boxes[i];
          box = layout.box;
          box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
          const { same, other } = updateDims(chartArea, params, layout, stacks);
          refit |= same && refitBoxes.length;
          changed = changed || other;
          if (!box.fullSize) {
            refitBoxes.push(layout);
          }
        }
        return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
      }
      function setBoxDims(box, left, top, width, height) {
        box.top = top;
        box.left = left;
        box.right = left + width;
        box.bottom = top + height;
        box.width = width;
        box.height = height;
      }
      function placeBoxes(boxes, chartArea, params, stacks) {
        const userPadding = params.padding;
        let { x, y } = chartArea;
        for (const layout of boxes) {
          const box = layout.box;
          const stack = stacks[layout.stack] || { count: 1, placed: 0, weight: 1 };
          const weight = layout.stackWeight / stack.weight || 1;
          if (layout.horizontal) {
            const width = chartArea.w * weight;
            const height = stack.size || box.height;
            if (defined(stack.start)) {
              y = stack.start;
            }
            if (box.fullSize) {
              setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);
            } else {
              setBoxDims(box, chartArea.left + stack.placed, y, width, height);
            }
            stack.start = y;
            stack.placed += width;
            y = box.bottom;
          } else {
            const height = chartArea.h * weight;
            const width = stack.size || box.width;
            if (defined(stack.start)) {
              x = stack.start;
            }
            if (box.fullSize) {
              setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);
            } else {
              setBoxDims(box, x, chartArea.top + stack.placed, width, height);
            }
            stack.start = x;
            stack.placed += height;
            x = box.right;
          }
        }
        chartArea.x = x;
        chartArea.y = y;
      }
      defaults.set("layout", {
        padding: {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        }
      });
      var layouts = {
        addBox(chart, item) {
          if (!chart.boxes) {
            chart.boxes = [];
          }
          item.fullSize = item.fullSize || false;
          item.position = item.position || "top";
          item.weight = item.weight || 0;
          item._layers = item._layers || function() {
            return [{
              z: 0,
              draw(chartArea) {
                item.draw(chartArea);
              }
            }];
          };
          chart.boxes.push(item);
        },
        removeBox(chart, layoutItem) {
          const index2 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
          if (index2 !== -1) {
            chart.boxes.splice(index2, 1);
          }
        },
        configure(chart, item, options2) {
          item.fullSize = options2.fullSize;
          item.position = options2.position;
          item.weight = options2.weight;
        },
        update(chart, width, height, minPadding) {
          if (!chart) {
            return;
          }
          const padding = toPadding(chart.options.layout.padding);
          const availableWidth = Math.max(width - padding.width, 0);
          const availableHeight = Math.max(height - padding.height, 0);
          const boxes = buildLayoutBoxes(chart.boxes);
          const verticalBoxes = boxes.vertical;
          const horizontalBoxes = boxes.horizontal;
          each2(chart.boxes, (box) => {
            if (typeof box.beforeLayout === "function") {
              box.beforeLayout();
            }
          });
          const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;
          const params = Object.freeze({
            outerWidth: width,
            outerHeight: height,
            padding,
            availableWidth,
            availableHeight,
            vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
            hBoxMaxHeight: availableHeight / 2
          });
          const maxPadding = Object.assign({}, padding);
          updateMaxPadding(maxPadding, toPadding(minPadding));
          const chartArea = Object.assign({
            maxPadding,
            w: availableWidth,
            h: availableHeight,
            x: padding.left,
            y: padding.top
          }, padding);
          const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
          fitBoxes(boxes.fullSize, chartArea, params, stacks);
          fitBoxes(verticalBoxes, chartArea, params, stacks);
          if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
            fitBoxes(verticalBoxes, chartArea, params, stacks);
          }
          handleMaxPadding(chartArea);
          placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
          chartArea.x += chartArea.w;
          chartArea.y += chartArea.h;
          placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
          chart.chartArea = {
            left: chartArea.left,
            top: chartArea.top,
            right: chartArea.left + chartArea.w,
            bottom: chartArea.top + chartArea.h,
            height: chartArea.h,
            width: chartArea.w
          };
          each2(boxes.chartArea, (layout) => {
            const box = layout.box;
            Object.assign(box, chart.chartArea);
            box.update(chartArea.w, chartArea.h);
          });
        }
      };
      function _createResolver(scopes, prefixes = [""], rootScopes = scopes, fallback, getTarget2 = () => scopes[0]) {
        if (!defined(fallback)) {
          fallback = _resolve("_fallback", scopes);
        }
        const cache = {
          [Symbol.toStringTag]: "Object",
          _cacheable: true,
          _scopes: scopes,
          _rootScopes: rootScopes,
          _fallback: fallback,
          _getTarget: getTarget2,
          override: (scope) => _createResolver([scope, ...scopes], prefixes, rootScopes, fallback)
        };
        return new Proxy(cache, {
          deleteProperty(target, prop) {
            delete target[prop];
            delete target._keys;
            delete scopes[0][prop];
            return true;
          },
          get(target, prop) {
            return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));
          },
          getOwnPropertyDescriptor(target, prop) {
            return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
          },
          getPrototypeOf() {
            return Reflect.getPrototypeOf(scopes[0]);
          },
          has(target, prop) {
            return getKeysFromAllScopes(target).includes(prop);
          },
          ownKeys(target) {
            return getKeysFromAllScopes(target);
          },
          set(target, prop, value) {
            const storage2 = target._storage || (target._storage = getTarget2());
            storage2[prop] = value;
            delete target[prop];
            delete target._keys;
            return true;
          }
        });
      }
      function _attachContext(proxy, context, subProxy, descriptorDefaults) {
        const cache = {
          _cacheable: false,
          _proxy: proxy,
          _context: context,
          _subProxy: subProxy,
          _stack: new Set(),
          _descriptors: _descriptors(proxy, descriptorDefaults),
          setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
          override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
        };
        return new Proxy(cache, {
          deleteProperty(target, prop) {
            delete target[prop];
            delete proxy[prop];
            return true;
          },
          get(target, prop, receiver) {
            return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));
          },
          getOwnPropertyDescriptor(target, prop) {
            return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? { enumerable: true, configurable: true } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
          },
          getPrototypeOf() {
            return Reflect.getPrototypeOf(proxy);
          },
          has(target, prop) {
            return Reflect.has(proxy, prop);
          },
          ownKeys() {
            return Reflect.ownKeys(proxy);
          },
          set(target, prop, value) {
            proxy[prop] = value;
            delete target[prop];
            return true;
          }
        });
      }
      function _descriptors(proxy, defaults2 = { scriptable: true, indexable: true }) {
        const { _scriptable = defaults2.scriptable, _indexable = defaults2.indexable, _allKeys = defaults2.allKeys } = proxy;
        return {
          allKeys: _allKeys,
          scriptable: _scriptable,
          indexable: _indexable,
          isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
          isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
        };
      }
      const readKey = (prefix, name2) => prefix ? prefix + _capitalize(name2) : name2;
      const needsSubResolver = (prop, value) => isObject2(value) && prop !== "adapters";
      function _cached(target, prop, resolve3) {
        let value = target[prop];
        if (defined(value)) {
          return value;
        }
        value = resolve3();
        if (defined(value)) {
          target[prop] = value;
        }
        return value;
      }
      function _resolveWithContext(target, prop, receiver) {
        const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
        let value = _proxy[prop];
        if (isFunction(value) && descriptors2.isScriptable(prop)) {
          value = _resolveScriptable(prop, value, target, receiver);
        }
        if (isArray(value) && value.length) {
          value = _resolveArray(prop, value, target, descriptors2.isIndexable);
        }
        if (needsSubResolver(prop, value)) {
          value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);
        }
        return value;
      }
      function _resolveScriptable(prop, value, target, receiver) {
        const { _proxy, _context, _subProxy, _stack } = target;
        if (_stack.has(prop)) {
          throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
        }
        _stack.add(prop);
        value = value(_context, _subProxy || receiver);
        _stack.delete(prop);
        if (isObject2(value)) {
          value = createSubResolver(_proxy._scopes, _proxy, prop, value);
        }
        return value;
      }
      function _resolveArray(prop, value, target, isIndexable) {
        const { _proxy, _context, _subProxy, _descriptors: descriptors2 } = target;
        if (defined(_context.index) && isIndexable(prop)) {
          value = value[_context.index % value.length];
        } else if (isObject2(value[0])) {
          const arr = value;
          const scopes = _proxy._scopes.filter((s2) => s2 !== arr);
          value = [];
          for (const item of arr) {
            const resolver = createSubResolver(scopes, _proxy, prop, item);
            value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));
          }
        }
        return value;
      }
      function resolveFallback(fallback, prop, value) {
        return isFunction(fallback) ? fallback(prop, value) : fallback;
      }
      const getScope = (key, parent2) => key === true ? parent2 : typeof key === "string" ? resolveObjectKey(parent2, key) : void 0;
      function addScopes(set3, parentScopes, key, parentFallback) {
        for (const parent2 of parentScopes) {
          const scope = getScope(key, parent2);
          if (scope) {
            set3.add(scope);
            const fallback = resolveFallback(scope._fallback, key, scope);
            if (defined(fallback) && fallback !== key && fallback !== parentFallback) {
              return fallback;
            }
          } else if (scope === false && defined(parentFallback) && key !== parentFallback) {
            return null;
          }
        }
        return false;
      }
      function createSubResolver(parentScopes, resolver, prop, value) {
        const rootScopes = resolver._rootScopes;
        const fallback = resolveFallback(resolver._fallback, prop, value);
        const allScopes = [...parentScopes, ...rootScopes];
        const set3 = new Set();
        set3.add(value);
        let key = addScopesFromKey(set3, allScopes, prop, fallback || prop);
        if (key === null) {
          return false;
        }
        if (defined(fallback) && fallback !== prop) {
          key = addScopesFromKey(set3, allScopes, fallback, key);
          if (key === null) {
            return false;
          }
        }
        return _createResolver(Array.from(set3), [""], rootScopes, fallback, () => subGetTarget(resolver, prop, value));
      }
      function addScopesFromKey(set3, allScopes, key, fallback) {
        while (key) {
          key = addScopes(set3, allScopes, key, fallback);
        }
        return key;
      }
      function subGetTarget(resolver, prop, value) {
        const parent2 = resolver._getTarget();
        if (!(prop in parent2)) {
          parent2[prop] = {};
        }
        const target = parent2[prop];
        if (isArray(target) && isObject2(value)) {
          return value;
        }
        return target;
      }
      function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
        let value;
        for (const prefix of prefixes) {
          value = _resolve(readKey(prefix, prop), scopes);
          if (defined(value)) {
            return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
          }
        }
      }
      function _resolve(key, scopes) {
        for (const scope of scopes) {
          if (!scope) {
            continue;
          }
          const value = scope[key];
          if (defined(value)) {
            return value;
          }
        }
      }
      function getKeysFromAllScopes(target) {
        let keys = target._keys;
        if (!keys) {
          keys = target._keys = resolveKeysFromAllScopes(target._scopes);
        }
        return keys;
      }
      function resolveKeysFromAllScopes(scopes) {
        const set3 = new Set();
        for (const scope of scopes) {
          for (const key of Object.keys(scope).filter((k) => !k.startsWith("_"))) {
            set3.add(key);
          }
        }
        return Array.from(set3);
      }
      const EPSILON = Number.EPSILON || 1e-14;
      const getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
      const getValueAxis = (indexAxis) => indexAxis === "x" ? "y" : "x";
      function splineCurve(firstPoint, middlePoint, afterPoint, t) {
        const previous = firstPoint.skip ? middlePoint : firstPoint;
        const current = middlePoint;
        const next = afterPoint.skip ? middlePoint : afterPoint;
        const d01 = distanceBetweenPoints(current, previous);
        const d12 = distanceBetweenPoints(next, current);
        let s01 = d01 / (d01 + d12);
        let s12 = d12 / (d01 + d12);
        s01 = isNaN(s01) ? 0 : s01;
        s12 = isNaN(s12) ? 0 : s12;
        const fa = t * s01;
        const fb = t * s12;
        return {
          previous: {
            x: current.x - fa * (next.x - previous.x),
            y: current.y - fa * (next.y - previous.y)
          },
          next: {
            x: current.x + fb * (next.x - previous.x),
            y: current.y + fb * (next.y - previous.y)
          }
        };
      }
      function monotoneAdjust(points, deltaK, mK) {
        const pointsLen = points.length;
        let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
        let pointAfter = getPoint(points, 0);
        for (let i = 0; i < pointsLen - 1; ++i) {
          pointCurrent = pointAfter;
          pointAfter = getPoint(points, i + 1);
          if (!pointCurrent || !pointAfter) {
            continue;
          }
          if (almostEquals(deltaK[i], 0, EPSILON)) {
            mK[i] = mK[i + 1] = 0;
            continue;
          }
          alphaK = mK[i] / deltaK[i];
          betaK = mK[i + 1] / deltaK[i];
          squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
          if (squaredMagnitude <= 9) {
            continue;
          }
          tauK = 3 / Math.sqrt(squaredMagnitude);
          mK[i] = alphaK * tauK * deltaK[i];
          mK[i + 1] = betaK * tauK * deltaK[i];
        }
      }
      function monotoneCompute(points, mK, indexAxis = "x") {
        const valueAxis = getValueAxis(indexAxis);
        const pointsLen = points.length;
        let delta, pointBefore, pointCurrent;
        let pointAfter = getPoint(points, 0);
        for (let i = 0; i < pointsLen; ++i) {
          pointBefore = pointCurrent;
          pointCurrent = pointAfter;
          pointAfter = getPoint(points, i + 1);
          if (!pointCurrent) {
            continue;
          }
          const iPixel = pointCurrent[indexAxis];
          const vPixel = pointCurrent[valueAxis];
          if (pointBefore) {
            delta = (iPixel - pointBefore[indexAxis]) / 3;
            pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
            pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
          }
          if (pointAfter) {
            delta = (pointAfter[indexAxis] - iPixel) / 3;
            pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
            pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
          }
        }
      }
      function splineCurveMonotone(points, indexAxis = "x") {
        const valueAxis = getValueAxis(indexAxis);
        const pointsLen = points.length;
        const deltaK = Array(pointsLen).fill(0);
        const mK = Array(pointsLen);
        let i, pointBefore, pointCurrent;
        let pointAfter = getPoint(points, 0);
        for (i = 0; i < pointsLen; ++i) {
          pointBefore = pointCurrent;
          pointCurrent = pointAfter;
          pointAfter = getPoint(points, i + 1);
          if (!pointCurrent) {
            continue;
          }
          if (pointAfter) {
            const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
            deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
          }
          mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
        }
        monotoneAdjust(points, deltaK, mK);
        monotoneCompute(points, mK, indexAxis);
      }
      function capControlPoint(pt, min, max) {
        return Math.max(Math.min(pt, max), min);
      }
      function capBezierPoints(points, area) {
        let i, ilen, point, inArea, inAreaPrev;
        let inAreaNext = _isPointInArea(points[0], area);
        for (i = 0, ilen = points.length; i < ilen; ++i) {
          inAreaPrev = inArea;
          inArea = inAreaNext;
          inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
          if (!inArea) {
            continue;
          }
          point = points[i];
          if (inAreaPrev) {
            point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
            point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
          }
          if (inAreaNext) {
            point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
            point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
          }
        }
      }
      function _updateBezierControlPoints(points, options2, area, loop, indexAxis) {
        let i, ilen, point, controlPoints;
        if (options2.spanGaps) {
          points = points.filter((pt) => !pt.skip);
        }
        if (options2.cubicInterpolationMode === "monotone") {
          splineCurveMonotone(points, indexAxis);
        } else {
          let prev = loop ? points[points.length - 1] : points[0];
          for (i = 0, ilen = points.length; i < ilen; ++i) {
            point = points[i];
            controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options2.tension);
            point.cp1x = controlPoints.previous.x;
            point.cp1y = controlPoints.previous.y;
            point.cp2x = controlPoints.next.x;
            point.cp2y = controlPoints.next.y;
            prev = point;
          }
        }
        if (options2.capBezierPoints) {
          capBezierPoints(points, area);
        }
      }
      const atEdge = (t) => t === 0 || t === 1;
      const elasticIn = (t, s2, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s2) * TAU / p));
      const elasticOut = (t, s2, p) => Math.pow(2, -10 * t) * Math.sin((t - s2) * TAU / p) + 1;
      const effects = {
        linear: (t) => t,
        easeInQuad: (t) => t * t,
        easeOutQuad: (t) => -t * (t - 2),
        easeInOutQuad: (t) => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
        easeInCubic: (t) => t * t * t,
        easeOutCubic: (t) => (t -= 1) * t * t + 1,
        easeInOutCubic: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
        easeInQuart: (t) => t * t * t * t,
        easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
        easeInOutQuart: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),
        easeInQuint: (t) => t * t * t * t * t,
        easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
        easeInOutQuint: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),
        easeInSine: (t) => -Math.cos(t * HALF_PI) + 1,
        easeOutSine: (t) => Math.sin(t * HALF_PI),
        easeInOutSine: (t) => -0.5 * (Math.cos(PI * t) - 1),
        easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
        easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
        easeInOutExpo: (t) => atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
        easeInCirc: (t) => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
        easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
        easeInOutCirc: (t) => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
        easeInElastic: (t) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),
        easeOutElastic: (t) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),
        easeInOutElastic(t) {
          const s2 = 0.1125;
          const p = 0.45;
          return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s2, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s2, p);
        },
        easeInBack(t) {
          const s2 = 1.70158;
          return t * t * ((s2 + 1) * t - s2);
        },
        easeOutBack(t) {
          const s2 = 1.70158;
          return (t -= 1) * t * ((s2 + 1) * t + s2) + 1;
        },
        easeInOutBack(t) {
          let s2 = 1.70158;
          if ((t /= 0.5) < 1) {
            return 0.5 * (t * t * (((s2 *= 1.525) + 1) * t - s2));
          }
          return 0.5 * ((t -= 2) * t * (((s2 *= 1.525) + 1) * t + s2) + 2);
        },
        easeInBounce: (t) => 1 - effects.easeOutBounce(1 - t),
        easeOutBounce(t) {
          const m = 7.5625;
          const d2 = 2.75;
          if (t < 1 / d2) {
            return m * t * t;
          }
          if (t < 2 / d2) {
            return m * (t -= 1.5 / d2) * t + 0.75;
          }
          if (t < 2.5 / d2) {
            return m * (t -= 2.25 / d2) * t + 0.9375;
          }
          return m * (t -= 2.625 / d2) * t + 0.984375;
        },
        easeInOutBounce: (t) => t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5
      };
      function _pointInLine(p1, p2, t, mode) {
        return {
          x: p1.x + t * (p2.x - p1.x),
          y: p1.y + t * (p2.y - p1.y)
        };
      }
      function _steppedInterpolation(p1, p2, t, mode) {
        return {
          x: p1.x + t * (p2.x - p1.x),
          y: mode === "middle" ? t < 0.5 ? p1.y : p2.y : mode === "after" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
        };
      }
      function _bezierInterpolation(p1, p2, t, mode) {
        const cp1 = { x: p1.cp2x, y: p1.cp2y };
        const cp2 = { x: p2.cp1x, y: p2.cp1y };
        const a = _pointInLine(p1, cp1, t);
        const b = _pointInLine(cp1, cp2, t);
        const c = _pointInLine(cp2, p2, t);
        const d2 = _pointInLine(a, b, t);
        const e = _pointInLine(b, c, t);
        return _pointInLine(d2, e, t);
      }
      const intlCache = new Map();
      function getNumberFormat(locale, options2) {
        options2 = options2 || {};
        const cacheKey = locale + JSON.stringify(options2);
        let formatter = intlCache.get(cacheKey);
        if (!formatter) {
          formatter = new Intl.NumberFormat(locale, options2);
          intlCache.set(cacheKey, formatter);
        }
        return formatter;
      }
      function formatNumber(num, locale, options2) {
        return getNumberFormat(locale, options2).format(num);
      }
      const getRightToLeftAdapter = function(rectX, width) {
        return {
          x(x) {
            return rectX + rectX + width - x;
          },
          setWidth(w) {
            width = w;
          },
          textAlign(align) {
            if (align === "center") {
              return align;
            }
            return align === "right" ? "left" : "right";
          },
          xPlus(x, value) {
            return x - value;
          },
          leftForLtr(x, itemWidth) {
            return x - itemWidth;
          }
        };
      };
      const getLeftToRightAdapter = function() {
        return {
          x(x) {
            return x;
          },
          setWidth(w) {
          },
          textAlign(align) {
            return align;
          },
          xPlus(x, value) {
            return x + value;
          },
          leftForLtr(x, _itemWidth) {
            return x;
          }
        };
      };
      function getRtlAdapter(rtl, rectX, width) {
        return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
      }
      function overrideTextDirection(ctx, direction) {
        let style, original;
        if (direction === "ltr" || direction === "rtl") {
          style = ctx.canvas.style;
          original = [
            style.getPropertyValue("direction"),
            style.getPropertyPriority("direction")
          ];
          style.setProperty("direction", direction, "important");
          ctx.prevTextDirection = original;
        }
      }
      function restoreTextDirection(ctx, original) {
        if (original !== void 0) {
          delete ctx.prevTextDirection;
          ctx.canvas.style.setProperty("direction", original[0], original[1]);
        }
      }
      function propertyFn(property) {
        if (property === "angle") {
          return {
            between: _angleBetween,
            compare: _angleDiff,
            normalize: _normalizeAngle
          };
        }
        return {
          between: (n, s2, e) => n >= Math.min(s2, e) && n <= Math.max(e, s2),
          compare: (a, b) => a - b,
          normalize: (x) => x
        };
      }
      function normalizeSegment({ start: start2, end, count, loop, style }) {
        return {
          start: start2 % count,
          end: end % count,
          loop: loop && (end - start2 + 1) % count === 0,
          style
        };
      }
      function getSegment(segment, points, bounds) {
        const { property, start: startBound, end: endBound } = bounds;
        const { between, normalize: normalize2 } = propertyFn(property);
        const count = points.length;
        let { start: start2, end, loop } = segment;
        let i, ilen;
        if (loop) {
          start2 += count;
          end += count;
          for (i = 0, ilen = count; i < ilen; ++i) {
            if (!between(normalize2(points[start2 % count][property]), startBound, endBound)) {
              break;
            }
            start2--;
            end--;
          }
          start2 %= count;
          end %= count;
        }
        if (end < start2) {
          end += count;
        }
        return { start: start2, end, loop, style: segment.style };
      }
      function _boundSegment(segment, points, bounds) {
        if (!bounds) {
          return [segment];
        }
        const { property, start: startBound, end: endBound } = bounds;
        const count = points.length;
        const { compare, between, normalize: normalize2 } = propertyFn(property);
        const { start: start2, end, loop, style } = getSegment(segment, points, bounds);
        const result = [];
        let inside = false;
        let subStart = null;
        let value, point, prevValue;
        const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
        const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
        const shouldStart = () => inside || startIsBefore();
        const shouldStop = () => !inside || endIsBefore();
        for (let i = start2, prev = start2; i <= end; ++i) {
          point = points[i % count];
          if (point.skip) {
            continue;
          }
          value = normalize2(point[property]);
          if (value === prevValue) {
            continue;
          }
          inside = between(value, startBound, endBound);
          if (subStart === null && shouldStart()) {
            subStart = compare(value, startBound) === 0 ? i : prev;
          }
          if (subStart !== null && shouldStop()) {
            result.push(normalizeSegment({ start: subStart, end: i, loop, count, style }));
            subStart = null;
          }
          prev = i;
          prevValue = value;
        }
        if (subStart !== null) {
          result.push(normalizeSegment({ start: subStart, end, loop, count, style }));
        }
        return result;
      }
      function _boundSegments(line, bounds) {
        const result = [];
        const segments = line.segments;
        for (let i = 0; i < segments.length; i++) {
          const sub = _boundSegment(segments[i], line.points, bounds);
          if (sub.length) {
            result.push(...sub);
          }
        }
        return result;
      }
      function findStartAndEnd(points, count, loop, spanGaps) {
        let start2 = 0;
        let end = count - 1;
        if (loop && !spanGaps) {
          while (start2 < count && !points[start2].skip) {
            start2++;
          }
        }
        while (start2 < count && points[start2].skip) {
          start2++;
        }
        start2 %= count;
        if (loop) {
          end += start2;
        }
        while (end > start2 && points[end % count].skip) {
          end--;
        }
        end %= count;
        return { start: start2, end };
      }
      function solidSegments(points, start2, max, loop) {
        const count = points.length;
        const result = [];
        let last = start2;
        let prev = points[start2];
        let end;
        for (end = start2 + 1; end <= max; ++end) {
          const cur = points[end % count];
          if (cur.skip || cur.stop) {
            if (!prev.skip) {
              loop = false;
              result.push({ start: start2 % count, end: (end - 1) % count, loop });
              start2 = last = cur.stop ? end : null;
            }
          } else {
            last = end;
            if (prev.skip) {
              start2 = end;
            }
          }
          prev = cur;
        }
        if (last !== null) {
          result.push({ start: start2 % count, end: last % count, loop });
        }
        return result;
      }
      function _computeSegments(line, segmentOptions) {
        const points = line.points;
        const spanGaps = line.options.spanGaps;
        const count = points.length;
        if (!count) {
          return [];
        }
        const loop = !!line._loop;
        const { start: start2, end } = findStartAndEnd(points, count, loop, spanGaps);
        if (spanGaps === true) {
          return splitByStyles(line, [{ start: start2, end, loop }], points, segmentOptions);
        }
        const max = end < start2 ? end + count : end;
        const completeLoop = !!line._fullLoop && start2 === 0 && end === count - 1;
        return splitByStyles(line, solidSegments(points, start2, max, completeLoop), points, segmentOptions);
      }
      function splitByStyles(line, segments, points, segmentOptions) {
        if (!segmentOptions || !segmentOptions.setContext || !points) {
          return segments;
        }
        return doSplitByStyles(line, segments, points, segmentOptions);
      }
      function doSplitByStyles(line, segments, points, segmentOptions) {
        const baseStyle = readStyle(line.options);
        const count = points.length;
        const result = [];
        let start2 = segments[0].start;
        let i = start2;
        for (const segment of segments) {
          let prevStyle = baseStyle;
          let prev = points[start2 % count];
          let style;
          for (i = start2 + 1; i <= segment.end; i++) {
            const pt = points[i % count];
            style = readStyle(segmentOptions.setContext({
              type: "segment",
              p0: prev,
              p1: pt,
              p0DataIndex: (i - 1) % count,
              p1DataIndex: i % count,
              datasetIndex: line._datasetIndex
            }));
            if (styleChanged(style, prevStyle)) {
              result.push({ start: start2, end: i - 1, loop: segment.loop, style: prevStyle });
              prevStyle = style;
              start2 = i - 1;
            }
            prev = pt;
            prevStyle = style;
          }
          if (start2 < i - 1) {
            result.push({ start: start2, end: i - 1, loop: segment.loop, style });
            start2 = i - 1;
          }
        }
        return result;
      }
      function readStyle(options2) {
        return {
          backgroundColor: options2.backgroundColor,
          borderCapStyle: options2.borderCapStyle,
          borderDash: options2.borderDash,
          borderDashOffset: options2.borderDashOffset,
          borderJoinStyle: options2.borderJoinStyle,
          borderWidth: options2.borderWidth,
          borderColor: options2.borderColor
        };
      }
      function styleChanged(style, prevStyle) {
        return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);
      }
      var helpers = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        easingEffects: effects,
        color,
        getHoverColor,
        noop: noop2,
        uid,
        isNullOrUndef,
        isArray,
        isObject: isObject2,
        isFinite: isNumberFinite,
        finiteOrDefault,
        valueOrDefault,
        toPercentage,
        toDimension,
        callback,
        each: each2,
        _elementsEqual,
        clone: clone2,
        _merger,
        merge,
        mergeIf,
        _mergerIf,
        _deprecated,
        resolveObjectKey,
        _capitalize,
        defined,
        isFunction,
        setsEqual,
        toFontString,
        _measureText,
        _longestText,
        _alignPixel,
        clearCanvas,
        drawPoint,
        _isPointInArea,
        clipArea,
        unclipArea,
        _steppedLineTo,
        _bezierCurveTo,
        renderText,
        addRoundedRectPath,
        _lookup,
        _lookupByKey,
        _rlookupByKey,
        _filterBetween,
        listenArrayEvents,
        unlistenArrayEvents,
        _arrayUnique,
        _createResolver,
        _attachContext,
        _descriptors,
        splineCurve,
        splineCurveMonotone,
        _updateBezierControlPoints,
        _isDomSupported,
        _getParentNode,
        getStyle,
        getRelativePosition: getRelativePosition$1,
        getMaximumSize,
        retinaScale,
        supportsEventListenerOptions,
        readUsedSize,
        fontString,
        requestAnimFrame,
        throttled,
        debounce,
        _toLeftRightCenter,
        _alignStartEnd,
        _textX,
        _pointInLine,
        _steppedInterpolation,
        _bezierInterpolation,
        formatNumber,
        toLineHeight,
        _readValueToProps,
        toTRBL,
        toTRBLCorners,
        toPadding,
        toFont,
        resolve: resolve2,
        _addGrace,
        PI,
        TAU,
        PITAU,
        INFINITY,
        RAD_PER_DEG,
        HALF_PI,
        QUARTER_PI,
        TWO_THIRDS_PI,
        log10,
        sign,
        niceNum,
        _factorize,
        isNumber,
        almostEquals,
        almostWhole,
        _setMinAndMaxByKey,
        toRadians,
        toDegrees,
        _decimalPlaces,
        getAngleFromPoint,
        distanceBetweenPoints,
        _angleDiff,
        _normalizeAngle,
        _angleBetween,
        _limitValue,
        _int16Range,
        getRtlAdapter,
        overrideTextDirection,
        restoreTextDirection,
        _boundSegment,
        _boundSegments,
        _computeSegments
      });
      class BasePlatform {
        acquireContext(canvas, aspectRatio) {
        }
        releaseContext(context) {
          return false;
        }
        addEventListener(chart, type, listener) {
        }
        removeEventListener(chart, type, listener) {
        }
        getDevicePixelRatio() {
          return 1;
        }
        getMaximumSize(element, width, height, aspectRatio) {
          width = Math.max(0, width || element.width);
          height = height || element.height;
          return {
            width,
            height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
          };
        }
        isAttached(canvas) {
          return true;
        }
      }
      class BasicPlatform extends BasePlatform {
        acquireContext(item) {
          return item && item.getContext && item.getContext("2d") || null;
        }
      }
      const EXPANDO_KEY = "$chartjs";
      const EVENT_TYPES = {
        touchstart: "mousedown",
        touchmove: "mousemove",
        touchend: "mouseup",
        pointerenter: "mouseenter",
        pointerdown: "mousedown",
        pointermove: "mousemove",
        pointerup: "mouseup",
        pointerleave: "mouseout",
        pointerout: "mouseout"
      };
      const isNullOrEmpty = (value) => value === null || value === "";
      function initCanvas(canvas, aspectRatio) {
        const style = canvas.style;
        const renderHeight = canvas.getAttribute("height");
        const renderWidth = canvas.getAttribute("width");
        canvas[EXPANDO_KEY] = {
          initial: {
            height: renderHeight,
            width: renderWidth,
            style: {
              display: style.display,
              height: style.height,
              width: style.width
            }
          }
        };
        style.display = style.display || "block";
        style.boxSizing = style.boxSizing || "border-box";
        if (isNullOrEmpty(renderWidth)) {
          const displayWidth = readUsedSize(canvas, "width");
          if (displayWidth !== void 0) {
            canvas.width = displayWidth;
          }
        }
        if (isNullOrEmpty(renderHeight)) {
          if (canvas.style.height === "") {
            canvas.height = canvas.width / (aspectRatio || 2);
          } else {
            const displayHeight = readUsedSize(canvas, "height");
            if (displayHeight !== void 0) {
              canvas.height = displayHeight;
            }
          }
        }
        return canvas;
      }
      const eventListenerOptions = supportsEventListenerOptions ? { passive: true } : false;
      function addListener(node, type, listener) {
        node.addEventListener(type, listener, eventListenerOptions);
      }
      function removeListener(chart, type, listener) {
        chart.canvas.removeEventListener(type, listener, eventListenerOptions);
      }
      function fromNativeEvent(event, chart) {
        const type = EVENT_TYPES[event.type] || event.type;
        const { x, y } = getRelativePosition$1(event, chart);
        return {
          type,
          chart,
          native: event,
          x: x !== void 0 ? x : null,
          y: y !== void 0 ? y : null
        };
      }
      function createAttachObserver(chart, type, listener) {
        const canvas = chart.canvas;
        const container = canvas && _getParentNode(canvas);
        const element = container || canvas;
        const observer = new MutationObserver((entries) => {
          const parent2 = _getParentNode(element);
          entries.forEach((entry) => {
            for (let i = 0; i < entry.addedNodes.length; i++) {
              const added = entry.addedNodes[i];
              if (added === element || added === parent2) {
                listener(entry.target);
              }
            }
          });
        });
        observer.observe(document, { childList: true, subtree: true });
        return observer;
      }
      function createDetachObserver(chart, type, listener) {
        const canvas = chart.canvas;
        const container = canvas && _getParentNode(canvas);
        if (!container) {
          return;
        }
        const observer = new MutationObserver((entries) => {
          entries.forEach((entry) => {
            for (let i = 0; i < entry.removedNodes.length; i++) {
              if (entry.removedNodes[i] === canvas) {
                listener();
                break;
              }
            }
          });
        });
        observer.observe(container, { childList: true });
        return observer;
      }
      const drpListeningCharts = new Map();
      let oldDevicePixelRatio = 0;
      function onWindowResize() {
        const dpr = window.devicePixelRatio;
        if (dpr === oldDevicePixelRatio) {
          return;
        }
        oldDevicePixelRatio = dpr;
        drpListeningCharts.forEach((resize, chart) => {
          if (chart.currentDevicePixelRatio !== dpr) {
            resize();
          }
        });
      }
      function listenDevicePixelRatioChanges(chart, resize) {
        if (!drpListeningCharts.size) {
          window.addEventListener("resize", onWindowResize);
        }
        drpListeningCharts.set(chart, resize);
      }
      function unlistenDevicePixelRatioChanges(chart) {
        drpListeningCharts.delete(chart);
        if (!drpListeningCharts.size) {
          window.removeEventListener("resize", onWindowResize);
        }
      }
      function createResizeObserver(chart, type, listener) {
        const canvas = chart.canvas;
        const container = canvas && _getParentNode(canvas);
        if (!container) {
          return;
        }
        const resize = throttled((width, height) => {
          const w = container.clientWidth;
          listener(width, height);
          if (w < container.clientWidth) {
            listener();
          }
        }, window);
        const observer = new ResizeObserver((entries) => {
          const entry = entries[0];
          const width = entry.contentRect.width;
          const height = entry.contentRect.height;
          if (width === 0 && height === 0) {
            return;
          }
          resize(width, height);
        });
        observer.observe(container);
        listenDevicePixelRatioChanges(chart, resize);
        return observer;
      }
      function releaseObserver(chart, type, observer) {
        if (observer) {
          observer.disconnect();
        }
        if (type === "resize") {
          unlistenDevicePixelRatioChanges(chart);
        }
      }
      function createProxyAndListen(chart, type, listener) {
        const canvas = chart.canvas;
        const proxy = throttled((event) => {
          if (chart.ctx !== null) {
            listener(fromNativeEvent(event, chart));
          }
        }, chart, (args) => {
          const event = args[0];
          return [event, event.offsetX, event.offsetY];
        });
        addListener(canvas, type, proxy);
        return proxy;
      }
      class DomPlatform extends BasePlatform {
        acquireContext(canvas, aspectRatio) {
          const context = canvas && canvas.getContext && canvas.getContext("2d");
          if (context && context.canvas === canvas) {
            initCanvas(canvas, aspectRatio);
            return context;
          }
          return null;
        }
        releaseContext(context) {
          const canvas = context.canvas;
          if (!canvas[EXPANDO_KEY]) {
            return false;
          }
          const initial = canvas[EXPANDO_KEY].initial;
          ["height", "width"].forEach((prop) => {
            const value = initial[prop];
            if (isNullOrUndef(value)) {
              canvas.removeAttribute(prop);
            } else {
              canvas.setAttribute(prop, value);
            }
          });
          const style = initial.style || {};
          Object.keys(style).forEach((key) => {
            canvas.style[key] = style[key];
          });
          canvas.width = canvas.width;
          delete canvas[EXPANDO_KEY];
          return true;
        }
        addEventListener(chart, type, listener) {
          this.removeEventListener(chart, type);
          const proxies = chart.$proxies || (chart.$proxies = {});
          const handlers = {
            attach: createAttachObserver,
            detach: createDetachObserver,
            resize: createResizeObserver
          };
          const handler2 = handlers[type] || createProxyAndListen;
          proxies[type] = handler2(chart, type, listener);
        }
        removeEventListener(chart, type) {
          const proxies = chart.$proxies || (chart.$proxies = {});
          const proxy = proxies[type];
          if (!proxy) {
            return;
          }
          const handlers = {
            attach: releaseObserver,
            detach: releaseObserver,
            resize: releaseObserver
          };
          const handler2 = handlers[type] || removeListener;
          handler2(chart, type, proxy);
          proxies[type] = void 0;
        }
        getDevicePixelRatio() {
          return window.devicePixelRatio;
        }
        getMaximumSize(canvas, width, height, aspectRatio) {
          return getMaximumSize(canvas, width, height, aspectRatio);
        }
        isAttached(canvas) {
          const container = _getParentNode(canvas);
          return !!(container && container.isConnected);
        }
      }
      function _detectPlatform(canvas) {
        if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) {
          return BasicPlatform;
        }
        return DomPlatform;
      }
      var platforms = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        _detectPlatform,
        BasePlatform,
        BasicPlatform,
        DomPlatform
      });
      const transparent = "transparent";
      const interpolators = {
        boolean(from, to, factor) {
          return factor > 0.5 ? to : from;
        },
        color(from, to, factor) {
          const c0 = color(from || transparent);
          const c1 = c0.valid && color(to || transparent);
          return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;
        },
        number(from, to, factor) {
          return from + (to - from) * factor;
        }
      };
      class Animation {
        constructor(cfg, target, prop, to) {
          const currentValue = target[prop];
          to = resolve2([cfg.to, to, currentValue, cfg.from]);
          const from = resolve2([cfg.from, currentValue, to]);
          this._active = true;
          this._fn = cfg.fn || interpolators[cfg.type || typeof from];
          this._easing = effects[cfg.easing] || effects.linear;
          this._start = Math.floor(Date.now() + (cfg.delay || 0));
          this._duration = this._total = Math.floor(cfg.duration);
          this._loop = !!cfg.loop;
          this._target = target;
          this._prop = prop;
          this._from = from;
          this._to = to;
          this._promises = void 0;
        }
        active() {
          return this._active;
        }
        update(cfg, to, date) {
          const me = this;
          if (me._active) {
            me._notify(false);
            const currentValue = me._target[me._prop];
            const elapsed = date - me._start;
            const remain = me._duration - elapsed;
            me._start = date;
            me._duration = Math.floor(Math.max(remain, cfg.duration));
            me._total += elapsed;
            me._loop = !!cfg.loop;
            me._to = resolve2([cfg.to, to, currentValue, cfg.from]);
            me._from = resolve2([cfg.from, currentValue, to]);
          }
        }
        cancel() {
          const me = this;
          if (me._active) {
            me.tick(Date.now());
            me._active = false;
            me._notify(false);
          }
        }
        tick(date) {
          const me = this;
          const elapsed = date - me._start;
          const duration = me._duration;
          const prop = me._prop;
          const from = me._from;
          const loop = me._loop;
          const to = me._to;
          let factor;
          me._active = from !== to && (loop || elapsed < duration);
          if (!me._active) {
            me._target[prop] = to;
            me._notify(true);
            return;
          }
          if (elapsed < 0) {
            me._target[prop] = from;
            return;
          }
          factor = elapsed / duration % 2;
          factor = loop && factor > 1 ? 2 - factor : factor;
          factor = me._easing(Math.min(1, Math.max(0, factor)));
          me._target[prop] = me._fn(from, to, factor);
        }
        wait() {
          const promises = this._promises || (this._promises = []);
          return new Promise((res, rej) => {
            promises.push({ res, rej });
          });
        }
        _notify(resolved) {
          const method = resolved ? "res" : "rej";
          const promises = this._promises || [];
          for (let i = 0; i < promises.length; i++) {
            promises[i][method]();
          }
        }
      }
      const numbers = ["x", "y", "borderWidth", "radius", "tension"];
      const colors = ["color", "borderColor", "backgroundColor"];
      defaults.set("animation", {
        delay: void 0,
        duration: 1e3,
        easing: "easeOutQuart",
        fn: void 0,
        from: void 0,
        loop: void 0,
        to: void 0,
        type: void 0
      });
      const animationOptions = Object.keys(defaults.animation);
      defaults.describe("animation", {
        _fallback: false,
        _indexable: false,
        _scriptable: (name2) => name2 !== "onProgress" && name2 !== "onComplete" && name2 !== "fn"
      });
      defaults.set("animations", {
        colors: {
          type: "color",
          properties: colors
        },
        numbers: {
          type: "number",
          properties: numbers
        }
      });
      defaults.describe("animations", {
        _fallback: "animation"
      });
      defaults.set("transitions", {
        active: {
          animation: {
            duration: 400
          }
        },
        resize: {
          animation: {
            duration: 0
          }
        },
        show: {
          animations: {
            colors: {
              from: "transparent"
            },
            visible: {
              type: "boolean",
              duration: 0
            }
          }
        },
        hide: {
          animations: {
            colors: {
              to: "transparent"
            },
            visible: {
              type: "boolean",
              easing: "linear",
              fn: (v) => v | 0
            }
          }
        }
      });
      class Animations {
        constructor(chart, config2) {
          this._chart = chart;
          this._properties = new Map();
          this.configure(config2);
        }
        configure(config2) {
          if (!isObject2(config2)) {
            return;
          }
          const animatedProps = this._properties;
          Object.getOwnPropertyNames(config2).forEach((key) => {
            const cfg = config2[key];
            if (!isObject2(cfg)) {
              return;
            }
            const resolved = {};
            for (const option of animationOptions) {
              resolved[option] = cfg[option];
            }
            (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {
              if (prop === key || !animatedProps.has(prop)) {
                animatedProps.set(prop, resolved);
              }
            });
          });
        }
        _animateOptions(target, values) {
          const newOptions = values.options;
          const options2 = resolveTargetOptions(target, newOptions);
          if (!options2) {
            return [];
          }
          const animations = this._createAnimations(options2, newOptions);
          if (newOptions.$shared) {
            awaitAll(target.options.$animations, newOptions).then(() => {
              target.options = newOptions;
            }, () => {
            });
          }
          return animations;
        }
        _createAnimations(target, values) {
          const animatedProps = this._properties;
          const animations = [];
          const running = target.$animations || (target.$animations = {});
          const props = Object.keys(values);
          const date = Date.now();
          let i;
          for (i = props.length - 1; i >= 0; --i) {
            const prop = props[i];
            if (prop.charAt(0) === "$") {
              continue;
            }
            if (prop === "options") {
              animations.push(...this._animateOptions(target, values));
              continue;
            }
            const value = values[prop];
            let animation = running[prop];
            const cfg = animatedProps.get(prop);
            if (animation) {
              if (cfg && animation.active()) {
                animation.update(cfg, value, date);
                continue;
              } else {
                animation.cancel();
              }
            }
            if (!cfg || !cfg.duration) {
              target[prop] = value;
              continue;
            }
            running[prop] = animation = new Animation(cfg, target, prop, value);
            animations.push(animation);
          }
          return animations;
        }
        update(target, values) {
          if (this._properties.size === 0) {
            Object.assign(target, values);
            return;
          }
          const animations = this._createAnimations(target, values);
          if (animations.length) {
            animator.add(this._chart, animations);
            return true;
          }
        }
      }
      function awaitAll(animations, properties) {
        const running = [];
        const keys = Object.keys(properties);
        for (let i = 0; i < keys.length; i++) {
          const anim = animations[keys[i]];
          if (anim && anim.active()) {
            running.push(anim.wait());
          }
        }
        return Promise.all(running);
      }
      function resolveTargetOptions(target, newOptions) {
        if (!newOptions) {
          return;
        }
        let options2 = target.options;
        if (!options2) {
          target.options = newOptions;
          return;
        }
        if (options2.$shared) {
          target.options = options2 = Object.assign({}, options2, { $shared: false, $animations: {} });
        }
        return options2;
      }
      function scaleClip(scale, allowedOverflow) {
        const opts = scale && scale.options || {};
        const reverse = opts.reverse;
        const min = opts.min === void 0 ? allowedOverflow : 0;
        const max = opts.max === void 0 ? allowedOverflow : 0;
        return {
          start: reverse ? max : min,
          end: reverse ? min : max
        };
      }
      function defaultClip(xScale, yScale, allowedOverflow) {
        if (allowedOverflow === false) {
          return false;
        }
        const x = scaleClip(xScale, allowedOverflow);
        const y = scaleClip(yScale, allowedOverflow);
        return {
          top: y.end,
          right: x.end,
          bottom: y.start,
          left: x.start
        };
      }
      function toClip(value) {
        let t, r, b, l;
        if (isObject2(value)) {
          t = value.top;
          r = value.right;
          b = value.bottom;
          l = value.left;
        } else {
          t = r = b = l = value;
        }
        return {
          top: t,
          right: r,
          bottom: b,
          left: l,
          disabled: value === false
        };
      }
      function getSortedDatasetIndices(chart, filterVisible) {
        const keys = [];
        const metasets = chart._getSortedDatasetMetas(filterVisible);
        let i, ilen;
        for (i = 0, ilen = metasets.length; i < ilen; ++i) {
          keys.push(metasets[i].index);
        }
        return keys;
      }
      function applyStack(stack, value, dsIndex, options2) {
        const keys = stack.keys;
        const singleMode = options2.mode === "single";
        let i, ilen, datasetIndex, otherValue;
        if (value === null) {
          return;
        }
        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          datasetIndex = +keys[i];
          if (datasetIndex === dsIndex) {
            if (options2.all) {
              continue;
            }
            break;
          }
          otherValue = stack.values[datasetIndex];
          if (isNumberFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {
            value += otherValue;
          }
        }
        return value;
      }
      function convertObjectDataToArray(data) {
        const keys = Object.keys(data);
        const adata = new Array(keys.length);
        let i, ilen, key;
        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          adata[i] = {
            x: key,
            y: data[key]
          };
        }
        return adata;
      }
      function isStacked(scale, meta) {
        const stacked = scale && scale.options.stacked;
        return stacked || stacked === void 0 && meta.stack !== void 0;
      }
      function getStackKey(indexScale, valueScale, meta) {
        return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
      }
      function getUserBounds(scale) {
        const { min, max, minDefined, maxDefined } = scale.getUserBounds();
        return {
          min: minDefined ? min : Number.NEGATIVE_INFINITY,
          max: maxDefined ? max : Number.POSITIVE_INFINITY
        };
      }
      function getOrCreateStack(stacks, stackKey, indexValue) {
        const subStack = stacks[stackKey] || (stacks[stackKey] = {});
        return subStack[indexValue] || (subStack[indexValue] = {});
      }
      function getLastIndexInStack(stack, vScale, positive) {
        for (const meta of vScale.getMatchingVisibleMetas("bar").reverse()) {
          const value = stack[meta.index];
          if (positive && value > 0 || !positive && value < 0) {
            return meta.index;
          }
        }
        return null;
      }
      function updateStacks(controller, parsed) {
        const { chart, _cachedMeta: meta } = controller;
        const stacks = chart._stacks || (chart._stacks = {});
        const { iScale, vScale, index: datasetIndex } = meta;
        const iAxis = iScale.axis;
        const vAxis = vScale.axis;
        const key = getStackKey(iScale, vScale, meta);
        const ilen = parsed.length;
        let stack;
        for (let i = 0; i < ilen; ++i) {
          const item = parsed[i];
          const { [iAxis]: index2, [vAxis]: value } = item;
          const itemStacks = item._stacks || (item._stacks = {});
          stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index2);
          stack[datasetIndex] = value;
          stack._top = getLastIndexInStack(stack, vScale, true);
          stack._bottom = getLastIndexInStack(stack, vScale, false);
        }
      }
      function getFirstScaleId(chart, axis) {
        const scales2 = chart.scales;
        return Object.keys(scales2).filter((key) => scales2[key].axis === axis).shift();
      }
      function createDatasetContext(parent2, index2) {
        return Object.assign(Object.create(parent2), {
          active: false,
          dataset: void 0,
          datasetIndex: index2,
          index: index2,
          mode: "default",
          type: "dataset"
        });
      }
      function createDataContext(parent2, index2, element) {
        return Object.assign(Object.create(parent2), {
          active: false,
          dataIndex: index2,
          parsed: void 0,
          raw: void 0,
          element,
          index: index2,
          mode: "default",
          type: "data"
        });
      }
      function clearStacks(meta, items) {
        const datasetIndex = meta.controller.index;
        const axis = meta.vScale && meta.vScale.axis;
        if (!axis) {
          return;
        }
        items = items || meta._parsed;
        for (const parsed of items) {
          const stacks = parsed._stacks;
          if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {
            return;
          }
          delete stacks[axis][datasetIndex];
        }
      }
      const isDirectUpdateMode = (mode) => mode === "reset" || mode === "none";
      const cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
      class DatasetController {
        constructor(chart, datasetIndex) {
          this.chart = chart;
          this._ctx = chart.ctx;
          this.index = datasetIndex;
          this._cachedDataOpts = {};
          this._cachedMeta = this.getMeta();
          this._type = this._cachedMeta.type;
          this.options = void 0;
          this._parsing = false;
          this._data = void 0;
          this._objectData = void 0;
          this._sharedOptions = void 0;
          this._drawStart = void 0;
          this._drawCount = void 0;
          this.enableOptionSharing = false;
          this.$context = void 0;
          this._syncList = [];
          this.initialize();
        }
        initialize() {
          const me = this;
          const meta = me._cachedMeta;
          me.configure();
          me.linkScales();
          meta._stacked = isStacked(meta.vScale, meta);
          me.addElements();
        }
        updateIndex(datasetIndex) {
          if (this.index !== datasetIndex) {
            clearStacks(this._cachedMeta);
          }
          this.index = datasetIndex;
        }
        linkScales() {
          const me = this;
          const chart = me.chart;
          const meta = me._cachedMeta;
          const dataset = me.getDataset();
          const chooseId = (axis, x, y, r) => axis === "x" ? x : axis === "r" ? r : y;
          const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
          const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
          const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
          const indexAxis = meta.indexAxis;
          const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
          const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
          meta.xScale = me.getScaleForId(xid);
          meta.yScale = me.getScaleForId(yid);
          meta.rScale = me.getScaleForId(rid);
          meta.iScale = me.getScaleForId(iid);
          meta.vScale = me.getScaleForId(vid);
        }
        getDataset() {
          return this.chart.data.datasets[this.index];
        }
        getMeta() {
          return this.chart.getDatasetMeta(this.index);
        }
        getScaleForId(scaleID) {
          return this.chart.scales[scaleID];
        }
        _getOtherScale(scale) {
          const meta = this._cachedMeta;
          return scale === meta.iScale ? meta.vScale : meta.iScale;
        }
        reset() {
          this._update("reset");
        }
        _destroy() {
          const meta = this._cachedMeta;
          if (this._data) {
            unlistenArrayEvents(this._data, this);
          }
          if (meta._stacked) {
            clearStacks(meta);
          }
        }
        _dataCheck() {
          const me = this;
          const dataset = me.getDataset();
          const data = dataset.data || (dataset.data = []);
          const _data = me._data;
          if (isObject2(data)) {
            me._data = convertObjectDataToArray(data);
          } else if (_data !== data) {
            if (_data) {
              unlistenArrayEvents(_data, me);
              const meta = me._cachedMeta;
              clearStacks(meta);
              meta._parsed = [];
            }
            if (data && Object.isExtensible(data)) {
              listenArrayEvents(data, me);
            }
            me._syncList = [];
            me._data = data;
          }
        }
        addElements() {
          const me = this;
          const meta = me._cachedMeta;
          me._dataCheck();
          if (me.datasetElementType) {
            meta.dataset = new me.datasetElementType();
          }
        }
        buildOrUpdateElements(resetNewElements) {
          const me = this;
          const meta = me._cachedMeta;
          const dataset = me.getDataset();
          let stackChanged = false;
          me._dataCheck();
          const oldStacked = meta._stacked;
          meta._stacked = isStacked(meta.vScale, meta);
          if (meta.stack !== dataset.stack) {
            stackChanged = true;
            clearStacks(meta);
            meta.stack = dataset.stack;
          }
          me._resyncElements(resetNewElements);
          if (stackChanged || oldStacked !== meta._stacked) {
            updateStacks(me, meta._parsed);
          }
        }
        configure() {
          const me = this;
          const config2 = me.chart.config;
          const scopeKeys = config2.datasetScopeKeys(me._type);
          const scopes = config2.getOptionScopes(me.getDataset(), scopeKeys, true);
          me.options = config2.createResolver(scopes, me.getContext());
          me._parsing = me.options.parsing;
        }
        parse(start2, count) {
          const me = this;
          const { _cachedMeta: meta, _data: data } = me;
          const { iScale, _stacked } = meta;
          const iAxis = iScale.axis;
          let sorted = start2 === 0 && count === data.length ? true : meta._sorted;
          let prev = start2 > 0 && meta._parsed[start2 - 1];
          let i, cur, parsed;
          if (me._parsing === false) {
            meta._parsed = data;
            meta._sorted = true;
            parsed = data;
          } else {
            if (isArray(data[start2])) {
              parsed = me.parseArrayData(meta, data, start2, count);
            } else if (isObject2(data[start2])) {
              parsed = me.parseObjectData(meta, data, start2, count);
            } else {
              parsed = me.parsePrimitiveData(meta, data, start2, count);
            }
            const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
            for (i = 0; i < count; ++i) {
              meta._parsed[i + start2] = cur = parsed[i];
              if (sorted) {
                if (isNotInOrderComparedToPrev()) {
                  sorted = false;
                }
                prev = cur;
              }
            }
            meta._sorted = sorted;
          }
          if (_stacked) {
            updateStacks(me, parsed);
          }
        }
        parsePrimitiveData(meta, data, start2, count) {
          const { iScale, vScale } = meta;
          const iAxis = iScale.axis;
          const vAxis = vScale.axis;
          const labels = iScale.getLabels();
          const singleScale = iScale === vScale;
          const parsed = new Array(count);
          let i, ilen, index2;
          for (i = 0, ilen = count; i < ilen; ++i) {
            index2 = i + start2;
            parsed[i] = {
              [iAxis]: singleScale || iScale.parse(labels[index2], index2),
              [vAxis]: vScale.parse(data[index2], index2)
            };
          }
          return parsed;
        }
        parseArrayData(meta, data, start2, count) {
          const { xScale, yScale } = meta;
          const parsed = new Array(count);
          let i, ilen, index2, item;
          for (i = 0, ilen = count; i < ilen; ++i) {
            index2 = i + start2;
            item = data[index2];
            parsed[i] = {
              x: xScale.parse(item[0], index2),
              y: yScale.parse(item[1], index2)
            };
          }
          return parsed;
        }
        parseObjectData(meta, data, start2, count) {
          const { xScale, yScale } = meta;
          const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
          const parsed = new Array(count);
          let i, ilen, index2, item;
          for (i = 0, ilen = count; i < ilen; ++i) {
            index2 = i + start2;
            item = data[index2];
            parsed[i] = {
              x: xScale.parse(resolveObjectKey(item, xAxisKey), index2),
              y: yScale.parse(resolveObjectKey(item, yAxisKey), index2)
            };
          }
          return parsed;
        }
        getParsed(index2) {
          return this._cachedMeta._parsed[index2];
        }
        getDataElement(index2) {
          return this._cachedMeta.data[index2];
        }
        applyStack(scale, parsed, mode) {
          const chart = this.chart;
          const meta = this._cachedMeta;
          const value = parsed[scale.axis];
          const stack = {
            keys: getSortedDatasetIndices(chart, true),
            values: parsed._stacks[scale.axis]
          };
          return applyStack(stack, value, meta.index, { mode });
        }
        updateRangeFromParsed(range, scale, parsed, stack) {
          const parsedValue = parsed[scale.axis];
          let value = parsedValue === null ? NaN : parsedValue;
          const values = stack && parsed._stacks[scale.axis];
          if (stack && values) {
            stack.values = values;
            range.min = Math.min(range.min, value);
            range.max = Math.max(range.max, value);
            value = applyStack(stack, parsedValue, this._cachedMeta.index, { all: true });
          }
          range.min = Math.min(range.min, value);
          range.max = Math.max(range.max, value);
        }
        getMinMax(scale, canStack) {
          const me = this;
          const meta = me._cachedMeta;
          const _parsed = meta._parsed;
          const sorted = meta._sorted && scale === meta.iScale;
          const ilen = _parsed.length;
          const otherScale = me._getOtherScale(scale);
          const stack = canStack && meta._stacked && { keys: getSortedDatasetIndices(me.chart, true), values: null };
          const range = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
          const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
          let i, value, parsed, otherValue;
          function _skip() {
            parsed = _parsed[i];
            value = parsed[scale.axis];
            otherValue = parsed[otherScale.axis];
            return !isNumberFinite(value) || otherMin > otherValue || otherMax < otherValue;
          }
          for (i = 0; i < ilen; ++i) {
            if (_skip()) {
              continue;
            }
            me.updateRangeFromParsed(range, scale, parsed, stack);
            if (sorted) {
              break;
            }
          }
          if (sorted) {
            for (i = ilen - 1; i >= 0; --i) {
              if (_skip()) {
                continue;
              }
              me.updateRangeFromParsed(range, scale, parsed, stack);
              break;
            }
          }
          return range;
        }
        getAllParsedValues(scale) {
          const parsed = this._cachedMeta._parsed;
          const values = [];
          let i, ilen, value;
          for (i = 0, ilen = parsed.length; i < ilen; ++i) {
            value = parsed[i][scale.axis];
            if (isNumberFinite(value)) {
              values.push(value);
            }
          }
          return values;
        }
        getMaxOverflow() {
          return false;
        }
        getLabelAndValue(index2) {
          const me = this;
          const meta = me._cachedMeta;
          const iScale = meta.iScale;
          const vScale = meta.vScale;
          const parsed = me.getParsed(index2);
          return {
            label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
            value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
          };
        }
        _update(mode) {
          const me = this;
          const meta = me._cachedMeta;
          me.configure();
          me._cachedDataOpts = {};
          me.update(mode || "default");
          meta._clip = toClip(valueOrDefault(me.options.clip, defaultClip(meta.xScale, meta.yScale, me.getMaxOverflow())));
        }
        update(mode) {
        }
        draw() {
          const me = this;
          const ctx = me._ctx;
          const chart = me.chart;
          const meta = me._cachedMeta;
          const elements2 = meta.data || [];
          const area = chart.chartArea;
          const active = [];
          const start2 = me._drawStart || 0;
          const count = me._drawCount || elements2.length - start2;
          let i;
          if (meta.dataset) {
            meta.dataset.draw(ctx, area, start2, count);
          }
          for (i = start2; i < start2 + count; ++i) {
            const element = elements2[i];
            if (element.hidden) {
              continue;
            }
            if (element.active) {
              active.push(element);
            } else {
              element.draw(ctx, area);
            }
          }
          for (i = 0; i < active.length; ++i) {
            active[i].draw(ctx, area);
          }
        }
        getStyle(index2, active) {
          const mode = active ? "active" : "default";
          return index2 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index2 || 0, mode);
        }
        getContext(index2, active, mode) {
          const me = this;
          const dataset = me.getDataset();
          let context;
          if (index2 >= 0 && index2 < me._cachedMeta.data.length) {
            const element = me._cachedMeta.data[index2];
            context = element.$context || (element.$context = createDataContext(me.getContext(), index2, element));
            context.parsed = me.getParsed(index2);
            context.raw = dataset.data[index2];
            context.index = context.dataIndex = index2;
          } else {
            context = me.$context || (me.$context = createDatasetContext(me.chart.getContext(), me.index));
            context.dataset = dataset;
            context.index = context.datasetIndex = me.index;
          }
          context.active = !!active;
          context.mode = mode;
          return context;
        }
        resolveDatasetElementOptions(mode) {
          return this._resolveElementOptions(this.datasetElementType.id, mode);
        }
        resolveDataElementOptions(index2, mode) {
          return this._resolveElementOptions(this.dataElementType.id, mode, index2);
        }
        _resolveElementOptions(elementType, mode = "default", index2) {
          const me = this;
          const active = mode === "active";
          const cache = me._cachedDataOpts;
          const cacheKey = elementType + "-" + mode;
          const cached = cache[cacheKey];
          const sharing = me.enableOptionSharing && defined(index2);
          if (cached) {
            return cloneIfNotShared(cached, sharing);
          }
          const config2 = me.chart.config;
          const scopeKeys = config2.datasetElementScopeKeys(me._type, elementType);
          const prefixes = active ? [`${elementType}Hover`, "hover", elementType, ""] : [elementType, ""];
          const scopes = config2.getOptionScopes(me.getDataset(), scopeKeys);
          const names2 = Object.keys(defaults.elements[elementType]);
          const context = () => me.getContext(index2, active);
          const values = config2.resolveNamedOptions(scopes, names2, context, prefixes);
          if (values.$shared) {
            values.$shared = sharing;
            cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
          }
          return values;
        }
        _resolveAnimations(index2, transition, active) {
          const me = this;
          const chart = me.chart;
          const cache = me._cachedDataOpts;
          const cacheKey = `animation-${transition}`;
          const cached = cache[cacheKey];
          if (cached) {
            return cached;
          }
          let options2;
          if (chart.options.animation !== false) {
            const config2 = me.chart.config;
            const scopeKeys = config2.datasetAnimationScopeKeys(me._type, transition);
            const scopes = config2.getOptionScopes(me.getDataset(), scopeKeys);
            options2 = config2.createResolver(scopes, me.getContext(index2, active, transition));
          }
          const animations = new Animations(chart, options2 && options2.animations);
          if (options2 && options2._cacheable) {
            cache[cacheKey] = Object.freeze(animations);
          }
          return animations;
        }
        getSharedOptions(options2) {
          if (!options2.$shared) {
            return;
          }
          return this._sharedOptions || (this._sharedOptions = Object.assign({}, options2));
        }
        includeOptions(mode, sharedOptions) {
          return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
        }
        updateElement(element, index2, properties, mode) {
          if (isDirectUpdateMode(mode)) {
            Object.assign(element, properties);
          } else {
            this._resolveAnimations(index2, mode).update(element, properties);
          }
        }
        updateSharedOptions(sharedOptions, mode, newOptions) {
          if (sharedOptions && !isDirectUpdateMode(mode)) {
            this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
          }
        }
        _setStyle(element, index2, mode, active) {
          element.active = active;
          const options2 = this.getStyle(index2, active);
          this._resolveAnimations(index2, mode, active).update(element, {
            options: !active && this.getSharedOptions(options2) || options2
          });
        }
        removeHoverStyle(element, datasetIndex, index2) {
          this._setStyle(element, index2, "active", false);
        }
        setHoverStyle(element, datasetIndex, index2) {
          this._setStyle(element, index2, "active", true);
        }
        _removeDatasetHoverStyle() {
          const element = this._cachedMeta.dataset;
          if (element) {
            this._setStyle(element, void 0, "active", false);
          }
        }
        _setDatasetHoverStyle() {
          const element = this._cachedMeta.dataset;
          if (element) {
            this._setStyle(element, void 0, "active", true);
          }
        }
        _resyncElements(resetNewElements) {
          const me = this;
          const data = me._data;
          const elements2 = me._cachedMeta.data;
          for (const [method, arg1, arg2] of me._syncList) {
            me[method](arg1, arg2);
          }
          me._syncList = [];
          const numMeta = elements2.length;
          const numData = data.length;
          const count = Math.min(numData, numMeta);
          if (count) {
            me.parse(0, count);
          }
          if (numData > numMeta) {
            me._insertElements(numMeta, numData - numMeta, resetNewElements);
          } else if (numData < numMeta) {
            me._removeElements(numData, numMeta - numData);
          }
        }
        _insertElements(start2, count, resetNewElements = true) {
          const me = this;
          const meta = me._cachedMeta;
          const data = meta.data;
          const end = start2 + count;
          let i;
          const move = (arr) => {
            arr.length += count;
            for (i = arr.length - 1; i >= end; i--) {
              arr[i] = arr[i - count];
            }
          };
          move(data);
          for (i = start2; i < end; ++i) {
            data[i] = new me.dataElementType();
          }
          if (me._parsing) {
            move(meta._parsed);
          }
          me.parse(start2, count);
          if (resetNewElements) {
            me.updateElements(data, start2, count, "reset");
          }
        }
        updateElements(element, start2, count, mode) {
        }
        _removeElements(start2, count) {
          const me = this;
          const meta = me._cachedMeta;
          if (me._parsing) {
            const removed = meta._parsed.splice(start2, count);
            if (meta._stacked) {
              clearStacks(meta, removed);
            }
          }
          meta.data.splice(start2, count);
        }
        _sync(args) {
          if (this._parsing) {
            this._syncList.push(args);
          } else {
            const [method, arg1, arg2] = args;
            this[method](arg1, arg2);
          }
        }
        _onDataPush() {
          const count = arguments.length;
          this._sync(["_insertElements", this.getDataset().data.length - count, count]);
        }
        _onDataPop() {
          this._sync(["_removeElements", this._cachedMeta.data.length - 1, 1]);
        }
        _onDataShift() {
          this._sync(["_removeElements", 0, 1]);
        }
        _onDataSplice(start2, count) {
          this._sync(["_removeElements", start2, count]);
          this._sync(["_insertElements", start2, arguments.length - 2]);
        }
        _onDataUnshift() {
          this._sync(["_insertElements", 0, arguments.length]);
        }
      }
      DatasetController.defaults = {};
      DatasetController.prototype.datasetElementType = null;
      DatasetController.prototype.dataElementType = null;
      class Element {
        constructor() {
          this.x = void 0;
          this.y = void 0;
          this.active = false;
          this.options = void 0;
          this.$animations = void 0;
        }
        tooltipPosition(useFinalPosition) {
          const { x, y } = this.getProps(["x", "y"], useFinalPosition);
          return { x, y };
        }
        hasValue() {
          return isNumber(this.x) && isNumber(this.y);
        }
        getProps(props, final) {
          const me = this;
          const anims = this.$animations;
          if (!final || !anims) {
            return me;
          }
          const ret = {};
          props.forEach((prop) => {
            ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : me[prop];
          });
          return ret;
        }
      }
      Element.defaults = {};
      Element.defaultRoutes = void 0;
      const formatters = {
        values(value) {
          return isArray(value) ? value : "" + value;
        },
        numeric(tickValue, index2, ticks) {
          if (tickValue === 0) {
            return "0";
          }
          const locale = this.chart.options.locale;
          let notation;
          let delta = tickValue;
          if (ticks.length > 1) {
            const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
            if (maxTick < 1e-4 || maxTick > 1e15) {
              notation = "scientific";
            }
            delta = calculateDelta(tickValue, ticks);
          }
          const logDelta = log10(Math.abs(delta));
          const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
          const options2 = { notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal };
          Object.assign(options2, this.options.ticks.format);
          return formatNumber(tickValue, locale, options2);
        },
        logarithmic(tickValue, index2, ticks) {
          if (tickValue === 0) {
            return "0";
          }
          const remain = tickValue / Math.pow(10, Math.floor(log10(tickValue)));
          if (remain === 1 || remain === 2 || remain === 5) {
            return formatters.numeric.call(this, tickValue, index2, ticks);
          }
          return "";
        }
      };
      function calculateDelta(tickValue, ticks) {
        let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
        if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
          delta = tickValue - Math.floor(tickValue);
        }
        return delta;
      }
      var Ticks = { formatters };
      defaults.set("scale", {
        display: true,
        offset: false,
        reverse: false,
        beginAtZero: false,
        bounds: "ticks",
        grace: 0,
        grid: {
          display: true,
          lineWidth: 1,
          drawBorder: true,
          drawOnChartArea: true,
          drawTicks: true,
          tickLength: 8,
          tickWidth: (_ctx, options2) => options2.lineWidth,
          tickColor: (_ctx, options2) => options2.color,
          offset: false,
          borderDash: [],
          borderDashOffset: 0,
          borderWidth: 1
        },
        title: {
          display: false,
          text: "",
          padding: {
            top: 4,
            bottom: 4
          }
        },
        ticks: {
          minRotation: 0,
          maxRotation: 50,
          mirror: false,
          textStrokeWidth: 0,
          textStrokeColor: "",
          padding: 3,
          display: true,
          autoSkip: true,
          autoSkipPadding: 3,
          labelOffset: 0,
          callback: Ticks.formatters.values,
          minor: {},
          major: {},
          align: "center",
          crossAlign: "near",
          showLabelBackdrop: false,
          backdropColor: "rgba(255, 255, 255, 0.75)",
          backdropPadding: 2
        }
      });
      defaults.route("scale.ticks", "color", "", "color");
      defaults.route("scale.grid", "color", "", "borderColor");
      defaults.route("scale.grid", "borderColor", "", "borderColor");
      defaults.route("scale.title", "color", "", "color");
      defaults.describe("scale", {
        _fallback: false,
        _scriptable: (name2) => !name2.startsWith("before") && !name2.startsWith("after") && name2 !== "callback" && name2 !== "parser",
        _indexable: (name2) => name2 !== "borderDash" && name2 !== "tickBorderDash"
      });
      defaults.describe("scales", {
        _fallback: "scale"
      });
      defaults.describe("scale.ticks", {
        _scriptable: (name2) => name2 !== "backdropPadding" && name2 !== "callback",
        _indexable: (name2) => name2 !== "backdropPadding"
      });
      function autoSkip(scale, ticks) {
        const tickOpts = scale.options.ticks;
        const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);
        const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
        const numMajorIndices = majorIndices.length;
        const first = majorIndices[0];
        const last = majorIndices[numMajorIndices - 1];
        const newTicks = [];
        if (numMajorIndices > ticksLimit) {
          skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
          return newTicks;
        }
        const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
        if (numMajorIndices > 0) {
          let i, ilen;
          const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
          skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
          for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
            skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
          }
          skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
          return newTicks;
        }
        skip(ticks, newTicks, spacing);
        return newTicks;
      }
      function determineMaxTicks(scale) {
        const offset = scale.options.offset;
        const tickLength = scale._tickSize();
        const maxScale = scale._length / tickLength + (offset ? 0 : 1);
        const maxChart = scale._maxLength / tickLength;
        return Math.floor(Math.min(maxScale, maxChart));
      }
      function calculateSpacing(majorIndices, ticks, ticksLimit) {
        const evenMajorSpacing = getEvenSpacing(majorIndices);
        const spacing = ticks.length / ticksLimit;
        if (!evenMajorSpacing) {
          return Math.max(spacing, 1);
        }
        const factors = _factorize(evenMajorSpacing);
        for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
          const factor = factors[i];
          if (factor > spacing) {
            return factor;
          }
        }
        return Math.max(spacing, 1);
      }
      function getMajorIndices(ticks) {
        const result = [];
        let i, ilen;
        for (i = 0, ilen = ticks.length; i < ilen; i++) {
          if (ticks[i].major) {
            result.push(i);
          }
        }
        return result;
      }
      function skipMajors(ticks, newTicks, majorIndices, spacing) {
        let count = 0;
        let next = majorIndices[0];
        let i;
        spacing = Math.ceil(spacing);
        for (i = 0; i < ticks.length; i++) {
          if (i === next) {
            newTicks.push(ticks[i]);
            count++;
            next = majorIndices[count * spacing];
          }
        }
      }
      function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
        const start2 = valueOrDefault(majorStart, 0);
        const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
        let count = 0;
        let length, i, next;
        spacing = Math.ceil(spacing);
        if (majorEnd) {
          length = majorEnd - majorStart;
          spacing = length / Math.floor(length / spacing);
        }
        next = start2;
        while (next < 0) {
          count++;
          next = Math.round(start2 + count * spacing);
        }
        for (i = Math.max(start2, 0); i < end; i++) {
          if (i === next) {
            newTicks.push(ticks[i]);
            count++;
            next = Math.round(start2 + count * spacing);
          }
        }
      }
      function getEvenSpacing(arr) {
        const len = arr.length;
        let i, diff;
        if (len < 2) {
          return false;
        }
        for (diff = arr[0], i = 1; i < len; ++i) {
          if (arr[i] - arr[i - 1] !== diff) {
            return false;
          }
        }
        return diff;
      }
      const reverseAlign = (align) => align === "left" ? "right" : align === "right" ? "left" : align;
      const offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
      function sample(arr, numItems) {
        const result = [];
        const increment = arr.length / numItems;
        const len = arr.length;
        let i = 0;
        for (; i < len; i += increment) {
          result.push(arr[Math.floor(i)]);
        }
        return result;
      }
      function getPixelForGridLine(scale, index2, offsetGridLines) {
        const length = scale.ticks.length;
        const validIndex2 = Math.min(index2, length - 1);
        const start2 = scale._startPixel;
        const end = scale._endPixel;
        const epsilon = 1e-6;
        let lineValue = scale.getPixelForTick(validIndex2);
        let offset;
        if (offsetGridLines) {
          if (length === 1) {
            offset = Math.max(lineValue - start2, end - lineValue);
          } else if (index2 === 0) {
            offset = (scale.getPixelForTick(1) - lineValue) / 2;
          } else {
            offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;
          }
          lineValue += validIndex2 < index2 ? offset : -offset;
          if (lineValue < start2 - epsilon || lineValue > end + epsilon) {
            return;
          }
        }
        return lineValue;
      }
      function garbageCollect(caches, length) {
        each2(caches, (cache) => {
          const gc = cache.gc;
          const gcLen = gc.length / 2;
          let i;
          if (gcLen > length) {
            for (i = 0; i < gcLen; ++i) {
              delete cache.data[gc[i]];
            }
            gc.splice(0, gcLen);
          }
        });
      }
      function getTickMarkLength(options2) {
        return options2.drawTicks ? options2.tickLength : 0;
      }
      function getTitleHeight(options2, fallback) {
        if (!options2.display) {
          return 0;
        }
        const font = toFont(options2.font, fallback);
        const padding = toPadding(options2.padding);
        const lines = isArray(options2.text) ? options2.text.length : 1;
        return lines * font.lineHeight + padding.height;
      }
      function createScaleContext(parent2, scale) {
        return Object.assign(Object.create(parent2), {
          scale,
          type: "scale"
        });
      }
      function createTickContext(parent2, index2, tick) {
        return Object.assign(Object.create(parent2), {
          tick,
          index: index2,
          type: "tick"
        });
      }
      function titleAlign(align, position, reverse) {
        let ret = _toLeftRightCenter(align);
        if (reverse && position !== "right" || !reverse && position === "right") {
          ret = reverseAlign(ret);
        }
        return ret;
      }
      function titleArgs(scale, offset, position, align) {
        const { top, left, bottom, right, chart } = scale;
        const { chartArea, scales: scales2 } = chart;
        let rotation = 0;
        let maxWidth, titleX, titleY;
        const height = bottom - top;
        const width = right - left;
        if (scale.isHorizontal()) {
          titleX = _alignStartEnd(align, left, right);
          if (isObject2(position)) {
            const positionAxisID = Object.keys(position)[0];
            const value = position[positionAxisID];
            titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset;
          } else if (position === "center") {
            titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
          } else {
            titleY = offsetFromEdge(scale, position, offset);
          }
          maxWidth = right - left;
        } else {
          if (isObject2(position)) {
            const positionAxisID = Object.keys(position)[0];
            const value = position[positionAxisID];
            titleX = scales2[positionAxisID].getPixelForValue(value) - width + offset;
          } else if (position === "center") {
            titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
          } else {
            titleX = offsetFromEdge(scale, position, offset);
          }
          titleY = _alignStartEnd(align, bottom, top);
          rotation = position === "left" ? -HALF_PI : HALF_PI;
        }
        return { titleX, titleY, maxWidth, rotation };
      }
      class Scale extends Element {
        constructor(cfg) {
          super();
          this.id = cfg.id;
          this.type = cfg.type;
          this.options = void 0;
          this.ctx = cfg.ctx;
          this.chart = cfg.chart;
          this.top = void 0;
          this.bottom = void 0;
          this.left = void 0;
          this.right = void 0;
          this.width = void 0;
          this.height = void 0;
          this._margins = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
          };
          this.maxWidth = void 0;
          this.maxHeight = void 0;
          this.paddingTop = void 0;
          this.paddingBottom = void 0;
          this.paddingLeft = void 0;
          this.paddingRight = void 0;
          this.axis = void 0;
          this.labelRotation = void 0;
          this.min = void 0;
          this.max = void 0;
          this._range = void 0;
          this.ticks = [];
          this._gridLineItems = null;
          this._labelItems = null;
          this._labelSizes = null;
          this._length = 0;
          this._maxLength = 0;
          this._longestTextCache = {};
          this._startPixel = void 0;
          this._endPixel = void 0;
          this._reversePixels = false;
          this._userMax = void 0;
          this._userMin = void 0;
          this._suggestedMax = void 0;
          this._suggestedMin = void 0;
          this._ticksLength = 0;
          this._borderValue = 0;
          this._cache = {};
          this._dataLimitsCached = false;
          this.$context = void 0;
        }
        init(options2) {
          const me = this;
          me.options = options2.setContext(me.getContext());
          me.axis = options2.axis;
          me._userMin = me.parse(options2.min);
          me._userMax = me.parse(options2.max);
          me._suggestedMin = me.parse(options2.suggestedMin);
          me._suggestedMax = me.parse(options2.suggestedMax);
        }
        parse(raw, index2) {
          return raw;
        }
        getUserBounds() {
          let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
          _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
          _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
          _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
          _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
          return {
            min: finiteOrDefault(_userMin, _suggestedMin),
            max: finiteOrDefault(_userMax, _suggestedMax),
            minDefined: isNumberFinite(_userMin),
            maxDefined: isNumberFinite(_userMax)
          };
        }
        getMinMax(canStack) {
          const me = this;
          let { min, max, minDefined, maxDefined } = me.getUserBounds();
          let range;
          if (minDefined && maxDefined) {
            return { min, max };
          }
          const metas = me.getMatchingVisibleMetas();
          for (let i = 0, ilen = metas.length; i < ilen; ++i) {
            range = metas[i].controller.getMinMax(me, canStack);
            if (!minDefined) {
              min = Math.min(min, range.min);
            }
            if (!maxDefined) {
              max = Math.max(max, range.max);
            }
          }
          return {
            min: finiteOrDefault(min, finiteOrDefault(max, min)),
            max: finiteOrDefault(max, finiteOrDefault(min, max))
          };
        }
        getPadding() {
          const me = this;
          return {
            left: me.paddingLeft || 0,
            top: me.paddingTop || 0,
            right: me.paddingRight || 0,
            bottom: me.paddingBottom || 0
          };
        }
        getTicks() {
          return this.ticks;
        }
        getLabels() {
          const data = this.chart.data;
          return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
        }
        beforeLayout() {
          this._cache = {};
          this._dataLimitsCached = false;
        }
        beforeUpdate() {
          callback(this.options.beforeUpdate, [this]);
        }
        update(maxWidth, maxHeight, margins) {
          const me = this;
          const tickOpts = me.options.ticks;
          const sampleSize = tickOpts.sampleSize;
          me.beforeUpdate();
          me.maxWidth = maxWidth;
          me.maxHeight = maxHeight;
          me._margins = margins = Object.assign({
            left: 0,
            right: 0,
            top: 0,
            bottom: 0
          }, margins);
          me.ticks = null;
          me._labelSizes = null;
          me._gridLineItems = null;
          me._labelItems = null;
          me.beforeSetDimensions();
          me.setDimensions();
          me.afterSetDimensions();
          me._maxLength = me.isHorizontal() ? me.width + margins.left + margins.right : me.height + margins.top + margins.bottom;
          if (!me._dataLimitsCached) {
            me.beforeDataLimits();
            me.determineDataLimits();
            me.afterDataLimits();
            me._range = _addGrace(me, me.options.grace);
            me._dataLimitsCached = true;
          }
          me.beforeBuildTicks();
          me.ticks = me.buildTicks() || [];
          me.afterBuildTicks();
          const samplingEnabled = sampleSize < me.ticks.length;
          me._convertTicksToLabels(samplingEnabled ? sample(me.ticks, sampleSize) : me.ticks);
          me.configure();
          me.beforeCalculateLabelRotation();
          me.calculateLabelRotation();
          me.afterCalculateLabelRotation();
          if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
            me.ticks = autoSkip(me, me.ticks);
            me._labelSizes = null;
          }
          if (samplingEnabled) {
            me._convertTicksToLabels(me.ticks);
          }
          me.beforeFit();
          me.fit();
          me.afterFit();
          me.afterUpdate();
        }
        configure() {
          const me = this;
          let reversePixels = me.options.reverse;
          let startPixel, endPixel;
          if (me.isHorizontal()) {
            startPixel = me.left;
            endPixel = me.right;
          } else {
            startPixel = me.top;
            endPixel = me.bottom;
            reversePixels = !reversePixels;
          }
          me._startPixel = startPixel;
          me._endPixel = endPixel;
          me._reversePixels = reversePixels;
          me._length = endPixel - startPixel;
          me._alignToPixels = me.options.alignToPixels;
        }
        afterUpdate() {
          callback(this.options.afterUpdate, [this]);
        }
        beforeSetDimensions() {
          callback(this.options.beforeSetDimensions, [this]);
        }
        setDimensions() {
          const me = this;
          if (me.isHorizontal()) {
            me.width = me.maxWidth;
            me.left = 0;
            me.right = me.width;
          } else {
            me.height = me.maxHeight;
            me.top = 0;
            me.bottom = me.height;
          }
          me.paddingLeft = 0;
          me.paddingTop = 0;
          me.paddingRight = 0;
          me.paddingBottom = 0;
        }
        afterSetDimensions() {
          callback(this.options.afterSetDimensions, [this]);
        }
        _callHooks(name2) {
          const me = this;
          me.chart.notifyPlugins(name2, me.getContext());
          callback(me.options[name2], [me]);
        }
        beforeDataLimits() {
          this._callHooks("beforeDataLimits");
        }
        determineDataLimits() {
        }
        afterDataLimits() {
          this._callHooks("afterDataLimits");
        }
        beforeBuildTicks() {
          this._callHooks("beforeBuildTicks");
        }
        buildTicks() {
          return [];
        }
        afterBuildTicks() {
          this._callHooks("afterBuildTicks");
        }
        beforeTickToLabelConversion() {
          callback(this.options.beforeTickToLabelConversion, [this]);
        }
        generateTickLabels(ticks) {
          const me = this;
          const tickOpts = me.options.ticks;
          let i, ilen, tick;
          for (i = 0, ilen = ticks.length; i < ilen; i++) {
            tick = ticks[i];
            tick.label = callback(tickOpts.callback, [tick.value, i, ticks], me);
          }
        }
        afterTickToLabelConversion() {
          callback(this.options.afterTickToLabelConversion, [this]);
        }
        beforeCalculateLabelRotation() {
          callback(this.options.beforeCalculateLabelRotation, [this]);
        }
        calculateLabelRotation() {
          const me = this;
          const options2 = me.options;
          const tickOpts = options2.ticks;
          const numTicks = me.ticks.length;
          const minRotation = tickOpts.minRotation || 0;
          const maxRotation = tickOpts.maxRotation;
          let labelRotation = minRotation;
          let tickWidth, maxHeight, maxLabelDiagonal;
          if (!me._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !me.isHorizontal()) {
            me.labelRotation = minRotation;
            return;
          }
          const labelSizes = me._getLabelSizes();
          const maxLabelWidth = labelSizes.widest.width;
          const maxLabelHeight = labelSizes.highest.height;
          const maxWidth = _limitValue(me.chart.width - maxLabelWidth, 0, me.maxWidth);
          tickWidth = options2.offset ? me.maxWidth / numTicks : maxWidth / (numTicks - 1);
          if (maxLabelWidth + 6 > tickWidth) {
            tickWidth = maxWidth / (numTicks - (options2.offset ? 0.5 : 1));
            maxHeight = me.maxHeight - getTickMarkLength(options2.grid) - tickOpts.padding - getTitleHeight(options2.title, me.chart.options.font);
            maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
            labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
            labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
          }
          me.labelRotation = labelRotation;
        }
        afterCalculateLabelRotation() {
          callback(this.options.afterCalculateLabelRotation, [this]);
        }
        beforeFit() {
          callback(this.options.beforeFit, [this]);
        }
        fit() {
          const me = this;
          const minSize = {
            width: 0,
            height: 0
          };
          const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = me;
          const display = me._isVisible();
          const isHorizontal = me.isHorizontal();
          if (display) {
            const titleHeight = getTitleHeight(titleOpts, chart.options.font);
            if (isHorizontal) {
              minSize.width = me.maxWidth;
              minSize.height = getTickMarkLength(gridOpts) + titleHeight;
            } else {
              minSize.height = me.maxHeight;
              minSize.width = getTickMarkLength(gridOpts) + titleHeight;
            }
            if (tickOpts.display && me.ticks.length) {
              const { first, last, widest, highest } = me._getLabelSizes();
              const tickPadding = tickOpts.padding * 2;
              const angleRadians = toRadians(me.labelRotation);
              const cos = Math.cos(angleRadians);
              const sin = Math.sin(angleRadians);
              if (isHorizontal) {
                const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
                minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);
              } else {
                const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
                minSize.width = Math.min(me.maxWidth, minSize.width + labelWidth + tickPadding);
              }
              me._calculatePadding(first, last, sin, cos);
            }
          }
          me._handleMargins();
          if (isHorizontal) {
            me.width = me._length = chart.width - me._margins.left - me._margins.right;
            me.height = minSize.height;
          } else {
            me.width = minSize.width;
            me.height = me._length = chart.height - me._margins.top - me._margins.bottom;
          }
        }
        _calculatePadding(first, last, sin, cos) {
          const me = this;
          const { ticks: { align, padding }, position } = me.options;
          const isRotated = me.labelRotation !== 0;
          const labelsBelowTicks = position !== "top" && me.axis === "x";
          if (me.isHorizontal()) {
            const offsetLeft = me.getPixelForTick(0) - me.left;
            const offsetRight = me.right - me.getPixelForTick(me.ticks.length - 1);
            let paddingLeft = 0;
            let paddingRight = 0;
            if (isRotated) {
              if (labelsBelowTicks) {
                paddingLeft = cos * first.width;
                paddingRight = sin * last.height;
              } else {
                paddingLeft = sin * first.height;
                paddingRight = cos * last.width;
              }
            } else if (align === "start") {
              paddingRight = last.width;
            } else if (align === "end") {
              paddingLeft = first.width;
            } else {
              paddingLeft = first.width / 2;
              paddingRight = last.width / 2;
            }
            me.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * me.width / (me.width - offsetLeft), 0);
            me.paddingRight = Math.max((paddingRight - offsetRight + padding) * me.width / (me.width - offsetRight), 0);
          } else {
            let paddingTop = last.height / 2;
            let paddingBottom = first.height / 2;
            if (align === "start") {
              paddingTop = 0;
              paddingBottom = first.height;
            } else if (align === "end") {
              paddingTop = last.height;
              paddingBottom = 0;
            }
            me.paddingTop = paddingTop + padding;
            me.paddingBottom = paddingBottom + padding;
          }
        }
        _handleMargins() {
          const me = this;
          if (me._margins) {
            me._margins.left = Math.max(me.paddingLeft, me._margins.left);
            me._margins.top = Math.max(me.paddingTop, me._margins.top);
            me._margins.right = Math.max(me.paddingRight, me._margins.right);
            me._margins.bottom = Math.max(me.paddingBottom, me._margins.bottom);
          }
        }
        afterFit() {
          callback(this.options.afterFit, [this]);
        }
        isHorizontal() {
          const { axis, position } = this.options;
          return position === "top" || position === "bottom" || axis === "x";
        }
        isFullSize() {
          return this.options.fullSize;
        }
        _convertTicksToLabels(ticks) {
          const me = this;
          me.beforeTickToLabelConversion();
          me.generateTickLabels(ticks);
          let i, ilen;
          for (i = 0, ilen = ticks.length; i < ilen; i++) {
            if (isNullOrUndef(ticks[i].label)) {
              ticks.splice(i, 1);
              ilen--;
              i--;
            }
          }
          me.afterTickToLabelConversion();
        }
        _getLabelSizes() {
          const me = this;
          let labelSizes = me._labelSizes;
          if (!labelSizes) {
            const sampleSize = me.options.ticks.sampleSize;
            let ticks = me.ticks;
            if (sampleSize < ticks.length) {
              ticks = sample(ticks, sampleSize);
            }
            me._labelSizes = labelSizes = me._computeLabelSizes(ticks, ticks.length);
          }
          return labelSizes;
        }
        _computeLabelSizes(ticks, length) {
          const { ctx, _longestTextCache: caches } = this;
          const widths = [];
          const heights = [];
          let widestLabelSize = 0;
          let highestLabelSize = 0;
          let i, j, jlen, label, tickFont, fontString2, cache, lineHeight, width, height, nestedLabel;
          for (i = 0; i < length; ++i) {
            label = ticks[i].label;
            tickFont = this._resolveTickFontOptions(i);
            ctx.font = fontString2 = tickFont.string;
            cache = caches[fontString2] = caches[fontString2] || { data: {}, gc: [] };
            lineHeight = tickFont.lineHeight;
            width = height = 0;
            if (!isNullOrUndef(label) && !isArray(label)) {
              width = _measureText(ctx, cache.data, cache.gc, width, label);
              height = lineHeight;
            } else if (isArray(label)) {
              for (j = 0, jlen = label.length; j < jlen; ++j) {
                nestedLabel = label[j];
                if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
                  width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
                  height += lineHeight;
                }
              }
            }
            widths.push(width);
            heights.push(height);
            widestLabelSize = Math.max(width, widestLabelSize);
            highestLabelSize = Math.max(height, highestLabelSize);
          }
          garbageCollect(caches, length);
          const widest = widths.indexOf(widestLabelSize);
          const highest = heights.indexOf(highestLabelSize);
          const valueAt = (idx) => ({ width: widths[idx] || 0, height: heights[idx] || 0 });
          return {
            first: valueAt(0),
            last: valueAt(length - 1),
            widest: valueAt(widest),
            highest: valueAt(highest),
            widths,
            heights
          };
        }
        getLabelForValue(value) {
          return value;
        }
        getPixelForValue(value, index2) {
          return NaN;
        }
        getValueForPixel(pixel) {
        }
        getPixelForTick(index2) {
          const ticks = this.ticks;
          if (index2 < 0 || index2 > ticks.length - 1) {
            return null;
          }
          return this.getPixelForValue(ticks[index2].value);
        }
        getPixelForDecimal(decimal) {
          const me = this;
          if (me._reversePixels) {
            decimal = 1 - decimal;
          }
          const pixel = me._startPixel + decimal * me._length;
          return _int16Range(me._alignToPixels ? _alignPixel(me.chart, pixel, 0) : pixel);
        }
        getDecimalForPixel(pixel) {
          const decimal = (pixel - this._startPixel) / this._length;
          return this._reversePixels ? 1 - decimal : decimal;
        }
        getBasePixel() {
          return this.getPixelForValue(this.getBaseValue());
        }
        getBaseValue() {
          const { min, max } = this;
          return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
        }
        getContext(index2) {
          const me = this;
          const ticks = me.ticks || [];
          if (index2 >= 0 && index2 < ticks.length) {
            const tick = ticks[index2];
            return tick.$context || (tick.$context = createTickContext(me.getContext(), index2, tick));
          }
          return me.$context || (me.$context = createScaleContext(me.chart.getContext(), me));
        }
        _tickSize() {
          const me = this;
          const optionTicks = me.options.ticks;
          const rot = toRadians(me.labelRotation);
          const cos = Math.abs(Math.cos(rot));
          const sin = Math.abs(Math.sin(rot));
          const labelSizes = me._getLabelSizes();
          const padding = optionTicks.autoSkipPadding || 0;
          const w = labelSizes ? labelSizes.widest.width + padding : 0;
          const h = labelSizes ? labelSizes.highest.height + padding : 0;
          return me.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
        }
        _isVisible() {
          const display = this.options.display;
          if (display !== "auto") {
            return !!display;
          }
          return this.getMatchingVisibleMetas().length > 0;
        }
        _computeGridLineItems(chartArea) {
          const me = this;
          const axis = me.axis;
          const chart = me.chart;
          const options2 = me.options;
          const { grid, position } = options2;
          const offset = grid.offset;
          const isHorizontal = me.isHorizontal();
          const ticks = me.ticks;
          const ticksLength = ticks.length + (offset ? 1 : 0);
          const tl = getTickMarkLength(grid);
          const items = [];
          const borderOpts = grid.setContext(me.getContext());
          const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;
          const axisHalfWidth = axisWidth / 2;
          const alignBorderValue = function(pixel) {
            return _alignPixel(chart, pixel, axisWidth);
          };
          let borderValue, i, lineValue, alignedLineValue;
          let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
          if (position === "top") {
            borderValue = alignBorderValue(me.bottom);
            ty1 = me.bottom - tl;
            ty2 = borderValue - axisHalfWidth;
            y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
            y2 = chartArea.bottom;
          } else if (position === "bottom") {
            borderValue = alignBorderValue(me.top);
            y1 = chartArea.top;
            y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
            ty1 = borderValue + axisHalfWidth;
            ty2 = me.top + tl;
          } else if (position === "left") {
            borderValue = alignBorderValue(me.right);
            tx1 = me.right - tl;
            tx2 = borderValue - axisHalfWidth;
            x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
            x2 = chartArea.right;
          } else if (position === "right") {
            borderValue = alignBorderValue(me.left);
            x1 = chartArea.left;
            x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
            tx1 = borderValue + axisHalfWidth;
            tx2 = me.left + tl;
          } else if (axis === "x") {
            if (position === "center") {
              borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);
            } else if (isObject2(position)) {
              const positionAxisID = Object.keys(position)[0];
              const value = position[positionAxisID];
              borderValue = alignBorderValue(me.chart.scales[positionAxisID].getPixelForValue(value));
            }
            y1 = chartArea.top;
            y2 = chartArea.bottom;
            ty1 = borderValue + axisHalfWidth;
            ty2 = ty1 + tl;
          } else if (axis === "y") {
            if (position === "center") {
              borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);
            } else if (isObject2(position)) {
              const positionAxisID = Object.keys(position)[0];
              const value = position[positionAxisID];
              borderValue = alignBorderValue(me.chart.scales[positionAxisID].getPixelForValue(value));
            }
            tx1 = borderValue - axisHalfWidth;
            tx2 = tx1 - tl;
            x1 = chartArea.left;
            x2 = chartArea.right;
          }
          const limit = valueOrDefault(options2.ticks.maxTicksLimit, ticksLength);
          const step = Math.max(1, Math.ceil(ticksLength / limit));
          for (i = 0; i < ticksLength; i += step) {
            const optsAtIndex = grid.setContext(me.getContext(i));
            const lineWidth = optsAtIndex.lineWidth;
            const lineColor = optsAtIndex.color;
            const borderDash = grid.borderDash || [];
            const borderDashOffset = optsAtIndex.borderDashOffset;
            const tickWidth = optsAtIndex.tickWidth;
            const tickColor = optsAtIndex.tickColor;
            const tickBorderDash = optsAtIndex.tickBorderDash || [];
            const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
            lineValue = getPixelForGridLine(me, i, offset);
            if (lineValue === void 0) {
              continue;
            }
            alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
            if (isHorizontal) {
              tx1 = tx2 = x1 = x2 = alignedLineValue;
            } else {
              ty1 = ty2 = y1 = y2 = alignedLineValue;
            }
            items.push({
              tx1,
              ty1,
              tx2,
              ty2,
              x1,
              y1,
              x2,
              y2,
              width: lineWidth,
              color: lineColor,
              borderDash,
              borderDashOffset,
              tickWidth,
              tickColor,
              tickBorderDash,
              tickBorderDashOffset
            });
          }
          me._ticksLength = ticksLength;
          me._borderValue = borderValue;
          return items;
        }
        _computeLabelItems(chartArea) {
          const me = this;
          const axis = me.axis;
          const options2 = me.options;
          const { position, ticks: optionTicks } = options2;
          const isHorizontal = me.isHorizontal();
          const ticks = me.ticks;
          const { align, crossAlign, padding, mirror } = optionTicks;
          const tl = getTickMarkLength(options2.grid);
          const tickAndPadding = tl + padding;
          const hTickAndPadding = mirror ? -padding : tickAndPadding;
          const rotation = -toRadians(me.labelRotation);
          const items = [];
          let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
          let textBaseline = "middle";
          if (position === "top") {
            y = me.bottom - hTickAndPadding;
            textAlign = me._getXAxisLabelAlignment();
          } else if (position === "bottom") {
            y = me.top + hTickAndPadding;
            textAlign = me._getXAxisLabelAlignment();
          } else if (position === "left") {
            const ret = me._getYAxisLabelAlignment(tl);
            textAlign = ret.textAlign;
            x = ret.x;
          } else if (position === "right") {
            const ret = me._getYAxisLabelAlignment(tl);
            textAlign = ret.textAlign;
            x = ret.x;
          } else if (axis === "x") {
            if (position === "center") {
              y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
            } else if (isObject2(position)) {
              const positionAxisID = Object.keys(position)[0];
              const value = position[positionAxisID];
              y = me.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
            }
            textAlign = me._getXAxisLabelAlignment();
          } else if (axis === "y") {
            if (position === "center") {
              x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
            } else if (isObject2(position)) {
              const positionAxisID = Object.keys(position)[0];
              const value = position[positionAxisID];
              x = me.chart.scales[positionAxisID].getPixelForValue(value);
            }
            textAlign = me._getYAxisLabelAlignment(tl).textAlign;
          }
          if (axis === "y") {
            if (align === "start") {
              textBaseline = "top";
            } else if (align === "end") {
              textBaseline = "bottom";
            }
          }
          const labelSizes = me._getLabelSizes();
          for (i = 0, ilen = ticks.length; i < ilen; ++i) {
            tick = ticks[i];
            label = tick.label;
            const optsAtIndex = optionTicks.setContext(me.getContext(i));
            pixel = me.getPixelForTick(i) + optionTicks.labelOffset;
            font = me._resolveTickFontOptions(i);
            lineHeight = font.lineHeight;
            lineCount = isArray(label) ? label.length : 1;
            const halfCount = lineCount / 2;
            const color2 = optsAtIndex.color;
            const strokeColor = optsAtIndex.textStrokeColor;
            const strokeWidth = optsAtIndex.textStrokeWidth;
            if (isHorizontal) {
              x = pixel;
              if (position === "top") {
                if (crossAlign === "near" || rotation !== 0) {
                  textOffset = -lineCount * lineHeight + lineHeight / 2;
                } else if (crossAlign === "center") {
                  textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;
                } else {
                  textOffset = -labelSizes.highest.height + lineHeight / 2;
                }
              } else {
                if (crossAlign === "near" || rotation !== 0) {
                  textOffset = lineHeight / 2;
                } else if (crossAlign === "center") {
                  textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;
                } else {
                  textOffset = labelSizes.highest.height - lineCount * lineHeight;
                }
              }
              if (mirror) {
                textOffset *= -1;
              }
            } else {
              y = pixel;
              textOffset = (1 - lineCount) * lineHeight / 2;
            }
            let backdrop;
            if (optsAtIndex.showLabelBackdrop) {
              const labelPadding = toPadding(optsAtIndex.backdropPadding);
              const height = labelSizes.heights[i];
              const width = labelSizes.widths[i];
              let top = y + textOffset - labelPadding.top;
              let left = x - labelPadding.left;
              switch (textBaseline) {
                case "middle":
                  top -= height / 2;
                  break;
                case "bottom":
                  top -= height;
                  break;
              }
              switch (textAlign) {
                case "center":
                  left -= width / 2;
                  break;
                case "right":
                  left -= width;
                  break;
              }
              backdrop = {
                left,
                top,
                width: width + labelPadding.width,
                height: height + labelPadding.height,
                color: optsAtIndex.backdropColor
              };
            }
            items.push({
              rotation,
              label,
              font,
              color: color2,
              strokeColor,
              strokeWidth,
              textOffset,
              textAlign,
              textBaseline,
              translation: [x, y],
              backdrop
            });
          }
          return items;
        }
        _getXAxisLabelAlignment() {
          const me = this;
          const { position, ticks } = me.options;
          const rotation = -toRadians(me.labelRotation);
          if (rotation) {
            return position === "top" ? "left" : "right";
          }
          let align = "center";
          if (ticks.align === "start") {
            align = "left";
          } else if (ticks.align === "end") {
            align = "right";
          }
          return align;
        }
        _getYAxisLabelAlignment(tl) {
          const me = this;
          const { position, ticks: { crossAlign, mirror, padding } } = me.options;
          const labelSizes = me._getLabelSizes();
          const tickAndPadding = tl + padding;
          const widest = labelSizes.widest.width;
          let textAlign;
          let x;
          if (position === "left") {
            if (mirror) {
              x = me.right + padding;
              if (crossAlign === "near") {
                textAlign = "left";
              } else if (crossAlign === "center") {
                textAlign = "center";
                x += widest / 2;
              } else {
                textAlign = "right";
                x += widest;
              }
            } else {
              x = me.right - tickAndPadding;
              if (crossAlign === "near") {
                textAlign = "right";
              } else if (crossAlign === "center") {
                textAlign = "center";
                x -= widest / 2;
              } else {
                textAlign = "left";
                x = me.left;
              }
            }
          } else if (position === "right") {
            if (mirror) {
              x = me.left + padding;
              if (crossAlign === "near") {
                textAlign = "right";
              } else if (crossAlign === "center") {
                textAlign = "center";
                x -= widest / 2;
              } else {
                textAlign = "left";
                x -= widest;
              }
            } else {
              x = me.left + tickAndPadding;
              if (crossAlign === "near") {
                textAlign = "left";
              } else if (crossAlign === "center") {
                textAlign = "center";
                x += widest / 2;
              } else {
                textAlign = "right";
                x = me.right;
              }
            }
          } else {
            textAlign = "right";
          }
          return { textAlign, x };
        }
        _computeLabelArea() {
          const me = this;
          if (me.options.ticks.mirror) {
            return;
          }
          const chart = me.chart;
          const position = me.options.position;
          if (position === "left" || position === "right") {
            return { top: 0, left: me.left, bottom: chart.height, right: me.right };
          }
          if (position === "top" || position === "bottom") {
            return { top: me.top, left: 0, bottom: me.bottom, right: chart.width };
          }
        }
        drawBackground() {
          const { ctx, options: { backgroundColor }, left, top, width, height } = this;
          if (backgroundColor) {
            ctx.save();
            ctx.fillStyle = backgroundColor;
            ctx.fillRect(left, top, width, height);
            ctx.restore();
          }
        }
        getLineWidthForValue(value) {
          const me = this;
          const grid = me.options.grid;
          if (!me._isVisible() || !grid.display) {
            return 0;
          }
          const ticks = me.ticks;
          const index2 = ticks.findIndex((t) => t.value === value);
          if (index2 >= 0) {
            const opts = grid.setContext(me.getContext(index2));
            return opts.lineWidth;
          }
          return 0;
        }
        drawGrid(chartArea) {
          const me = this;
          const grid = me.options.grid;
          const ctx = me.ctx;
          const items = me._gridLineItems || (me._gridLineItems = me._computeGridLineItems(chartArea));
          let i, ilen;
          const drawLine = (p1, p2, style) => {
            if (!style.width || !style.color) {
              return;
            }
            ctx.save();
            ctx.lineWidth = style.width;
            ctx.strokeStyle = style.color;
            ctx.setLineDash(style.borderDash || []);
            ctx.lineDashOffset = style.borderDashOffset;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
            ctx.restore();
          };
          if (grid.display) {
            for (i = 0, ilen = items.length; i < ilen; ++i) {
              const item = items[i];
              if (grid.drawOnChartArea) {
                drawLine({ x: item.x1, y: item.y1 }, { x: item.x2, y: item.y2 }, item);
              }
              if (grid.drawTicks) {
                drawLine({ x: item.tx1, y: item.ty1 }, { x: item.tx2, y: item.ty2 }, {
                  color: item.tickColor,
                  width: item.tickWidth,
                  borderDash: item.tickBorderDash,
                  borderDashOffset: item.tickBorderDashOffset
                });
              }
            }
          }
        }
        drawBorder() {
          const me = this;
          const { chart, ctx, options: { grid } } = me;
          const borderOpts = grid.setContext(me.getContext());
          const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;
          if (!axisWidth) {
            return;
          }
          const lastLineWidth = grid.setContext(me.getContext(0)).lineWidth;
          const borderValue = me._borderValue;
          let x1, x2, y1, y2;
          if (me.isHorizontal()) {
            x1 = _alignPixel(chart, me.left, axisWidth) - axisWidth / 2;
            x2 = _alignPixel(chart, me.right, lastLineWidth) + lastLineWidth / 2;
            y1 = y2 = borderValue;
          } else {
            y1 = _alignPixel(chart, me.top, axisWidth) - axisWidth / 2;
            y2 = _alignPixel(chart, me.bottom, lastLineWidth) + lastLineWidth / 2;
            x1 = x2 = borderValue;
          }
          ctx.save();
          ctx.lineWidth = borderOpts.borderWidth;
          ctx.strokeStyle = borderOpts.borderColor;
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
          ctx.restore();
        }
        drawLabels(chartArea) {
          const me = this;
          const optionTicks = me.options.ticks;
          if (!optionTicks.display) {
            return;
          }
          const ctx = me.ctx;
          const area = me._computeLabelArea();
          if (area) {
            clipArea(ctx, area);
          }
          const items = me._labelItems || (me._labelItems = me._computeLabelItems(chartArea));
          let i, ilen;
          for (i = 0, ilen = items.length; i < ilen; ++i) {
            const item = items[i];
            const tickFont = item.font;
            const label = item.label;
            if (item.backdrop) {
              ctx.fillStyle = item.backdrop.color;
              ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);
            }
            let y = item.textOffset;
            renderText(ctx, label, 0, y, tickFont, item);
          }
          if (area) {
            unclipArea(ctx);
          }
        }
        drawTitle() {
          const { ctx, options: { position, title, reverse } } = this;
          if (!title.display) {
            return;
          }
          const font = toFont(title.font);
          const padding = toPadding(title.padding);
          const align = title.align;
          let offset = font.lineHeight / 2;
          if (position === "bottom" || position === "center" || isObject2(position)) {
            offset += padding.bottom;
            if (isArray(title.text)) {
              offset += font.lineHeight * (title.text.length - 1);
            }
          } else {
            offset += padding.top;
          }
          const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);
          renderText(ctx, title.text, 0, 0, font, {
            color: title.color,
            maxWidth,
            rotation,
            textAlign: titleAlign(align, position, reverse),
            textBaseline: "middle",
            translation: [titleX, titleY]
          });
        }
        draw(chartArea) {
          const me = this;
          if (!me._isVisible()) {
            return;
          }
          me.drawBackground();
          me.drawGrid(chartArea);
          me.drawBorder();
          me.drawTitle();
          me.drawLabels(chartArea);
        }
        _layers() {
          const me = this;
          const opts = me.options;
          const tz = opts.ticks && opts.ticks.z || 0;
          const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
          if (!me._isVisible() || me.draw !== Scale.prototype.draw) {
            return [{
              z: tz,
              draw(chartArea) {
                me.draw(chartArea);
              }
            }];
          }
          return [{
            z: gz,
            draw(chartArea) {
              me.drawBackground();
              me.drawGrid(chartArea);
              me.drawTitle();
            }
          }, {
            z: gz + 1,
            draw() {
              me.drawBorder();
            }
          }, {
            z: tz,
            draw(chartArea) {
              me.drawLabels(chartArea);
            }
          }];
        }
        getMatchingVisibleMetas(type) {
          const me = this;
          const metas = me.chart.getSortedVisibleDatasetMetas();
          const axisID = me.axis + "AxisID";
          const result = [];
          let i, ilen;
          for (i = 0, ilen = metas.length; i < ilen; ++i) {
            const meta = metas[i];
            if (meta[axisID] === me.id && (!type || meta.type === type)) {
              result.push(meta);
            }
          }
          return result;
        }
        _resolveTickFontOptions(index2) {
          const opts = this.options.ticks.setContext(this.getContext(index2));
          return toFont(opts.font);
        }
        _maxDigits() {
          const me = this;
          const fontSize = me._resolveTickFontOptions(0).lineHeight;
          return (me.isHorizontal() ? me.width : me.height) / fontSize;
        }
      }
      class TypedRegistry {
        constructor(type, scope, override) {
          this.type = type;
          this.scope = scope;
          this.override = override;
          this.items = Object.create(null);
        }
        isForType(type) {
          return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
        }
        register(item) {
          const me = this;
          const proto = Object.getPrototypeOf(item);
          let parentScope;
          if (isIChartComponent(proto)) {
            parentScope = me.register(proto);
          }
          const items = me.items;
          const id = item.id;
          const scope = me.scope + "." + id;
          if (!id) {
            throw new Error("class does not have id: " + item);
          }
          if (id in items) {
            return scope;
          }
          items[id] = item;
          registerDefaults(item, scope, parentScope);
          if (me.override) {
            defaults.override(item.id, item.overrides);
          }
          return scope;
        }
        get(id) {
          return this.items[id];
        }
        unregister(item) {
          const items = this.items;
          const id = item.id;
          const scope = this.scope;
          if (id in items) {
            delete items[id];
          }
          if (scope && id in defaults[scope]) {
            delete defaults[scope][id];
            if (this.override) {
              delete overrides[id];
            }
          }
        }
      }
      function registerDefaults(item, scope, parentScope) {
        const itemDefaults = merge(Object.create(null), [
          parentScope ? defaults.get(parentScope) : {},
          defaults.get(scope),
          item.defaults
        ]);
        defaults.set(scope, itemDefaults);
        if (item.defaultRoutes) {
          routeDefaults(scope, item.defaultRoutes);
        }
        if (item.descriptors) {
          defaults.describe(scope, item.descriptors);
        }
      }
      function routeDefaults(scope, routes) {
        Object.keys(routes).forEach((property) => {
          const propertyParts = property.split(".");
          const sourceName = propertyParts.pop();
          const sourceScope = [scope].concat(propertyParts).join(".");
          const parts = routes[property].split(".");
          const targetName = parts.pop();
          const targetScope = parts.join(".");
          defaults.route(sourceScope, sourceName, targetScope, targetName);
        });
      }
      function isIChartComponent(proto) {
        return "id" in proto && "defaults" in proto;
      }
      class Registry {
        constructor() {
          this.controllers = new TypedRegistry(DatasetController, "datasets", true);
          this.elements = new TypedRegistry(Element, "elements");
          this.plugins = new TypedRegistry(Object, "plugins");
          this.scales = new TypedRegistry(Scale, "scales");
          this._typedRegistries = [this.controllers, this.scales, this.elements];
        }
        add(...args) {
          this._each("register", args);
        }
        remove(...args) {
          this._each("unregister", args);
        }
        addControllers(...args) {
          this._each("register", args, this.controllers);
        }
        addElements(...args) {
          this._each("register", args, this.elements);
        }
        addPlugins(...args) {
          this._each("register", args, this.plugins);
        }
        addScales(...args) {
          this._each("register", args, this.scales);
        }
        getController(id) {
          return this._get(id, this.controllers, "controller");
        }
        getElement(id) {
          return this._get(id, this.elements, "element");
        }
        getPlugin(id) {
          return this._get(id, this.plugins, "plugin");
        }
        getScale(id) {
          return this._get(id, this.scales, "scale");
        }
        removeControllers(...args) {
          this._each("unregister", args, this.controllers);
        }
        removeElements(...args) {
          this._each("unregister", args, this.elements);
        }
        removePlugins(...args) {
          this._each("unregister", args, this.plugins);
        }
        removeScales(...args) {
          this._each("unregister", args, this.scales);
        }
        _each(method, args, typedRegistry) {
          const me = this;
          [...args].forEach((arg) => {
            const reg = typedRegistry || me._getRegistryForType(arg);
            if (typedRegistry || reg.isForType(arg) || reg === me.plugins && arg.id) {
              me._exec(method, reg, arg);
            } else {
              each2(arg, (item) => {
                const itemReg = typedRegistry || me._getRegistryForType(item);
                me._exec(method, itemReg, item);
              });
            }
          });
        }
        _exec(method, registry2, component) {
          const camelMethod = _capitalize(method);
          callback(component["before" + camelMethod], [], component);
          registry2[method](component);
          callback(component["after" + camelMethod], [], component);
        }
        _getRegistryForType(type) {
          for (let i = 0; i < this._typedRegistries.length; i++) {
            const reg = this._typedRegistries[i];
            if (reg.isForType(type)) {
              return reg;
            }
          }
          return this.plugins;
        }
        _get(id, typedRegistry, type) {
          const item = typedRegistry.get(id);
          if (item === void 0) {
            throw new Error('"' + id + '" is not a registered ' + type + ".");
          }
          return item;
        }
      }
      var registry = new Registry();
      class PluginService {
        constructor() {
          this._init = [];
        }
        notify(chart, hook, args, filter2) {
          const me = this;
          if (hook === "beforeInit") {
            me._init = me._createDescriptors(chart, true);
            me._notify(me._init, chart, "install");
          }
          const descriptors2 = filter2 ? me._descriptors(chart).filter(filter2) : me._descriptors(chart);
          const result = me._notify(descriptors2, chart, hook, args);
          if (hook === "destroy") {
            me._notify(descriptors2, chart, "stop");
            me._notify(me._init, chart, "uninstall");
          }
          return result;
        }
        _notify(descriptors2, chart, hook, args) {
          args = args || {};
          for (const descriptor of descriptors2) {
            const plugin = descriptor.plugin;
            const method = plugin[hook];
            const params = [chart, args, descriptor.options];
            if (callback(method, params, plugin) === false && args.cancelable) {
              return false;
            }
          }
          return true;
        }
        invalidate() {
          if (!isNullOrUndef(this._cache)) {
            this._oldCache = this._cache;
            this._cache = void 0;
          }
        }
        _descriptors(chart) {
          if (this._cache) {
            return this._cache;
          }
          const descriptors2 = this._cache = this._createDescriptors(chart);
          this._notifyStateChanges(chart);
          return descriptors2;
        }
        _createDescriptors(chart, all) {
          const config2 = chart && chart.config;
          const options2 = valueOrDefault(config2.options && config2.options.plugins, {});
          const plugins2 = allPlugins(config2);
          return options2 === false && !all ? [] : createDescriptors(chart, plugins2, options2, all);
        }
        _notifyStateChanges(chart) {
          const previousDescriptors = this._oldCache || [];
          const descriptors2 = this._cache;
          const diff = (a, b) => a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
          this._notify(diff(previousDescriptors, descriptors2), chart, "stop");
          this._notify(diff(descriptors2, previousDescriptors), chart, "start");
        }
      }
      function allPlugins(config2) {
        const plugins2 = [];
        const keys = Object.keys(registry.plugins.items);
        for (let i = 0; i < keys.length; i++) {
          plugins2.push(registry.getPlugin(keys[i]));
        }
        const local = config2.plugins || [];
        for (let i = 0; i < local.length; i++) {
          const plugin = local[i];
          if (plugins2.indexOf(plugin) === -1) {
            plugins2.push(plugin);
          }
        }
        return plugins2;
      }
      function getOpts(options2, all) {
        if (!all && options2 === false) {
          return null;
        }
        if (options2 === true) {
          return {};
        }
        return options2;
      }
      function createDescriptors(chart, plugins2, options2, all) {
        const result = [];
        const context = chart.getContext();
        for (let i = 0; i < plugins2.length; i++) {
          const plugin = plugins2[i];
          const id = plugin.id;
          const opts = getOpts(options2[id], all);
          if (opts === null) {
            continue;
          }
          result.push({
            plugin,
            options: pluginOpts(chart.config, plugin, opts, context)
          });
        }
        return result;
      }
      function pluginOpts(config2, plugin, opts, context) {
        const keys = config2.pluginScopeKeys(plugin);
        const scopes = config2.getOptionScopes(opts, keys);
        return config2.createResolver(scopes, context, [""], { scriptable: false, indexable: false, allKeys: true });
      }
      function getIndexAxis(type, options2) {
        const datasetDefaults = defaults.datasets[type] || {};
        const datasetOptions = (options2.datasets || {})[type] || {};
        return datasetOptions.indexAxis || options2.indexAxis || datasetDefaults.indexAxis || "x";
      }
      function getAxisFromDefaultScaleID(id, indexAxis) {
        let axis = id;
        if (id === "_index_") {
          axis = indexAxis;
        } else if (id === "_value_") {
          axis = indexAxis === "x" ? "y" : "x";
        }
        return axis;
      }
      function getDefaultScaleIDFromAxis(axis, indexAxis) {
        return axis === indexAxis ? "_index_" : "_value_";
      }
      function axisFromPosition(position) {
        if (position === "top" || position === "bottom") {
          return "x";
        }
        if (position === "left" || position === "right") {
          return "y";
        }
      }
      function determineAxis(id, scaleOptions) {
        if (id === "x" || id === "y") {
          return id;
        }
        return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();
      }
      function mergeScaleConfig(config2, options2) {
        const chartDefaults = overrides[config2.type] || { scales: {} };
        const configScales = options2.scales || {};
        const chartIndexAxis = getIndexAxis(config2.type, options2);
        const firstIDs = Object.create(null);
        const scales2 = Object.create(null);
        Object.keys(configScales).forEach((id) => {
          const scaleConf = configScales[id];
          const axis = determineAxis(id, scaleConf);
          const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
          const defaultScaleOptions = chartDefaults.scales || {};
          firstIDs[axis] = firstIDs[axis] || id;
          scales2[id] = mergeIf(Object.create(null), [{ axis }, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);
        });
        config2.data.datasets.forEach((dataset) => {
          const type = dataset.type || config2.type;
          const indexAxis = dataset.indexAxis || getIndexAxis(type, options2);
          const datasetDefaults = overrides[type] || {};
          const defaultScaleOptions = datasetDefaults.scales || {};
          Object.keys(defaultScaleOptions).forEach((defaultID) => {
            const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
            const id = dataset[axis + "AxisID"] || firstIDs[axis] || axis;
            scales2[id] = scales2[id] || Object.create(null);
            mergeIf(scales2[id], [{ axis }, configScales[id], defaultScaleOptions[defaultID]]);
          });
        });
        Object.keys(scales2).forEach((key) => {
          const scale = scales2[key];
          mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);
        });
        return scales2;
      }
      function initOptions(config2) {
        const options2 = config2.options || (config2.options = {});
        options2.plugins = valueOrDefault(options2.plugins, {});
        options2.scales = mergeScaleConfig(config2, options2);
      }
      function initData(data) {
        data = data || {};
        data.datasets = data.datasets || [];
        data.labels = data.labels || [];
        return data;
      }
      function initConfig(config2) {
        config2 = config2 || {};
        config2.data = initData(config2.data);
        initOptions(config2);
        return config2;
      }
      const keyCache = new Map();
      const keysCached = new Set();
      function cachedKeys(cacheKey, generate) {
        let keys = keyCache.get(cacheKey);
        if (!keys) {
          keys = generate();
          keyCache.set(cacheKey, keys);
          keysCached.add(keys);
        }
        return keys;
      }
      const addIfFound = (set3, obj, key) => {
        const opts = resolveObjectKey(obj, key);
        if (opts !== void 0) {
          set3.add(opts);
        }
      };
      class Config {
        constructor(config2) {
          this._config = initConfig(config2);
          this._scopeCache = new Map();
          this._resolverCache = new Map();
        }
        get platform() {
          return this._config.platform;
        }
        get type() {
          return this._config.type;
        }
        set type(type) {
          this._config.type = type;
        }
        get data() {
          return this._config.data;
        }
        set data(data) {
          this._config.data = initData(data);
        }
        get options() {
          return this._config.options;
        }
        set options(options2) {
          this._config.options = options2;
        }
        get plugins() {
          return this._config.plugins;
        }
        update() {
          const config2 = this._config;
          this.clearCache();
          initOptions(config2);
        }
        clearCache() {
          this._scopeCache.clear();
          this._resolverCache.clear();
        }
        datasetScopeKeys(datasetType) {
          return cachedKeys(datasetType, () => [[
            `datasets.${datasetType}`,
            ""
          ]]);
        }
        datasetAnimationScopeKeys(datasetType, transition) {
          return cachedKeys(`${datasetType}.transition.${transition}`, () => [
            [
              `datasets.${datasetType}.transitions.${transition}`,
              `transitions.${transition}`
            ],
            [
              `datasets.${datasetType}`,
              ""
            ]
          ]);
        }
        datasetElementScopeKeys(datasetType, elementType) {
          return cachedKeys(`${datasetType}-${elementType}`, () => [[
            `datasets.${datasetType}.elements.${elementType}`,
            `datasets.${datasetType}`,
            `elements.${elementType}`,
            ""
          ]]);
        }
        pluginScopeKeys(plugin) {
          const id = plugin.id;
          const type = this.type;
          return cachedKeys(`${type}-plugin-${id}`, () => [[
            `plugins.${id}`,
            ...plugin.additionalOptionScopes || []
          ]]);
        }
        _cachedScopes(mainScope, resetCache) {
          const _scopeCache = this._scopeCache;
          let cache = _scopeCache.get(mainScope);
          if (!cache || resetCache) {
            cache = new Map();
            _scopeCache.set(mainScope, cache);
          }
          return cache;
        }
        getOptionScopes(mainScope, keyLists, resetCache) {
          const { options: options2, type } = this;
          const cache = this._cachedScopes(mainScope, resetCache);
          const cached = cache.get(keyLists);
          if (cached) {
            return cached;
          }
          const scopes = new Set();
          keyLists.forEach((keys) => {
            if (mainScope) {
              scopes.add(mainScope);
              keys.forEach((key) => addIfFound(scopes, mainScope, key));
            }
            keys.forEach((key) => addIfFound(scopes, options2, key));
            keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));
            keys.forEach((key) => addIfFound(scopes, defaults, key));
            keys.forEach((key) => addIfFound(scopes, descriptors, key));
          });
          const array = Array.from(scopes);
          if (array.length === 0) {
            array.push(Object.create(null));
          }
          if (keysCached.has(keyLists)) {
            cache.set(keyLists, array);
          }
          return array;
        }
        chartOptionScopes() {
          const { options: options2, type } = this;
          return [
            options2,
            overrides[type] || {},
            defaults.datasets[type] || {},
            { type },
            defaults,
            descriptors
          ];
        }
        resolveNamedOptions(scopes, names2, context, prefixes = [""]) {
          const result = { $shared: true };
          const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);
          let options2 = resolver;
          if (needContext(resolver, names2)) {
            result.$shared = false;
            context = isFunction(context) ? context() : context;
            const subResolver = this.createResolver(scopes, context, subPrefixes);
            options2 = _attachContext(resolver, context, subResolver);
          }
          for (const prop of names2) {
            result[prop] = options2[prop];
          }
          return result;
        }
        createResolver(scopes, context, prefixes = [""], descriptorDefaults) {
          const { resolver } = getResolver(this._resolverCache, scopes, prefixes);
          return isObject2(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
        }
      }
      function getResolver(resolverCache, scopes, prefixes) {
        let cache = resolverCache.get(scopes);
        if (!cache) {
          cache = new Map();
          resolverCache.set(scopes, cache);
        }
        const cacheKey = prefixes.join();
        let cached = cache.get(cacheKey);
        if (!cached) {
          const resolver = _createResolver(scopes, prefixes);
          cached = {
            resolver,
            subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes("hover"))
          };
          cache.set(cacheKey, cached);
        }
        return cached;
      }
      function needContext(proxy, names2) {
        const { isScriptable, isIndexable } = _descriptors(proxy);
        for (const prop of names2) {
          if (isScriptable(prop) && isFunction(proxy[prop]) || isIndexable(prop) && isArray(proxy[prop])) {
            return true;
          }
        }
        return false;
      }
      var version2 = "3.5.1";
      const KNOWN_POSITIONS = ["top", "bottom", "left", "right", "chartArea"];
      function positionIsHorizontal(position, axis) {
        return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
      }
      function compare2Level(l1, l2) {
        return function(a, b) {
          return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
        };
      }
      function onAnimationsComplete(context) {
        const chart = context.chart;
        const animationOptions2 = chart.options.animation;
        chart.notifyPlugins("afterRender");
        callback(animationOptions2 && animationOptions2.onComplete, [context], chart);
      }
      function onAnimationProgress(context) {
        const chart = context.chart;
        const animationOptions2 = chart.options.animation;
        callback(animationOptions2 && animationOptions2.onProgress, [context], chart);
      }
      function getCanvas(item) {
        if (_isDomSupported() && typeof item === "string") {
          item = document.getElementById(item);
        } else if (item && item.length) {
          item = item[0];
        }
        if (item && item.canvas) {
          item = item.canvas;
        }
        return item;
      }
      const instances = {};
      const getChart = (key) => {
        const canvas = getCanvas(key);
        return Object.values(instances).filter((c) => c.canvas === canvas).pop();
      };
      class Chart {
        constructor(item, userConfig) {
          const me = this;
          const config2 = this.config = new Config(userConfig);
          const initialCanvas = getCanvas(item);
          const existingChart = getChart(initialCanvas);
          if (existingChart) {
            throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "' must be destroyed before the canvas can be reused.");
          }
          const options2 = config2.createResolver(config2.chartOptionScopes(), me.getContext());
          this.platform = new (config2.platform || _detectPlatform(initialCanvas))();
          const context = me.platform.acquireContext(initialCanvas, options2.aspectRatio);
          const canvas = context && context.canvas;
          const height = canvas && canvas.height;
          const width = canvas && canvas.width;
          this.id = uid();
          this.ctx = context;
          this.canvas = canvas;
          this.width = width;
          this.height = height;
          this._options = options2;
          this._aspectRatio = this.aspectRatio;
          this._layers = [];
          this._metasets = [];
          this._stacks = void 0;
          this.boxes = [];
          this.currentDevicePixelRatio = void 0;
          this.chartArea = void 0;
          this._active = [];
          this._lastEvent = void 0;
          this._listeners = {};
          this._responsiveListeners = void 0;
          this._sortedMetasets = [];
          this.scales = {};
          this._plugins = new PluginService();
          this.$proxies = {};
          this._hiddenIndices = {};
          this.attached = false;
          this._animationsDisabled = void 0;
          this.$context = void 0;
          this._doResize = debounce(() => this.update("resize"), options2.resizeDelay || 0);
          instances[me.id] = me;
          if (!context || !canvas) {
            console.error("Failed to create chart: can't acquire context from the given item");
            return;
          }
          animator.listen(me, "complete", onAnimationsComplete);
          animator.listen(me, "progress", onAnimationProgress);
          me._initialize();
          if (me.attached) {
            me.update();
          }
        }
        get aspectRatio() {
          const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;
          if (!isNullOrUndef(aspectRatio)) {
            return aspectRatio;
          }
          if (maintainAspectRatio && _aspectRatio) {
            return _aspectRatio;
          }
          return height ? width / height : null;
        }
        get data() {
          return this.config.data;
        }
        set data(data) {
          this.config.data = data;
        }
        get options() {
          return this._options;
        }
        set options(options2) {
          this.config.options = options2;
        }
        _initialize() {
          const me = this;
          me.notifyPlugins("beforeInit");
          if (me.options.responsive) {
            me.resize();
          } else {
            retinaScale(me, me.options.devicePixelRatio);
          }
          me.bindEvents();
          me.notifyPlugins("afterInit");
          return me;
        }
        clear() {
          clearCanvas(this.canvas, this.ctx);
          return this;
        }
        stop() {
          animator.stop(this);
          return this;
        }
        resize(width, height) {
          if (!animator.running(this)) {
            this._resize(width, height);
          } else {
            this._resizeBeforeDraw = { width, height };
          }
        }
        _resize(width, height) {
          const me = this;
          const options2 = me.options;
          const canvas = me.canvas;
          const aspectRatio = options2.maintainAspectRatio && me.aspectRatio;
          const newSize = me.platform.getMaximumSize(canvas, width, height, aspectRatio);
          const newRatio = options2.devicePixelRatio || me.platform.getDevicePixelRatio();
          me.width = newSize.width;
          me.height = newSize.height;
          me._aspectRatio = me.aspectRatio;
          if (!retinaScale(me, newRatio, true)) {
            return;
          }
          me.notifyPlugins("resize", { size: newSize });
          callback(options2.onResize, [me, newSize], me);
          if (me.attached) {
            if (me._doResize()) {
              me.render();
            }
          }
        }
        ensureScalesHaveIDs() {
          const options2 = this.options;
          const scalesOptions = options2.scales || {};
          each2(scalesOptions, (axisOptions, axisID) => {
            axisOptions.id = axisID;
          });
        }
        buildOrUpdateScales() {
          const me = this;
          const options2 = me.options;
          const scaleOpts = options2.scales;
          const scales2 = me.scales;
          const updated = Object.keys(scales2).reduce((obj, id) => {
            obj[id] = false;
            return obj;
          }, {});
          let items = [];
          if (scaleOpts) {
            items = items.concat(Object.keys(scaleOpts).map((id) => {
              const scaleOptions = scaleOpts[id];
              const axis = determineAxis(id, scaleOptions);
              const isRadial = axis === "r";
              const isHorizontal = axis === "x";
              return {
                options: scaleOptions,
                dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
                dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
              };
            }));
          }
          each2(items, (item) => {
            const scaleOptions = item.options;
            const id = scaleOptions.id;
            const axis = determineAxis(id, scaleOptions);
            const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
            if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {
              scaleOptions.position = item.dposition;
            }
            updated[id] = true;
            let scale = null;
            if (id in scales2 && scales2[id].type === scaleType) {
              scale = scales2[id];
            } else {
              const scaleClass = registry.getScale(scaleType);
              scale = new scaleClass({
                id,
                type: scaleType,
                ctx: me.ctx,
                chart: me
              });
              scales2[scale.id] = scale;
            }
            scale.init(scaleOptions, options2);
          });
          each2(updated, (hasUpdated, id) => {
            if (!hasUpdated) {
              delete scales2[id];
            }
          });
          each2(scales2, (scale) => {
            layouts.configure(me, scale, scale.options);
            layouts.addBox(me, scale);
          });
        }
        _updateMetasets() {
          const me = this;
          const metasets = me._metasets;
          const numData = me.data.datasets.length;
          const numMeta = metasets.length;
          metasets.sort((a, b) => a.index - b.index);
          if (numMeta > numData) {
            for (let i = numData; i < numMeta; ++i) {
              me._destroyDatasetMeta(i);
            }
            metasets.splice(numData, numMeta - numData);
          }
          me._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
        }
        _removeUnreferencedMetasets() {
          const me = this;
          const { _metasets: metasets, data: { datasets } } = me;
          if (metasets.length > datasets.length) {
            delete me._stacks;
          }
          metasets.forEach((meta, index2) => {
            if (datasets.filter((x) => x === meta._dataset).length === 0) {
              me._destroyDatasetMeta(index2);
            }
          });
        }
        buildOrUpdateControllers() {
          const me = this;
          const newControllers = [];
          const datasets = me.data.datasets;
          let i, ilen;
          me._removeUnreferencedMetasets();
          for (i = 0, ilen = datasets.length; i < ilen; i++) {
            const dataset = datasets[i];
            let meta = me.getDatasetMeta(i);
            const type = dataset.type || me.config.type;
            if (meta.type && meta.type !== type) {
              me._destroyDatasetMeta(i);
              meta = me.getDatasetMeta(i);
            }
            meta.type = type;
            meta.indexAxis = dataset.indexAxis || getIndexAxis(type, me.options);
            meta.order = dataset.order || 0;
            meta.index = i;
            meta.label = "" + dataset.label;
            meta.visible = me.isDatasetVisible(i);
            if (meta.controller) {
              meta.controller.updateIndex(i);
              meta.controller.linkScales();
            } else {
              const ControllerClass = registry.getController(type);
              const { datasetElementType, dataElementType } = defaults.datasets[type];
              Object.assign(ControllerClass.prototype, {
                dataElementType: registry.getElement(dataElementType),
                datasetElementType: datasetElementType && registry.getElement(datasetElementType)
              });
              meta.controller = new ControllerClass(me, i);
              newControllers.push(meta.controller);
            }
          }
          me._updateMetasets();
          return newControllers;
        }
        _resetElements() {
          const me = this;
          each2(me.data.datasets, (dataset, datasetIndex) => {
            me.getDatasetMeta(datasetIndex).controller.reset();
          }, me);
        }
        reset() {
          this._resetElements();
          this.notifyPlugins("reset");
        }
        update(mode) {
          const me = this;
          const config2 = me.config;
          config2.update();
          me._options = config2.createResolver(config2.chartOptionScopes(), me.getContext());
          each2(me.scales, (scale) => {
            layouts.removeBox(me, scale);
          });
          const animsDisabled = me._animationsDisabled = !me.options.animation;
          me.ensureScalesHaveIDs();
          me.buildOrUpdateScales();
          const existingEvents = new Set(Object.keys(me._listeners));
          const newEvents = new Set(me.options.events);
          if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== me.options.responsive) {
            me.unbindEvents();
            me.bindEvents();
          }
          me._plugins.invalidate();
          if (me.notifyPlugins("beforeUpdate", { mode, cancelable: true }) === false) {
            return;
          }
          const newControllers = me.buildOrUpdateControllers();
          me.notifyPlugins("beforeElementsUpdate");
          let minPadding = 0;
          for (let i = 0, ilen = me.data.datasets.length; i < ilen; i++) {
            const { controller } = me.getDatasetMeta(i);
            const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
            controller.buildOrUpdateElements(reset);
            minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
          }
          me._minPadding = minPadding;
          me._updateLayout(minPadding);
          if (!animsDisabled) {
            each2(newControllers, (controller) => {
              controller.reset();
            });
          }
          me._updateDatasets(mode);
          me.notifyPlugins("afterUpdate", { mode });
          me._layers.sort(compare2Level("z", "_idx"));
          if (me._lastEvent) {
            me._eventHandler(me._lastEvent, true);
          }
          me.render();
        }
        _updateLayout(minPadding) {
          const me = this;
          if (me.notifyPlugins("beforeLayout", { cancelable: true }) === false) {
            return;
          }
          layouts.update(me, me.width, me.height, minPadding);
          const area = me.chartArea;
          const noArea = area.width <= 0 || area.height <= 0;
          me._layers = [];
          each2(me.boxes, (box) => {
            if (noArea && box.position === "chartArea") {
              return;
            }
            if (box.configure) {
              box.configure();
            }
            me._layers.push(...box._layers());
          }, me);
          me._layers.forEach((item, index2) => {
            item._idx = index2;
          });
          me.notifyPlugins("afterLayout");
        }
        _updateDatasets(mode) {
          const me = this;
          const isFunction2 = typeof mode === "function";
          if (me.notifyPlugins("beforeDatasetsUpdate", { mode, cancelable: true }) === false) {
            return;
          }
          for (let i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
            me._updateDataset(i, isFunction2 ? mode({ datasetIndex: i }) : mode);
          }
          me.notifyPlugins("afterDatasetsUpdate", { mode });
        }
        _updateDataset(index2, mode) {
          const me = this;
          const meta = me.getDatasetMeta(index2);
          const args = { meta, index: index2, mode, cancelable: true };
          if (me.notifyPlugins("beforeDatasetUpdate", args) === false) {
            return;
          }
          meta.controller._update(mode);
          args.cancelable = false;
          me.notifyPlugins("afterDatasetUpdate", args);
        }
        render() {
          const me = this;
          if (me.notifyPlugins("beforeRender", { cancelable: true }) === false) {
            return;
          }
          if (animator.has(me)) {
            if (me.attached && !animator.running(me)) {
              animator.start(me);
            }
          } else {
            me.draw();
            onAnimationsComplete({ chart: me });
          }
        }
        draw() {
          const me = this;
          let i;
          if (me._resizeBeforeDraw) {
            const { width, height } = me._resizeBeforeDraw;
            me._resize(width, height);
            me._resizeBeforeDraw = null;
          }
          me.clear();
          if (me.width <= 0 || me.height <= 0) {
            return;
          }
          if (me.notifyPlugins("beforeDraw", { cancelable: true }) === false) {
            return;
          }
          const layers = me._layers;
          for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
            layers[i].draw(me.chartArea);
          }
          me._drawDatasets();
          for (; i < layers.length; ++i) {
            layers[i].draw(me.chartArea);
          }
          me.notifyPlugins("afterDraw");
        }
        _getSortedDatasetMetas(filterVisible) {
          const me = this;
          const metasets = me._sortedMetasets;
          const result = [];
          let i, ilen;
          for (i = 0, ilen = metasets.length; i < ilen; ++i) {
            const meta = metasets[i];
            if (!filterVisible || meta.visible) {
              result.push(meta);
            }
          }
          return result;
        }
        getSortedVisibleDatasetMetas() {
          return this._getSortedDatasetMetas(true);
        }
        _drawDatasets() {
          const me = this;
          if (me.notifyPlugins("beforeDatasetsDraw", { cancelable: true }) === false) {
            return;
          }
          const metasets = me.getSortedVisibleDatasetMetas();
          for (let i = metasets.length - 1; i >= 0; --i) {
            me._drawDataset(metasets[i]);
          }
          me.notifyPlugins("afterDatasetsDraw");
        }
        _drawDataset(meta) {
          const me = this;
          const ctx = me.ctx;
          const clip = meta._clip;
          const useClip = !clip.disabled;
          const area = me.chartArea;
          const args = {
            meta,
            index: meta.index,
            cancelable: true
          };
          if (me.notifyPlugins("beforeDatasetDraw", args) === false) {
            return;
          }
          if (useClip) {
            clipArea(ctx, {
              left: clip.left === false ? 0 : area.left - clip.left,
              right: clip.right === false ? me.width : area.right + clip.right,
              top: clip.top === false ? 0 : area.top - clip.top,
              bottom: clip.bottom === false ? me.height : area.bottom + clip.bottom
            });
          }
          meta.controller.draw();
          if (useClip) {
            unclipArea(ctx);
          }
          args.cancelable = false;
          me.notifyPlugins("afterDatasetDraw", args);
        }
        getElementsAtEventForMode(e, mode, options2, useFinalPosition) {
          const method = Interaction.modes[mode];
          if (typeof method === "function") {
            return method(this, e, options2, useFinalPosition);
          }
          return [];
        }
        getDatasetMeta(datasetIndex) {
          const me = this;
          const dataset = me.data.datasets[datasetIndex];
          const metasets = me._metasets;
          let meta = metasets.filter((x) => x && x._dataset === dataset).pop();
          if (!meta) {
            meta = {
              type: null,
              data: [],
              dataset: null,
              controller: null,
              hidden: null,
              xAxisID: null,
              yAxisID: null,
              order: dataset && dataset.order || 0,
              index: datasetIndex,
              _dataset: dataset,
              _parsed: [],
              _sorted: false
            };
            metasets.push(meta);
          }
          return meta;
        }
        getContext() {
          return this.$context || (this.$context = { chart: this, type: "chart" });
        }
        getVisibleDatasetCount() {
          return this.getSortedVisibleDatasetMetas().length;
        }
        isDatasetVisible(datasetIndex) {
          const dataset = this.data.datasets[datasetIndex];
          if (!dataset) {
            return false;
          }
          const meta = this.getDatasetMeta(datasetIndex);
          return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
        }
        setDatasetVisibility(datasetIndex, visible) {
          const meta = this.getDatasetMeta(datasetIndex);
          meta.hidden = !visible;
        }
        toggleDataVisibility(index2) {
          this._hiddenIndices[index2] = !this._hiddenIndices[index2];
        }
        getDataVisibility(index2) {
          return !this._hiddenIndices[index2];
        }
        _updateVisibility(datasetIndex, dataIndex, visible) {
          const me = this;
          const mode = visible ? "show" : "hide";
          const meta = me.getDatasetMeta(datasetIndex);
          const anims = meta.controller._resolveAnimations(void 0, mode);
          if (defined(dataIndex)) {
            meta.data[dataIndex].hidden = !visible;
            me.update();
          } else {
            me.setDatasetVisibility(datasetIndex, visible);
            anims.update(meta, { visible });
            me.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);
          }
        }
        hide(datasetIndex, dataIndex) {
          this._updateVisibility(datasetIndex, dataIndex, false);
        }
        show(datasetIndex, dataIndex) {
          this._updateVisibility(datasetIndex, dataIndex, true);
        }
        _destroyDatasetMeta(datasetIndex) {
          const me = this;
          const meta = me._metasets && me._metasets[datasetIndex];
          if (meta && meta.controller) {
            meta.controller._destroy();
            delete me._metasets[datasetIndex];
          }
        }
        destroy() {
          const me = this;
          const { canvas, ctx } = me;
          let i, ilen;
          me.stop();
          animator.remove(me);
          for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
            me._destroyDatasetMeta(i);
          }
          me.config.clearCache();
          if (canvas) {
            me.unbindEvents();
            clearCanvas(canvas, ctx);
            me.platform.releaseContext(ctx);
            me.canvas = null;
            me.ctx = null;
          }
          me.notifyPlugins("destroy");
          delete instances[me.id];
        }
        toBase64Image(...args) {
          return this.canvas.toDataURL(...args);
        }
        bindEvents() {
          this.bindUserEvents();
          if (this.options.responsive) {
            this.bindResponsiveEvents();
          } else {
            this.attached = true;
          }
        }
        bindUserEvents() {
          const me = this;
          const listeners = me._listeners;
          const platform = me.platform;
          const _add = (type, listener2) => {
            platform.addEventListener(me, type, listener2);
            listeners[type] = listener2;
          };
          const listener = function(e, x, y) {
            e.offsetX = x;
            e.offsetY = y;
            me._eventHandler(e);
          };
          each2(me.options.events, (type) => _add(type, listener));
        }
        bindResponsiveEvents() {
          const me = this;
          if (!me._responsiveListeners) {
            me._responsiveListeners = {};
          }
          const listeners = me._responsiveListeners;
          const platform = me.platform;
          const _add = (type, listener2) => {
            platform.addEventListener(me, type, listener2);
            listeners[type] = listener2;
          };
          const _remove = (type, listener2) => {
            if (listeners[type]) {
              platform.removeEventListener(me, type, listener2);
              delete listeners[type];
            }
          };
          const listener = (width, height) => {
            if (me.canvas) {
              me.resize(width, height);
            }
          };
          let detached;
          const attached = () => {
            _remove("attach", attached);
            me.attached = true;
            me.resize();
            _add("resize", listener);
            _add("detach", detached);
          };
          detached = () => {
            me.attached = false;
            _remove("resize", listener);
            _add("attach", attached);
          };
          if (platform.isAttached(me.canvas)) {
            attached();
          } else {
            detached();
          }
        }
        unbindEvents() {
          const me = this;
          each2(me._listeners, (listener, type) => {
            me.platform.removeEventListener(me, type, listener);
          });
          me._listeners = {};
          each2(me._responsiveListeners, (listener, type) => {
            me.platform.removeEventListener(me, type, listener);
          });
          me._responsiveListeners = void 0;
        }
        updateHoverStyle(items, mode, enabled) {
          const prefix = enabled ? "set" : "remove";
          let meta, item, i, ilen;
          if (mode === "dataset") {
            meta = this.getDatasetMeta(items[0].datasetIndex);
            meta.controller["_" + prefix + "DatasetHoverStyle"]();
          }
          for (i = 0, ilen = items.length; i < ilen; ++i) {
            item = items[i];
            const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
            if (controller) {
              controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
            }
          }
        }
        getActiveElements() {
          return this._active || [];
        }
        setActiveElements(activeElements) {
          const me = this;
          const lastActive = me._active || [];
          const active = activeElements.map(({ datasetIndex, index: index2 }) => {
            const meta = me.getDatasetMeta(datasetIndex);
            if (!meta) {
              throw new Error("No dataset found at index " + datasetIndex);
            }
            return {
              datasetIndex,
              element: meta.data[index2],
              index: index2
            };
          });
          const changed = !_elementsEqual(active, lastActive);
          if (changed) {
            me._active = active;
            me._updateHoverStyles(active, lastActive);
          }
        }
        notifyPlugins(hook, args, filter2) {
          return this._plugins.notify(this, hook, args, filter2);
        }
        _updateHoverStyles(active, lastActive, replay) {
          const me = this;
          const hoverOptions = me.options.hover;
          const diff = (a, b) => a.filter((x) => !b.some((y) => x.datasetIndex === y.datasetIndex && x.index === y.index));
          const deactivated = diff(lastActive, active);
          const activated = replay ? active : diff(active, lastActive);
          if (deactivated.length) {
            me.updateHoverStyle(deactivated, hoverOptions.mode, false);
          }
          if (activated.length && hoverOptions.mode) {
            me.updateHoverStyle(activated, hoverOptions.mode, true);
          }
        }
        _eventHandler(e, replay) {
          const me = this;
          const args = { event: e, replay, cancelable: true };
          const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.type);
          if (me.notifyPlugins("beforeEvent", args, eventFilter) === false) {
            return;
          }
          const changed = me._handleEvent(e, replay);
          args.cancelable = false;
          me.notifyPlugins("afterEvent", args, eventFilter);
          if (changed || args.changed) {
            me.render();
          }
          return me;
        }
        _handleEvent(e, replay) {
          const me = this;
          const { _active: lastActive = [], options: options2 } = me;
          const hoverOptions = options2.hover;
          const useFinalPosition = replay;
          let active = [];
          let changed = false;
          let lastEvent = null;
          if (e.type !== "mouseout") {
            active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
            lastEvent = e.type === "click" ? me._lastEvent : e;
          }
          me._lastEvent = null;
          if (_isPointInArea(e, me.chartArea, me._minPadding)) {
            callback(options2.onHover, [e, active, me], me);
            if (e.type === "mouseup" || e.type === "click" || e.type === "contextmenu") {
              callback(options2.onClick, [e, active, me], me);
            }
          }
          changed = !_elementsEqual(active, lastActive);
          if (changed || replay) {
            me._active = active;
            me._updateHoverStyles(active, lastActive, replay);
          }
          me._lastEvent = lastEvent;
          return changed;
        }
      }
      const invalidatePlugins = () => each2(Chart.instances, (chart) => chart._plugins.invalidate());
      const enumerable = true;
      Object.defineProperties(Chart, {
        defaults: {
          enumerable,
          value: defaults
        },
        instances: {
          enumerable,
          value: instances
        },
        overrides: {
          enumerable,
          value: overrides
        },
        registry: {
          enumerable,
          value: registry
        },
        version: {
          enumerable,
          value: version2
        },
        getChart: {
          enumerable,
          value: getChart
        },
        register: {
          enumerable,
          value: (...items) => {
            registry.add(...items);
            invalidatePlugins();
          }
        },
        unregister: {
          enumerable,
          value: (...items) => {
            registry.remove(...items);
            invalidatePlugins();
          }
        }
      });
      function abstract() {
        throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
      }
      class DateAdapter {
        constructor(options2) {
          this.options = options2 || {};
        }
        formats() {
          return abstract();
        }
        parse(value, format2) {
          return abstract();
        }
        format(timestamp, format2) {
          return abstract();
        }
        add(timestamp, amount, unit) {
          return abstract();
        }
        diff(a, b, unit) {
          return abstract();
        }
        startOf(timestamp, unit, weekday) {
          return abstract();
        }
        endOf(timestamp, unit) {
          return abstract();
        }
      }
      DateAdapter.override = function(members) {
        Object.assign(DateAdapter.prototype, members);
      };
      var _adapters = {
        _date: DateAdapter
      };
      function getAllScaleValues(scale) {
        if (!scale._cache.$bar) {
          const metas = scale.getMatchingVisibleMetas("bar");
          let values = [];
          for (let i = 0, ilen = metas.length; i < ilen; i++) {
            values = values.concat(metas[i].controller.getAllParsedValues(scale));
          }
          scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));
        }
        return scale._cache.$bar;
      }
      function computeMinSampleSize(scale) {
        const values = getAllScaleValues(scale);
        let min = scale._length;
        let i, ilen, curr, prev;
        const updateMinAndPrev = () => {
          if (curr === 32767 || curr === -32768) {
            return;
          }
          if (defined(prev)) {
            min = Math.min(min, Math.abs(curr - prev) || min);
          }
          prev = curr;
        };
        for (i = 0, ilen = values.length; i < ilen; ++i) {
          curr = scale.getPixelForValue(values[i]);
          updateMinAndPrev();
        }
        prev = void 0;
        for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
          curr = scale.getPixelForTick(i);
          updateMinAndPrev();
        }
        return min;
      }
      function computeFitCategoryTraits(index2, ruler, options2, stackCount) {
        const thickness = options2.barThickness;
        let size, ratio;
        if (isNullOrUndef(thickness)) {
          size = ruler.min * options2.categoryPercentage;
          ratio = options2.barPercentage;
        } else {
          size = thickness * stackCount;
          ratio = 1;
        }
        return {
          chunk: size / stackCount,
          ratio,
          start: ruler.pixels[index2] - size / 2
        };
      }
      function computeFlexCategoryTraits(index2, ruler, options2, stackCount) {
        const pixels = ruler.pixels;
        const curr = pixels[index2];
        let prev = index2 > 0 ? pixels[index2 - 1] : null;
        let next = index2 < pixels.length - 1 ? pixels[index2 + 1] : null;
        const percent = options2.categoryPercentage;
        if (prev === null) {
          prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
        }
        if (next === null) {
          next = curr + curr - prev;
        }
        const start2 = curr - (curr - Math.min(prev, next)) / 2 * percent;
        const size = Math.abs(next - prev) / 2 * percent;
        return {
          chunk: size / stackCount,
          ratio: options2.barPercentage,
          start: start2
        };
      }
      function parseFloatBar(entry, item, vScale, i) {
        const startValue = vScale.parse(entry[0], i);
        const endValue = vScale.parse(entry[1], i);
        const min = Math.min(startValue, endValue);
        const max = Math.max(startValue, endValue);
        let barStart = min;
        let barEnd = max;
        if (Math.abs(min) > Math.abs(max)) {
          barStart = max;
          barEnd = min;
        }
        item[vScale.axis] = barEnd;
        item._custom = {
          barStart,
          barEnd,
          start: startValue,
          end: endValue,
          min,
          max
        };
      }
      function parseValue(entry, item, vScale, i) {
        if (isArray(entry)) {
          parseFloatBar(entry, item, vScale, i);
        } else {
          item[vScale.axis] = vScale.parse(entry, i);
        }
        return item;
      }
      function parseArrayOrPrimitive(meta, data, start2, count) {
        const iScale = meta.iScale;
        const vScale = meta.vScale;
        const labels = iScale.getLabels();
        const singleScale = iScale === vScale;
        const parsed = [];
        let i, ilen, item, entry;
        for (i = start2, ilen = start2 + count; i < ilen; ++i) {
          entry = data[i];
          item = {};
          item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
          parsed.push(parseValue(entry, item, vScale, i));
        }
        return parsed;
      }
      function isFloatBar(custom) {
        return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
      }
      function barSign(size, vScale, actualBase) {
        if (size !== 0) {
          return sign(size);
        }
        return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
      }
      function borderProps(properties) {
        let reverse, start2, end, top, bottom;
        if (properties.horizontal) {
          reverse = properties.base > properties.x;
          start2 = "left";
          end = "right";
        } else {
          reverse = properties.base < properties.y;
          start2 = "bottom";
          end = "top";
        }
        if (reverse) {
          top = "end";
          bottom = "start";
        } else {
          top = "start";
          bottom = "end";
        }
        return { start: start2, end, reverse, top, bottom };
      }
      function setBorderSkipped(properties, options2, stack, index2) {
        let edge = options2.borderSkipped;
        const res = {};
        if (!edge) {
          properties.borderSkipped = res;
          return;
        }
        const { start: start2, end, reverse, top, bottom } = borderProps(properties);
        if (edge === "middle" && stack) {
          properties.enableBorderRadius = true;
          if ((stack._top || 0) === index2) {
            edge = top;
          } else if ((stack._bottom || 0) === index2) {
            edge = bottom;
          } else {
            res[parseEdge(bottom, start2, end, reverse)] = true;
            edge = top;
          }
        }
        res[parseEdge(edge, start2, end, reverse)] = true;
        properties.borderSkipped = res;
      }
      function parseEdge(edge, a, b, reverse) {
        if (reverse) {
          edge = swap(edge, a, b);
          edge = startEnd(edge, b, a);
        } else {
          edge = startEnd(edge, a, b);
        }
        return edge;
      }
      function swap(orig, v1, v2) {
        return orig === v1 ? v2 : orig === v2 ? v1 : orig;
      }
      function startEnd(v, start2, end) {
        return v === "start" ? start2 : v === "end" ? end : v;
      }
      class BarController extends DatasetController {
        parsePrimitiveData(meta, data, start2, count) {
          return parseArrayOrPrimitive(meta, data, start2, count);
        }
        parseArrayData(meta, data, start2, count) {
          return parseArrayOrPrimitive(meta, data, start2, count);
        }
        parseObjectData(meta, data, start2, count) {
          const { iScale, vScale } = meta;
          const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
          const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
          const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
          const parsed = [];
          let i, ilen, item, obj;
          for (i = start2, ilen = start2 + count; i < ilen; ++i) {
            obj = data[i];
            item = {};
            item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
            parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
          }
          return parsed;
        }
        updateRangeFromParsed(range, scale, parsed, stack) {
          super.updateRangeFromParsed(range, scale, parsed, stack);
          const custom = parsed._custom;
          if (custom && scale === this._cachedMeta.vScale) {
            range.min = Math.min(range.min, custom.min);
            range.max = Math.max(range.max, custom.max);
          }
        }
        getMaxOverflow() {
          return 0;
        }
        getLabelAndValue(index2) {
          const me = this;
          const meta = me._cachedMeta;
          const { iScale, vScale } = meta;
          const parsed = me.getParsed(index2);
          const custom = parsed._custom;
          const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
          return {
            label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
            value
          };
        }
        initialize() {
          const me = this;
          me.enableOptionSharing = true;
          super.initialize();
          const meta = me._cachedMeta;
          meta.stack = me.getDataset().stack;
        }
        update(mode) {
          const me = this;
          const meta = me._cachedMeta;
          me.updateElements(meta.data, 0, meta.data.length, mode);
        }
        updateElements(bars, start2, count, mode) {
          const me = this;
          const reset = mode === "reset";
          const { index: index2, _cachedMeta: { vScale } } = me;
          const base2 = vScale.getBasePixel();
          const horizontal = vScale.isHorizontal();
          const ruler = me._getRuler();
          const firstOpts = me.resolveDataElementOptions(start2, mode);
          const sharedOptions = me.getSharedOptions(firstOpts);
          const includeOptions = me.includeOptions(mode, sharedOptions);
          me.updateSharedOptions(sharedOptions, mode, firstOpts);
          for (let i = start2; i < start2 + count; i++) {
            const parsed = me.getParsed(i);
            const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? { base: base2, head: base2 } : me._calculateBarValuePixels(i);
            const ipixels = me._calculateBarIndexPixels(i, ruler);
            const stack = (parsed._stacks || {})[vScale.axis];
            const properties = {
              horizontal,
              base: vpixels.base,
              enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index2 === stack._top || index2 === stack._bottom),
              x: horizontal ? vpixels.head : ipixels.center,
              y: horizontal ? ipixels.center : vpixels.head,
              height: horizontal ? ipixels.size : Math.abs(vpixels.size),
              width: horizontal ? Math.abs(vpixels.size) : ipixels.size
            };
            if (includeOptions) {
              properties.options = sharedOptions || me.resolveDataElementOptions(i, bars[i].active ? "active" : mode);
            }
            setBorderSkipped(properties, properties.options || bars[i].options, stack, index2);
            me.updateElement(bars[i], i, properties, mode);
          }
        }
        _getStacks(last, dataIndex) {
          const me = this;
          const meta = me._cachedMeta;
          const iScale = meta.iScale;
          const metasets = iScale.getMatchingVisibleMetas(me._type);
          const stacked = iScale.options.stacked;
          const ilen = metasets.length;
          const stacks = [];
          let i, item;
          for (i = 0; i < ilen; ++i) {
            item = metasets[i];
            if (!item.controller.options.grouped) {
              continue;
            }
            if (typeof dataIndex !== "undefined") {
              const val = item.controller.getParsed(dataIndex)[item.controller._cachedMeta.vScale.axis];
              if (isNullOrUndef(val) || isNaN(val)) {
                continue;
              }
            }
            if (stacked === false || stacks.indexOf(item.stack) === -1 || stacked === void 0 && item.stack === void 0) {
              stacks.push(item.stack);
            }
            if (item.index === last) {
              break;
            }
          }
          if (!stacks.length) {
            stacks.push(void 0);
          }
          return stacks;
        }
        _getStackCount(index2) {
          return this._getStacks(void 0, index2).length;
        }
        _getStackIndex(datasetIndex, name2, dataIndex) {
          const stacks = this._getStacks(datasetIndex, dataIndex);
          const index2 = name2 !== void 0 ? stacks.indexOf(name2) : -1;
          return index2 === -1 ? stacks.length - 1 : index2;
        }
        _getRuler() {
          const me = this;
          const opts = me.options;
          const meta = me._cachedMeta;
          const iScale = meta.iScale;
          const pixels = [];
          let i, ilen;
          for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
            pixels.push(iScale.getPixelForValue(me.getParsed(i)[iScale.axis], i));
          }
          const barThickness = opts.barThickness;
          const min = barThickness || computeMinSampleSize(iScale);
          return {
            min,
            pixels,
            start: iScale._startPixel,
            end: iScale._endPixel,
            stackCount: me._getStackCount(),
            scale: iScale,
            grouped: opts.grouped,
            ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
          };
        }
        _calculateBarValuePixels(index2) {
          const me = this;
          const { _cachedMeta: { vScale, _stacked }, options: { base: baseValue, minBarLength } } = me;
          const actualBase = baseValue || 0;
          const parsed = me.getParsed(index2);
          const custom = parsed._custom;
          const floating = isFloatBar(custom);
          let value = parsed[vScale.axis];
          let start2 = 0;
          let length = _stacked ? me.applyStack(vScale, parsed, _stacked) : value;
          let head, size;
          if (length !== value) {
            start2 = length - value;
            length = value;
          }
          if (floating) {
            value = custom.barStart;
            length = custom.barEnd - custom.barStart;
            if (value !== 0 && sign(value) !== sign(custom.barEnd)) {
              start2 = 0;
            }
            start2 += value;
          }
          const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start2;
          let base2 = vScale.getPixelForValue(startValue);
          if (me.chart.getDataVisibility(index2)) {
            head = vScale.getPixelForValue(start2 + length);
          } else {
            head = base2;
          }
          size = head - base2;
          if (Math.abs(size) < minBarLength) {
            size = barSign(size, vScale, actualBase) * minBarLength;
            if (value === actualBase) {
              base2 -= size / 2;
            }
            head = base2 + size;
          }
          if (base2 === vScale.getPixelForValue(actualBase)) {
            const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
            base2 += halfGrid;
            size -= halfGrid;
          }
          return {
            size,
            base: base2,
            head,
            center: head + size / 2
          };
        }
        _calculateBarIndexPixels(index2, ruler) {
          const me = this;
          const scale = ruler.scale;
          const options2 = me.options;
          const skipNull = options2.skipNull;
          const maxBarThickness = valueOrDefault(options2.maxBarThickness, Infinity);
          let center, size;
          if (ruler.grouped) {
            const stackCount = skipNull ? me._getStackCount(index2) : ruler.stackCount;
            const range = options2.barThickness === "flex" ? computeFlexCategoryTraits(index2, ruler, options2, stackCount) : computeFitCategoryTraits(index2, ruler, options2, stackCount);
            const stackIndex = me._getStackIndex(me.index, me._cachedMeta.stack, skipNull ? index2 : void 0);
            center = range.start + range.chunk * stackIndex + range.chunk / 2;
            size = Math.min(maxBarThickness, range.chunk * range.ratio);
          } else {
            center = scale.getPixelForValue(me.getParsed(index2)[scale.axis], index2);
            size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
          }
          return {
            base: center - size / 2,
            head: center + size / 2,
            center,
            size
          };
        }
        draw() {
          const me = this;
          const meta = me._cachedMeta;
          const vScale = meta.vScale;
          const rects = meta.data;
          const ilen = rects.length;
          let i = 0;
          for (; i < ilen; ++i) {
            if (me.getParsed(i)[vScale.axis] !== null) {
              rects[i].draw(me._ctx);
            }
          }
        }
      }
      BarController.id = "bar";
      BarController.defaults = {
        datasetElementType: false,
        dataElementType: "bar",
        categoryPercentage: 0.8,
        barPercentage: 0.9,
        grouped: true,
        animations: {
          numbers: {
            type: "number",
            properties: ["x", "y", "base", "width", "height"]
          }
        }
      };
      BarController.overrides = {
        scales: {
          _index_: {
            type: "category",
            offset: true,
            grid: {
              offset: true
            }
          },
          _value_: {
            type: "linear",
            beginAtZero: true
          }
        }
      };
      class BubbleController extends DatasetController {
        initialize() {
          this.enableOptionSharing = true;
          super.initialize();
        }
        parseObjectData(meta, data, start2, count) {
          const { xScale, yScale } = meta;
          const { xAxisKey = "x", yAxisKey = "y" } = this._parsing;
          const parsed = [];
          let i, ilen, item;
          for (i = start2, ilen = start2 + count; i < ilen; ++i) {
            item = data[i];
            parsed.push({
              x: xScale.parse(resolveObjectKey(item, xAxisKey), i),
              y: yScale.parse(resolveObjectKey(item, yAxisKey), i),
              _custom: item && item.r && +item.r
            });
          }
          return parsed;
        }
        getMaxOverflow() {
          const { data, _parsed } = this._cachedMeta;
          let max = 0;
          for (let i = data.length - 1; i >= 0; --i) {
            max = Math.max(max, data[i].size() / 2, _parsed[i]._custom);
          }
          return max > 0 && max;
        }
        getLabelAndValue(index2) {
          const me = this;
          const meta = me._cachedMeta;
          const { xScale, yScale } = meta;
          const parsed = me.getParsed(index2);
          const x = xScale.getLabelForValue(parsed.x);
          const y = yScale.getLabelForValue(parsed.y);
          const r = parsed._custom;
          return {
            label: meta.label,
            value: "(" + x + ", " + y + (r ? ", " + r : "") + ")"
          };
        }
        update(mode) {
          const me = this;
          const points = me._cachedMeta.data;
          me.updateElements(points, 0, points.length, mode);
        }
        updateElements(points, start2, count, mode) {
          const me = this;
          const reset = mode === "reset";
          const { iScale, vScale } = me._cachedMeta;
          const firstOpts = me.resolveDataElementOptions(start2, mode);
          const sharedOptions = me.getSharedOptions(firstOpts);
          const includeOptions = me.includeOptions(mode, sharedOptions);
          const iAxis = iScale.axis;
          const vAxis = vScale.axis;
          for (let i = start2; i < start2 + count; i++) {
            const point = points[i];
            const parsed = !reset && me.getParsed(i);
            const properties = {};
            const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);
            const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
            properties.skip = isNaN(iPixel) || isNaN(vPixel);
            if (includeOptions) {
              properties.options = me.resolveDataElementOptions(i, point.active ? "active" : mode);
              if (reset) {
                properties.options.radius = 0;
              }
            }
            me.updateElement(point, i, properties, mode);
          }
          me.updateSharedOptions(sharedOptions, mode, firstOpts);
        }
        resolveDataElementOptions(index2, mode) {
          const parsed = this.getParsed(index2);
          let values = super.resolveDataElementOptions(index2, mode);
          if (values.$shared) {
            values = Object.assign({}, values, { $shared: false });
          }
          const radius = values.radius;
          if (mode !== "active") {
            values.radius = 0;
          }
          values.radius += valueOrDefault(parsed && parsed._custom, radius);
          return values;
        }
      }
      BubbleController.id = "bubble";
      BubbleController.defaults = {
        datasetElementType: false,
        dataElementType: "point",
        animations: {
          numbers: {
            type: "number",
            properties: ["x", "y", "borderWidth", "radius"]
          }
        }
      };
      BubbleController.overrides = {
        scales: {
          x: {
            type: "linear"
          },
          y: {
            type: "linear"
          }
        },
        plugins: {
          tooltip: {
            callbacks: {
              title() {
                return "";
              }
            }
          }
        }
      };
      function getRatioAndOffset(rotation, circumference, cutout) {
        let ratioX = 1;
        let ratioY = 1;
        let offsetX = 0;
        let offsetY = 0;
        if (circumference < TAU) {
          const startAngle = rotation;
          const endAngle = startAngle + circumference;
          const startX = Math.cos(startAngle);
          const startY = Math.sin(startAngle);
          const endX = Math.cos(endAngle);
          const endY = Math.sin(endAngle);
          const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
          const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
          const maxX = calcMax(0, startX, endX);
          const maxY = calcMax(HALF_PI, startY, endY);
          const minX = calcMin(PI, startX, endX);
          const minY = calcMin(PI + HALF_PI, startY, endY);
          ratioX = (maxX - minX) / 2;
          ratioY = (maxY - minY) / 2;
          offsetX = -(maxX + minX) / 2;
          offsetY = -(maxY + minY) / 2;
        }
        return { ratioX, ratioY, offsetX, offsetY };
      }
      class DoughnutController extends DatasetController {
        constructor(chart, datasetIndex) {
          super(chart, datasetIndex);
          this.enableOptionSharing = true;
          this.innerRadius = void 0;
          this.outerRadius = void 0;
          this.offsetX = void 0;
          this.offsetY = void 0;
        }
        linkScales() {
        }
        parse(start2, count) {
          const data = this.getDataset().data;
          const meta = this._cachedMeta;
          let i, ilen;
          for (i = start2, ilen = start2 + count; i < ilen; ++i) {
            meta._parsed[i] = +data[i];
          }
        }
        _getRotation() {
          return toRadians(this.options.rotation - 90);
        }
        _getCircumference() {
          return toRadians(this.options.circumference);
        }
        _getRotationExtents() {
          let min = TAU;
          let max = -TAU;
          const me = this;
          for (let i = 0; i < me.chart.data.datasets.length; ++i) {
            if (me.chart.isDatasetVisible(i)) {
              const controller = me.chart.getDatasetMeta(i).controller;
              const rotation = controller._getRotation();
              const circumference = controller._getCircumference();
              min = Math.min(min, rotation);
              max = Math.max(max, rotation + circumference);
            }
          }
          return {
            rotation: min,
            circumference: max - min
          };
        }
        update(mode) {
          const me = this;
          const chart = me.chart;
          const { chartArea } = chart;
          const meta = me._cachedMeta;
          const arcs = meta.data;
          const spacing = me.getMaxBorderWidth() + me.getMaxOffset(arcs) + me.options.spacing;
          const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
          const cutout = Math.min(toPercentage(me.options.cutout, maxSize), 1);
          const chartWeight = me._getRingWeight(me.index);
          const { circumference, rotation } = me._getRotationExtents();
          const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);
          const maxWidth = (chartArea.width - spacing) / ratioX;
          const maxHeight = (chartArea.height - spacing) / ratioY;
          const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
          const outerRadius = toDimension(me.options.radius, maxRadius);
          const innerRadius = Math.max(outerRadius * cutout, 0);
          const radiusLength = (outerRadius - innerRadius) / me._getVisibleDatasetWeightTotal();
          me.offsetX = offsetX * outerRadius;
          me.offsetY = offsetY * outerRadius;
          meta.total = me.calculateTotal();
          me.outerRadius = outerRadius - radiusLength * me._getRingWeightOffset(me.index);
          me.innerRadius = Math.max(me.outerRadius - radiusLength * chartWeight, 0);
          me.updateElements(arcs, 0, arcs.length, mode);
        }
        _circumference(i, reset) {
          const me = this;
          const opts = me.options;
          const meta = me._cachedMeta;
          const circumference = me._getCircumference();
          if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {
            return 0;
          }
          return me.calculateCircumference(meta._parsed[i] * circumference / TAU);
        }
        updateElements(arcs, start2, count, mode) {
          const me = this;
          const reset = mode === "reset";
          const chart = me.chart;
          const chartArea = chart.chartArea;
          const opts = chart.options;
          const animationOpts = opts.animation;
          const centerX = (chartArea.left + chartArea.right) / 2;
          const centerY = (chartArea.top + chartArea.bottom) / 2;
          const animateScale = reset && animationOpts.animateScale;
          const innerRadius = animateScale ? 0 : me.innerRadius;
          const outerRadius = animateScale ? 0 : me.outerRadius;
          const firstOpts = me.resolveDataElementOptions(start2, mode);
          const sharedOptions = me.getSharedOptions(firstOpts);
          const includeOptions = me.includeOptions(mode, sharedOptions);
          let startAngle = me._getRotation();
          let i;
          for (i = 0; i < start2; ++i) {
            startAngle += me._circumference(i, reset);
          }
          for (i = start2; i < start2 + count; ++i) {
            const circumference = me._circumference(i, reset);
            const arc = arcs[i];
            const properties = {
              x: centerX + me.offsetX,
              y: centerY + me.offsetY,
              startAngle,
              endAngle: startAngle + circumference,
              circumference,
              outerRadius,
              innerRadius
            };
            if (includeOptions) {
              properties.options = sharedOptions || me.resolveDataElementOptions(i, arc.active ? "active" : mode);
            }
            startAngle += circumference;
            me.updateElement(arc, i, properties, mode);
          }
          me.updateSharedOptions(sharedOptions, mode, firstOpts);
        }
        calculateTotal() {
          const meta = this._cachedMeta;
          const metaData = meta.data;
          let total = 0;
          let i;
          for (i = 0; i < metaData.length; i++) {
            const value = meta._parsed[i];
            if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {
              total += Math.abs(value);
            }
          }
          return total;
        }
        calculateCircumference(value) {
          const total = this._cachedMeta.total;
          if (total > 0 && !isNaN(value)) {
            return TAU * (Math.abs(value) / total);
          }
          return 0;
        }
        getLabelAndValue(index2) {
          const me = this;
          const meta = me._cachedMeta;
          const chart = me.chart;
          const labels = chart.data.labels || [];
          const value = formatNumber(meta._parsed[index2], chart.options.locale);
          return {
            label: labels[index2] || "",
            value
          };
        }
        getMaxBorderWidth(arcs) {
          const me = this;
          let max = 0;
          const chart = me.chart;
          let i, ilen, meta, controller, options2;
          if (!arcs) {
            for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
              if (chart.isDatasetVisible(i)) {
                meta = chart.getDatasetMeta(i);
                arcs = meta.data;
                controller = meta.controller;
                if (controller !== me) {
                  controller.configure();
                }
                break;
              }
            }
          }
          if (!arcs) {
            return 0;
          }
          for (i = 0, ilen = arcs.length; i < ilen; ++i) {
            options2 = controller.resolveDataElementOptions(i);
            if (options2.borderAlign !== "inner") {
              max = Math.max(max, options2.borderWidth || 0, options2.hoverBorderWidth || 0);
            }
          }
          return max;
        }
        getMaxOffset(arcs) {
          let max = 0;
          for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
            const options2 = this.resolveDataElementOptions(i);
            max = Math.max(max, options2.offset || 0, options2.hoverOffset || 0);
          }
          return max;
        }
        _getRingWeightOffset(datasetIndex) {
          let ringWeightOffset = 0;
          for (let i = 0; i < datasetIndex; ++i) {
            if (this.chart.isDatasetVisible(i)) {
              ringWeightOffset += this._getRingWeight(i);
            }
          }
          return ringWeightOffset;
        }
        _getRingWeight(datasetIndex) {
          return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
        }
        _getVisibleDatasetWeightTotal() {
          return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
        }
      }
      DoughnutController.id = "doughnut";
      DoughnutController.defaults = {
        datasetElementType: false,
        dataElementType: "arc",
        animation: {
          animateRotate: true,
          animateScale: false
        },
        animations: {
          numbers: {
            type: "number",
            properties: ["circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing"]
          }
        },
        cutout: "50%",
        rotation: 0,
        circumference: 360,
        radius: "100%",
        spacing: 0,
        indexAxis: "r"
      };
      DoughnutController.descriptors = {
        _scriptable: (name2) => name2 !== "spacing",
        _indexable: (name2) => name2 !== "spacing"
      };
      DoughnutController.overrides = {
        aspectRatio: 1,
        plugins: {
          legend: {
            labels: {
              generateLabels(chart) {
                const data = chart.data;
                if (data.labels.length && data.datasets.length) {
                  const { labels: { pointStyle } } = chart.legend.options;
                  return data.labels.map((label, i) => {
                    const meta = chart.getDatasetMeta(0);
                    const style = meta.controller.getStyle(i);
                    return {
                      text: label,
                      fillStyle: style.backgroundColor,
                      strokeStyle: style.borderColor,
                      lineWidth: style.borderWidth,
                      pointStyle,
                      hidden: !chart.getDataVisibility(i),
                      index: i
                    };
                  });
                }
                return [];
              }
            },
            onClick(e, legendItem, legend) {
              legend.chart.toggleDataVisibility(legendItem.index);
              legend.chart.update();
            }
          },
          tooltip: {
            callbacks: {
              title() {
                return "";
              },
              label(tooltipItem) {
                let dataLabel = tooltipItem.label;
                const value = ": " + tooltipItem.formattedValue;
                if (isArray(dataLabel)) {
                  dataLabel = dataLabel.slice();
                  dataLabel[0] += value;
                } else {
                  dataLabel += value;
                }
                return dataLabel;
              }
            }
          }
        }
      };
      class LineController extends DatasetController {
        initialize() {
          this.enableOptionSharing = true;
          super.initialize();
        }
        update(mode) {
          const me = this;
          const meta = me._cachedMeta;
          const { dataset: line, data: points = [], _dataset } = meta;
          const animationsDisabled = me.chart._animationsDisabled;
          let { start: start2, count } = getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
          me._drawStart = start2;
          me._drawCount = count;
          if (scaleRangesChanged(meta)) {
            start2 = 0;
            count = points.length;
          }
          line._datasetIndex = me.index;
          line._decimated = !!_dataset._decimated;
          line.points = points;
          const options2 = me.resolveDatasetElementOptions(mode);
          if (!me.options.showLine) {
            options2.borderWidth = 0;
          }
          options2.segment = me.options.segment;
          me.updateElement(line, void 0, {
            animated: !animationsDisabled,
            options: options2
          }, mode);
          me.updateElements(points, start2, count, mode);
        }
        updateElements(points, start2, count, mode) {
          const me = this;
          const reset = mode === "reset";
          const { iScale, vScale, _stacked } = me._cachedMeta;
          const firstOpts = me.resolveDataElementOptions(start2, mode);
          const sharedOptions = me.getSharedOptions(firstOpts);
          const includeOptions = me.includeOptions(mode, sharedOptions);
          const iAxis = iScale.axis;
          const vAxis = vScale.axis;
          const spanGaps = me.options.spanGaps;
          const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
          const directUpdate = me.chart._animationsDisabled || reset || mode === "none";
          let prevParsed = start2 > 0 && me.getParsed(start2 - 1);
          for (let i = start2; i < start2 + count; ++i) {
            const point = points[i];
            const parsed = me.getParsed(i);
            const properties = directUpdate ? point : {};
            const nullData = isNullOrUndef(parsed[vAxis]);
            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? me.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
            properties.stop = i > 0 && parsed[iAxis] - prevParsed[iAxis] > maxGapLength;
            properties.parsed = parsed;
            if (includeOptions) {
              properties.options = sharedOptions || me.resolveDataElementOptions(i, point.active ? "active" : mode);
            }
            if (!directUpdate) {
              me.updateElement(point, i, properties, mode);
            }
            prevParsed = parsed;
          }
          me.updateSharedOptions(sharedOptions, mode, firstOpts);
        }
        getMaxOverflow() {
          const me = this;
          const meta = me._cachedMeta;
          const dataset = meta.dataset;
          const border = dataset.options && dataset.options.borderWidth || 0;
          const data = meta.data || [];
          if (!data.length) {
            return border;
          }
          const firstPoint = data[0].size(me.resolveDataElementOptions(0));
          const lastPoint = data[data.length - 1].size(me.resolveDataElementOptions(data.length - 1));
          return Math.max(border, firstPoint, lastPoint) / 2;
        }
        draw() {
          const meta = this._cachedMeta;
          meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
          super.draw();
        }
      }
      LineController.id = "line";
      LineController.defaults = {
        datasetElementType: "line",
        dataElementType: "point",
        showLine: true,
        spanGaps: false
      };
      LineController.overrides = {
        scales: {
          _index_: {
            type: "category"
          },
          _value_: {
            type: "linear"
          }
        }
      };
      function getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
        const pointCount = points.length;
        let start2 = 0;
        let count = pointCount;
        if (meta._sorted) {
          const { iScale, _parsed } = meta;
          const axis = iScale.axis;
          const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
          if (minDefined) {
            start2 = _limitValue(Math.min(_lookupByKey(_parsed, iScale.axis, min).lo, animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);
          }
          if (maxDefined) {
            count = _limitValue(Math.max(_lookupByKey(_parsed, iScale.axis, max).hi + 1, animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max)).hi + 1), start2, pointCount) - start2;
          } else {
            count = pointCount - start2;
          }
        }
        return { start: start2, count };
      }
      function scaleRangesChanged(meta) {
        const { xScale, yScale, _scaleRanges } = meta;
        const newRanges = {
          xmin: xScale.min,
          xmax: xScale.max,
          ymin: yScale.min,
          ymax: yScale.max
        };
        if (!_scaleRanges) {
          meta._scaleRanges = newRanges;
          return true;
        }
        const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
        Object.assign(_scaleRanges, newRanges);
        return changed;
      }
      class PolarAreaController extends DatasetController {
        constructor(chart, datasetIndex) {
          super(chart, datasetIndex);
          this.innerRadius = void 0;
          this.outerRadius = void 0;
        }
        getLabelAndValue(index2) {
          const me = this;
          const meta = me._cachedMeta;
          const chart = me.chart;
          const labels = chart.data.labels || [];
          const value = formatNumber(meta._parsed[index2].r, chart.options.locale);
          return {
            label: labels[index2] || "",
            value
          };
        }
        update(mode) {
          const arcs = this._cachedMeta.data;
          this._updateRadius();
          this.updateElements(arcs, 0, arcs.length, mode);
        }
        _updateRadius() {
          const me = this;
          const chart = me.chart;
          const chartArea = chart.chartArea;
          const opts = chart.options;
          const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
          const outerRadius = Math.max(minSize / 2, 0);
          const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
          const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
          me.outerRadius = outerRadius - radiusLength * me.index;
          me.innerRadius = me.outerRadius - radiusLength;
        }
        updateElements(arcs, start2, count, mode) {
          const me = this;
          const reset = mode === "reset";
          const chart = me.chart;
          const dataset = me.getDataset();
          const opts = chart.options;
          const animationOpts = opts.animation;
          const scale = me._cachedMeta.rScale;
          const centerX = scale.xCenter;
          const centerY = scale.yCenter;
          const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;
          let angle = datasetStartAngle;
          let i;
          const defaultAngle = 360 / me.countVisibleElements();
          for (i = 0; i < start2; ++i) {
            angle += me._computeAngle(i, mode, defaultAngle);
          }
          for (i = start2; i < start2 + count; i++) {
            const arc = arcs[i];
            let startAngle = angle;
            let endAngle = angle + me._computeAngle(i, mode, defaultAngle);
            let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(dataset.data[i]) : 0;
            angle = endAngle;
            if (reset) {
              if (animationOpts.animateScale) {
                outerRadius = 0;
              }
              if (animationOpts.animateRotate) {
                startAngle = endAngle = datasetStartAngle;
              }
            }
            const properties = {
              x: centerX,
              y: centerY,
              innerRadius: 0,
              outerRadius,
              startAngle,
              endAngle,
              options: me.resolveDataElementOptions(i, arc.active ? "active" : mode)
            };
            me.updateElement(arc, i, properties, mode);
          }
        }
        countVisibleElements() {
          const dataset = this.getDataset();
          const meta = this._cachedMeta;
          let count = 0;
          meta.data.forEach((element, index2) => {
            if (!isNaN(dataset.data[index2]) && this.chart.getDataVisibility(index2)) {
              count++;
            }
          });
          return count;
        }
        _computeAngle(index2, mode, defaultAngle) {
          return this.chart.getDataVisibility(index2) ? toRadians(this.resolveDataElementOptions(index2, mode).angle || defaultAngle) : 0;
        }
      }
      PolarAreaController.id = "polarArea";
      PolarAreaController.defaults = {
        dataElementType: "arc",
        animation: {
          animateRotate: true,
          animateScale: true
        },
        animations: {
          numbers: {
            type: "number",
            properties: ["x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius"]
          }
        },
        indexAxis: "r",
        startAngle: 0
      };
      PolarAreaController.overrides = {
        aspectRatio: 1,
        plugins: {
          legend: {
            labels: {
              generateLabels(chart) {
                const data = chart.data;
                if (data.labels.length && data.datasets.length) {
                  const { labels: { pointStyle } } = chart.legend.options;
                  return data.labels.map((label, i) => {
                    const meta = chart.getDatasetMeta(0);
                    const style = meta.controller.getStyle(i);
                    return {
                      text: label,
                      fillStyle: style.backgroundColor,
                      strokeStyle: style.borderColor,
                      lineWidth: style.borderWidth,
                      pointStyle,
                      hidden: !chart.getDataVisibility(i),
                      index: i
                    };
                  });
                }
                return [];
              }
            },
            onClick(e, legendItem, legend) {
              legend.chart.toggleDataVisibility(legendItem.index);
              legend.chart.update();
            }
          },
          tooltip: {
            callbacks: {
              title() {
                return "";
              },
              label(context) {
                return context.chart.data.labels[context.dataIndex] + ": " + context.formattedValue;
              }
            }
          }
        },
        scales: {
          r: {
            type: "radialLinear",
            angleLines: {
              display: false
            },
            beginAtZero: true,
            grid: {
              circular: true
            },
            pointLabels: {
              display: false
            },
            startAngle: 0
          }
        }
      };
      class PieController extends DoughnutController {
      }
      PieController.id = "pie";
      PieController.defaults = {
        cutout: 0,
        rotation: 0,
        circumference: 360,
        radius: "100%"
      };
      class RadarController extends DatasetController {
        getLabelAndValue(index2) {
          const me = this;
          const vScale = me._cachedMeta.vScale;
          const parsed = me.getParsed(index2);
          return {
            label: vScale.getLabels()[index2],
            value: "" + vScale.getLabelForValue(parsed[vScale.axis])
          };
        }
        update(mode) {
          const me = this;
          const meta = me._cachedMeta;
          const line = meta.dataset;
          const points = meta.data || [];
          const labels = meta.iScale.getLabels();
          line.points = points;
          if (mode !== "resize") {
            const options2 = me.resolveDatasetElementOptions(mode);
            if (!me.options.showLine) {
              options2.borderWidth = 0;
            }
            const properties = {
              _loop: true,
              _fullLoop: labels.length === points.length,
              options: options2
            };
            me.updateElement(line, void 0, properties, mode);
          }
          me.updateElements(points, 0, points.length, mode);
        }
        updateElements(points, start2, count, mode) {
          const me = this;
          const dataset = me.getDataset();
          const scale = me._cachedMeta.rScale;
          const reset = mode === "reset";
          for (let i = start2; i < start2 + count; i++) {
            const point = points[i];
            const options2 = me.resolveDataElementOptions(i, point.active ? "active" : mode);
            const pointPosition = scale.getPointPositionForValue(i, dataset.data[i]);
            const x = reset ? scale.xCenter : pointPosition.x;
            const y = reset ? scale.yCenter : pointPosition.y;
            const properties = {
              x,
              y,
              angle: pointPosition.angle,
              skip: isNaN(x) || isNaN(y),
              options: options2
            };
            me.updateElement(point, i, properties, mode);
          }
        }
      }
      RadarController.id = "radar";
      RadarController.defaults = {
        datasetElementType: "line",
        dataElementType: "point",
        indexAxis: "r",
        showLine: true,
        elements: {
          line: {
            fill: "start"
          }
        }
      };
      RadarController.overrides = {
        aspectRatio: 1,
        scales: {
          r: {
            type: "radialLinear"
          }
        }
      };
      class ScatterController extends LineController {
      }
      ScatterController.id = "scatter";
      ScatterController.defaults = {
        showLine: false,
        fill: false
      };
      ScatterController.overrides = {
        interaction: {
          mode: "point"
        },
        plugins: {
          tooltip: {
            callbacks: {
              title() {
                return "";
              },
              label(item) {
                return "(" + item.label + ", " + item.formattedValue + ")";
              }
            }
          }
        },
        scales: {
          x: {
            type: "linear"
          },
          y: {
            type: "linear"
          }
        }
      };
      var controllers = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        BarController,
        BubbleController,
        DoughnutController,
        LineController,
        PolarAreaController,
        PieController,
        RadarController,
        ScatterController
      });
      function clipArc(ctx, element, endAngle) {
        const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element;
        let angleMargin = pixelMargin / outerRadius;
        ctx.beginPath();
        ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
        if (innerRadius > pixelMargin) {
          angleMargin = pixelMargin / innerRadius;
          ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
        } else {
          ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
        }
        ctx.closePath();
        ctx.clip();
      }
      function toRadiusCorners(value) {
        return _readValueToProps(value, ["outerStart", "outerEnd", "innerStart", "innerEnd"]);
      }
      function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
        const o = toRadiusCorners(arc.options.borderRadius);
        const halfThickness = (outerRadius - innerRadius) / 2;
        const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
        const computeOuterLimit = (val) => {
          const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
          return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
        };
        return {
          outerStart: computeOuterLimit(o.outerStart),
          outerEnd: computeOuterLimit(o.outerEnd),
          innerStart: _limitValue(o.innerStart, 0, innerLimit),
          innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
        };
      }
      function rThetaToXY(r, theta, x, y) {
        return {
          x: x + r * Math.cos(theta),
          y: y + r * Math.sin(theta)
        };
      }
      function pathArc(ctx, element, offset, spacing, end) {
        const { x, y, startAngle: start2, pixelMargin, innerRadius: innerR } = element;
        const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
        const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
        let spacingOffset = 0;
        const alpha = end - start2;
        if (spacing) {
          const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
          const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
          const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
          const adjustedAngle = avNogSpacingRadius !== 0 ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha;
          spacingOffset = (alpha - adjustedAngle) / 2;
        }
        const beta = Math.max(1e-3, alpha * outerRadius - offset / PI) / outerRadius;
        const angleOffset = (alpha - beta) / 2;
        const startAngle = start2 + angleOffset + spacingOffset;
        const endAngle = end - angleOffset - spacingOffset;
        const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
        const outerStartAdjustedRadius = outerRadius - outerStart;
        const outerEndAdjustedRadius = outerRadius - outerEnd;
        const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
        const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
        const innerStartAdjustedRadius = innerRadius + innerStart;
        const innerEndAdjustedRadius = innerRadius + innerEnd;
        const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
        const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
        ctx.beginPath();
        ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);
        if (outerEnd > 0) {
          const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
          ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
        }
        const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
        ctx.lineTo(p4.x, p4.y);
        if (innerEnd > 0) {
          const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
          ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
        }
        ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, startAngle + innerStart / innerRadius, true);
        if (innerStart > 0) {
          const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
          ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
        }
        const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
        ctx.lineTo(p8.x, p8.y);
        if (outerStart > 0) {
          const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
          ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
        }
        ctx.closePath();
      }
      function drawArc(ctx, element, offset, spacing) {
        const { fullCircles, startAngle, circumference } = element;
        let endAngle = element.endAngle;
        if (fullCircles) {
          pathArc(ctx, element, offset, spacing, startAngle + TAU);
          for (let i = 0; i < fullCircles; ++i) {
            ctx.fill();
          }
          if (!isNaN(circumference)) {
            endAngle = startAngle + circumference % TAU;
            if (circumference % TAU === 0) {
              endAngle += TAU;
            }
          }
        }
        pathArc(ctx, element, offset, spacing, endAngle);
        ctx.fill();
        return endAngle;
      }
      function drawFullCircleBorders(ctx, element, inner) {
        const { x, y, startAngle, pixelMargin, fullCircles } = element;
        const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);
        const innerRadius = element.innerRadius + pixelMargin;
        let i;
        if (inner) {
          clipArc(ctx, element, startAngle + TAU);
        }
        ctx.beginPath();
        ctx.arc(x, y, innerRadius, startAngle + TAU, startAngle, true);
        for (i = 0; i < fullCircles; ++i) {
          ctx.stroke();
        }
        ctx.beginPath();
        ctx.arc(x, y, outerRadius, startAngle, startAngle + TAU);
        for (i = 0; i < fullCircles; ++i) {
          ctx.stroke();
        }
      }
      function drawBorder(ctx, element, offset, spacing, endAngle) {
        const { options: options2 } = element;
        const inner = options2.borderAlign === "inner";
        if (!options2.borderWidth) {
          return;
        }
        if (inner) {
          ctx.lineWidth = options2.borderWidth * 2;
          ctx.lineJoin = "round";
        } else {
          ctx.lineWidth = options2.borderWidth;
          ctx.lineJoin = "bevel";
        }
        if (element.fullCircles) {
          drawFullCircleBorders(ctx, element, inner);
        }
        if (inner) {
          clipArc(ctx, element, endAngle);
        }
        pathArc(ctx, element, offset, spacing, endAngle);
        ctx.stroke();
      }
      class ArcElement extends Element {
        constructor(cfg) {
          super();
          this.options = void 0;
          this.circumference = void 0;
          this.startAngle = void 0;
          this.endAngle = void 0;
          this.innerRadius = void 0;
          this.outerRadius = void 0;
          this.pixelMargin = 0;
          this.fullCircles = 0;
          if (cfg) {
            Object.assign(this, cfg);
          }
        }
        inRange(chartX, chartY, useFinalPosition) {
          const point = this.getProps(["x", "y"], useFinalPosition);
          const { angle, distance } = getAngleFromPoint(point, { x: chartX, y: chartY });
          const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([
            "startAngle",
            "endAngle",
            "innerRadius",
            "outerRadius",
            "circumference"
          ], useFinalPosition);
          const rAdjust = this.options.spacing / 2;
          const betweenAngles = circumference >= TAU || _angleBetween(angle, startAngle, endAngle);
          const withinRadius = distance >= innerRadius + rAdjust && distance <= outerRadius + rAdjust;
          return betweenAngles && withinRadius;
        }
        getCenterPoint(useFinalPosition) {
          const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([
            "x",
            "y",
            "startAngle",
            "endAngle",
            "innerRadius",
            "outerRadius",
            "circumference"
          ], useFinalPosition);
          const { offset, spacing } = this.options;
          const halfAngle = (startAngle + endAngle) / 2;
          const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
          return {
            x: x + Math.cos(halfAngle) * halfRadius,
            y: y + Math.sin(halfAngle) * halfRadius
          };
        }
        tooltipPosition(useFinalPosition) {
          return this.getCenterPoint(useFinalPosition);
        }
        draw(ctx) {
          const me = this;
          const { options: options2, circumference } = me;
          const offset = (options2.offset || 0) / 2;
          const spacing = (options2.spacing || 0) / 2;
          me.pixelMargin = options2.borderAlign === "inner" ? 0.33 : 0;
          me.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
          if (circumference === 0 || me.innerRadius < 0 || me.outerRadius < 0) {
            return;
          }
          ctx.save();
          let radiusOffset = 0;
          if (offset) {
            radiusOffset = offset / 2;
            const halfAngle = (me.startAngle + me.endAngle) / 2;
            ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);
            if (me.circumference >= PI) {
              radiusOffset = offset;
            }
          }
          ctx.fillStyle = options2.backgroundColor;
          ctx.strokeStyle = options2.borderColor;
          const endAngle = drawArc(ctx, me, radiusOffset, spacing);
          drawBorder(ctx, me, radiusOffset, spacing, endAngle);
          ctx.restore();
        }
      }
      ArcElement.id = "arc";
      ArcElement.defaults = {
        borderAlign: "center",
        borderColor: "#fff",
        borderRadius: 0,
        borderWidth: 2,
        offset: 0,
        spacing: 0,
        angle: void 0
      };
      ArcElement.defaultRoutes = {
        backgroundColor: "backgroundColor"
      };
      function setStyle(ctx, options2, style = options2) {
        ctx.lineCap = valueOrDefault(style.borderCapStyle, options2.borderCapStyle);
        ctx.setLineDash(valueOrDefault(style.borderDash, options2.borderDash));
        ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options2.borderDashOffset);
        ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options2.borderJoinStyle);
        ctx.lineWidth = valueOrDefault(style.borderWidth, options2.borderWidth);
        ctx.strokeStyle = valueOrDefault(style.borderColor, options2.borderColor);
      }
      function lineTo(ctx, previous, target) {
        ctx.lineTo(target.x, target.y);
      }
      function getLineMethod(options2) {
        if (options2.stepped) {
          return _steppedLineTo;
        }
        if (options2.tension || options2.cubicInterpolationMode === "monotone") {
          return _bezierCurveTo;
        }
        return lineTo;
      }
      function pathVars(points, segment, params = {}) {
        const count = points.length;
        const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
        const { start: segmentStart, end: segmentEnd } = segment;
        const start2 = Math.max(paramsStart, segmentStart);
        const end = Math.min(paramsEnd, segmentEnd);
        const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
        return {
          count,
          start: start2,
          loop: segment.loop,
          ilen: end < start2 && !outside ? count + end - start2 : end - start2
        };
      }
      function pathSegment(ctx, line, segment, params) {
        const { points, options: options2 } = line;
        const { count, start: start2, loop, ilen } = pathVars(points, segment, params);
        const lineMethod = getLineMethod(options2);
        let { move = true, reverse } = params || {};
        let i, point, prev;
        for (i = 0; i <= ilen; ++i) {
          point = points[(start2 + (reverse ? ilen - i : i)) % count];
          if (point.skip) {
            continue;
          } else if (move) {
            ctx.moveTo(point.x, point.y);
            move = false;
          } else {
            lineMethod(ctx, prev, point, reverse, options2.stepped);
          }
          prev = point;
        }
        if (loop) {
          point = points[(start2 + (reverse ? ilen : 0)) % count];
          lineMethod(ctx, prev, point, reverse, options2.stepped);
        }
        return !!loop;
      }
      function fastPathSegment(ctx, line, segment, params) {
        const points = line.points;
        const { count, start: start2, ilen } = pathVars(points, segment, params);
        const { move = true, reverse } = params || {};
        let avgX = 0;
        let countX = 0;
        let i, point, prevX, minY, maxY, lastY;
        const pointIndex = (index2) => (start2 + (reverse ? ilen - index2 : index2)) % count;
        const drawX = () => {
          if (minY !== maxY) {
            ctx.lineTo(avgX, maxY);
            ctx.lineTo(avgX, minY);
            ctx.lineTo(avgX, lastY);
          }
        };
        if (move) {
          point = points[pointIndex(0)];
          ctx.moveTo(point.x, point.y);
        }
        for (i = 0; i <= ilen; ++i) {
          point = points[pointIndex(i)];
          if (point.skip) {
            continue;
          }
          const x = point.x;
          const y = point.y;
          const truncX = x | 0;
          if (truncX === prevX) {
            if (y < minY) {
              minY = y;
            } else if (y > maxY) {
              maxY = y;
            }
            avgX = (countX * avgX + x) / ++countX;
          } else {
            drawX();
            ctx.lineTo(x, y);
            prevX = truncX;
            countX = 0;
            minY = maxY = y;
          }
          lastY = y;
        }
        drawX();
      }
      function _getSegmentMethod(line) {
        const opts = line.options;
        const borderDash = opts.borderDash && opts.borderDash.length;
        const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
        return useFastPath ? fastPathSegment : pathSegment;
      }
      function _getInterpolationMethod(options2) {
        if (options2.stepped) {
          return _steppedInterpolation;
        }
        if (options2.tension || options2.cubicInterpolationMode === "monotone") {
          return _bezierInterpolation;
        }
        return _pointInLine;
      }
      function strokePathWithCache(ctx, line, start2, count) {
        let path = line._path;
        if (!path) {
          path = line._path = new Path2D();
          if (line.path(path, start2, count)) {
            path.closePath();
          }
        }
        setStyle(ctx, line.options);
        ctx.stroke(path);
      }
      function strokePathDirect(ctx, line, start2, count) {
        const { segments, options: options2 } = line;
        const segmentMethod = _getSegmentMethod(line);
        for (const segment of segments) {
          setStyle(ctx, options2, segment.style);
          ctx.beginPath();
          if (segmentMethod(ctx, line, segment, { start: start2, end: start2 + count - 1 })) {
            ctx.closePath();
          }
          ctx.stroke();
        }
      }
      const usePath2D = typeof Path2D === "function";
      function draw(ctx, line, start2, count) {
        if (usePath2D && line.segments.length === 1) {
          strokePathWithCache(ctx, line, start2, count);
        } else {
          strokePathDirect(ctx, line, start2, count);
        }
      }
      class LineElement extends Element {
        constructor(cfg) {
          super();
          this.animated = true;
          this.options = void 0;
          this._loop = void 0;
          this._fullLoop = void 0;
          this._path = void 0;
          this._points = void 0;
          this._segments = void 0;
          this._decimated = false;
          this._pointsUpdated = false;
          this._datasetIndex = void 0;
          if (cfg) {
            Object.assign(this, cfg);
          }
        }
        updateControlPoints(chartArea, indexAxis) {
          const me = this;
          const options2 = me.options;
          if ((options2.tension || options2.cubicInterpolationMode === "monotone") && !options2.stepped && !me._pointsUpdated) {
            const loop = options2.spanGaps ? me._loop : me._fullLoop;
            _updateBezierControlPoints(me._points, options2, chartArea, loop, indexAxis);
            me._pointsUpdated = true;
          }
        }
        set points(points) {
          const me = this;
          me._points = points;
          delete me._segments;
          delete me._path;
          me._pointsUpdated = false;
        }
        get points() {
          return this._points;
        }
        get segments() {
          return this._segments || (this._segments = _computeSegments(this, this.options.segment));
        }
        first() {
          const segments = this.segments;
          const points = this.points;
          return segments.length && points[segments[0].start];
        }
        last() {
          const segments = this.segments;
          const points = this.points;
          const count = segments.length;
          return count && points[segments[count - 1].end];
        }
        interpolate(point, property) {
          const me = this;
          const options2 = me.options;
          const value = point[property];
          const points = me.points;
          const segments = _boundSegments(me, { property, start: value, end: value });
          if (!segments.length) {
            return;
          }
          const result = [];
          const _interpolate = _getInterpolationMethod(options2);
          let i, ilen;
          for (i = 0, ilen = segments.length; i < ilen; ++i) {
            const { start: start2, end } = segments[i];
            const p1 = points[start2];
            const p2 = points[end];
            if (p1 === p2) {
              result.push(p1);
              continue;
            }
            const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
            const interpolated = _interpolate(p1, p2, t, options2.stepped);
            interpolated[property] = point[property];
            result.push(interpolated);
          }
          return result.length === 1 ? result[0] : result;
        }
        pathSegment(ctx, segment, params) {
          const segmentMethod = _getSegmentMethod(this);
          return segmentMethod(ctx, this, segment, params);
        }
        path(ctx, start2, count) {
          const me = this;
          const segments = me.segments;
          const segmentMethod = _getSegmentMethod(me);
          let loop = me._loop;
          start2 = start2 || 0;
          count = count || me.points.length - start2;
          for (const segment of segments) {
            loop &= segmentMethod(ctx, me, segment, { start: start2, end: start2 + count - 1 });
          }
          return !!loop;
        }
        draw(ctx, chartArea, start2, count) {
          const me = this;
          const options2 = me.options || {};
          const points = me.points || [];
          if (!points.length || !options2.borderWidth) {
            return;
          }
          ctx.save();
          draw(ctx, me, start2, count);
          ctx.restore();
          if (me.animated) {
            me._pointsUpdated = false;
            me._path = void 0;
          }
        }
      }
      LineElement.id = "line";
      LineElement.defaults = {
        borderCapStyle: "butt",
        borderDash: [],
        borderDashOffset: 0,
        borderJoinStyle: "miter",
        borderWidth: 3,
        capBezierPoints: true,
        cubicInterpolationMode: "default",
        fill: false,
        spanGaps: false,
        stepped: false,
        tension: 0
      };
      LineElement.defaultRoutes = {
        backgroundColor: "backgroundColor",
        borderColor: "borderColor"
      };
      LineElement.descriptors = {
        _scriptable: true,
        _indexable: (name2) => name2 !== "borderDash" && name2 !== "fill"
      };
      function inRange$1(el, pos, axis, useFinalPosition) {
        const options2 = el.options;
        const { [axis]: value } = el.getProps([axis], useFinalPosition);
        return Math.abs(pos - value) < options2.radius + options2.hitRadius;
      }
      class PointElement extends Element {
        constructor(cfg) {
          super();
          this.options = void 0;
          this.parsed = void 0;
          this.skip = void 0;
          this.stop = void 0;
          if (cfg) {
            Object.assign(this, cfg);
          }
        }
        inRange(mouseX, mouseY, useFinalPosition) {
          const options2 = this.options;
          const { x, y } = this.getProps(["x", "y"], useFinalPosition);
          return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options2.hitRadius + options2.radius, 2);
        }
        inXRange(mouseX, useFinalPosition) {
          return inRange$1(this, mouseX, "x", useFinalPosition);
        }
        inYRange(mouseY, useFinalPosition) {
          return inRange$1(this, mouseY, "y", useFinalPosition);
        }
        getCenterPoint(useFinalPosition) {
          const { x, y } = this.getProps(["x", "y"], useFinalPosition);
          return { x, y };
        }
        size(options2) {
          options2 = options2 || this.options || {};
          let radius = options2.radius || 0;
          radius = Math.max(radius, radius && options2.hoverRadius || 0);
          const borderWidth = radius && options2.borderWidth || 0;
          return (radius + borderWidth) * 2;
        }
        draw(ctx, area) {
          const me = this;
          const options2 = me.options;
          if (me.skip || options2.radius < 0.1 || !_isPointInArea(me, area, me.size(options2) / 2)) {
            return;
          }
          ctx.strokeStyle = options2.borderColor;
          ctx.lineWidth = options2.borderWidth;
          ctx.fillStyle = options2.backgroundColor;
          drawPoint(ctx, options2, me.x, me.y);
        }
        getRange() {
          const options2 = this.options || {};
          return options2.radius + options2.hitRadius;
        }
      }
      PointElement.id = "point";
      PointElement.defaults = {
        borderWidth: 1,
        hitRadius: 1,
        hoverBorderWidth: 1,
        hoverRadius: 4,
        pointStyle: "circle",
        radius: 3,
        rotation: 0
      };
      PointElement.defaultRoutes = {
        backgroundColor: "backgroundColor",
        borderColor: "borderColor"
      };
      function getBarBounds(bar, useFinalPosition) {
        const { x, y, base: base2, width, height } = bar.getProps(["x", "y", "base", "width", "height"], useFinalPosition);
        let left, right, top, bottom, half;
        if (bar.horizontal) {
          half = height / 2;
          left = Math.min(x, base2);
          right = Math.max(x, base2);
          top = y - half;
          bottom = y + half;
        } else {
          half = width / 2;
          left = x - half;
          right = x + half;
          top = Math.min(y, base2);
          bottom = Math.max(y, base2);
        }
        return { left, top, right, bottom };
      }
      function skipOrLimit(skip2, value, min, max) {
        return skip2 ? 0 : _limitValue(value, min, max);
      }
      function parseBorderWidth(bar, maxW, maxH) {
        const value = bar.options.borderWidth;
        const skip2 = bar.borderSkipped;
        const o = toTRBL(value);
        return {
          t: skipOrLimit(skip2.top, o.top, 0, maxH),
          r: skipOrLimit(skip2.right, o.right, 0, maxW),
          b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),
          l: skipOrLimit(skip2.left, o.left, 0, maxW)
        };
      }
      function parseBorderRadius(bar, maxW, maxH) {
        const { enableBorderRadius } = bar.getProps(["enableBorderRadius"]);
        const value = bar.options.borderRadius;
        const o = toTRBLCorners(value);
        const maxR = Math.min(maxW, maxH);
        const skip2 = bar.borderSkipped;
        const enableBorder = enableBorderRadius || isObject2(value);
        return {
          topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o.topLeft, 0, maxR),
          topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o.topRight, 0, maxR),
          bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o.bottomLeft, 0, maxR),
          bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o.bottomRight, 0, maxR)
        };
      }
      function boundingRects(bar) {
        const bounds = getBarBounds(bar);
        const width = bounds.right - bounds.left;
        const height = bounds.bottom - bounds.top;
        const border = parseBorderWidth(bar, width / 2, height / 2);
        const radius = parseBorderRadius(bar, width / 2, height / 2);
        return {
          outer: {
            x: bounds.left,
            y: bounds.top,
            w: width,
            h: height,
            radius
          },
          inner: {
            x: bounds.left + border.l,
            y: bounds.top + border.t,
            w: width - border.l - border.r,
            h: height - border.t - border.b,
            radius: {
              topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
              topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
              bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
              bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
            }
          }
        };
      }
      function inRange(bar, x, y, useFinalPosition) {
        const skipX = x === null;
        const skipY = y === null;
        const skipBoth = skipX && skipY;
        const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
        return bounds && (skipX || x >= bounds.left && x <= bounds.right) && (skipY || y >= bounds.top && y <= bounds.bottom);
      }
      function hasRadius(radius) {
        return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
      }
      function addNormalRectPath(ctx, rect) {
        ctx.rect(rect.x, rect.y, rect.w, rect.h);
      }
      function inflateRect(rect, amount, refRect = {}) {
        const x = rect.x !== refRect.x ? -amount : 0;
        const y = rect.y !== refRect.y ? -amount : 0;
        const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
        const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
        return {
          x: rect.x + x,
          y: rect.y + y,
          w: rect.w + w,
          h: rect.h + h,
          radius: rect.radius
        };
      }
      class BarElement extends Element {
        constructor(cfg) {
          super();
          this.options = void 0;
          this.horizontal = void 0;
          this.base = void 0;
          this.width = void 0;
          this.height = void 0;
          if (cfg) {
            Object.assign(this, cfg);
          }
        }
        draw(ctx) {
          const options2 = this.options;
          const { inner, outer } = boundingRects(this);
          const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
          const inflateAmount = 0.33;
          ctx.save();
          if (outer.w !== inner.w || outer.h !== inner.h) {
            ctx.beginPath();
            addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
            ctx.clip();
            addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
            ctx.fillStyle = options2.borderColor;
            ctx.fill("evenodd");
          }
          ctx.beginPath();
          addRectPath(ctx, inflateRect(inner, inflateAmount, outer));
          ctx.fillStyle = options2.backgroundColor;
          ctx.fill();
          ctx.restore();
        }
        inRange(mouseX, mouseY, useFinalPosition) {
          return inRange(this, mouseX, mouseY, useFinalPosition);
        }
        inXRange(mouseX, useFinalPosition) {
          return inRange(this, mouseX, null, useFinalPosition);
        }
        inYRange(mouseY, useFinalPosition) {
          return inRange(this, null, mouseY, useFinalPosition);
        }
        getCenterPoint(useFinalPosition) {
          const { x, y, base: base2, horizontal } = this.getProps(["x", "y", "base", "horizontal"], useFinalPosition);
          return {
            x: horizontal ? (x + base2) / 2 : x,
            y: horizontal ? y : (y + base2) / 2
          };
        }
        getRange(axis) {
          return axis === "x" ? this.width / 2 : this.height / 2;
        }
      }
      BarElement.id = "bar";
      BarElement.defaults = {
        borderSkipped: "start",
        borderWidth: 0,
        borderRadius: 0,
        enableBorderRadius: true,
        pointStyle: void 0
      };
      BarElement.defaultRoutes = {
        backgroundColor: "backgroundColor",
        borderColor: "borderColor"
      };
      var elements = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        ArcElement,
        LineElement,
        PointElement,
        BarElement
      });
      function lttbDecimation(data, start2, count, availableWidth, options2) {
        const samples = options2.samples || availableWidth;
        if (samples >= count) {
          return data.slice(start2, start2 + count);
        }
        const decimated = [];
        const bucketWidth = (count - 2) / (samples - 2);
        let sampledIndex = 0;
        const endIndex = start2 + count - 1;
        let a = start2;
        let i, maxAreaPoint, maxArea, area, nextA;
        decimated[sampledIndex++] = data[a];
        for (i = 0; i < samples - 2; i++) {
          let avgX = 0;
          let avgY = 0;
          let j;
          const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start2;
          const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start2;
          const avgRangeLength = avgRangeEnd - avgRangeStart;
          for (j = avgRangeStart; j < avgRangeEnd; j++) {
            avgX += data[j].x;
            avgY += data[j].y;
          }
          avgX /= avgRangeLength;
          avgY /= avgRangeLength;
          const rangeOffs = Math.floor(i * bucketWidth) + 1 + start2;
          const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start2;
          const { x: pointAx, y: pointAy } = data[a];
          maxArea = area = -1;
          for (j = rangeOffs; j < rangeTo; j++) {
            area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
            if (area > maxArea) {
              maxArea = area;
              maxAreaPoint = data[j];
              nextA = j;
            }
          }
          decimated[sampledIndex++] = maxAreaPoint;
          a = nextA;
        }
        decimated[sampledIndex++] = data[endIndex];
        return decimated;
      }
      function minMaxDecimation(data, start2, count, availableWidth) {
        let avgX = 0;
        let countX = 0;
        let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
        const decimated = [];
        const endIndex = start2 + count - 1;
        const xMin = data[start2].x;
        const xMax = data[endIndex].x;
        const dx = xMax - xMin;
        for (i = start2; i < start2 + count; ++i) {
          point = data[i];
          x = (point.x - xMin) / dx * availableWidth;
          y = point.y;
          const truncX = x | 0;
          if (truncX === prevX) {
            if (y < minY) {
              minY = y;
              minIndex = i;
            } else if (y > maxY) {
              maxY = y;
              maxIndex = i;
            }
            avgX = (countX * avgX + point.x) / ++countX;
          } else {
            const lastIndex = i - 1;
            if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
              const intermediateIndex1 = Math.min(minIndex, maxIndex);
              const intermediateIndex2 = Math.max(minIndex, maxIndex);
              if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {
                decimated.push({
                  ...data[intermediateIndex1],
                  x: avgX
                });
              }
              if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {
                decimated.push({
                  ...data[intermediateIndex2],
                  x: avgX
                });
              }
            }
            if (i > 0 && lastIndex !== startIndex) {
              decimated.push(data[lastIndex]);
            }
            decimated.push(point);
            prevX = truncX;
            countX = 0;
            minY = maxY = y;
            minIndex = maxIndex = startIndex = i;
          }
        }
        return decimated;
      }
      function cleanDecimatedDataset(dataset) {
        if (dataset._decimated) {
          const data = dataset._data;
          delete dataset._decimated;
          delete dataset._data;
          Object.defineProperty(dataset, "data", { value: data });
        }
      }
      function cleanDecimatedData(chart) {
        chart.data.datasets.forEach((dataset) => {
          cleanDecimatedDataset(dataset);
        });
      }
      function getStartAndCountOfVisiblePointsSimplified(meta, points) {
        const pointCount = points.length;
        let start2 = 0;
        let count;
        const { iScale } = meta;
        const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
        if (minDefined) {
          start2 = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
        }
        if (maxDefined) {
          count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start2, pointCount) - start2;
        } else {
          count = pointCount - start2;
        }
        return { start: start2, count };
      }
      var plugin_decimation = {
        id: "decimation",
        defaults: {
          algorithm: "min-max",
          enabled: false
        },
        beforeElementsUpdate: (chart, args, options2) => {
          if (!options2.enabled) {
            cleanDecimatedData(chart);
            return;
          }
          const availableWidth = chart.width;
          chart.data.datasets.forEach((dataset, datasetIndex) => {
            const { _data, indexAxis } = dataset;
            const meta = chart.getDatasetMeta(datasetIndex);
            const data = _data || dataset.data;
            if (resolve2([indexAxis, chart.options.indexAxis]) === "y") {
              return;
            }
            if (meta.type !== "line") {
              return;
            }
            const xAxis = chart.scales[meta.xAxisID];
            if (xAxis.type !== "linear" && xAxis.type !== "time") {
              return;
            }
            if (chart.options.parsing) {
              return;
            }
            let { start: start2, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);
            const threshold = options2.threshold || 4 * availableWidth;
            if (count <= threshold) {
              cleanDecimatedDataset(dataset);
              return;
            }
            if (isNullOrUndef(_data)) {
              dataset._data = data;
              delete dataset.data;
              Object.defineProperty(dataset, "data", {
                configurable: true,
                enumerable: true,
                get: function() {
                  return this._decimated;
                },
                set: function(d2) {
                  this._data = d2;
                }
              });
            }
            let decimated;
            switch (options2.algorithm) {
              case "lttb":
                decimated = lttbDecimation(data, start2, count, availableWidth, options2);
                break;
              case "min-max":
                decimated = minMaxDecimation(data, start2, count, availableWidth);
                break;
              default:
                throw new Error(`Unsupported decimation algorithm '${options2.algorithm}'`);
            }
            dataset._decimated = decimated;
          });
        },
        destroy(chart) {
          cleanDecimatedData(chart);
        }
      };
      function getLineByIndex(chart, index2) {
        const meta = chart.getDatasetMeta(index2);
        const visible = meta && chart.isDatasetVisible(index2);
        return visible ? meta.dataset : null;
      }
      function parseFillOption(line) {
        const options2 = line.options;
        const fillOption = options2.fill;
        let fill = valueOrDefault(fillOption && fillOption.target, fillOption);
        if (fill === void 0) {
          fill = !!options2.backgroundColor;
        }
        if (fill === false || fill === null) {
          return false;
        }
        if (fill === true) {
          return "origin";
        }
        return fill;
      }
      function decodeFill(line, index2, count) {
        const fill = parseFillOption(line);
        if (isObject2(fill)) {
          return isNaN(fill.value) ? false : fill;
        }
        let target = parseFloat(fill);
        if (isNumberFinite(target) && Math.floor(target) === target) {
          if (fill[0] === "-" || fill[0] === "+") {
            target = index2 + target;
          }
          if (target === index2 || target < 0 || target >= count) {
            return false;
          }
          return target;
        }
        return ["origin", "start", "end", "stack", "shape"].indexOf(fill) >= 0 && fill;
      }
      function computeLinearBoundary(source) {
        const { scale = {}, fill } = source;
        let target = null;
        let horizontal;
        if (fill === "start") {
          target = scale.bottom;
        } else if (fill === "end") {
          target = scale.top;
        } else if (isObject2(fill)) {
          target = scale.getPixelForValue(fill.value);
        } else if (scale.getBasePixel) {
          target = scale.getBasePixel();
        }
        if (isNumberFinite(target)) {
          horizontal = scale.isHorizontal();
          return {
            x: horizontal ? target : null,
            y: horizontal ? null : target
          };
        }
        return null;
      }
      class simpleArc {
        constructor(opts) {
          this.x = opts.x;
          this.y = opts.y;
          this.radius = opts.radius;
        }
        pathSegment(ctx, bounds, opts) {
          const { x, y, radius } = this;
          bounds = bounds || { start: 0, end: TAU };
          ctx.arc(x, y, radius, bounds.end, bounds.start, true);
          return !opts.bounds;
        }
        interpolate(point) {
          const { x, y, radius } = this;
          const angle = point.angle;
          return {
            x: x + Math.cos(angle) * radius,
            y: y + Math.sin(angle) * radius,
            angle
          };
        }
      }
      function computeCircularBoundary(source) {
        const { scale, fill } = source;
        const options2 = scale.options;
        const length = scale.getLabels().length;
        const target = [];
        const start2 = options2.reverse ? scale.max : scale.min;
        const end = options2.reverse ? scale.min : scale.max;
        let i, center, value;
        if (fill === "start") {
          value = start2;
        } else if (fill === "end") {
          value = end;
        } else if (isObject2(fill)) {
          value = fill.value;
        } else {
          value = scale.getBaseValue();
        }
        if (options2.grid.circular) {
          center = scale.getPointPositionForValue(0, start2);
          return new simpleArc({
            x: center.x,
            y: center.y,
            radius: scale.getDistanceFromCenterForValue(value)
          });
        }
        for (i = 0; i < length; ++i) {
          target.push(scale.getPointPositionForValue(i, value));
        }
        return target;
      }
      function computeBoundary(source) {
        const scale = source.scale || {};
        if (scale.getPointPositionForValue) {
          return computeCircularBoundary(source);
        }
        return computeLinearBoundary(source);
      }
      function findSegmentEnd(start2, end, points) {
        for (; end > start2; end--) {
          const point = points[end];
          if (!isNaN(point.x) && !isNaN(point.y)) {
            break;
          }
        }
        return end;
      }
      function pointsFromSegments(boundary, line) {
        const { x = null, y = null } = boundary || {};
        const linePoints = line.points;
        const points = [];
        line.segments.forEach(({ start: start2, end }) => {
          end = findSegmentEnd(start2, end, linePoints);
          const first = linePoints[start2];
          const last = linePoints[end];
          if (y !== null) {
            points.push({ x: first.x, y });
            points.push({ x: last.x, y });
          } else if (x !== null) {
            points.push({ x, y: first.y });
            points.push({ x, y: last.y });
          }
        });
        return points;
      }
      function buildStackLine(source) {
        const { chart, scale, index: index2, line } = source;
        const points = [];
        const segments = line.segments;
        const sourcePoints = line.points;
        const linesBelow = getLinesBelow(chart, index2);
        linesBelow.push(createBoundaryLine({ x: null, y: scale.bottom }, line));
        for (let i = 0; i < segments.length; i++) {
          const segment = segments[i];
          for (let j = segment.start; j <= segment.end; j++) {
            addPointsBelow(points, sourcePoints[j], linesBelow);
          }
        }
        return new LineElement({ points, options: {} });
      }
      const isLineAndNotInHideAnimation = (meta) => meta.type === "line" && !meta.hidden;
      function getLinesBelow(chart, index2) {
        const below = [];
        const metas = chart.getSortedVisibleDatasetMetas();
        for (let i = 0; i < metas.length; i++) {
          const meta = metas[i];
          if (meta.index === index2) {
            break;
          }
          if (isLineAndNotInHideAnimation(meta)) {
            below.unshift(meta.dataset);
          }
        }
        return below;
      }
      function addPointsBelow(points, sourcePoint, linesBelow) {
        const postponed = [];
        for (let j = 0; j < linesBelow.length; j++) {
          const line = linesBelow[j];
          const { first, last, point } = findPoint(line, sourcePoint, "x");
          if (!point || first && last) {
            continue;
          }
          if (first) {
            postponed.unshift(point);
          } else {
            points.push(point);
            if (!last) {
              break;
            }
          }
        }
        points.push(...postponed);
      }
      function findPoint(line, sourcePoint, property) {
        const point = line.interpolate(sourcePoint, property);
        if (!point) {
          return {};
        }
        const pointValue = point[property];
        const segments = line.segments;
        const linePoints = line.points;
        let first = false;
        let last = false;
        for (let i = 0; i < segments.length; i++) {
          const segment = segments[i];
          const firstValue = linePoints[segment.start][property];
          const lastValue = linePoints[segment.end][property];
          if (pointValue >= firstValue && pointValue <= lastValue) {
            first = pointValue === firstValue;
            last = pointValue === lastValue;
            break;
          }
        }
        return { first, last, point };
      }
      function getTarget(source) {
        const { chart, fill, line } = source;
        if (isNumberFinite(fill)) {
          return getLineByIndex(chart, fill);
        }
        if (fill === "stack") {
          return buildStackLine(source);
        }
        if (fill === "shape") {
          return true;
        }
        const boundary = computeBoundary(source);
        if (boundary instanceof simpleArc) {
          return boundary;
        }
        return createBoundaryLine(boundary, line);
      }
      function createBoundaryLine(boundary, line) {
        let points = [];
        let _loop = false;
        if (isArray(boundary)) {
          _loop = true;
          points = boundary;
        } else {
          points = pointsFromSegments(boundary, line);
        }
        return points.length ? new LineElement({
          points,
          options: { tension: 0 },
          _loop,
          _fullLoop: _loop
        }) : null;
      }
      function resolveTarget(sources, index2, propagate) {
        const source = sources[index2];
        let fill = source.fill;
        const visited = [index2];
        let target;
        if (!propagate) {
          return fill;
        }
        while (fill !== false && visited.indexOf(fill) === -1) {
          if (!isNumberFinite(fill)) {
            return fill;
          }
          target = sources[fill];
          if (!target) {
            return false;
          }
          if (target.visible) {
            return fill;
          }
          visited.push(fill);
          fill = target.fill;
        }
        return false;
      }
      function _clip(ctx, target, clipY) {
        ctx.beginPath();
        target.path(ctx);
        ctx.lineTo(target.last().x, clipY);
        ctx.lineTo(target.first().x, clipY);
        ctx.closePath();
        ctx.clip();
      }
      function getBounds(property, first, last, loop) {
        if (loop) {
          return;
        }
        let start2 = first[property];
        let end = last[property];
        if (property === "angle") {
          start2 = _normalizeAngle(start2);
          end = _normalizeAngle(end);
        }
        return { property, start: start2, end };
      }
      function _getEdge(a, b, prop, fn) {
        if (a && b) {
          return fn(a[prop], b[prop]);
        }
        return a ? a[prop] : b ? b[prop] : 0;
      }
      function _segments(line, target, property) {
        const segments = line.segments;
        const points = line.points;
        const tpoints = target.points;
        const parts = [];
        for (const segment of segments) {
          let { start: start2, end } = segment;
          end = findSegmentEnd(start2, end, points);
          const bounds = getBounds(property, points[start2], points[end], segment.loop);
          if (!target.segments) {
            parts.push({
              source: segment,
              target: bounds,
              start: points[start2],
              end: points[end]
            });
            continue;
          }
          const targetSegments = _boundSegments(target, bounds);
          for (const tgt of targetSegments) {
            const subBounds = getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
            const fillSources = _boundSegment(segment, points, subBounds);
            for (const fillSource of fillSources) {
              parts.push({
                source: fillSource,
                target: tgt,
                start: {
                  [property]: _getEdge(bounds, subBounds, "start", Math.max)
                },
                end: {
                  [property]: _getEdge(bounds, subBounds, "end", Math.min)
                }
              });
            }
          }
        }
        return parts;
      }
      function clipBounds(ctx, scale, bounds) {
        const { top, bottom } = scale.chart.chartArea;
        const { property, start: start2, end } = bounds || {};
        if (property === "x") {
          ctx.beginPath();
          ctx.rect(start2, top, end - start2, bottom - top);
          ctx.clip();
        }
      }
      function interpolatedLineTo(ctx, target, point, property) {
        const interpolatedPoint = target.interpolate(point, property);
        if (interpolatedPoint) {
          ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
        }
      }
      function _fill(ctx, cfg) {
        const { line, target, property, color: color2, scale } = cfg;
        const segments = _segments(line, target, property);
        for (const { source: src2, target: tgt, start: start2, end } of segments) {
          const { style: { backgroundColor = color2 } = {} } = src2;
          const notShape = target !== true;
          ctx.save();
          ctx.fillStyle = backgroundColor;
          clipBounds(ctx, scale, notShape && getBounds(property, start2, end));
          ctx.beginPath();
          const lineLoop = !!line.pathSegment(ctx, src2);
          let loop;
          if (notShape) {
            if (lineLoop) {
              ctx.closePath();
            } else {
              interpolatedLineTo(ctx, target, end, property);
            }
            const targetLoop = !!target.pathSegment(ctx, tgt, { move: lineLoop, reverse: true });
            loop = lineLoop && targetLoop;
            if (!loop) {
              interpolatedLineTo(ctx, target, start2, property);
            }
          }
          ctx.closePath();
          ctx.fill(loop ? "evenodd" : "nonzero");
          ctx.restore();
        }
      }
      function doFill(ctx, cfg) {
        const { line, target, above, below, area, scale } = cfg;
        const property = line._loop ? "angle" : cfg.axis;
        ctx.save();
        if (property === "x" && below !== above) {
          _clip(ctx, target, area.top);
          _fill(ctx, { line, target, color: above, scale, property });
          ctx.restore();
          ctx.save();
          _clip(ctx, target, area.bottom);
        }
        _fill(ctx, { line, target, color: below, scale, property });
        ctx.restore();
      }
      function drawfill(ctx, source, area) {
        const target = getTarget(source);
        const { line, scale, axis } = source;
        const lineOpts = line.options;
        const fillOption = lineOpts.fill;
        const color2 = lineOpts.backgroundColor;
        const { above = color2, below = color2 } = fillOption || {};
        if (target && line.points.length) {
          clipArea(ctx, area);
          doFill(ctx, { line, target, above, below, area, scale, axis });
          unclipArea(ctx);
        }
      }
      var plugin_filler = {
        id: "filler",
        afterDatasetsUpdate(chart, _args, options2) {
          const count = (chart.data.datasets || []).length;
          const sources = [];
          let meta, i, line, source;
          for (i = 0; i < count; ++i) {
            meta = chart.getDatasetMeta(i);
            line = meta.dataset;
            source = null;
            if (line && line.options && line instanceof LineElement) {
              source = {
                visible: chart.isDatasetVisible(i),
                index: i,
                fill: decodeFill(line, i, count),
                chart,
                axis: meta.controller.options.indexAxis,
                scale: meta.vScale,
                line
              };
            }
            meta.$filler = source;
            sources.push(source);
          }
          for (i = 0; i < count; ++i) {
            source = sources[i];
            if (!source || source.fill === false) {
              continue;
            }
            source.fill = resolveTarget(sources, i, options2.propagate);
          }
        },
        beforeDraw(chart, _args, options2) {
          const draw2 = options2.drawTime === "beforeDraw";
          const metasets = chart.getSortedVisibleDatasetMetas();
          const area = chart.chartArea;
          for (let i = metasets.length - 1; i >= 0; --i) {
            const source = metasets[i].$filler;
            if (!source) {
              continue;
            }
            source.line.updateControlPoints(area, source.axis);
            if (draw2) {
              drawfill(chart.ctx, source, area);
            }
          }
        },
        beforeDatasetsDraw(chart, _args, options2) {
          if (options2.drawTime !== "beforeDatasetsDraw") {
            return;
          }
          const metasets = chart.getSortedVisibleDatasetMetas();
          for (let i = metasets.length - 1; i >= 0; --i) {
            const source = metasets[i].$filler;
            if (source) {
              drawfill(chart.ctx, source, chart.chartArea);
            }
          }
        },
        beforeDatasetDraw(chart, args, options2) {
          const source = args.meta.$filler;
          if (!source || source.fill === false || options2.drawTime !== "beforeDatasetDraw") {
            return;
          }
          drawfill(chart.ctx, source, chart.chartArea);
        },
        defaults: {
          propagate: true,
          drawTime: "beforeDatasetDraw"
        }
      };
      const getBoxSize = (labelOpts, fontSize) => {
        let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
        if (labelOpts.usePointStyle) {
          boxHeight = Math.min(boxHeight, fontSize);
          boxWidth = Math.min(boxWidth, fontSize);
        }
        return {
          boxWidth,
          boxHeight,
          itemHeight: Math.max(fontSize, boxHeight)
        };
      };
      const itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
      class Legend extends Element {
        constructor(config2) {
          super();
          this._added = false;
          this.legendHitBoxes = [];
          this._hoveredItem = null;
          this.doughnutMode = false;
          this.chart = config2.chart;
          this.options = config2.options;
          this.ctx = config2.ctx;
          this.legendItems = void 0;
          this.columnSizes = void 0;
          this.lineWidths = void 0;
          this.maxHeight = void 0;
          this.maxWidth = void 0;
          this.top = void 0;
          this.bottom = void 0;
          this.left = void 0;
          this.right = void 0;
          this.height = void 0;
          this.width = void 0;
          this._margins = void 0;
          this.position = void 0;
          this.weight = void 0;
          this.fullSize = void 0;
        }
        update(maxWidth, maxHeight, margins) {
          const me = this;
          me.maxWidth = maxWidth;
          me.maxHeight = maxHeight;
          me._margins = margins;
          me.setDimensions();
          me.buildLabels();
          me.fit();
        }
        setDimensions() {
          const me = this;
          if (me.isHorizontal()) {
            me.width = me.maxWidth;
            me.left = me._margins.left;
            me.right = me.width;
          } else {
            me.height = me.maxHeight;
            me.top = me._margins.top;
            me.bottom = me.height;
          }
        }
        buildLabels() {
          const me = this;
          const labelOpts = me.options.labels || {};
          let legendItems = callback(labelOpts.generateLabels, [me.chart], me) || [];
          if (labelOpts.filter) {
            legendItems = legendItems.filter((item) => labelOpts.filter(item, me.chart.data));
          }
          if (labelOpts.sort) {
            legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, me.chart.data));
          }
          if (me.options.reverse) {
            legendItems.reverse();
          }
          me.legendItems = legendItems;
        }
        fit() {
          const me = this;
          const { options: options2, ctx } = me;
          if (!options2.display) {
            me.width = me.height = 0;
            return;
          }
          const labelOpts = options2.labels;
          const labelFont = toFont(labelOpts.font);
          const fontSize = labelFont.size;
          const titleHeight = me._computeTitleHeight();
          const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
          let width, height;
          ctx.font = labelFont.string;
          if (me.isHorizontal()) {
            width = me.maxWidth;
            height = me._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
          } else {
            height = me.maxHeight;
            width = me._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;
          }
          me.width = Math.min(width, options2.maxWidth || me.maxWidth);
          me.height = Math.min(height, options2.maxHeight || me.maxHeight);
        }
        _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
          const me = this;
          const { ctx, maxWidth, options: { labels: { padding } } } = me;
          const hitboxes = me.legendHitBoxes = [];
          const lineWidths = me.lineWidths = [0];
          const lineHeight = itemHeight + padding;
          let totalHeight = titleHeight;
          ctx.textAlign = "left";
          ctx.textBaseline = "middle";
          let row = -1;
          let top = -lineHeight;
          me.legendItems.forEach((legendItem, i) => {
            const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
            if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
              totalHeight += lineHeight;
              lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
              top += lineHeight;
              row++;
            }
            hitboxes[i] = { left: 0, top, row, width: itemWidth, height: itemHeight };
            lineWidths[lineWidths.length - 1] += itemWidth + padding;
          });
          return totalHeight;
        }
        _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {
          const me = this;
          const { ctx, maxHeight, options: { labels: { padding } } } = me;
          const hitboxes = me.legendHitBoxes = [];
          const columnSizes = me.columnSizes = [];
          const heightLimit = maxHeight - titleHeight;
          let totalWidth = padding;
          let currentColWidth = 0;
          let currentColHeight = 0;
          let left = 0;
          let col = 0;
          me.legendItems.forEach((legendItem, i) => {
            const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
            if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
              totalWidth += currentColWidth + padding;
              columnSizes.push({ width: currentColWidth, height: currentColHeight });
              left += currentColWidth + padding;
              col++;
              currentColWidth = currentColHeight = 0;
            }
            hitboxes[i] = { left, top: currentColHeight, col, width: itemWidth, height: itemHeight };
            currentColWidth = Math.max(currentColWidth, itemWidth);
            currentColHeight += itemHeight + padding;
          });
          totalWidth += currentColWidth;
          columnSizes.push({ width: currentColWidth, height: currentColHeight });
          return totalWidth;
        }
        adjustHitBoxes() {
          const me = this;
          if (!me.options.display) {
            return;
          }
          const titleHeight = me._computeTitleHeight();
          const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = me;
          const rtlHelper = getRtlAdapter(rtl, me.left, me.width);
          if (this.isHorizontal()) {
            let row = 0;
            let left = _alignStartEnd(align, me.left + padding, me.right - me.lineWidths[row]);
            for (const hitbox of hitboxes) {
              if (row !== hitbox.row) {
                row = hitbox.row;
                left = _alignStartEnd(align, me.left + padding, me.right - me.lineWidths[row]);
              }
              hitbox.top += me.top + titleHeight + padding;
              hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
              left += hitbox.width + padding;
            }
          } else {
            let col = 0;
            let top = _alignStartEnd(align, me.top + titleHeight + padding, me.bottom - me.columnSizes[col].height);
            for (const hitbox of hitboxes) {
              if (hitbox.col !== col) {
                col = hitbox.col;
                top = _alignStartEnd(align, me.top + titleHeight + padding, me.bottom - me.columnSizes[col].height);
              }
              hitbox.top = top;
              hitbox.left += me.left + padding;
              hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
              top += hitbox.height + padding;
            }
          }
        }
        isHorizontal() {
          return this.options.position === "top" || this.options.position === "bottom";
        }
        draw() {
          const me = this;
          if (me.options.display) {
            const ctx = me.ctx;
            clipArea(ctx, me);
            me._draw();
            unclipArea(ctx);
          }
        }
        _draw() {
          const me = this;
          const { options: opts, columnSizes, lineWidths, ctx } = me;
          const { align, labels: labelOpts } = opts;
          const defaultColor = defaults.color;
          const rtlHelper = getRtlAdapter(opts.rtl, me.left, me.width);
          const labelFont = toFont(labelOpts.font);
          const { color: fontColor, padding } = labelOpts;
          const fontSize = labelFont.size;
          const halfFontSize = fontSize / 2;
          let cursor;
          me.drawTitle();
          ctx.textAlign = rtlHelper.textAlign("left");
          ctx.textBaseline = "middle";
          ctx.lineWidth = 0.5;
          ctx.font = labelFont.string;
          const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);
          const drawLegendBox = function(x, y, legendItem) {
            if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {
              return;
            }
            ctx.save();
            const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
            ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
            ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
            ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
            ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
            ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
            if (labelOpts.usePointStyle) {
              const drawOptions = {
                radius: boxWidth * Math.SQRT2 / 2,
                pointStyle: legendItem.pointStyle,
                rotation: legendItem.rotation,
                borderWidth: lineWidth
              };
              const centerX = rtlHelper.xPlus(x, boxWidth / 2);
              const centerY = y + halfFontSize;
              drawPoint(ctx, drawOptions, centerX, centerY);
            } else {
              const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
              const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
              const borderRadius = toTRBLCorners(legendItem.borderRadius);
              ctx.beginPath();
              if (Object.values(borderRadius).some((v) => v !== 0)) {
                addRoundedRectPath(ctx, {
                  x: xBoxLeft,
                  y: yBoxTop,
                  w: boxWidth,
                  h: boxHeight,
                  radius: borderRadius
                });
              } else {
                ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
              }
              ctx.fill();
              if (lineWidth !== 0) {
                ctx.stroke();
              }
            }
            ctx.restore();
          };
          const fillText = function(x, y, legendItem) {
            renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
              strikethrough: legendItem.hidden,
              textAlign: rtlHelper.textAlign(legendItem.textAlign)
            });
          };
          const isHorizontal = me.isHorizontal();
          const titleHeight = this._computeTitleHeight();
          if (isHorizontal) {
            cursor = {
              x: _alignStartEnd(align, me.left + padding, me.right - lineWidths[0]),
              y: me.top + padding + titleHeight,
              line: 0
            };
          } else {
            cursor = {
              x: me.left + padding,
              y: _alignStartEnd(align, me.top + titleHeight + padding, me.bottom - columnSizes[0].height),
              line: 0
            };
          }
          overrideTextDirection(me.ctx, opts.textDirection);
          const lineHeight = itemHeight + padding;
          me.legendItems.forEach((legendItem, i) => {
            ctx.strokeStyle = legendItem.fontColor || fontColor;
            ctx.fillStyle = legendItem.fontColor || fontColor;
            const textWidth = ctx.measureText(legendItem.text).width;
            const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
            const width = boxWidth + halfFontSize + textWidth;
            let x = cursor.x;
            let y = cursor.y;
            rtlHelper.setWidth(me.width);
            if (isHorizontal) {
              if (i > 0 && x + width + padding > me.right) {
                y = cursor.y += lineHeight;
                cursor.line++;
                x = cursor.x = _alignStartEnd(align, me.left + padding, me.right - lineWidths[cursor.line]);
              }
            } else if (i > 0 && y + lineHeight > me.bottom) {
              x = cursor.x = x + columnSizes[cursor.line].width + padding;
              cursor.line++;
              y = cursor.y = _alignStartEnd(align, me.top + titleHeight + padding, me.bottom - columnSizes[cursor.line].height);
            }
            const realX = rtlHelper.x(x);
            drawLegendBox(realX, y, legendItem);
            x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : me.right, opts.rtl);
            fillText(rtlHelper.x(x), y, legendItem);
            if (isHorizontal) {
              cursor.x += width + padding;
            } else {
              cursor.y += lineHeight;
            }
          });
          restoreTextDirection(me.ctx, opts.textDirection);
        }
        drawTitle() {
          const me = this;
          const opts = me.options;
          const titleOpts = opts.title;
          const titleFont = toFont(titleOpts.font);
          const titlePadding = toPadding(titleOpts.padding);
          if (!titleOpts.display) {
            return;
          }
          const rtlHelper = getRtlAdapter(opts.rtl, me.left, me.width);
          const ctx = me.ctx;
          const position = titleOpts.position;
          const halfFontSize = titleFont.size / 2;
          const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
          let y;
          let left = me.left;
          let maxWidth = me.width;
          if (this.isHorizontal()) {
            maxWidth = Math.max(...me.lineWidths);
            y = me.top + topPaddingPlusHalfFontSize;
            left = _alignStartEnd(opts.align, left, me.right - maxWidth);
          } else {
            const maxHeight = me.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);
            y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, me.top, me.bottom - maxHeight - opts.labels.padding - me._computeTitleHeight());
          }
          const x = _alignStartEnd(position, left, left + maxWidth);
          ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
          ctx.textBaseline = "middle";
          ctx.strokeStyle = titleOpts.color;
          ctx.fillStyle = titleOpts.color;
          ctx.font = titleFont.string;
          renderText(ctx, titleOpts.text, x, y, titleFont);
        }
        _computeTitleHeight() {
          const titleOpts = this.options.title;
          const titleFont = toFont(titleOpts.font);
          const titlePadding = toPadding(titleOpts.padding);
          return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
        }
        _getLegendItemAt(x, y) {
          const me = this;
          let i, hitBox, lh;
          if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {
            lh = me.legendHitBoxes;
            for (i = 0; i < lh.length; ++i) {
              hitBox = lh[i];
              if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
                return me.legendItems[i];
              }
            }
          }
          return null;
        }
        handleEvent(e) {
          const me = this;
          const opts = me.options;
          if (!isListened(e.type, opts)) {
            return;
          }
          const hoveredItem = me._getLegendItemAt(e.x, e.y);
          if (e.type === "mousemove") {
            const previous = me._hoveredItem;
            const sameItem = itemsEqual(previous, hoveredItem);
            if (previous && !sameItem) {
              callback(opts.onLeave, [e, previous, me], me);
            }
            me._hoveredItem = hoveredItem;
            if (hoveredItem && !sameItem) {
              callback(opts.onHover, [e, hoveredItem, me], me);
            }
          } else if (hoveredItem) {
            callback(opts.onClick, [e, hoveredItem, me], me);
          }
        }
      }
      function isListened(type, opts) {
        if (type === "mousemove" && (opts.onHover || opts.onLeave)) {
          return true;
        }
        if (opts.onClick && (type === "click" || type === "mouseup")) {
          return true;
        }
        return false;
      }
      var plugin_legend = {
        id: "legend",
        _element: Legend,
        start(chart, _args, options2) {
          const legend = chart.legend = new Legend({ ctx: chart.ctx, options: options2, chart });
          layouts.configure(chart, legend, options2);
          layouts.addBox(chart, legend);
        },
        stop(chart) {
          layouts.removeBox(chart, chart.legend);
          delete chart.legend;
        },
        beforeUpdate(chart, _args, options2) {
          const legend = chart.legend;
          layouts.configure(chart, legend, options2);
          legend.options = options2;
        },
        afterUpdate(chart) {
          const legend = chart.legend;
          legend.buildLabels();
          legend.adjustHitBoxes();
        },
        afterEvent(chart, args) {
          if (!args.replay) {
            chart.legend.handleEvent(args.event);
          }
        },
        defaults: {
          display: true,
          position: "top",
          align: "center",
          fullSize: true,
          reverse: false,
          weight: 1e3,
          onClick(e, legendItem, legend) {
            const index2 = legendItem.datasetIndex;
            const ci = legend.chart;
            if (ci.isDatasetVisible(index2)) {
              ci.hide(index2);
              legendItem.hidden = true;
            } else {
              ci.show(index2);
              legendItem.hidden = false;
            }
          },
          onHover: null,
          onLeave: null,
          labels: {
            color: (ctx) => ctx.chart.options.color,
            boxWidth: 40,
            padding: 10,
            generateLabels(chart) {
              const datasets = chart.data.datasets;
              const { labels: { usePointStyle, pointStyle, textAlign, color: color2 } } = chart.legend.options;
              return chart._getSortedDatasetMetas().map((meta) => {
                const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
                const borderWidth = toPadding(style.borderWidth);
                return {
                  text: datasets[meta.index].label,
                  fillStyle: style.backgroundColor,
                  fontColor: color2,
                  hidden: !meta.visible,
                  lineCap: style.borderCapStyle,
                  lineDash: style.borderDash,
                  lineDashOffset: style.borderDashOffset,
                  lineJoin: style.borderJoinStyle,
                  lineWidth: (borderWidth.width + borderWidth.height) / 4,
                  strokeStyle: style.borderColor,
                  pointStyle: pointStyle || style.pointStyle,
                  rotation: style.rotation,
                  textAlign: textAlign || style.textAlign,
                  borderRadius: 0,
                  datasetIndex: meta.index
                };
              }, this);
            }
          },
          title: {
            color: (ctx) => ctx.chart.options.color,
            display: false,
            position: "center",
            text: ""
          }
        },
        descriptors: {
          _scriptable: (name2) => !name2.startsWith("on"),
          labels: {
            _scriptable: (name2) => !["generateLabels", "filter", "sort"].includes(name2)
          }
        }
      };
      class Title extends Element {
        constructor(config2) {
          super();
          this.chart = config2.chart;
          this.options = config2.options;
          this.ctx = config2.ctx;
          this._padding = void 0;
          this.top = void 0;
          this.bottom = void 0;
          this.left = void 0;
          this.right = void 0;
          this.width = void 0;
          this.height = void 0;
          this.position = void 0;
          this.weight = void 0;
          this.fullSize = void 0;
        }
        update(maxWidth, maxHeight) {
          const me = this;
          const opts = me.options;
          me.left = 0;
          me.top = 0;
          if (!opts.display) {
            me.width = me.height = me.right = me.bottom = 0;
            return;
          }
          me.width = me.right = maxWidth;
          me.height = me.bottom = maxHeight;
          const lineCount = isArray(opts.text) ? opts.text.length : 1;
          me._padding = toPadding(opts.padding);
          const textSize = lineCount * toFont(opts.font).lineHeight + me._padding.height;
          if (me.isHorizontal()) {
            me.height = textSize;
          } else {
            me.width = textSize;
          }
        }
        isHorizontal() {
          const pos = this.options.position;
          return pos === "top" || pos === "bottom";
        }
        _drawArgs(offset) {
          const { top, left, bottom, right, options: options2 } = this;
          const align = options2.align;
          let rotation = 0;
          let maxWidth, titleX, titleY;
          if (this.isHorizontal()) {
            titleX = _alignStartEnd(align, left, right);
            titleY = top + offset;
            maxWidth = right - left;
          } else {
            if (options2.position === "left") {
              titleX = left + offset;
              titleY = _alignStartEnd(align, bottom, top);
              rotation = PI * -0.5;
            } else {
              titleX = right - offset;
              titleY = _alignStartEnd(align, top, bottom);
              rotation = PI * 0.5;
            }
            maxWidth = bottom - top;
          }
          return { titleX, titleY, maxWidth, rotation };
        }
        draw() {
          const me = this;
          const ctx = me.ctx;
          const opts = me.options;
          if (!opts.display) {
            return;
          }
          const fontOpts = toFont(opts.font);
          const lineHeight = fontOpts.lineHeight;
          const offset = lineHeight / 2 + me._padding.top;
          const { titleX, titleY, maxWidth, rotation } = me._drawArgs(offset);
          renderText(ctx, opts.text, 0, 0, fontOpts, {
            color: opts.color,
            maxWidth,
            rotation,
            textAlign: _toLeftRightCenter(opts.align),
            textBaseline: "middle",
            translation: [titleX, titleY]
          });
        }
      }
      function createTitle(chart, titleOpts) {
        const title = new Title({
          ctx: chart.ctx,
          options: titleOpts,
          chart
        });
        layouts.configure(chart, title, titleOpts);
        layouts.addBox(chart, title);
        chart.titleBlock = title;
      }
      var plugin_title = {
        id: "title",
        _element: Title,
        start(chart, _args, options2) {
          createTitle(chart, options2);
        },
        stop(chart) {
          const titleBlock = chart.titleBlock;
          layouts.removeBox(chart, titleBlock);
          delete chart.titleBlock;
        },
        beforeUpdate(chart, _args, options2) {
          const title = chart.titleBlock;
          layouts.configure(chart, title, options2);
          title.options = options2;
        },
        defaults: {
          align: "center",
          display: false,
          font: {
            weight: "bold"
          },
          fullSize: true,
          padding: 10,
          position: "top",
          text: "",
          weight: 2e3
        },
        defaultRoutes: {
          color: "color"
        },
        descriptors: {
          _scriptable: true,
          _indexable: false
        }
      };
      const map = new WeakMap();
      var plugin_subtitle = {
        id: "subtitle",
        start(chart, _args, options2) {
          const title = new Title({
            ctx: chart.ctx,
            options: options2,
            chart
          });
          layouts.configure(chart, title, options2);
          layouts.addBox(chart, title);
          map.set(chart, title);
        },
        stop(chart) {
          layouts.removeBox(chart, map.get(chart));
          map.delete(chart);
        },
        beforeUpdate(chart, _args, options2) {
          const title = map.get(chart);
          layouts.configure(chart, title, options2);
          title.options = options2;
        },
        defaults: {
          align: "center",
          display: false,
          font: {
            weight: "normal"
          },
          fullSize: true,
          padding: 0,
          position: "top",
          text: "",
          weight: 1500
        },
        defaultRoutes: {
          color: "color"
        },
        descriptors: {
          _scriptable: true,
          _indexable: false
        }
      };
      const positioners = {
        average(items) {
          if (!items.length) {
            return false;
          }
          let i, len;
          let x = 0;
          let y = 0;
          let count = 0;
          for (i = 0, len = items.length; i < len; ++i) {
            const el = items[i].element;
            if (el && el.hasValue()) {
              const pos = el.tooltipPosition();
              x += pos.x;
              y += pos.y;
              ++count;
            }
          }
          return {
            x: x / count,
            y: y / count
          };
        },
        nearest(items, eventPosition) {
          if (!items.length) {
            return false;
          }
          let x = eventPosition.x;
          let y = eventPosition.y;
          let minDistance = Number.POSITIVE_INFINITY;
          let i, len, nearestElement;
          for (i = 0, len = items.length; i < len; ++i) {
            const el = items[i].element;
            if (el && el.hasValue()) {
              const center = el.getCenterPoint();
              const d2 = distanceBetweenPoints(eventPosition, center);
              if (d2 < minDistance) {
                minDistance = d2;
                nearestElement = el;
              }
            }
          }
          if (nearestElement) {
            const tp = nearestElement.tooltipPosition();
            x = tp.x;
            y = tp.y;
          }
          return {
            x,
            y
          };
        }
      };
      function pushOrConcat(base2, toPush) {
        if (toPush) {
          if (isArray(toPush)) {
            Array.prototype.push.apply(base2, toPush);
          } else {
            base2.push(toPush);
          }
        }
        return base2;
      }
      function splitNewlines(str) {
        if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) {
          return str.split("\n");
        }
        return str;
      }
      function createTooltipItem(chart, item) {
        const { element, datasetIndex, index: index2 } = item;
        const controller = chart.getDatasetMeta(datasetIndex).controller;
        const { label, value } = controller.getLabelAndValue(index2);
        return {
          chart,
          label,
          parsed: controller.getParsed(index2),
          raw: chart.data.datasets[datasetIndex].data[index2],
          formattedValue: value,
          dataset: controller.getDataset(),
          dataIndex: index2,
          datasetIndex,
          element
        };
      }
      function getTooltipSize(tooltip, options2) {
        const ctx = tooltip._chart.ctx;
        const { body, footer, title } = tooltip;
        const { boxWidth, boxHeight } = options2;
        const bodyFont = toFont(options2.bodyFont);
        const titleFont = toFont(options2.titleFont);
        const footerFont = toFont(options2.footerFont);
        const titleLineCount = title.length;
        const footerLineCount = footer.length;
        const bodyLineItemCount = body.length;
        const padding = toPadding(options2.padding);
        let height = padding.height;
        let width = 0;
        let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);
        combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
        if (titleLineCount) {
          height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options2.titleSpacing + options2.titleMarginBottom;
        }
        if (combinedBodyLength) {
          const bodyLineHeight = options2.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
          height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options2.bodySpacing;
        }
        if (footerLineCount) {
          height += options2.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options2.footerSpacing;
        }
        let widthPadding = 0;
        const maxLineWidth = function(line) {
          width = Math.max(width, ctx.measureText(line).width + widthPadding);
        };
        ctx.save();
        ctx.font = titleFont.string;
        each2(tooltip.title, maxLineWidth);
        ctx.font = bodyFont.string;
        each2(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
        widthPadding = options2.displayColors ? boxWidth + 2 : 0;
        each2(body, (bodyItem) => {
          each2(bodyItem.before, maxLineWidth);
          each2(bodyItem.lines, maxLineWidth);
          each2(bodyItem.after, maxLineWidth);
        });
        widthPadding = 0;
        ctx.font = footerFont.string;
        each2(tooltip.footer, maxLineWidth);
        ctx.restore();
        width += padding.width;
        return { width, height };
      }
      function determineYAlign(chart, size) {
        const { y, height } = size;
        if (y < height / 2) {
          return "top";
        } else if (y > chart.height - height / 2) {
          return "bottom";
        }
        return "center";
      }
      function doesNotFitWithAlign(xAlign, chart, options2, size) {
        const { x, width } = size;
        const caret = options2.caretSize + options2.caretPadding;
        if (xAlign === "left" && x + width + caret > chart.width) {
          return true;
        }
        if (xAlign === "right" && x - width - caret < 0) {
          return true;
        }
      }
      function determineXAlign(chart, options2, size, yAlign) {
        const { x, width } = size;
        const { width: chartWidth, chartArea: { left, right } } = chart;
        let xAlign = "center";
        if (yAlign === "center") {
          xAlign = x <= (left + right) / 2 ? "left" : "right";
        } else if (x <= width / 2) {
          xAlign = "left";
        } else if (x >= chartWidth - width / 2) {
          xAlign = "right";
        }
        if (doesNotFitWithAlign(xAlign, chart, options2, size)) {
          xAlign = "center";
        }
        return xAlign;
      }
      function determineAlignment(chart, options2, size) {
        const yAlign = options2.yAlign || determineYAlign(chart, size);
        return {
          xAlign: options2.xAlign || determineXAlign(chart, options2, size, yAlign),
          yAlign
        };
      }
      function alignX(size, xAlign) {
        let { x, width } = size;
        if (xAlign === "right") {
          x -= width;
        } else if (xAlign === "center") {
          x -= width / 2;
        }
        return x;
      }
      function alignY(size, yAlign, paddingAndSize) {
        let { y, height } = size;
        if (yAlign === "top") {
          y += paddingAndSize;
        } else if (yAlign === "bottom") {
          y -= height + paddingAndSize;
        } else {
          y -= height / 2;
        }
        return y;
      }
      function getBackgroundPoint(options2, size, alignment, chart) {
        const { caretSize, caretPadding, cornerRadius } = options2;
        const { xAlign, yAlign } = alignment;
        const paddingAndSize = caretSize + caretPadding;
        const radiusAndPadding = cornerRadius + caretPadding;
        let x = alignX(size, xAlign);
        const y = alignY(size, yAlign, paddingAndSize);
        if (yAlign === "center") {
          if (xAlign === "left") {
            x += paddingAndSize;
          } else if (xAlign === "right") {
            x -= paddingAndSize;
          }
        } else if (xAlign === "left") {
          x -= radiusAndPadding;
        } else if (xAlign === "right") {
          x += radiusAndPadding;
        }
        return {
          x: _limitValue(x, 0, chart.width - size.width),
          y: _limitValue(y, 0, chart.height - size.height)
        };
      }
      function getAlignedX(tooltip, align, options2) {
        const padding = toPadding(options2.padding);
        return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
      }
      function getBeforeAfterBodyLines(callback2) {
        return pushOrConcat([], splitNewlines(callback2));
      }
      function createTooltipContext(parent2, tooltip, tooltipItems) {
        return Object.assign(Object.create(parent2), {
          tooltip,
          tooltipItems,
          type: "tooltip"
        });
      }
      function overrideCallbacks(callbacks, context) {
        const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
        return override ? callbacks.override(override) : callbacks;
      }
      class Tooltip extends Element {
        constructor(config2) {
          super();
          this.opacity = 0;
          this._active = [];
          this._chart = config2._chart;
          this._eventPosition = void 0;
          this._size = void 0;
          this._cachedAnimations = void 0;
          this._tooltipItems = [];
          this.$animations = void 0;
          this.$context = void 0;
          this.options = config2.options;
          this.dataPoints = void 0;
          this.title = void 0;
          this.beforeBody = void 0;
          this.body = void 0;
          this.afterBody = void 0;
          this.footer = void 0;
          this.xAlign = void 0;
          this.yAlign = void 0;
          this.x = void 0;
          this.y = void 0;
          this.height = void 0;
          this.width = void 0;
          this.caretX = void 0;
          this.caretY = void 0;
          this.labelColors = void 0;
          this.labelPointStyles = void 0;
          this.labelTextColors = void 0;
        }
        initialize(options2) {
          this.options = options2;
          this._cachedAnimations = void 0;
          this.$context = void 0;
        }
        _resolveAnimations() {
          const me = this;
          const cached = me._cachedAnimations;
          if (cached) {
            return cached;
          }
          const chart = me._chart;
          const options2 = me.options.setContext(me.getContext());
          const opts = options2.enabled && chart.options.animation && options2.animations;
          const animations = new Animations(me._chart, opts);
          if (opts._cacheable) {
            me._cachedAnimations = Object.freeze(animations);
          }
          return animations;
        }
        getContext() {
          const me = this;
          return me.$context || (me.$context = createTooltipContext(me._chart.getContext(), me, me._tooltipItems));
        }
        getTitle(context, options2) {
          const me = this;
          const { callbacks } = options2;
          const beforeTitle = callbacks.beforeTitle.apply(me, [context]);
          const title = callbacks.title.apply(me, [context]);
          const afterTitle = callbacks.afterTitle.apply(me, [context]);
          let lines = [];
          lines = pushOrConcat(lines, splitNewlines(beforeTitle));
          lines = pushOrConcat(lines, splitNewlines(title));
          lines = pushOrConcat(lines, splitNewlines(afterTitle));
          return lines;
        }
        getBeforeBody(tooltipItems, options2) {
          return getBeforeAfterBodyLines(options2.callbacks.beforeBody.apply(this, [tooltipItems]));
        }
        getBody(tooltipItems, options2) {
          const me = this;
          const { callbacks } = options2;
          const bodyItems = [];
          each2(tooltipItems, (context) => {
            const bodyItem = {
              before: [],
              lines: [],
              after: []
            };
            const scoped = overrideCallbacks(callbacks, context);
            pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(me, context)));
            pushOrConcat(bodyItem.lines, scoped.label.call(me, context));
            pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(me, context)));
            bodyItems.push(bodyItem);
          });
          return bodyItems;
        }
        getAfterBody(tooltipItems, options2) {
          return getBeforeAfterBodyLines(options2.callbacks.afterBody.apply(this, [tooltipItems]));
        }
        getFooter(tooltipItems, options2) {
          const me = this;
          const { callbacks } = options2;
          const beforeFooter = callbacks.beforeFooter.apply(me, [tooltipItems]);
          const footer = callbacks.footer.apply(me, [tooltipItems]);
          const afterFooter = callbacks.afterFooter.apply(me, [tooltipItems]);
          let lines = [];
          lines = pushOrConcat(lines, splitNewlines(beforeFooter));
          lines = pushOrConcat(lines, splitNewlines(footer));
          lines = pushOrConcat(lines, splitNewlines(afterFooter));
          return lines;
        }
        _createItems(options2) {
          const me = this;
          const active = me._active;
          const data = me._chart.data;
          const labelColors = [];
          const labelPointStyles = [];
          const labelTextColors = [];
          let tooltipItems = [];
          let i, len;
          for (i = 0, len = active.length; i < len; ++i) {
            tooltipItems.push(createTooltipItem(me._chart, active[i]));
          }
          if (options2.filter) {
            tooltipItems = tooltipItems.filter((element, index2, array) => options2.filter(element, index2, array, data));
          }
          if (options2.itemSort) {
            tooltipItems = tooltipItems.sort((a, b) => options2.itemSort(a, b, data));
          }
          each2(tooltipItems, (context) => {
            const scoped = overrideCallbacks(options2.callbacks, context);
            labelColors.push(scoped.labelColor.call(me, context));
            labelPointStyles.push(scoped.labelPointStyle.call(me, context));
            labelTextColors.push(scoped.labelTextColor.call(me, context));
          });
          me.labelColors = labelColors;
          me.labelPointStyles = labelPointStyles;
          me.labelTextColors = labelTextColors;
          me.dataPoints = tooltipItems;
          return tooltipItems;
        }
        update(changed, replay) {
          const me = this;
          const options2 = me.options.setContext(me.getContext());
          const active = me._active;
          let properties;
          let tooltipItems = [];
          if (!active.length) {
            if (me.opacity !== 0) {
              properties = {
                opacity: 0
              };
            }
          } else {
            const position = positioners[options2.position].call(me, active, me._eventPosition);
            tooltipItems = me._createItems(options2);
            me.title = me.getTitle(tooltipItems, options2);
            me.beforeBody = me.getBeforeBody(tooltipItems, options2);
            me.body = me.getBody(tooltipItems, options2);
            me.afterBody = me.getAfterBody(tooltipItems, options2);
            me.footer = me.getFooter(tooltipItems, options2);
            const size = me._size = getTooltipSize(me, options2);
            const positionAndSize = Object.assign({}, position, size);
            const alignment = determineAlignment(me._chart, options2, positionAndSize);
            const backgroundPoint = getBackgroundPoint(options2, positionAndSize, alignment, me._chart);
            me.xAlign = alignment.xAlign;
            me.yAlign = alignment.yAlign;
            properties = {
              opacity: 1,
              x: backgroundPoint.x,
              y: backgroundPoint.y,
              width: size.width,
              height: size.height,
              caretX: position.x,
              caretY: position.y
            };
          }
          me._tooltipItems = tooltipItems;
          me.$context = void 0;
          if (properties) {
            me._resolveAnimations().update(me, properties);
          }
          if (changed && options2.external) {
            options2.external.call(me, { chart: me._chart, tooltip: me, replay });
          }
        }
        drawCaret(tooltipPoint, ctx, size, options2) {
          const caretPosition = this.getCaretPosition(tooltipPoint, size, options2);
          ctx.lineTo(caretPosition.x1, caretPosition.y1);
          ctx.lineTo(caretPosition.x2, caretPosition.y2);
          ctx.lineTo(caretPosition.x3, caretPosition.y3);
        }
        getCaretPosition(tooltipPoint, size, options2) {
          const { xAlign, yAlign } = this;
          const { cornerRadius, caretSize } = options2;
          const { x: ptX, y: ptY } = tooltipPoint;
          const { width, height } = size;
          let x1, x2, x3, y1, y2, y3;
          if (yAlign === "center") {
            y2 = ptY + height / 2;
            if (xAlign === "left") {
              x1 = ptX;
              x2 = x1 - caretSize;
              y1 = y2 + caretSize;
              y3 = y2 - caretSize;
            } else {
              x1 = ptX + width;
              x2 = x1 + caretSize;
              y1 = y2 - caretSize;
              y3 = y2 + caretSize;
            }
            x3 = x1;
          } else {
            if (xAlign === "left") {
              x2 = ptX + cornerRadius + caretSize;
            } else if (xAlign === "right") {
              x2 = ptX + width - cornerRadius - caretSize;
            } else {
              x2 = this.caretX;
            }
            if (yAlign === "top") {
              y1 = ptY;
              y2 = y1 - caretSize;
              x1 = x2 - caretSize;
              x3 = x2 + caretSize;
            } else {
              y1 = ptY + height;
              y2 = y1 + caretSize;
              x1 = x2 + caretSize;
              x3 = x2 - caretSize;
            }
            y3 = y1;
          }
          return { x1, x2, x3, y1, y2, y3 };
        }
        drawTitle(pt, ctx, options2) {
          const me = this;
          const title = me.title;
          const length = title.length;
          let titleFont, titleSpacing, i;
          if (length) {
            const rtlHelper = getRtlAdapter(options2.rtl, me.x, me.width);
            pt.x = getAlignedX(me, options2.titleAlign, options2);
            ctx.textAlign = rtlHelper.textAlign(options2.titleAlign);
            ctx.textBaseline = "middle";
            titleFont = toFont(options2.titleFont);
            titleSpacing = options2.titleSpacing;
            ctx.fillStyle = options2.titleColor;
            ctx.font = titleFont.string;
            for (i = 0; i < length; ++i) {
              ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
              pt.y += titleFont.lineHeight + titleSpacing;
              if (i + 1 === length) {
                pt.y += options2.titleMarginBottom - titleSpacing;
              }
            }
          }
        }
        _drawColorBox(ctx, pt, i, rtlHelper, options2) {
          const me = this;
          const labelColors = me.labelColors[i];
          const labelPointStyle = me.labelPointStyles[i];
          const { boxHeight, boxWidth } = options2;
          const bodyFont = toFont(options2.bodyFont);
          const colorX = getAlignedX(me, "left", options2);
          const rtlColorX = rtlHelper.x(colorX);
          const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
          const colorY = pt.y + yOffSet;
          if (options2.usePointStyle) {
            const drawOptions = {
              radius: Math.min(boxWidth, boxHeight) / 2,
              pointStyle: labelPointStyle.pointStyle,
              rotation: labelPointStyle.rotation,
              borderWidth: 1
            };
            const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
            const centerY = colorY + boxHeight / 2;
            ctx.strokeStyle = options2.multiKeyBackground;
            ctx.fillStyle = options2.multiKeyBackground;
            drawPoint(ctx, drawOptions, centerX, centerY);
            ctx.strokeStyle = labelColors.borderColor;
            ctx.fillStyle = labelColors.backgroundColor;
            drawPoint(ctx, drawOptions, centerX, centerY);
          } else {
            ctx.lineWidth = labelColors.borderWidth || 1;
            ctx.strokeStyle = labelColors.borderColor;
            ctx.setLineDash(labelColors.borderDash || []);
            ctx.lineDashOffset = labelColors.borderDashOffset || 0;
            const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
            const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
            const borderRadius = toTRBLCorners(labelColors.borderRadius);
            if (Object.values(borderRadius).some((v) => v !== 0)) {
              ctx.beginPath();
              ctx.fillStyle = options2.multiKeyBackground;
              addRoundedRectPath(ctx, {
                x: outerX,
                y: colorY,
                w: boxWidth,
                h: boxHeight,
                radius: borderRadius
              });
              ctx.fill();
              ctx.stroke();
              ctx.fillStyle = labelColors.backgroundColor;
              ctx.beginPath();
              addRoundedRectPath(ctx, {
                x: innerX,
                y: colorY + 1,
                w: boxWidth - 2,
                h: boxHeight - 2,
                radius: borderRadius
              });
              ctx.fill();
            } else {
              ctx.fillStyle = options2.multiKeyBackground;
              ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
              ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
              ctx.fillStyle = labelColors.backgroundColor;
              ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
            }
          }
          ctx.fillStyle = me.labelTextColors[i];
        }
        drawBody(pt, ctx, options2) {
          const me = this;
          const { body } = me;
          const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth } = options2;
          const bodyFont = toFont(options2.bodyFont);
          let bodyLineHeight = bodyFont.lineHeight;
          let xLinePadding = 0;
          const rtlHelper = getRtlAdapter(options2.rtl, me.x, me.width);
          const fillLineOfText = function(line) {
            ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
            pt.y += bodyLineHeight + bodySpacing;
          };
          const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
          let bodyItem, textColor, lines, i, j, ilen, jlen;
          ctx.textAlign = bodyAlign;
          ctx.textBaseline = "middle";
          ctx.font = bodyFont.string;
          pt.x = getAlignedX(me, bodyAlignForCalculation, options2);
          ctx.fillStyle = options2.bodyColor;
          each2(me.beforeBody, fillLineOfText);
          xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + 1 : boxWidth + 2 : 0;
          for (i = 0, ilen = body.length; i < ilen; ++i) {
            bodyItem = body[i];
            textColor = me.labelTextColors[i];
            ctx.fillStyle = textColor;
            each2(bodyItem.before, fillLineOfText);
            lines = bodyItem.lines;
            if (displayColors && lines.length) {
              me._drawColorBox(ctx, pt, i, rtlHelper, options2);
              bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
            }
            for (j = 0, jlen = lines.length; j < jlen; ++j) {
              fillLineOfText(lines[j]);
              bodyLineHeight = bodyFont.lineHeight;
            }
            each2(bodyItem.after, fillLineOfText);
          }
          xLinePadding = 0;
          bodyLineHeight = bodyFont.lineHeight;
          each2(me.afterBody, fillLineOfText);
          pt.y -= bodySpacing;
        }
        drawFooter(pt, ctx, options2) {
          const me = this;
          const footer = me.footer;
          const length = footer.length;
          let footerFont, i;
          if (length) {
            const rtlHelper = getRtlAdapter(options2.rtl, me.x, me.width);
            pt.x = getAlignedX(me, options2.footerAlign, options2);
            pt.y += options2.footerMarginTop;
            ctx.textAlign = rtlHelper.textAlign(options2.footerAlign);
            ctx.textBaseline = "middle";
            footerFont = toFont(options2.footerFont);
            ctx.fillStyle = options2.footerColor;
            ctx.font = footerFont.string;
            for (i = 0; i < length; ++i) {
              ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
              pt.y += footerFont.lineHeight + options2.footerSpacing;
            }
          }
        }
        drawBackground(pt, ctx, tooltipSize, options2) {
          const { xAlign, yAlign } = this;
          const { x, y } = pt;
          const { width, height } = tooltipSize;
          const radius = options2.cornerRadius;
          ctx.fillStyle = options2.backgroundColor;
          ctx.strokeStyle = options2.borderColor;
          ctx.lineWidth = options2.borderWidth;
          ctx.beginPath();
          ctx.moveTo(x + radius, y);
          if (yAlign === "top") {
            this.drawCaret(pt, ctx, tooltipSize, options2);
          }
          ctx.lineTo(x + width - radius, y);
          ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
          if (yAlign === "center" && xAlign === "right") {
            this.drawCaret(pt, ctx, tooltipSize, options2);
          }
          ctx.lineTo(x + width, y + height - radius);
          ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
          if (yAlign === "bottom") {
            this.drawCaret(pt, ctx, tooltipSize, options2);
          }
          ctx.lineTo(x + radius, y + height);
          ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
          if (yAlign === "center" && xAlign === "left") {
            this.drawCaret(pt, ctx, tooltipSize, options2);
          }
          ctx.lineTo(x, y + radius);
          ctx.quadraticCurveTo(x, y, x + radius, y);
          ctx.closePath();
          ctx.fill();
          if (options2.borderWidth > 0) {
            ctx.stroke();
          }
        }
        _updateAnimationTarget(options2) {
          const me = this;
          const chart = me._chart;
          const anims = me.$animations;
          const animX = anims && anims.x;
          const animY = anims && anims.y;
          if (animX || animY) {
            const position = positioners[options2.position].call(me, me._active, me._eventPosition);
            if (!position) {
              return;
            }
            const size = me._size = getTooltipSize(me, options2);
            const positionAndSize = Object.assign({}, position, me._size);
            const alignment = determineAlignment(chart, options2, positionAndSize);
            const point = getBackgroundPoint(options2, positionAndSize, alignment, chart);
            if (animX._to !== point.x || animY._to !== point.y) {
              me.xAlign = alignment.xAlign;
              me.yAlign = alignment.yAlign;
              me.width = size.width;
              me.height = size.height;
              me.caretX = position.x;
              me.caretY = position.y;
              me._resolveAnimations().update(me, point);
            }
          }
        }
        draw(ctx) {
          const me = this;
          const options2 = me.options.setContext(me.getContext());
          let opacity = me.opacity;
          if (!opacity) {
            return;
          }
          me._updateAnimationTarget(options2);
          const tooltipSize = {
            width: me.width,
            height: me.height
          };
          const pt = {
            x: me.x,
            y: me.y
          };
          opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
          const padding = toPadding(options2.padding);
          const hasTooltipContent = me.title.length || me.beforeBody.length || me.body.length || me.afterBody.length || me.footer.length;
          if (options2.enabled && hasTooltipContent) {
            ctx.save();
            ctx.globalAlpha = opacity;
            me.drawBackground(pt, ctx, tooltipSize, options2);
            overrideTextDirection(ctx, options2.textDirection);
            pt.y += padding.top;
            me.drawTitle(pt, ctx, options2);
            me.drawBody(pt, ctx, options2);
            me.drawFooter(pt, ctx, options2);
            restoreTextDirection(ctx, options2.textDirection);
            ctx.restore();
          }
        }
        getActiveElements() {
          return this._active || [];
        }
        setActiveElements(activeElements, eventPosition) {
          const me = this;
          const lastActive = me._active;
          const active = activeElements.map(({ datasetIndex, index: index2 }) => {
            const meta = me._chart.getDatasetMeta(datasetIndex);
            if (!meta) {
              throw new Error("Cannot find a dataset at index " + datasetIndex);
            }
            return {
              datasetIndex,
              element: meta.data[index2],
              index: index2
            };
          });
          const changed = !_elementsEqual(lastActive, active);
          const positionChanged = me._positionChanged(active, eventPosition);
          if (changed || positionChanged) {
            me._active = active;
            me._eventPosition = eventPosition;
            me.update(true);
          }
        }
        handleEvent(e, replay) {
          const me = this;
          const options2 = me.options;
          const lastActive = me._active || [];
          let changed = false;
          let active = [];
          if (e.type !== "mouseout") {
            active = me._chart.getElementsAtEventForMode(e, options2.mode, options2, replay);
            if (options2.reverse) {
              active.reverse();
            }
          }
          const positionChanged = me._positionChanged(active, e);
          changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
          if (changed) {
            me._active = active;
            if (options2.enabled || options2.external) {
              me._eventPosition = {
                x: e.x,
                y: e.y
              };
              me.update(true, replay);
            }
          }
          return changed;
        }
        _positionChanged(active, e) {
          const { caretX, caretY, options: options2 } = this;
          const position = positioners[options2.position].call(this, active, e);
          return position !== false && (caretX !== position.x || caretY !== position.y);
        }
      }
      Tooltip.positioners = positioners;
      var plugin_tooltip = {
        id: "tooltip",
        _element: Tooltip,
        positioners,
        afterInit(chart, _args, options2) {
          if (options2) {
            chart.tooltip = new Tooltip({ _chart: chart, options: options2 });
          }
        },
        beforeUpdate(chart, _args, options2) {
          if (chart.tooltip) {
            chart.tooltip.initialize(options2);
          }
        },
        reset(chart, _args, options2) {
          if (chart.tooltip) {
            chart.tooltip.initialize(options2);
          }
        },
        afterDraw(chart) {
          const tooltip = chart.tooltip;
          const args = {
            tooltip
          };
          if (chart.notifyPlugins("beforeTooltipDraw", args) === false) {
            return;
          }
          if (tooltip) {
            tooltip.draw(chart.ctx);
          }
          chart.notifyPlugins("afterTooltipDraw", args);
        },
        afterEvent(chart, args) {
          if (chart.tooltip) {
            const useFinalPosition = args.replay;
            if (chart.tooltip.handleEvent(args.event, useFinalPosition)) {
              args.changed = true;
            }
          }
        },
        defaults: {
          enabled: true,
          external: null,
          position: "average",
          backgroundColor: "rgba(0,0,0,0.8)",
          titleColor: "#fff",
          titleFont: {
            weight: "bold"
          },
          titleSpacing: 2,
          titleMarginBottom: 6,
          titleAlign: "left",
          bodyColor: "#fff",
          bodySpacing: 2,
          bodyFont: {},
          bodyAlign: "left",
          footerColor: "#fff",
          footerSpacing: 2,
          footerMarginTop: 6,
          footerFont: {
            weight: "bold"
          },
          footerAlign: "left",
          padding: 6,
          caretPadding: 2,
          caretSize: 5,
          cornerRadius: 6,
          boxHeight: (ctx, opts) => opts.bodyFont.size,
          boxWidth: (ctx, opts) => opts.bodyFont.size,
          multiKeyBackground: "#fff",
          displayColors: true,
          borderColor: "rgba(0,0,0,0)",
          borderWidth: 0,
          animation: {
            duration: 400,
            easing: "easeOutQuart"
          },
          animations: {
            numbers: {
              type: "number",
              properties: ["x", "y", "width", "height", "caretX", "caretY"]
            },
            opacity: {
              easing: "linear",
              duration: 200
            }
          },
          callbacks: {
            beforeTitle: noop2,
            title(tooltipItems) {
              if (tooltipItems.length > 0) {
                const item = tooltipItems[0];
                const labels = item.chart.data.labels;
                const labelCount = labels ? labels.length : 0;
                if (this && this.options && this.options.mode === "dataset") {
                  return item.dataset.label || "";
                } else if (item.label) {
                  return item.label;
                } else if (labelCount > 0 && item.dataIndex < labelCount) {
                  return labels[item.dataIndex];
                }
              }
              return "";
            },
            afterTitle: noop2,
            beforeBody: noop2,
            beforeLabel: noop2,
            label(tooltipItem) {
              if (this && this.options && this.options.mode === "dataset") {
                return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
              }
              let label = tooltipItem.dataset.label || "";
              if (label) {
                label += ": ";
              }
              const value = tooltipItem.formattedValue;
              if (!isNullOrUndef(value)) {
                label += value;
              }
              return label;
            },
            labelColor(tooltipItem) {
              const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
              const options2 = meta.controller.getStyle(tooltipItem.dataIndex);
              return {
                borderColor: options2.borderColor,
                backgroundColor: options2.backgroundColor,
                borderWidth: options2.borderWidth,
                borderDash: options2.borderDash,
                borderDashOffset: options2.borderDashOffset,
                borderRadius: 0
              };
            },
            labelTextColor() {
              return this.options.bodyColor;
            },
            labelPointStyle(tooltipItem) {
              const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
              const options2 = meta.controller.getStyle(tooltipItem.dataIndex);
              return {
                pointStyle: options2.pointStyle,
                rotation: options2.rotation
              };
            },
            afterLabel: noop2,
            afterBody: noop2,
            beforeFooter: noop2,
            footer: noop2,
            afterFooter: noop2
          }
        },
        defaultRoutes: {
          bodyFont: "font",
          footerFont: "font",
          titleFont: "font"
        },
        descriptors: {
          _scriptable: (name2) => name2 !== "filter" && name2 !== "itemSort" && name2 !== "external",
          _indexable: false,
          callbacks: {
            _scriptable: false,
            _indexable: false
          },
          animation: {
            _fallback: false
          },
          animations: {
            _fallback: "animation"
          }
        },
        additionalOptionScopes: ["interaction"]
      };
      var plugins = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        Decimation: plugin_decimation,
        Filler: plugin_filler,
        Legend: plugin_legend,
        SubTitle: plugin_subtitle,
        Title: plugin_title,
        Tooltip: plugin_tooltip
      });
      const addIfString = (labels, raw, index2) => typeof raw === "string" ? labels.push(raw) - 1 : isNaN(raw) ? null : index2;
      function findOrAddLabel(labels, raw, index2) {
        const first = labels.indexOf(raw);
        if (first === -1) {
          return addIfString(labels, raw, index2);
        }
        const last = labels.lastIndexOf(raw);
        return first !== last ? index2 : first;
      }
      const validIndex = (index2, max) => index2 === null ? null : _limitValue(Math.round(index2), 0, max);
      class CategoryScale extends Scale {
        constructor(cfg) {
          super(cfg);
          this._startValue = void 0;
          this._valueRange = 0;
        }
        parse(raw, index2) {
          if (isNullOrUndef(raw)) {
            return null;
          }
          const labels = this.getLabels();
          index2 = isFinite(index2) && labels[index2] === raw ? index2 : findOrAddLabel(labels, raw, valueOrDefault(index2, raw));
          return validIndex(index2, labels.length - 1);
        }
        determineDataLimits() {
          const me = this;
          const { minDefined, maxDefined } = me.getUserBounds();
          let { min, max } = me.getMinMax(true);
          if (me.options.bounds === "ticks") {
            if (!minDefined) {
              min = 0;
            }
            if (!maxDefined) {
              max = me.getLabels().length - 1;
            }
          }
          me.min = min;
          me.max = max;
        }
        buildTicks() {
          const me = this;
          const min = me.min;
          const max = me.max;
          const offset = me.options.offset;
          const ticks = [];
          let labels = me.getLabels();
          labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
          me._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
          me._startValue = me.min - (offset ? 0.5 : 0);
          for (let value = min; value <= max; value++) {
            ticks.push({ value });
          }
          return ticks;
        }
        getLabelForValue(value) {
          const me = this;
          const labels = me.getLabels();
          if (value >= 0 && value < labels.length) {
            return labels[value];
          }
          return value;
        }
        configure() {
          const me = this;
          super.configure();
          if (!me.isHorizontal()) {
            me._reversePixels = !me._reversePixels;
          }
        }
        getPixelForValue(value) {
          const me = this;
          if (typeof value !== "number") {
            value = me.parse(value);
          }
          return value === null ? NaN : me.getPixelForDecimal((value - me._startValue) / me._valueRange);
        }
        getPixelForTick(index2) {
          const me = this;
          const ticks = me.ticks;
          if (index2 < 0 || index2 > ticks.length - 1) {
            return null;
          }
          return me.getPixelForValue(ticks[index2].value);
        }
        getValueForPixel(pixel) {
          const me = this;
          return Math.round(me._startValue + me.getDecimalForPixel(pixel) * me._valueRange);
        }
        getBasePixel() {
          return this.bottom;
        }
      }
      CategoryScale.id = "category";
      CategoryScale.defaults = {
        ticks: {
          callback: CategoryScale.prototype.getLabelForValue
        }
      };
      function generateTicks$1(generationOptions, dataRange) {
        const ticks = [];
        const MIN_SPACING = 1e-14;
        const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;
        const unit = step || 1;
        const maxSpaces = maxTicks - 1;
        const { min: rmin, max: rmax } = dataRange;
        const minDefined = !isNullOrUndef(min);
        const maxDefined = !isNullOrUndef(max);
        const countDefined = !isNullOrUndef(count);
        const minSpacing = (rmax - rmin) / (maxDigits + 1);
        let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
        let factor, niceMin, niceMax, numSpaces;
        if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
          return [{ value: rmin }, { value: rmax }];
        }
        numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
        if (numSpaces > maxSpaces) {
          spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
        }
        if (!isNullOrUndef(precision)) {
          factor = Math.pow(10, precision);
          spacing = Math.ceil(spacing * factor) / factor;
        }
        if (bounds === "ticks") {
          niceMin = Math.floor(rmin / spacing) * spacing;
          niceMax = Math.ceil(rmax / spacing) * spacing;
        } else {
          niceMin = rmin;
          niceMax = rmax;
        }
        if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
          numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
          spacing = (max - min) / numSpaces;
          niceMin = min;
          niceMax = max;
        } else if (countDefined) {
          niceMin = minDefined ? min : niceMin;
          niceMax = maxDefined ? max : niceMax;
          numSpaces = count - 1;
          spacing = (niceMax - niceMin) / numSpaces;
        } else {
          numSpaces = (niceMax - niceMin) / spacing;
          if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {
            numSpaces = Math.round(numSpaces);
          } else {
            numSpaces = Math.ceil(numSpaces);
          }
        }
        const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
        factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
        niceMin = Math.round(niceMin * factor) / factor;
        niceMax = Math.round(niceMax * factor) / factor;
        let j = 0;
        if (minDefined) {
          if (includeBounds && niceMin !== min) {
            ticks.push({ value: min });
            if (niceMin < min) {
              j++;
            }
            if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {
              j++;
            }
          } else if (niceMin < min) {
            j++;
          }
        }
        for (; j < numSpaces; ++j) {
          ticks.push({ value: Math.round((niceMin + j * spacing) * factor) / factor });
        }
        if (maxDefined && includeBounds && niceMax !== max) {
          if (almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {
            ticks[ticks.length - 1].value = max;
          } else {
            ticks.push({ value: max });
          }
        } else if (!maxDefined || niceMax === max) {
          ticks.push({ value: niceMax });
        }
        return ticks;
      }
      function relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {
        const rad = toRadians(minRotation);
        const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;
        const length = 0.75 * minSpacing * ("" + value).length;
        return Math.min(minSpacing / ratio, length);
      }
      class LinearScaleBase extends Scale {
        constructor(cfg) {
          super(cfg);
          this.start = void 0;
          this.end = void 0;
          this._startValue = void 0;
          this._endValue = void 0;
          this._valueRange = 0;
        }
        parse(raw, index2) {
          if (isNullOrUndef(raw)) {
            return null;
          }
          if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) {
            return null;
          }
          return +raw;
        }
        handleTickRangeOptions() {
          const me = this;
          const { beginAtZero } = me.options;
          const { minDefined, maxDefined } = me.getUserBounds();
          let { min, max } = me;
          const setMin = (v) => min = minDefined ? min : v;
          const setMax = (v) => max = maxDefined ? max : v;
          if (beginAtZero) {
            const minSign = sign(min);
            const maxSign = sign(max);
            if (minSign < 0 && maxSign < 0) {
              setMax(0);
            } else if (minSign > 0 && maxSign > 0) {
              setMin(0);
            }
          }
          if (min === max) {
            let offset = 1;
            if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) {
              offset = Math.abs(max * 0.05);
            }
            setMax(max + offset);
            if (!beginAtZero) {
              setMin(min - offset);
            }
          }
          me.min = min;
          me.max = max;
        }
        getTickLimit() {
          const me = this;
          const tickOpts = me.options.ticks;
          let { maxTicksLimit, stepSize } = tickOpts;
          let maxTicks;
          if (stepSize) {
            maxTicks = Math.ceil(me.max / stepSize) - Math.floor(me.min / stepSize) + 1;
          } else {
            maxTicks = me.computeTickLimit();
            maxTicksLimit = maxTicksLimit || 11;
          }
          if (maxTicksLimit) {
            maxTicks = Math.min(maxTicksLimit, maxTicks);
          }
          return maxTicks;
        }
        computeTickLimit() {
          return Number.POSITIVE_INFINITY;
        }
        buildTicks() {
          const me = this;
          const opts = me.options;
          const tickOpts = opts.ticks;
          let maxTicks = me.getTickLimit();
          maxTicks = Math.max(2, maxTicks);
          const numericGeneratorOptions = {
            maxTicks,
            bounds: opts.bounds,
            min: opts.min,
            max: opts.max,
            precision: tickOpts.precision,
            step: tickOpts.stepSize,
            count: tickOpts.count,
            maxDigits: me._maxDigits(),
            horizontal: me.isHorizontal(),
            minRotation: tickOpts.minRotation || 0,
            includeBounds: tickOpts.includeBounds !== false
          };
          const dataRange = me._range || me;
          const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
          if (opts.bounds === "ticks") {
            _setMinAndMaxByKey(ticks, me, "value");
          }
          if (opts.reverse) {
            ticks.reverse();
            me.start = me.max;
            me.end = me.min;
          } else {
            me.start = me.min;
            me.end = me.max;
          }
          return ticks;
        }
        configure() {
          const me = this;
          const ticks = me.ticks;
          let start2 = me.min;
          let end = me.max;
          super.configure();
          if (me.options.offset && ticks.length) {
            const offset = (end - start2) / Math.max(ticks.length - 1, 1) / 2;
            start2 -= offset;
            end += offset;
          }
          me._startValue = start2;
          me._endValue = end;
          me._valueRange = end - start2;
        }
        getLabelForValue(value) {
          return formatNumber(value, this.chart.options.locale);
        }
      }
      class LinearScale extends LinearScaleBase {
        determineDataLimits() {
          const me = this;
          const { min, max } = me.getMinMax(true);
          me.min = isNumberFinite(min) ? min : 0;
          me.max = isNumberFinite(max) ? max : 1;
          me.handleTickRangeOptions();
        }
        computeTickLimit() {
          const me = this;
          const horizontal = me.isHorizontal();
          const length = horizontal ? me.width : me.height;
          const minRotation = toRadians(me.options.ticks.minRotation);
          const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;
          const tickFont = me._resolveTickFontOptions(0);
          return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
        }
        getPixelForValue(value) {
          return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
        }
        getValueForPixel(pixel) {
          return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
        }
      }
      LinearScale.id = "linear";
      LinearScale.defaults = {
        ticks: {
          callback: Ticks.formatters.numeric
        }
      };
      function isMajor(tickVal) {
        const remain = tickVal / Math.pow(10, Math.floor(log10(tickVal)));
        return remain === 1;
      }
      function generateTicks(generationOptions, dataRange) {
        const endExp = Math.floor(log10(dataRange.max));
        const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
        const ticks = [];
        let tickVal = finiteOrDefault(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));
        let exp = Math.floor(log10(tickVal));
        let significand = Math.floor(tickVal / Math.pow(10, exp));
        let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
        do {
          ticks.push({ value: tickVal, major: isMajor(tickVal) });
          ++significand;
          if (significand === 10) {
            significand = 1;
            ++exp;
            precision = exp >= 0 ? 1 : precision;
          }
          tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
        } while (exp < endExp || exp === endExp && significand < endSignificand);
        const lastTick = finiteOrDefault(generationOptions.max, tickVal);
        ticks.push({ value: lastTick, major: isMajor(tickVal) });
        return ticks;
      }
      class LogarithmicScale extends Scale {
        constructor(cfg) {
          super(cfg);
          this.start = void 0;
          this.end = void 0;
          this._startValue = void 0;
          this._valueRange = 0;
        }
        parse(raw, index2) {
          const value = LinearScaleBase.prototype.parse.apply(this, [raw, index2]);
          if (value === 0) {
            this._zero = true;
            return void 0;
          }
          return isNumberFinite(value) && value > 0 ? value : null;
        }
        determineDataLimits() {
          const me = this;
          const { min, max } = me.getMinMax(true);
          me.min = isNumberFinite(min) ? Math.max(0, min) : null;
          me.max = isNumberFinite(max) ? Math.max(0, max) : null;
          if (me.options.beginAtZero) {
            me._zero = true;
          }
          me.handleTickRangeOptions();
        }
        handleTickRangeOptions() {
          const me = this;
          const { minDefined, maxDefined } = me.getUserBounds();
          let min = me.min;
          let max = me.max;
          const setMin = (v) => min = minDefined ? min : v;
          const setMax = (v) => max = maxDefined ? max : v;
          const exp = (v, m) => Math.pow(10, Math.floor(log10(v)) + m);
          if (min === max) {
            if (min <= 0) {
              setMin(1);
              setMax(10);
            } else {
              setMin(exp(min, -1));
              setMax(exp(max, 1));
            }
          }
          if (min <= 0) {
            setMin(exp(max, -1));
          }
          if (max <= 0) {
            setMax(exp(min, 1));
          }
          if (me._zero && me.min !== me._suggestedMin && min === exp(me.min, 0)) {
            setMin(exp(min, -1));
          }
          me.min = min;
          me.max = max;
        }
        buildTicks() {
          const me = this;
          const opts = me.options;
          const generationOptions = {
            min: me._userMin,
            max: me._userMax
          };
          const ticks = generateTicks(generationOptions, me);
          if (opts.bounds === "ticks") {
            _setMinAndMaxByKey(ticks, me, "value");
          }
          if (opts.reverse) {
            ticks.reverse();
            me.start = me.max;
            me.end = me.min;
          } else {
            me.start = me.min;
            me.end = me.max;
          }
          return ticks;
        }
        getLabelForValue(value) {
          return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale);
        }
        configure() {
          const me = this;
          const start2 = me.min;
          super.configure();
          me._startValue = log10(start2);
          me._valueRange = log10(me.max) - log10(start2);
        }
        getPixelForValue(value) {
          const me = this;
          if (value === void 0 || value === 0) {
            value = me.min;
          }
          if (value === null || isNaN(value)) {
            return NaN;
          }
          return me.getPixelForDecimal(value === me.min ? 0 : (log10(value) - me._startValue) / me._valueRange);
        }
        getValueForPixel(pixel) {
          const me = this;
          const decimal = me.getDecimalForPixel(pixel);
          return Math.pow(10, me._startValue + decimal * me._valueRange);
        }
      }
      LogarithmicScale.id = "logarithmic";
      LogarithmicScale.defaults = {
        ticks: {
          callback: Ticks.formatters.logarithmic,
          major: {
            enabled: true
          }
        }
      };
      function getTickBackdropHeight(opts) {
        const tickOpts = opts.ticks;
        if (tickOpts.display && opts.display) {
          const padding = toPadding(tickOpts.backdropPadding);
          return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
        }
        return 0;
      }
      function measureLabelSize(ctx, font, label) {
        label = isArray(label) ? label : [label];
        return {
          w: _longestText(ctx, font.string, label),
          h: label.length * font.lineHeight
        };
      }
      function determineLimits(angle, pos, size, min, max) {
        if (angle === min || angle === max) {
          return {
            start: pos - size / 2,
            end: pos + size / 2
          };
        } else if (angle < min || angle > max) {
          return {
            start: pos - size,
            end: pos
          };
        }
        return {
          start: pos,
          end: pos + size
        };
      }
      function fitWithPointLabels(scale) {
        const furthestLimits = {
          l: 0,
          r: scale.width,
          t: 0,
          b: scale.height - scale.paddingTop
        };
        const furthestAngles = {};
        const labelSizes = [];
        const padding = [];
        const valueCount = scale.getLabels().length;
        for (let i = 0; i < valueCount; i++) {
          const opts = scale.options.pointLabels.setContext(scale.getPointLabelContext(i));
          padding[i] = opts.padding;
          const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i]);
          const plFont = toFont(opts.font);
          const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
          labelSizes[i] = textSize;
          const angleRadians = scale.getIndexAngle(i);
          const angle = toDegrees(angleRadians);
          const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
          const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
          if (hLimits.start < furthestLimits.l) {
            furthestLimits.l = hLimits.start;
            furthestAngles.l = angleRadians;
          }
          if (hLimits.end > furthestLimits.r) {
            furthestLimits.r = hLimits.end;
            furthestAngles.r = angleRadians;
          }
          if (vLimits.start < furthestLimits.t) {
            furthestLimits.t = vLimits.start;
            furthestAngles.t = angleRadians;
          }
          if (vLimits.end > furthestLimits.b) {
            furthestLimits.b = vLimits.end;
            furthestAngles.b = angleRadians;
          }
        }
        scale._setReductions(scale.drawingArea, furthestLimits, furthestAngles);
        scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
      }
      function buildPointLabelItems(scale, labelSizes, padding) {
        const items = [];
        const valueCount = scale.getLabels().length;
        const opts = scale.options;
        const tickBackdropHeight = getTickBackdropHeight(opts);
        const outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);
        for (let i = 0; i < valueCount; i++) {
          const extra = i === 0 ? tickBackdropHeight / 2 : 0;
          const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i]);
          const angle = toDegrees(scale.getIndexAngle(i));
          const size = labelSizes[i];
          const y = yForAngle(pointLabelPosition.y, size.h, angle);
          const textAlign = getTextAlignForAngle(angle);
          const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
          items.push({
            x: pointLabelPosition.x,
            y,
            textAlign,
            left,
            top: y,
            right: left + size.w,
            bottom: y + size.h
          });
        }
        return items;
      }
      function getTextAlignForAngle(angle) {
        if (angle === 0 || angle === 180) {
          return "center";
        } else if (angle < 180) {
          return "left";
        }
        return "right";
      }
      function leftForTextAlign(x, w, align) {
        if (align === "right") {
          x -= w;
        } else if (align === "center") {
          x -= w / 2;
        }
        return x;
      }
      function yForAngle(y, h, angle) {
        if (angle === 90 || angle === 270) {
          y -= h / 2;
        } else if (angle > 270 || angle < 90) {
          y -= h;
        }
        return y;
      }
      function drawPointLabels(scale, labelCount) {
        const { ctx, options: { pointLabels } } = scale;
        for (let i = labelCount - 1; i >= 0; i--) {
          const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
          const plFont = toFont(optsAtIndex.font);
          const { x, y, textAlign, left, top, right, bottom } = scale._pointLabelItems[i];
          const { backdropColor } = optsAtIndex;
          if (!isNullOrUndef(backdropColor)) {
            const padding = toPadding(optsAtIndex.backdropPadding);
            ctx.fillStyle = backdropColor;
            ctx.fillRect(left - padding.left, top - padding.top, right - left + padding.width, bottom - top + padding.height);
          }
          renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
            color: optsAtIndex.color,
            textAlign,
            textBaseline: "middle"
          });
        }
      }
      function pathRadiusLine(scale, radius, circular, labelCount) {
        const { ctx } = scale;
        if (circular) {
          ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);
        } else {
          let pointPosition = scale.getPointPosition(0, radius);
          ctx.moveTo(pointPosition.x, pointPosition.y);
          for (let i = 1; i < labelCount; i++) {
            pointPosition = scale.getPointPosition(i, radius);
            ctx.lineTo(pointPosition.x, pointPosition.y);
          }
        }
      }
      function drawRadiusLine(scale, gridLineOpts, radius, labelCount) {
        const ctx = scale.ctx;
        const circular = gridLineOpts.circular;
        const { color: color2, lineWidth } = gridLineOpts;
        if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {
          return;
        }
        ctx.save();
        ctx.strokeStyle = color2;
        ctx.lineWidth = lineWidth;
        ctx.setLineDash(gridLineOpts.borderDash);
        ctx.lineDashOffset = gridLineOpts.borderDashOffset;
        ctx.beginPath();
        pathRadiusLine(scale, radius, circular, labelCount);
        ctx.closePath();
        ctx.stroke();
        ctx.restore();
      }
      function numberOrZero(param) {
        return isNumber(param) ? param : 0;
      }
      function createPointLabelContext(parent2, index2, label) {
        return Object.assign(Object.create(parent2), {
          label,
          index: index2,
          type: "pointLabel"
        });
      }
      class RadialLinearScale extends LinearScaleBase {
        constructor(cfg) {
          super(cfg);
          this.xCenter = void 0;
          this.yCenter = void 0;
          this.drawingArea = void 0;
          this._pointLabels = [];
          this._pointLabelItems = [];
        }
        setDimensions() {
          const me = this;
          me.width = me.maxWidth;
          me.height = me.maxHeight;
          me.paddingTop = getTickBackdropHeight(me.options) / 2;
          me.xCenter = Math.floor(me.width / 2);
          me.yCenter = Math.floor((me.height - me.paddingTop) / 2);
          me.drawingArea = Math.min(me.height - me.paddingTop, me.width) / 2;
        }
        determineDataLimits() {
          const me = this;
          const { min, max } = me.getMinMax(false);
          me.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
          me.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
          me.handleTickRangeOptions();
        }
        computeTickLimit() {
          return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
        }
        generateTickLabels(ticks) {
          const me = this;
          LinearScaleBase.prototype.generateTickLabels.call(me, ticks);
          me._pointLabels = me.getLabels().map((value, index2) => {
            const label = callback(me.options.pointLabels.callback, [value, index2], me);
            return label || label === 0 ? label : "";
          });
        }
        fit() {
          const me = this;
          const opts = me.options;
          if (opts.display && opts.pointLabels.display) {
            fitWithPointLabels(me);
          } else {
            me.setCenterPoint(0, 0, 0, 0);
          }
        }
        _setReductions(largestPossibleRadius, furthestLimits, furthestAngles) {
          const me = this;
          let radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
          let radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
          let radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
          let radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop), 0) / Math.cos(furthestAngles.b);
          radiusReductionLeft = numberOrZero(radiusReductionLeft);
          radiusReductionRight = numberOrZero(radiusReductionRight);
          radiusReductionTop = numberOrZero(radiusReductionTop);
          radiusReductionBottom = numberOrZero(radiusReductionBottom);
          me.drawingArea = Math.max(largestPossibleRadius / 2, Math.min(Math.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2), Math.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2)));
          me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
        }
        setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
          const me = this;
          const maxRight = me.width - rightMovement - me.drawingArea;
          const maxLeft = leftMovement + me.drawingArea;
          const maxTop = topMovement + me.drawingArea;
          const maxBottom = me.height - me.paddingTop - bottomMovement - me.drawingArea;
          me.xCenter = Math.floor((maxLeft + maxRight) / 2 + me.left);
          me.yCenter = Math.floor((maxTop + maxBottom) / 2 + me.top + me.paddingTop);
        }
        getIndexAngle(index2) {
          const angleMultiplier = TAU / this.getLabels().length;
          const startAngle = this.options.startAngle || 0;
          return _normalizeAngle(index2 * angleMultiplier + toRadians(startAngle));
        }
        getDistanceFromCenterForValue(value) {
          const me = this;
          if (isNullOrUndef(value)) {
            return NaN;
          }
          const scalingFactor = me.drawingArea / (me.max - me.min);
          if (me.options.reverse) {
            return (me.max - value) * scalingFactor;
          }
          return (value - me.min) * scalingFactor;
        }
        getValueForDistanceFromCenter(distance) {
          if (isNullOrUndef(distance)) {
            return NaN;
          }
          const me = this;
          const scaledDistance = distance / (me.drawingArea / (me.max - me.min));
          return me.options.reverse ? me.max - scaledDistance : me.min + scaledDistance;
        }
        getPointLabelContext(index2) {
          const me = this;
          const pointLabels = me._pointLabels || [];
          if (index2 >= 0 && index2 < pointLabels.length) {
            const pointLabel = pointLabels[index2];
            return createPointLabelContext(me.getContext(), index2, pointLabel);
          }
        }
        getPointPosition(index2, distanceFromCenter) {
          const me = this;
          const angle = me.getIndexAngle(index2) - HALF_PI;
          return {
            x: Math.cos(angle) * distanceFromCenter + me.xCenter,
            y: Math.sin(angle) * distanceFromCenter + me.yCenter,
            angle
          };
        }
        getPointPositionForValue(index2, value) {
          return this.getPointPosition(index2, this.getDistanceFromCenterForValue(value));
        }
        getBasePosition(index2) {
          return this.getPointPositionForValue(index2 || 0, this.getBaseValue());
        }
        getPointLabelPosition(index2) {
          const { left, top, right, bottom } = this._pointLabelItems[index2];
          return {
            left,
            top,
            right,
            bottom
          };
        }
        drawBackground() {
          const me = this;
          const { backgroundColor, grid: { circular } } = me.options;
          if (backgroundColor) {
            const ctx = me.ctx;
            ctx.save();
            ctx.beginPath();
            pathRadiusLine(me, me.getDistanceFromCenterForValue(me._endValue), circular, me.getLabels().length);
            ctx.closePath();
            ctx.fillStyle = backgroundColor;
            ctx.fill();
            ctx.restore();
          }
        }
        drawGrid() {
          const me = this;
          const ctx = me.ctx;
          const opts = me.options;
          const { angleLines, grid } = opts;
          const labelCount = me.getLabels().length;
          let i, offset, position;
          if (opts.pointLabels.display) {
            drawPointLabels(me, labelCount);
          }
          if (grid.display) {
            me.ticks.forEach((tick, index2) => {
              if (index2 !== 0) {
                offset = me.getDistanceFromCenterForValue(tick.value);
                const optsAtIndex = grid.setContext(me.getContext(index2 - 1));
                drawRadiusLine(me, optsAtIndex, offset, labelCount);
              }
            });
          }
          if (angleLines.display) {
            ctx.save();
            for (i = me.getLabels().length - 1; i >= 0; i--) {
              const optsAtIndex = angleLines.setContext(me.getPointLabelContext(i));
              const { color: color2, lineWidth } = optsAtIndex;
              if (!lineWidth || !color2) {
                continue;
              }
              ctx.lineWidth = lineWidth;
              ctx.strokeStyle = color2;
              ctx.setLineDash(optsAtIndex.borderDash);
              ctx.lineDashOffset = optsAtIndex.borderDashOffset;
              offset = me.getDistanceFromCenterForValue(opts.ticks.reverse ? me.min : me.max);
              position = me.getPointPosition(i, offset);
              ctx.beginPath();
              ctx.moveTo(me.xCenter, me.yCenter);
              ctx.lineTo(position.x, position.y);
              ctx.stroke();
            }
            ctx.restore();
          }
        }
        drawBorder() {
        }
        drawLabels() {
          const me = this;
          const ctx = me.ctx;
          const opts = me.options;
          const tickOpts = opts.ticks;
          if (!tickOpts.display) {
            return;
          }
          const startAngle = me.getIndexAngle(0);
          let offset, width;
          ctx.save();
          ctx.translate(me.xCenter, me.yCenter);
          ctx.rotate(startAngle);
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          me.ticks.forEach((tick, index2) => {
            if (index2 === 0 && !opts.reverse) {
              return;
            }
            const optsAtIndex = tickOpts.setContext(me.getContext(index2));
            const tickFont = toFont(optsAtIndex.font);
            offset = me.getDistanceFromCenterForValue(me.ticks[index2].value);
            if (optsAtIndex.showLabelBackdrop) {
              ctx.font = tickFont.string;
              width = ctx.measureText(tick.label).width;
              ctx.fillStyle = optsAtIndex.backdropColor;
              const padding = toPadding(optsAtIndex.backdropPadding);
              ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
            }
            renderText(ctx, tick.label, 0, -offset, tickFont, {
              color: optsAtIndex.color
            });
          });
          ctx.restore();
        }
        drawTitle() {
        }
      }
      RadialLinearScale.id = "radialLinear";
      RadialLinearScale.defaults = {
        display: true,
        animate: true,
        position: "chartArea",
        angleLines: {
          display: true,
          lineWidth: 1,
          borderDash: [],
          borderDashOffset: 0
        },
        grid: {
          circular: false
        },
        startAngle: 0,
        ticks: {
          showLabelBackdrop: true,
          callback: Ticks.formatters.numeric
        },
        pointLabels: {
          backdropColor: void 0,
          backdropPadding: 2,
          display: true,
          font: {
            size: 10
          },
          callback(label) {
            return label;
          },
          padding: 5
        }
      };
      RadialLinearScale.defaultRoutes = {
        "angleLines.color": "borderColor",
        "pointLabels.color": "color",
        "ticks.color": "color"
      };
      RadialLinearScale.descriptors = {
        angleLines: {
          _fallback: "grid"
        }
      };
      const INTERVALS = {
        millisecond: { common: true, size: 1, steps: 1e3 },
        second: { common: true, size: 1e3, steps: 60 },
        minute: { common: true, size: 6e4, steps: 60 },
        hour: { common: true, size: 36e5, steps: 24 },
        day: { common: true, size: 864e5, steps: 30 },
        week: { common: false, size: 6048e5, steps: 4 },
        month: { common: true, size: 2628e6, steps: 12 },
        quarter: { common: false, size: 7884e6, steps: 4 },
        year: { common: true, size: 3154e7 }
      };
      const UNITS = Object.keys(INTERVALS);
      function sorter(a, b) {
        return a - b;
      }
      function parse(scale, input) {
        if (isNullOrUndef(input)) {
          return null;
        }
        const adapter = scale._adapter;
        const { parser, round: round2, isoWeekday } = scale._parseOpts;
        let value = input;
        if (typeof parser === "function") {
          value = parser(value);
        }
        if (!isNumberFinite(value)) {
          value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
        }
        if (value === null) {
          return null;
        }
        if (round2) {
          value = round2 === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round2);
        }
        return +value;
      }
      function determineUnitForAutoTicks(minUnit, min, max, capacity) {
        const ilen = UNITS.length;
        for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
          const interval = INTERVALS[UNITS[i]];
          const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
          if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
            return UNITS[i];
          }
        }
        return UNITS[ilen - 1];
      }
      function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
        for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
          const unit = UNITS[i];
          if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
            return unit;
          }
        }
        return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
      }
      function determineMajorUnit(unit) {
        for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
          if (INTERVALS[UNITS[i]].common) {
            return UNITS[i];
          }
        }
      }
      function addTick(ticks, time, timestamps) {
        if (!timestamps) {
          ticks[time] = true;
        } else if (timestamps.length) {
          const { lo, hi } = _lookup(timestamps, time);
          const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
          ticks[timestamp] = true;
        }
      }
      function setMajorTicks(scale, ticks, map2, majorUnit) {
        const adapter = scale._adapter;
        const first = +adapter.startOf(ticks[0].value, majorUnit);
        const last = ticks[ticks.length - 1].value;
        let major, index2;
        for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
          index2 = map2[major];
          if (index2 >= 0) {
            ticks[index2].major = true;
          }
        }
        return ticks;
      }
      function ticksFromTimestamps(scale, values, majorUnit) {
        const ticks = [];
        const map2 = {};
        const ilen = values.length;
        let i, value;
        for (i = 0; i < ilen; ++i) {
          value = values[i];
          map2[value] = i;
          ticks.push({
            value,
            major: false
          });
        }
        return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map2, majorUnit);
      }
      class TimeScale extends Scale {
        constructor(props) {
          super(props);
          this._cache = {
            data: [],
            labels: [],
            all: []
          };
          this._unit = "day";
          this._majorUnit = void 0;
          this._offsets = {};
          this._normalized = false;
          this._parseOpts = void 0;
        }
        init(scaleOpts, opts) {
          const time = scaleOpts.time || (scaleOpts.time = {});
          const adapter = this._adapter = new _adapters._date(scaleOpts.adapters.date);
          mergeIf(time.displayFormats, adapter.formats());
          this._parseOpts = {
            parser: time.parser,
            round: time.round,
            isoWeekday: time.isoWeekday
          };
          super.init(scaleOpts);
          this._normalized = opts.normalized;
        }
        parse(raw, index2) {
          if (raw === void 0) {
            return null;
          }
          return parse(this, raw);
        }
        beforeLayout() {
          super.beforeLayout();
          this._cache = {
            data: [],
            labels: [],
            all: []
          };
        }
        determineDataLimits() {
          const me = this;
          const options2 = me.options;
          const adapter = me._adapter;
          const unit = options2.time.unit || "day";
          let { min, max, minDefined, maxDefined } = me.getUserBounds();
          function _applyBounds(bounds) {
            if (!minDefined && !isNaN(bounds.min)) {
              min = Math.min(min, bounds.min);
            }
            if (!maxDefined && !isNaN(bounds.max)) {
              max = Math.max(max, bounds.max);
            }
          }
          if (!minDefined || !maxDefined) {
            _applyBounds(me._getLabelBounds());
            if (options2.bounds !== "ticks" || options2.ticks.source !== "labels") {
              _applyBounds(me.getMinMax(false));
            }
          }
          min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
          max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
          me.min = Math.min(min, max - 1);
          me.max = Math.max(min + 1, max);
        }
        _getLabelBounds() {
          const arr = this.getLabelTimestamps();
          let min = Number.POSITIVE_INFINITY;
          let max = Number.NEGATIVE_INFINITY;
          if (arr.length) {
            min = arr[0];
            max = arr[arr.length - 1];
          }
          return { min, max };
        }
        buildTicks() {
          const me = this;
          const options2 = me.options;
          const timeOpts = options2.time;
          const tickOpts = options2.ticks;
          const timestamps = tickOpts.source === "labels" ? me.getLabelTimestamps() : me._generate();
          if (options2.bounds === "ticks" && timestamps.length) {
            me.min = me._userMin || timestamps[0];
            me.max = me._userMax || timestamps[timestamps.length - 1];
          }
          const min = me.min;
          const max = me.max;
          const ticks = _filterBetween(timestamps, min, max);
          me._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, me.min, me.max, me._getLabelCapacity(min)) : determineUnitForFormatting(me, ticks.length, timeOpts.minUnit, me.min, me.max));
          me._majorUnit = !tickOpts.major.enabled || me._unit === "year" ? void 0 : determineMajorUnit(me._unit);
          me.initOffsets(timestamps);
          if (options2.reverse) {
            ticks.reverse();
          }
          return ticksFromTimestamps(me, ticks, me._majorUnit);
        }
        initOffsets(timestamps) {
          const me = this;
          let start2 = 0;
          let end = 0;
          let first, last;
          if (me.options.offset && timestamps.length) {
            first = me.getDecimalForValue(timestamps[0]);
            if (timestamps.length === 1) {
              start2 = 1 - first;
            } else {
              start2 = (me.getDecimalForValue(timestamps[1]) - first) / 2;
            }
            last = me.getDecimalForValue(timestamps[timestamps.length - 1]);
            if (timestamps.length === 1) {
              end = last;
            } else {
              end = (last - me.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
            }
          }
          const limit = timestamps.length < 3 ? 0.5 : 0.25;
          start2 = _limitValue(start2, 0, limit);
          end = _limitValue(end, 0, limit);
          me._offsets = { start: start2, end, factor: 1 / (start2 + 1 + end) };
        }
        _generate() {
          const me = this;
          const adapter = me._adapter;
          const min = me.min;
          const max = me.max;
          const options2 = me.options;
          const timeOpts = options2.time;
          const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, me._getLabelCapacity(min));
          const stepSize = valueOrDefault(timeOpts.stepSize, 1);
          const weekday = minor === "week" ? timeOpts.isoWeekday : false;
          const hasWeekday = isNumber(weekday) || weekday === true;
          const ticks = {};
          let first = min;
          let time, count;
          if (hasWeekday) {
            first = +adapter.startOf(first, "isoWeek", weekday);
          }
          first = +adapter.startOf(first, hasWeekday ? "day" : minor);
          if (adapter.diff(max, min, minor) > 1e5 * stepSize) {
            throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
          }
          const timestamps = options2.ticks.source === "data" && me.getDataTimestamps();
          for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {
            addTick(ticks, time, timestamps);
          }
          if (time === max || options2.bounds === "ticks" || count === 1) {
            addTick(ticks, time, timestamps);
          }
          return Object.keys(ticks).sort((a, b) => a - b).map((x) => +x);
        }
        getLabelForValue(value) {
          const me = this;
          const adapter = me._adapter;
          const timeOpts = me.options.time;
          if (timeOpts.tooltipFormat) {
            return adapter.format(value, timeOpts.tooltipFormat);
          }
          return adapter.format(value, timeOpts.displayFormats.datetime);
        }
        _tickFormatFunction(time, index2, ticks, format2) {
          const me = this;
          const options2 = me.options;
          const formats = options2.time.displayFormats;
          const unit = me._unit;
          const majorUnit = me._majorUnit;
          const minorFormat = unit && formats[unit];
          const majorFormat = majorUnit && formats[majorUnit];
          const tick = ticks[index2];
          const major = majorUnit && majorFormat && tick && tick.major;
          const label = me._adapter.format(time, format2 || (major ? majorFormat : minorFormat));
          const formatter = options2.ticks.callback;
          return formatter ? callback(formatter, [label, index2, ticks], me) : label;
        }
        generateTickLabels(ticks) {
          let i, ilen, tick;
          for (i = 0, ilen = ticks.length; i < ilen; ++i) {
            tick = ticks[i];
            tick.label = this._tickFormatFunction(tick.value, i, ticks);
          }
        }
        getDecimalForValue(value) {
          const me = this;
          return value === null ? NaN : (value - me.min) / (me.max - me.min);
        }
        getPixelForValue(value) {
          const me = this;
          const offsets = me._offsets;
          const pos = me.getDecimalForValue(value);
          return me.getPixelForDecimal((offsets.start + pos) * offsets.factor);
        }
        getValueForPixel(pixel) {
          const me = this;
          const offsets = me._offsets;
          const pos = me.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
          return me.min + pos * (me.max - me.min);
        }
        _getLabelSize(label) {
          const me = this;
          const ticksOpts = me.options.ticks;
          const tickLabelWidth = me.ctx.measureText(label).width;
          const angle = toRadians(me.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
          const cosRotation = Math.cos(angle);
          const sinRotation = Math.sin(angle);
          const tickFontSize = me._resolveTickFontOptions(0).size;
          return {
            w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
            h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
          };
        }
        _getLabelCapacity(exampleTime) {
          const me = this;
          const timeOpts = me.options.time;
          const displayFormats = timeOpts.displayFormats;
          const format2 = displayFormats[timeOpts.unit] || displayFormats.millisecond;
          const exampleLabel = me._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(me, [exampleTime], me._majorUnit), format2);
          const size = me._getLabelSize(exampleLabel);
          const capacity = Math.floor(me.isHorizontal() ? me.width / size.w : me.height / size.h) - 1;
          return capacity > 0 ? capacity : 1;
        }
        getDataTimestamps() {
          const me = this;
          let timestamps = me._cache.data || [];
          let i, ilen;
          if (timestamps.length) {
            return timestamps;
          }
          const metas = me.getMatchingVisibleMetas();
          if (me._normalized && metas.length) {
            return me._cache.data = metas[0].controller.getAllParsedValues(me);
          }
          for (i = 0, ilen = metas.length; i < ilen; ++i) {
            timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(me));
          }
          return me._cache.data = me.normalize(timestamps);
        }
        getLabelTimestamps() {
          const me = this;
          const timestamps = me._cache.labels || [];
          let i, ilen;
          if (timestamps.length) {
            return timestamps;
          }
          const labels = me.getLabels();
          for (i = 0, ilen = labels.length; i < ilen; ++i) {
            timestamps.push(parse(me, labels[i]));
          }
          return me._cache.labels = me._normalized ? timestamps : me.normalize(timestamps);
        }
        normalize(values) {
          return _arrayUnique(values.sort(sorter));
        }
      }
      TimeScale.id = "time";
      TimeScale.defaults = {
        bounds: "data",
        adapters: {},
        time: {
          parser: false,
          unit: false,
          round: false,
          isoWeekday: false,
          minUnit: "millisecond",
          displayFormats: {}
        },
        ticks: {
          source: "auto",
          major: {
            enabled: false
          }
        }
      };
      function interpolate(table, val, reverse) {
        let lo = 0;
        let hi = table.length - 1;
        let prevSource, nextSource, prevTarget, nextTarget;
        if (reverse) {
          if (val >= table[lo].pos && val <= table[hi].pos) {
            ({ lo, hi } = _lookupByKey(table, "pos", val));
          }
          ({ pos: prevSource, time: prevTarget } = table[lo]);
          ({ pos: nextSource, time: nextTarget } = table[hi]);
        } else {
          if (val >= table[lo].time && val <= table[hi].time) {
            ({ lo, hi } = _lookupByKey(table, "time", val));
          }
          ({ time: prevSource, pos: prevTarget } = table[lo]);
          ({ time: nextSource, pos: nextTarget } = table[hi]);
        }
        const span = nextSource - prevSource;
        return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
      }
      class TimeSeriesScale extends TimeScale {
        constructor(props) {
          super(props);
          this._table = [];
          this._minPos = void 0;
          this._tableRange = void 0;
        }
        initOffsets() {
          const me = this;
          const timestamps = me._getTimestampsForTable();
          const table = me._table = me.buildLookupTable(timestamps);
          me._minPos = interpolate(table, me.min);
          me._tableRange = interpolate(table, me.max) - me._minPos;
          super.initOffsets(timestamps);
        }
        buildLookupTable(timestamps) {
          const { min, max } = this;
          const items = [];
          const table = [];
          let i, ilen, prev, curr, next;
          for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
            curr = timestamps[i];
            if (curr >= min && curr <= max) {
              items.push(curr);
            }
          }
          if (items.length < 2) {
            return [
              { time: min, pos: 0 },
              { time: max, pos: 1 }
            ];
          }
          for (i = 0, ilen = items.length; i < ilen; ++i) {
            next = items[i + 1];
            prev = items[i - 1];
            curr = items[i];
            if (Math.round((next + prev) / 2) !== curr) {
              table.push({ time: curr, pos: i / (ilen - 1) });
            }
          }
          return table;
        }
        _getTimestampsForTable() {
          const me = this;
          let timestamps = me._cache.all || [];
          if (timestamps.length) {
            return timestamps;
          }
          const data = me.getDataTimestamps();
          const label = me.getLabelTimestamps();
          if (data.length && label.length) {
            timestamps = me.normalize(data.concat(label));
          } else {
            timestamps = data.length ? data : label;
          }
          timestamps = me._cache.all = timestamps;
          return timestamps;
        }
        getDecimalForValue(value) {
          return (interpolate(this._table, value) - this._minPos) / this._tableRange;
        }
        getValueForPixel(pixel) {
          const me = this;
          const offsets = me._offsets;
          const decimal = me.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
          return interpolate(me._table, decimal * me._tableRange + me._minPos, true);
        }
      }
      TimeSeriesScale.id = "timeseries";
      TimeSeriesScale.defaults = TimeScale.defaults;
      var scales = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        CategoryScale,
        LinearScale,
        LogarithmicScale,
        RadialLinearScale,
        TimeScale,
        TimeSeriesScale
      });
      Chart.register(controllers, scales, elements, plugins);
      Chart.helpers = { ...helpers };
      Chart._adapters = _adapters;
      Chart.Animation = Animation;
      Chart.Animations = Animations;
      Chart.animator = animator;
      Chart.controllers = registry.controllers.items;
      Chart.DatasetController = DatasetController;
      Chart.Element = Element;
      Chart.elements = elements;
      Chart.Interaction = Interaction;
      Chart.layouts = layouts;
      Chart.platforms = platforms;
      Chart.Scale = Scale;
      Chart.Ticks = Ticks;
      Object.assign(Chart, controllers, scales, elements, plugins, platforms);
      Chart.Chart = Chart;
      if (typeof window !== "undefined") {
        window.Chart = Chart;
      }
      return Chart;
    });
  }
});

// node_modules/chart.js/auto/auto.js
var require_auto = __commonJS({
  "node_modules/chart.js/auto/auto.js"(exports2, module2) {
    init_shims();
    module2.exports = require_chart();
  }
});

// .svelte-kit/netlify/entry.js
__export(exports, {
  handler: () => handler
});
init_shims();

// .svelte-kit/output/server/app.js
init_shims();
var import_firestore = __toModule(require_index_node_cjs2());
var import_auto = __toModule(require_auto());

// node_modules/tslib/modules/index.js
init_shims();
var import_tslib = __toModule(require_tslib());
var {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __exportStar,
  __createBinding,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet
} = import_tslib.default;

// .svelte-kit/output/server/app.js
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _map;
function get_single_valued_header(headers, key) {
  const value = headers[key];
  if (Array.isArray(value)) {
    if (value.length === 0) {
      return void 0;
    }
    if (value.length > 1) {
      throw new Error(`Multiple headers provided for ${key}. Multiple may be provided only for set-cookie`);
    }
    return value[0];
  }
  return value;
}
function coalesce_to_error(err) {
  return err instanceof Error || err && err.name && err.message ? err : new Error(JSON.stringify(err));
}
function lowercase_keys(obj) {
  const clone2 = {};
  for (const key in obj) {
    clone2[key.toLowerCase()] = obj[key];
  }
  return clone2;
}
function error$1(body) {
  return {
    status: 500,
    body,
    headers: {}
  };
}
function is_string(s2) {
  return typeof s2 === "string" || s2 instanceof String;
}
function is_content_type_textual(content_type) {
  if (!content_type)
    return true;
  const [type] = content_type.split(";");
  return type === "text/plain" || type === "application/json" || type === "application/x-www-form-urlencoded" || type === "multipart/form-data";
}
async function render_endpoint(request, route, match) {
  const mod2 = await route.load();
  const handler2 = mod2[request.method.toLowerCase().replace("delete", "del")];
  if (!handler2) {
    return;
  }
  const params = route.params(match);
  const response = await handler2({ ...request, params });
  const preface = `Invalid response from route ${request.path}`;
  if (!response) {
    return;
  }
  if (typeof response !== "object") {
    return error$1(`${preface}: expected an object, got ${typeof response}`);
  }
  let { status = 200, body, headers = {} } = response;
  headers = lowercase_keys(headers);
  const type = get_single_valued_header(headers, "content-type");
  const is_type_textual = is_content_type_textual(type);
  if (!is_type_textual && !(body instanceof Uint8Array || is_string(body))) {
    return error$1(`${preface}: body must be an instance of string or Uint8Array if content-type is not a supported textual content-type`);
  }
  let normalized_body;
  if ((typeof body === "object" || typeof body === "undefined") && !(body instanceof Uint8Array) && (!type || type.startsWith("application/json"))) {
    headers = { ...headers, "content-type": "application/json; charset=utf-8" };
    normalized_body = JSON.stringify(typeof body === "undefined" ? {} : body);
  } else {
    normalized_body = body;
  }
  return { status, body: normalized_body, headers };
}
var chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
var unsafeChars = /[<>\b\f\n\r\t\0\u2028\u2029]/g;
var reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
var escaped$1 = {
  "<": "\\u003C",
  ">": "\\u003E",
  "/": "\\u002F",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\0": "\\0",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var objectProtoOwnPropertyNames = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function devalue(value) {
  var counts = new Map();
  function walk(thing) {
    if (typeof thing === "function") {
      throw new Error("Cannot stringify a function");
    }
    if (counts.has(thing)) {
      counts.set(thing, counts.get(thing) + 1);
      return;
    }
    counts.set(thing, 1);
    if (!isPrimitive(thing)) {
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
          return;
        case "Array":
          thing.forEach(walk);
          break;
        case "Set":
        case "Map":
          Array.from(thing).forEach(walk);
          break;
        default:
          var proto = Object.getPrototypeOf(thing);
          if (proto !== Object.prototype && proto !== null && Object.getOwnPropertyNames(proto).sort().join("\0") !== objectProtoOwnPropertyNames) {
            throw new Error("Cannot stringify arbitrary non-POJOs");
          }
          if (Object.getOwnPropertySymbols(thing).length > 0) {
            throw new Error("Cannot stringify POJOs with symbolic keys");
          }
          Object.keys(thing).forEach(function(key) {
            return walk(thing[key]);
          });
      }
    }
  }
  walk(value);
  var names = new Map();
  Array.from(counts).filter(function(entry) {
    return entry[1] > 1;
  }).sort(function(a, b) {
    return b[1] - a[1];
  }).forEach(function(entry, i) {
    names.set(entry[0], getName(i));
  });
  function stringify(thing) {
    if (names.has(thing)) {
      return names.get(thing);
    }
    if (isPrimitive(thing)) {
      return stringifyPrimitive(thing);
    }
    var type = getType(thing);
    switch (type) {
      case "Number":
      case "String":
      case "Boolean":
        return "Object(" + stringify(thing.valueOf()) + ")";
      case "RegExp":
        return "new RegExp(" + stringifyString(thing.source) + ', "' + thing.flags + '")';
      case "Date":
        return "new Date(" + thing.getTime() + ")";
      case "Array":
        var members = thing.map(function(v, i) {
          return i in thing ? stringify(v) : "";
        });
        var tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return "[" + members.join(",") + tail + "]";
      case "Set":
      case "Map":
        return "new " + type + "([" + Array.from(thing).map(stringify).join(",") + "])";
      default:
        var obj = "{" + Object.keys(thing).map(function(key) {
          return safeKey(key) + ":" + stringify(thing[key]);
        }).join(",") + "}";
        var proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return Object.keys(thing).length > 0 ? "Object.assign(Object.create(null)," + obj + ")" : "Object.create(null)";
        }
        return obj;
    }
  }
  var str = stringify(value);
  if (names.size) {
    var params_1 = [];
    var statements_1 = [];
    var values_1 = [];
    names.forEach(function(name2, thing) {
      params_1.push(name2);
      if (isPrimitive(thing)) {
        values_1.push(stringifyPrimitive(thing));
        return;
      }
      var type = getType(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          values_1.push("Object(" + stringify(thing.valueOf()) + ")");
          break;
        case "RegExp":
          values_1.push(thing.toString());
          break;
        case "Date":
          values_1.push("new Date(" + thing.getTime() + ")");
          break;
        case "Array":
          values_1.push("Array(" + thing.length + ")");
          thing.forEach(function(v, i) {
            statements_1.push(name2 + "[" + i + "]=" + stringify(v));
          });
          break;
        case "Set":
          values_1.push("new Set");
          statements_1.push(name2 + "." + Array.from(thing).map(function(v) {
            return "add(" + stringify(v) + ")";
          }).join("."));
          break;
        case "Map":
          values_1.push("new Map");
          statements_1.push(name2 + "." + Array.from(thing).map(function(_a) {
            var k = _a[0], v = _a[1];
            return "set(" + stringify(k) + ", " + stringify(v) + ")";
          }).join("."));
          break;
        default:
          values_1.push(Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}");
          Object.keys(thing).forEach(function(key) {
            statements_1.push("" + name2 + safeProp(key) + "=" + stringify(thing[key]));
          });
      }
    });
    statements_1.push("return " + str);
    return "(function(" + params_1.join(",") + "){" + statements_1.join(";") + "}(" + values_1.join(",") + "))";
  } else {
    return str;
  }
}
function getName(num) {
  var name2 = "";
  do {
    name2 = chars[num % chars.length] + name2;
    num = ~~(num / chars.length) - 1;
  } while (num >= 0);
  return reserved.test(name2) ? name2 + "_" : name2;
}
function isPrimitive(thing) {
  return Object(thing) !== thing;
}
function stringifyPrimitive(thing) {
  if (typeof thing === "string")
    return stringifyString(thing);
  if (thing === void 0)
    return "void 0";
  if (thing === 0 && 1 / thing < 0)
    return "-0";
  var str = String(thing);
  if (typeof thing === "number")
    return str.replace(/^(-)?0\./, "$1.");
  return str;
}
function getType(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function escapeUnsafeChar(c) {
  return escaped$1[c] || c;
}
function escapeUnsafeChars(str) {
  return str.replace(unsafeChars, escapeUnsafeChar);
}
function safeKey(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? key : escapeUnsafeChars(JSON.stringify(key));
}
function safeProp(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? "." + key : "[" + escapeUnsafeChars(JSON.stringify(key)) + "]";
}
function stringifyString(str) {
  var result = '"';
  for (var i = 0; i < str.length; i += 1) {
    var char = str.charAt(i);
    var code = char.charCodeAt(0);
    if (char === '"') {
      result += '\\"';
    } else if (char in escaped$1) {
      result += escaped$1[char];
    } else if (code >= 55296 && code <= 57343) {
      var next = str.charCodeAt(i + 1);
      if (code <= 56319 && (next >= 56320 && next <= 57343)) {
        result += char + str[++i];
      } else {
        result += "\\u" + code.toString(16).toUpperCase();
      }
    } else {
      result += char;
    }
  }
  result += '"';
  return result;
}
function noop$2() {
}
function safe_not_equal$1(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
Promise.resolve();
var subscriber_queue$1 = [];
function writable$1(value, start2 = noop$2) {
  let stop2;
  const subscribers = new Set();
  function set2(new_value) {
    if (safe_not_equal$1(value, new_value)) {
      value = new_value;
      if (stop2) {
        const run_queue = !subscriber_queue$1.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue$1.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue$1.length; i += 2) {
            subscriber_queue$1[i][0](subscriber_queue$1[i + 1]);
          }
          subscriber_queue$1.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set2(fn(value));
  }
  function subscribe(run2, invalidate = noop$2) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop2 = start2(set2) || noop$2;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop2();
        stop2 = null;
      }
    };
  }
  return { set: set2, update: update2, subscribe };
}
function hash(value) {
  let hash2 = 5381;
  let i = value.length;
  if (typeof value === "string") {
    while (i)
      hash2 = hash2 * 33 ^ value.charCodeAt(--i);
  } else {
    while (i)
      hash2 = hash2 * 33 ^ value[--i];
  }
  return (hash2 >>> 0).toString(36);
}
var escape_json_string_in_html_dict = {
  '"': '\\"',
  "<": "\\u003C",
  ">": "\\u003E",
  "/": "\\u002F",
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t",
  "\0": "\\0",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
function escape_json_string_in_html(str) {
  return escape$1(str, escape_json_string_in_html_dict, (code) => `\\u${code.toString(16).toUpperCase()}`);
}
var escape_html_attr_dict = {
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;"
};
function escape_html_attr(str) {
  return '"' + escape$1(str, escape_html_attr_dict, (code) => `&#${code};`) + '"';
}
function escape$1(str, dict, unicode_encoder) {
  let result = "";
  for (let i = 0; i < str.length; i += 1) {
    const char = str.charAt(i);
    const code = char.charCodeAt(0);
    if (char in dict) {
      result += dict[char];
    } else if (code >= 55296 && code <= 57343) {
      const next = str.charCodeAt(i + 1);
      if (code <= 56319 && next >= 56320 && next <= 57343) {
        result += char + str[++i];
      } else {
        result += unicode_encoder(code);
      }
    } else {
      result += char;
    }
  }
  return result;
}
var s$1 = JSON.stringify;
async function render_response({
  branch,
  options: options2,
  $session,
  page_config,
  status,
  error: error2,
  page
}) {
  const css2 = new Set(options2.entry.css);
  const js = new Set(options2.entry.js);
  const styles = new Set();
  const serialized_data = [];
  let rendered;
  let is_private = false;
  let maxage;
  if (error2) {
    error2.stack = options2.get_stack(error2);
  }
  if (page_config.ssr) {
    branch.forEach(({ node, loaded, fetched, uses_credentials }) => {
      if (node.css)
        node.css.forEach((url) => css2.add(url));
      if (node.js)
        node.js.forEach((url) => js.add(url));
      if (node.styles)
        node.styles.forEach((content) => styles.add(content));
      if (fetched && page_config.hydrate)
        serialized_data.push(...fetched);
      if (uses_credentials)
        is_private = true;
      maxage = loaded.maxage;
    });
    const session = writable$1($session);
    const props = {
      stores: {
        page: writable$1(null),
        navigating: writable$1(null),
        session
      },
      page,
      components: branch.map(({ node }) => node.module.default)
    };
    for (let i = 0; i < branch.length; i += 1) {
      props[`props_${i}`] = await branch[i].loaded.props;
    }
    let session_tracking_active = false;
    const unsubscribe = session.subscribe(() => {
      if (session_tracking_active)
        is_private = true;
    });
    session_tracking_active = true;
    try {
      rendered = options2.root.render(props);
    } finally {
      unsubscribe();
    }
  } else {
    rendered = { head: "", html: "", css: { code: "", map: null } };
  }
  const include_js = page_config.router || page_config.hydrate;
  if (!include_js)
    js.clear();
  const links = options2.amp ? styles.size > 0 || rendered.css.code.length > 0 ? `<style amp-custom>${Array.from(styles).concat(rendered.css.code).join("\n")}</style>` : "" : [
    ...Array.from(js).map((dep) => `<link rel="modulepreload" href="${dep}">`),
    ...Array.from(css2).map((dep) => `<link rel="stylesheet" href="${dep}">`)
  ].join("\n		");
  let init2 = "";
  if (options2.amp) {
    init2 = `
		<style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
		<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
		<script async src="https://cdn.ampproject.org/v0.js"><\/script>`;
  } else if (include_js) {
    init2 = `<script type="module">
			import { start } from ${s$1(options2.entry.file)};
			start({
				target: ${options2.target ? `document.querySelector(${s$1(options2.target)})` : "document.body"},
				paths: ${s$1(options2.paths)},
				session: ${try_serialize($session, (error3) => {
      throw new Error(`Failed to serialize session data: ${error3.message}`);
    })},
				host: ${page && page.host ? s$1(page.host) : "location.host"},
				route: ${!!page_config.router},
				spa: ${!page_config.ssr},
				trailing_slash: ${s$1(options2.trailing_slash)},
				hydrate: ${page_config.ssr && page_config.hydrate ? `{
					status: ${status},
					error: ${serialize_error(error2)},
					nodes: [
						${(branch || []).map(({ node }) => `import(${s$1(node.entry)})`).join(",\n						")}
					],
					page: {
						host: ${page && page.host ? s$1(page.host) : "location.host"}, // TODO this is redundant
						path: ${s$1(page && page.path)},
						query: new URLSearchParams(${page ? s$1(page.query.toString()) : ""}),
						params: ${page && s$1(page.params)}
					}
				}` : "null"}
			});
		<\/script>`;
  }
  if (options2.service_worker) {
    init2 += `<script>
			if ('serviceWorker' in navigator) {
				navigator.serviceWorker.register('${options2.service_worker}');
			}
		<\/script>`;
  }
  const head = [
    rendered.head,
    styles.size && !options2.amp ? `<style data-svelte>${Array.from(styles).join("\n")}</style>` : "",
    links,
    init2
  ].join("\n\n		");
  const body = options2.amp ? rendered.html : `${rendered.html}

			${serialized_data.map(({ url, body: body2, json }) => {
    let attributes = `type="application/json" data-type="svelte-data" data-url=${escape_html_attr(url)}`;
    if (body2)
      attributes += ` data-body="${hash(body2)}"`;
    return `<script ${attributes}>${json}<\/script>`;
  }).join("\n\n	")}
		`;
  const headers = {
    "content-type": "text/html"
  };
  if (maxage) {
    headers["cache-control"] = `${is_private ? "private" : "public"}, max-age=${maxage}`;
  }
  if (!options2.floc) {
    headers["permissions-policy"] = "interest-cohort=()";
  }
  return {
    status,
    headers,
    body: options2.template({ head, body })
  };
}
function try_serialize(data, fail) {
  try {
    return devalue(data);
  } catch (err) {
    if (fail)
      fail(coalesce_to_error(err));
    return null;
  }
}
function serialize_error(error2) {
  if (!error2)
    return null;
  let serialized = try_serialize(error2);
  if (!serialized) {
    const { name: name2, message, stack } = error2;
    serialized = try_serialize({ ...error2, name: name2, message, stack });
  }
  if (!serialized) {
    serialized = "{}";
  }
  return serialized;
}
function normalize(loaded) {
  const has_error_status = loaded.status && loaded.status >= 400 && loaded.status <= 599 && !loaded.redirect;
  if (loaded.error || has_error_status) {
    const status = loaded.status;
    if (!loaded.error && has_error_status) {
      return {
        status: status || 500,
        error: new Error()
      };
    }
    const error2 = typeof loaded.error === "string" ? new Error(loaded.error) : loaded.error;
    if (!(error2 instanceof Error)) {
      return {
        status: 500,
        error: new Error(`"error" property returned from load() must be a string or instance of Error, received type "${typeof error2}"`)
      };
    }
    if (!status || status < 400 || status > 599) {
      console.warn('"error" returned from load() without a valid status code \u2014 defaulting to 500');
      return { status: 500, error: error2 };
    }
    return { status, error: error2 };
  }
  if (loaded.redirect) {
    if (!loaded.status || Math.floor(loaded.status / 100) !== 3) {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be accompanied by a 3xx status code')
      };
    }
    if (typeof loaded.redirect !== "string") {
      return {
        status: 500,
        error: new Error('"redirect" property returned from load() must be a string')
      };
    }
  }
  if (loaded.context) {
    throw new Error('You are returning "context" from a load function. "context" was renamed to "stuff", please adjust your code accordingly.');
  }
  return loaded;
}
var s = JSON.stringify;
async function load_node({
  request,
  options: options2,
  state,
  route,
  page,
  node,
  $session,
  stuff,
  prerender_enabled,
  is_leaf,
  is_error,
  status,
  error: error2
}) {
  const { module: module2 } = node;
  let uses_credentials = false;
  const fetched = [];
  let set_cookie_headers = [];
  let loaded;
  const page_proxy = new Proxy(page, {
    get: (target, prop, receiver) => {
      if (prop === "query" && prerender_enabled) {
        throw new Error("Cannot access query on a page with prerendering enabled");
      }
      return Reflect.get(target, prop, receiver);
    }
  });
  if (module2.load) {
    const load_input = {
      page: page_proxy,
      get session() {
        uses_credentials = true;
        return $session;
      },
      fetch: async (resource, opts = {}) => {
        let url;
        if (typeof resource === "string") {
          url = resource;
        } else {
          url = resource.url;
          opts = {
            method: resource.method,
            headers: resource.headers,
            body: resource.body,
            mode: resource.mode,
            credentials: resource.credentials,
            cache: resource.cache,
            redirect: resource.redirect,
            referrer: resource.referrer,
            integrity: resource.integrity,
            ...opts
          };
        }
        const resolved = resolve(request.path, url.split("?")[0]);
        let response;
        const filename = resolved.replace(options2.paths.assets, "").slice(1);
        const filename_html = `${filename}/index.html`;
        const asset = options2.manifest.assets.find((d2) => d2.file === filename || d2.file === filename_html);
        if (asset) {
          response = options2.read ? new Response(options2.read(asset.file), {
            headers: asset.type ? { "content-type": asset.type } : {}
          }) : await fetch(`http://${page.host}/${asset.file}`, opts);
        } else if (resolved.startsWith("/") && !resolved.startsWith("//")) {
          const relative = resolved;
          const headers = {
            ...opts.headers
          };
          if (opts.credentials !== "omit") {
            uses_credentials = true;
            headers.cookie = request.headers.cookie;
            if (!headers.authorization) {
              headers.authorization = request.headers.authorization;
            }
          }
          if (opts.body && typeof opts.body !== "string") {
            throw new Error("Request body must be a string");
          }
          const search = url.includes("?") ? url.slice(url.indexOf("?") + 1) : "";
          const rendered = await respond({
            host: request.host,
            method: opts.method || "GET",
            headers,
            path: relative,
            rawBody: opts.body == null ? null : new TextEncoder().encode(opts.body),
            query: new URLSearchParams(search)
          }, options2, {
            fetched: url,
            initiator: route
          });
          if (rendered) {
            if (state.prerender) {
              state.prerender.dependencies.set(relative, rendered);
            }
            response = new Response(rendered.body, {
              status: rendered.status,
              headers: rendered.headers
            });
          }
        } else {
          if (resolved.startsWith("//")) {
            throw new Error(`Cannot request protocol-relative URL (${url}) in server-side fetch`);
          }
          if (typeof request.host !== "undefined") {
            const { hostname: fetch_hostname } = new URL(url);
            const [server_hostname] = request.host.split(":");
            if (`.${fetch_hostname}`.endsWith(`.${server_hostname}`) && opts.credentials !== "omit") {
              uses_credentials = true;
              opts.headers = {
                ...opts.headers,
                cookie: request.headers.cookie
              };
            }
          }
          const external_request = new Request(url, opts);
          response = await options2.hooks.externalFetch.call(null, external_request);
        }
        if (response) {
          const proxy = new Proxy(response, {
            get(response2, key, receiver) {
              async function text() {
                const body = await response2.text();
                const headers = {};
                for (const [key2, value] of response2.headers) {
                  if (key2 === "set-cookie") {
                    set_cookie_headers = set_cookie_headers.concat(value);
                  } else if (key2 !== "etag") {
                    headers[key2] = value;
                  }
                }
                if (!opts.body || typeof opts.body === "string") {
                  fetched.push({
                    url,
                    body: opts.body,
                    json: `{"status":${response2.status},"statusText":${s(response2.statusText)},"headers":${s(headers)},"body":"${escape_json_string_in_html(body)}"}`
                  });
                }
                return body;
              }
              if (key === "text") {
                return text;
              }
              if (key === "json") {
                return async () => {
                  return JSON.parse(await text());
                };
              }
              return Reflect.get(response2, key, response2);
            }
          });
          return proxy;
        }
        return response || new Response("Not found", {
          status: 404
        });
      },
      stuff: { ...stuff }
    };
    if (is_error) {
      load_input.status = status;
      load_input.error = error2;
    }
    loaded = await module2.load.call(null, load_input);
  } else {
    loaded = {};
  }
  if (!loaded && is_leaf && !is_error)
    return;
  if (!loaded) {
    throw new Error(`${node.entry} - load must return a value except for page fall through`);
  }
  return {
    node,
    loaded: normalize(loaded),
    stuff: loaded.stuff || stuff,
    fetched,
    set_cookie_headers,
    uses_credentials
  };
}
var absolute = /^([a-z]+:)?\/?\//;
function resolve(base2, path) {
  const base_match = absolute.exec(base2);
  const path_match = absolute.exec(path);
  if (!base_match) {
    throw new Error(`bad base path: "${base2}"`);
  }
  const baseparts = path_match ? [] : base2.slice(base_match[0].length).split("/");
  const pathparts = path_match ? path.slice(path_match[0].length).split("/") : path.split("/");
  baseparts.pop();
  for (let i = 0; i < pathparts.length; i += 1) {
    const part = pathparts[i];
    if (part === ".")
      continue;
    else if (part === "..")
      baseparts.pop();
    else
      baseparts.push(part);
  }
  const prefix = path_match && path_match[0] || base_match && base_match[0] || "";
  return `${prefix}${baseparts.join("/")}`;
}
async function respond_with_error({ request, options: options2, state, $session, status, error: error2 }) {
  const default_layout = await options2.load_component(options2.manifest.layout);
  const default_error = await options2.load_component(options2.manifest.error);
  const page = {
    host: request.host,
    path: request.path,
    query: request.query,
    params: {}
  };
  const loaded = await load_node({
    request,
    options: options2,
    state,
    route: null,
    page,
    node: default_layout,
    $session,
    stuff: {},
    prerender_enabled: is_prerender_enabled(options2, default_error, state),
    is_leaf: false,
    is_error: false
  });
  const branch = [
    loaded,
    await load_node({
      request,
      options: options2,
      state,
      route: null,
      page,
      node: default_error,
      $session,
      stuff: loaded ? loaded.stuff : {},
      prerender_enabled: is_prerender_enabled(options2, default_error, state),
      is_leaf: false,
      is_error: true,
      status,
      error: error2
    })
  ];
  try {
    return await render_response({
      options: options2,
      $session,
      page_config: {
        hydrate: options2.hydrate,
        router: options2.router,
        ssr: options2.ssr
      },
      status,
      error: error2,
      branch,
      page
    });
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options2.handle_error(error3, request);
    return {
      status: 500,
      headers: {},
      body: error3.stack
    };
  }
}
function is_prerender_enabled(options2, node, state) {
  return options2.prerender && (!!node.module.prerender || !!state.prerender && state.prerender.all);
}
async function respond$1(opts) {
  const { request, options: options2, state, $session, route } = opts;
  let nodes;
  try {
    nodes = await Promise.all(route.a.map((id) => id ? options2.load_component(id) : void 0));
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options2.handle_error(error3, request);
    return await respond_with_error({
      request,
      options: options2,
      state,
      $session,
      status: 500,
      error: error3
    });
  }
  const leaf = nodes[nodes.length - 1].module;
  let page_config = get_page_config(leaf, options2);
  if (!leaf.prerender && state.prerender && !state.prerender.all) {
    return {
      status: 204,
      headers: {},
      body: ""
    };
  }
  let branch = [];
  let status = 200;
  let error2;
  let set_cookie_headers = [];
  ssr:
    if (page_config.ssr) {
      let stuff = {};
      for (let i = 0; i < nodes.length; i += 1) {
        const node = nodes[i];
        let loaded;
        if (node) {
          try {
            loaded = await load_node({
              ...opts,
              node,
              stuff,
              prerender_enabled: is_prerender_enabled(options2, node, state),
              is_leaf: i === nodes.length - 1,
              is_error: false
            });
            if (!loaded)
              return;
            set_cookie_headers = set_cookie_headers.concat(loaded.set_cookie_headers);
            if (loaded.loaded.redirect) {
              return with_cookies({
                status: loaded.loaded.status,
                headers: {
                  location: encodeURI(loaded.loaded.redirect)
                }
              }, set_cookie_headers);
            }
            if (loaded.loaded.error) {
              ({ status, error: error2 } = loaded.loaded);
            }
          } catch (err) {
            const e = coalesce_to_error(err);
            options2.handle_error(e, request);
            status = 500;
            error2 = e;
          }
          if (loaded && !error2) {
            branch.push(loaded);
          }
          if (error2) {
            while (i--) {
              if (route.b[i]) {
                const error_node = await options2.load_component(route.b[i]);
                let node_loaded;
                let j = i;
                while (!(node_loaded = branch[j])) {
                  j -= 1;
                }
                try {
                  const error_loaded = await load_node({
                    ...opts,
                    node: error_node,
                    stuff: node_loaded.stuff,
                    prerender_enabled: is_prerender_enabled(options2, error_node, state),
                    is_leaf: false,
                    is_error: true,
                    status,
                    error: error2
                  });
                  if (error_loaded.loaded.error) {
                    continue;
                  }
                  page_config = get_page_config(error_node.module, options2);
                  branch = branch.slice(0, j + 1).concat(error_loaded);
                  break ssr;
                } catch (err) {
                  const e = coalesce_to_error(err);
                  options2.handle_error(e, request);
                  continue;
                }
              }
            }
            return with_cookies(await respond_with_error({
              request,
              options: options2,
              state,
              $session,
              status,
              error: error2
            }), set_cookie_headers);
          }
        }
        if (loaded && loaded.loaded.stuff) {
          stuff = {
            ...stuff,
            ...loaded.loaded.stuff
          };
        }
      }
    }
  try {
    return with_cookies(await render_response({
      ...opts,
      page_config,
      status,
      error: error2,
      branch: branch.filter(Boolean)
    }), set_cookie_headers);
  } catch (err) {
    const error3 = coalesce_to_error(err);
    options2.handle_error(error3, request);
    return with_cookies(await respond_with_error({
      ...opts,
      status: 500,
      error: error3
    }), set_cookie_headers);
  }
}
function get_page_config(leaf, options2) {
  return {
    ssr: "ssr" in leaf ? !!leaf.ssr : options2.ssr,
    router: "router" in leaf ? !!leaf.router : options2.router,
    hydrate: "hydrate" in leaf ? !!leaf.hydrate : options2.hydrate
  };
}
function with_cookies(response, set_cookie_headers) {
  if (set_cookie_headers.length) {
    response.headers["set-cookie"] = set_cookie_headers;
  }
  return response;
}
async function render_page(request, route, match, options2, state) {
  if (state.initiator === route) {
    return {
      status: 404,
      headers: {},
      body: `Not found: ${request.path}`
    };
  }
  const params = route.params(match);
  const page = {
    host: request.host,
    path: request.path,
    query: request.query,
    params
  };
  const $session = await options2.hooks.getSession(request);
  const response = await respond$1({
    request,
    options: options2,
    state,
    $session,
    route,
    page
  });
  if (response) {
    return response;
  }
  if (state.fetched) {
    return {
      status: 500,
      headers: {},
      body: `Bad request in load function: failed to fetch ${state.fetched}`
    };
  }
}
function read_only_form_data() {
  const map = new Map();
  return {
    append(key, value) {
      if (map.has(key)) {
        (map.get(key) || []).push(value);
      } else {
        map.set(key, [value]);
      }
    },
    data: new ReadOnlyFormData(map)
  };
}
var ReadOnlyFormData = class {
  constructor(map) {
    __privateAdd(this, _map, void 0);
    __privateSet(this, _map, map);
  }
  get(key) {
    const value = __privateGet(this, _map).get(key);
    return value && value[0];
  }
  getAll(key) {
    return __privateGet(this, _map).get(key);
  }
  has(key) {
    return __privateGet(this, _map).has(key);
  }
  *[Symbol.iterator]() {
    for (const [key, value] of __privateGet(this, _map)) {
      for (let i = 0; i < value.length; i += 1) {
        yield [key, value[i]];
      }
    }
  }
  *entries() {
    for (const [key, value] of __privateGet(this, _map)) {
      for (let i = 0; i < value.length; i += 1) {
        yield [key, value[i]];
      }
    }
  }
  *keys() {
    for (const [key] of __privateGet(this, _map))
      yield key;
  }
  *values() {
    for (const [, value] of __privateGet(this, _map)) {
      for (let i = 0; i < value.length; i += 1) {
        yield value[i];
      }
    }
  }
};
_map = new WeakMap();
function parse_body(raw, headers) {
  if (!raw)
    return raw;
  const content_type = headers["content-type"];
  const [type, ...directives] = content_type ? content_type.split(/;\s*/) : [];
  const text = () => new TextDecoder(headers["content-encoding"] || "utf-8").decode(raw);
  switch (type) {
    case "text/plain":
      return text();
    case "application/json":
      return JSON.parse(text());
    case "application/x-www-form-urlencoded":
      return get_urlencoded(text());
    case "multipart/form-data": {
      const boundary = directives.find((directive) => directive.startsWith("boundary="));
      if (!boundary)
        throw new Error("Missing boundary");
      return get_multipart(text(), boundary.slice("boundary=".length));
    }
    default:
      return raw;
  }
}
function get_urlencoded(text) {
  const { data, append } = read_only_form_data();
  text.replace(/\+/g, " ").split("&").forEach((str) => {
    const [key, value] = str.split("=");
    append(decodeURIComponent(key), decodeURIComponent(value));
  });
  return data;
}
function get_multipart(text, boundary) {
  const parts = text.split(`--${boundary}`);
  if (parts[0] !== "" || parts[parts.length - 1].trim() !== "--") {
    throw new Error("Malformed form data");
  }
  const { data, append } = read_only_form_data();
  parts.slice(1, -1).forEach((part) => {
    const match = /\s*([\s\S]+?)\r\n\r\n([\s\S]*)\s*/.exec(part);
    if (!match) {
      throw new Error("Malformed form data");
    }
    const raw_headers = match[1];
    const body = match[2].trim();
    let key;
    const headers = {};
    raw_headers.split("\r\n").forEach((str) => {
      const [raw_header, ...raw_directives] = str.split("; ");
      let [name2, value] = raw_header.split(": ");
      name2 = name2.toLowerCase();
      headers[name2] = value;
      const directives = {};
      raw_directives.forEach((raw_directive) => {
        const [name3, value2] = raw_directive.split("=");
        directives[name3] = JSON.parse(value2);
      });
      if (name2 === "content-disposition") {
        if (value !== "form-data")
          throw new Error("Malformed form data");
        if (directives.filename) {
          throw new Error("File upload is not yet implemented");
        }
        if (directives.name) {
          key = directives.name;
        }
      }
    });
    if (!key)
      throw new Error("Malformed form data");
    append(key, body);
  });
  return data;
}
async function respond(incoming, options2, state = {}) {
  if (incoming.path !== "/" && options2.trailing_slash !== "ignore") {
    const has_trailing_slash = incoming.path.endsWith("/");
    if (has_trailing_slash && options2.trailing_slash === "never" || !has_trailing_slash && options2.trailing_slash === "always" && !(incoming.path.split("/").pop() || "").includes(".")) {
      const path = has_trailing_slash ? incoming.path.slice(0, -1) : incoming.path + "/";
      const q = incoming.query.toString();
      return {
        status: 301,
        headers: {
          location: options2.paths.base + path + (q ? `?${q}` : "")
        }
      };
    }
  }
  const headers = lowercase_keys(incoming.headers);
  const request = {
    ...incoming,
    headers,
    body: parse_body(incoming.rawBody, headers),
    params: {},
    locals: {}
  };
  try {
    return await options2.hooks.handle({
      request,
      resolve: async (request2) => {
        if (state.prerender && state.prerender.fallback) {
          return await render_response({
            options: options2,
            $session: await options2.hooks.getSession(request2),
            page_config: { ssr: false, router: true, hydrate: true },
            status: 200,
            branch: []
          });
        }
        const decoded = decodeURI(request2.path);
        for (const route of options2.manifest.routes) {
          const match = route.pattern.exec(decoded);
          if (!match)
            continue;
          const response = route.type === "endpoint" ? await render_endpoint(request2, route, match) : await render_page(request2, route, match, options2, state);
          if (response) {
            if (response.status === 200) {
              const cache_control = get_single_valued_header(response.headers, "cache-control");
              if (!cache_control || !/(no-store|immutable)/.test(cache_control)) {
                const etag = `"${hash(response.body || "")}"`;
                if (request2.headers["if-none-match"] === etag) {
                  return {
                    status: 304,
                    headers: {},
                    body: ""
                  };
                }
                response.headers["etag"] = etag;
              }
            }
            return response;
          }
        }
        const $session = await options2.hooks.getSession(request2);
        return await respond_with_error({
          request: request2,
          options: options2,
          state,
          $session,
          status: 404,
          error: new Error(`Not found: ${request2.path}`)
        });
      }
    });
  } catch (err) {
    const e = coalesce_to_error(err);
    options2.handle_error(e, request);
    return {
      status: 500,
      headers: {},
      body: options2.dev ? e.stack : e.message
    };
  }
}
function noop$1() {
}
function is_promise(value) {
  return value && typeof value === "object" && typeof value.then === "function";
}
function run(fn) {
  return fn();
}
function blank_object() {
  return Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function null_to_empty(value) {
  return value == null ? "" : value;
}
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
}
Promise.resolve();
var escaped = {
  '"': "&quot;",
  "'": "&#39;",
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;"
};
function escape(html) {
  return String(html).replace(/["'&<>]/g, (match) => escaped[match]);
}
function each(items, fn) {
  let str = "";
  for (let i = 0; i < items.length; i += 1) {
    str += fn(items[i], i);
  }
  return str;
}
var missing_component = {
  $$render: () => ""
};
function validate_component(component, name2) {
  if (!component || !component.$$render) {
    if (name2 === "svelte:component")
      name2 += " this={...}";
    throw new Error(`<${name2}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
  }
  return component;
}
var on_destroy;
function create_ssr_component(fn) {
  function $$render(result, props, bindings, slots, context) {
    const parent_component = current_component;
    const $$ = {
      on_destroy,
      context: new Map(context || (parent_component ? parent_component.$$.context : [])),
      on_mount: [],
      before_update: [],
      after_update: [],
      callbacks: blank_object()
    };
    set_current_component({ $$ });
    const html = fn(result, props, bindings, slots);
    set_current_component(parent_component);
    return html;
  }
  return {
    render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {
      on_destroy = [];
      const result = { title: "", head: "", css: new Set() };
      const html = $$render(result, props, {}, $$slots, context);
      run_all(on_destroy);
      return {
        html,
        css: {
          code: Array.from(result.css).map((css2) => css2.code).join("\n"),
          map: null
        },
        head: result.title + result.head
      };
    },
    $$render
  };
}
function add_attribute(name2, value, boolean) {
  if (value == null || boolean && !value)
    return "";
  return ` ${name2}${value === true ? "" : `=${typeof value === "string" ? JSON.stringify(escape(value)) : `"${value}"`}`}`;
}
function afterUpdate() {
}
var css$e = {
  code: "#svelte-announcer.svelte-1j55zn5{position:absolute;left:0;top:0;clip:rect(0 0 0 0);clip-path:inset(50%);overflow:hidden;white-space:nowrap;width:1px;height:1px}",
  map: `{"version":3,"file":"root.svelte","sources":["root.svelte"],"sourcesContent":["<!-- This file is generated by @sveltejs/kit \u2014 do not edit it! -->\\n<script>\\n\\timport { setContext, afterUpdate, onMount } from 'svelte';\\n\\n\\t// stores\\n\\texport let stores;\\n\\texport let page;\\n\\n\\texport let components;\\n\\texport let props_0 = null;\\n\\texport let props_1 = null;\\n\\texport let props_2 = null;\\n\\n\\tsetContext('__svelte__', stores);\\n\\n\\t$: stores.page.set(page);\\n\\tafterUpdate(stores.page.notify);\\n\\n\\tlet mounted = false;\\n\\tlet navigated = false;\\n\\tlet title = null;\\n\\n\\tonMount(() => {\\n\\t\\tconst unsubscribe = stores.page.subscribe(() => {\\n\\t\\t\\tif (mounted) {\\n\\t\\t\\t\\tnavigated = true;\\n\\t\\t\\t\\ttitle = document.title || 'untitled page';\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tmounted = true;\\n\\t\\treturn unsubscribe;\\n\\t});\\n<\/script>\\n\\n<svelte:component this={components[0]} {...(props_0 || {})}>\\n\\t{#if components[1]}\\n\\t\\t<svelte:component this={components[1]} {...(props_1 || {})}>\\n\\t\\t\\t{#if components[2]}\\n\\t\\t\\t\\t<svelte:component this={components[2]} {...(props_2 || {})}/>\\n\\t\\t\\t{/if}\\n\\t\\t</svelte:component>\\n\\t{/if}\\n</svelte:component>\\n\\n{#if mounted}\\n\\t<div id=\\"svelte-announcer\\" aria-live=\\"assertive\\" aria-atomic=\\"true\\">\\n\\t\\t{#if navigated}\\n\\t\\t\\t{title}\\n\\t\\t{/if}\\n\\t</div>\\n{/if}\\n\\n<style>\\n\\t#svelte-announcer {\\n\\t\\tposition: absolute;\\n\\t\\tleft: 0;\\n\\t\\ttop: 0;\\n\\t\\tclip: rect(0 0 0 0);\\n\\t\\tclip-path: inset(50%);\\n\\t\\toverflow: hidden;\\n\\t\\twhite-space: nowrap;\\n\\t\\twidth: 1px;\\n\\t\\theight: 1px;\\n\\t}\\n</style>"],"names":[],"mappings":"AAsDC,iBAAiB,eAAC,CAAC,AAClB,QAAQ,CAAE,QAAQ,CAClB,IAAI,CAAE,CAAC,CACP,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CACnB,SAAS,CAAE,MAAM,GAAG,CAAC,CACrB,QAAQ,CAAE,MAAM,CAChB,WAAW,CAAE,MAAM,CACnB,KAAK,CAAE,GAAG,CACV,MAAM,CAAE,GAAG,AACZ,CAAC"}`
};
var Root = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { stores } = $$props;
  let { page } = $$props;
  let { components } = $$props;
  let { props_0 = null } = $$props;
  let { props_1 = null } = $$props;
  let { props_2 = null } = $$props;
  setContext("__svelte__", stores);
  afterUpdate(stores.page.notify);
  if ($$props.stores === void 0 && $$bindings.stores && stores !== void 0)
    $$bindings.stores(stores);
  if ($$props.page === void 0 && $$bindings.page && page !== void 0)
    $$bindings.page(page);
  if ($$props.components === void 0 && $$bindings.components && components !== void 0)
    $$bindings.components(components);
  if ($$props.props_0 === void 0 && $$bindings.props_0 && props_0 !== void 0)
    $$bindings.props_0(props_0);
  if ($$props.props_1 === void 0 && $$bindings.props_1 && props_1 !== void 0)
    $$bindings.props_1(props_1);
  if ($$props.props_2 === void 0 && $$bindings.props_2 && props_2 !== void 0)
    $$bindings.props_2(props_2);
  $$result.css.add(css$e);
  {
    stores.page.set(page);
  }
  return `


${validate_component(components[0] || missing_component, "svelte:component").$$render($$result, Object.assign(props_0 || {}), {}, {
    default: () => `${components[1] ? `${validate_component(components[1] || missing_component, "svelte:component").$$render($$result, Object.assign(props_1 || {}), {}, {
      default: () => `${components[2] ? `${validate_component(components[2] || missing_component, "svelte:component").$$render($$result, Object.assign(props_2 || {}), {}, {})}` : ``}`
    })}` : ``}`
  })}

${``}`;
});
var base = "";
var assets = "";
function set_paths(paths) {
  base = paths.base;
  assets = paths.assets || base;
}
function set_prerendering(value) {
}
var user_hooks = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module"
});
var template = ({ head, body }) => '<!DOCTYPE html>\n<html lang="en">\n	<head>\n		<meta charset="utf-8" />\n		<link rel="icon" href="/favicon.png" />\n		<link rel="stylesheet" href="./app.css" />\n		<meta name="viewport" content="width=device-width, initial-scale=1" />\n		' + head + '\n	</head>\n	<body>\n		<div id="svelte">' + body + "</div>\n	</body>\n</html>\n";
var options = null;
var default_settings = { paths: { "base": "", "assets": "" } };
function init(settings2 = default_settings) {
  set_paths(settings2.paths);
  set_prerendering(settings2.prerendering || false);
  const hooks = get_hooks(user_hooks);
  options = {
    amp: false,
    dev: false,
    entry: {
      file: assets + "/_app/start-9f7b1d9b.js",
      css: [assets + "/_app/assets/start-61d1577b.css"],
      js: [assets + "/_app/start-9f7b1d9b.js", assets + "/_app/chunks/vendor-ecad28c9.js"]
    },
    fetched: void 0,
    floc: false,
    get_component_path: (id) => assets + "/_app/" + entry_lookup[id],
    get_stack: (error2) => String(error2),
    handle_error: (error2, request) => {
      hooks.handleError({ error: error2, request });
      error2.stack = options.get_stack(error2);
    },
    hooks,
    hydrate: true,
    initiator: void 0,
    load_component,
    manifest,
    paths: settings2.paths,
    prerender: true,
    read: settings2.read,
    root: Root,
    service_worker: null,
    router: true,
    ssr: true,
    target: "#svelte",
    template,
    trailing_slash: "never"
  };
}
var d = (s2) => s2.replace(/%23/g, "#").replace(/%3[Bb]/g, ";").replace(/%2[Cc]/g, ",").replace(/%2[Ff]/g, "/").replace(/%3[Ff]/g, "?").replace(/%3[Aa]/g, ":").replace(/%40/g, "@").replace(/%26/g, "&").replace(/%3[Dd]/g, "=").replace(/%2[Bb]/g, "+").replace(/%24/g, "$");
var empty = () => ({});
var manifest = {
  assets: [{ "file": "favicon.png", "size": 1571, "type": "image/png" }],
  layout: "src/routes/__layout.svelte",
  error: ".svelte-kit/build/components/error.svelte",
  routes: [
    {
      type: "page",
      pattern: /^\/$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/index.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/dashboard\/?$/,
      params: empty,
      a: ["src/routes/dashboard/__layout.reset.svelte", "src/routes/dashboard/index.svelte"],
      b: []
    },
    {
      type: "page",
      pattern: /^\/dashboard\/all-posts\/?$/,
      params: empty,
      a: ["src/routes/dashboard/__layout.reset.svelte", "src/routes/dashboard/all-posts.svelte"],
      b: []
    },
    {
      type: "page",
      pattern: /^\/dashboard\/resources\/?$/,
      params: empty,
      a: ["src/routes/dashboard/__layout.reset.svelte", "src/routes/dashboard/resources.svelte"],
      b: []
    },
    {
      type: "page",
      pattern: /^\/dashboard\/writepost\/([^/]+?)\/?$/,
      params: (m) => ({ slug: d(m[1]) }),
      a: ["src/routes/dashboard/__layout.reset.svelte", "src/routes/dashboard/writepost/[slug].svelte"],
      b: []
    },
    {
      type: "page",
      pattern: /^\/dashboard\/writepost\/?$/,
      params: empty,
      a: ["src/routes/dashboard/__layout.reset.svelte", "src/routes/dashboard/writepost.svelte"],
      b: []
    },
    {
      type: "page",
      pattern: /^\/dashboard\/settings\/?$/,
      params: empty,
      a: ["src/routes/dashboard/__layout.reset.svelte", "src/routes/dashboard/settings.svelte"],
      b: []
    },
    {
      type: "page",
      pattern: /^\/dashboard\/profile\/?$/,
      params: empty,
      a: ["src/routes/dashboard/__layout.reset.svelte", "src/routes/dashboard/profile.svelte"],
      b: []
    },
    {
      type: "endpoint",
      pattern: /^\/getPosts\/?$/,
      params: empty,
      load: () => Promise.resolve().then(function() {
        return getPosts$2;
      })
    },
    {
      type: "page",
      pattern: /^\/about\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/about.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/login\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/login.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    },
    {
      type: "page",
      pattern: /^\/tags\/?$/,
      params: empty,
      a: ["src/routes/__layout.svelte", "src/routes/tags.svelte"],
      b: [".svelte-kit/build/components/error.svelte"]
    }
  ]
};
var get_hooks = (hooks) => ({
  getSession: hooks.getSession || (() => ({})),
  handle: hooks.handle || (({ request, resolve: resolve2 }) => resolve2(request)),
  handleError: hooks.handleError || (({ error: error2 }) => console.error(error2.stack)),
  externalFetch: hooks.externalFetch || fetch
});
var module_lookup = {
  "src/routes/__layout.svelte": () => Promise.resolve().then(function() {
    return __layout;
  }),
  ".svelte-kit/build/components/error.svelte": () => Promise.resolve().then(function() {
    return error;
  }),
  "src/routes/index.svelte": () => Promise.resolve().then(function() {
    return index$1;
  }),
  "src/routes/dashboard/__layout.reset.svelte": () => Promise.resolve().then(function() {
    return __layout_reset;
  }),
  "src/routes/dashboard/index.svelte": () => Promise.resolve().then(function() {
    return index;
  }),
  "src/routes/dashboard/all-posts.svelte": () => Promise.resolve().then(function() {
    return allPosts;
  }),
  "src/routes/dashboard/resources.svelte": () => Promise.resolve().then(function() {
    return resources;
  }),
  "src/routes/dashboard/writepost/[slug].svelte": () => Promise.resolve().then(function() {
    return _slug_;
  }),
  "src/routes/dashboard/writepost.svelte": () => Promise.resolve().then(function() {
    return writepost;
  }),
  "src/routes/dashboard/settings.svelte": () => Promise.resolve().then(function() {
    return settings;
  }),
  "src/routes/dashboard/profile.svelte": () => Promise.resolve().then(function() {
    return profile;
  }),
  "src/routes/about.svelte": () => Promise.resolve().then(function() {
    return about;
  }),
  "src/routes/login.svelte": () => Promise.resolve().then(function() {
    return login;
  }),
  "src/routes/tags.svelte": () => Promise.resolve().then(function() {
    return tags;
  })
};
var metadata_lookup = { "src/routes/__layout.svelte": { "entry": "pages/__layout.svelte-a6740214.js", "css": ["assets/pages/__layout.svelte-73629816.css"], "js": ["pages/__layout.svelte-a6740214.js", "chunks/vendor-ecad28c9.js", "chunks/authListener-bfc5ab65.js", "chunks/firebase-b7699a84.js", "chunks/profile_picture-0bd2acdc.js", "chunks/firebase.apis-84dd0dfe.js", "chunks/localStorage-cc15a467.js"], "styles": [] }, ".svelte-kit/build/components/error.svelte": { "entry": "error.svelte-2673a66b.js", "css": [], "js": ["error.svelte-2673a66b.js", "chunks/vendor-ecad28c9.js"], "styles": [] }, "src/routes/index.svelte": { "entry": "pages/index.svelte-cae0671c.js", "css": ["assets/pages/index.svelte-1120c8a6.css"], "js": ["pages/index.svelte-cae0671c.js", "chunks/vendor-ecad28c9.js", "chunks/firebase.apis-84dd0dfe.js", "chunks/firebase-b7699a84.js"], "styles": [] }, "src/routes/dashboard/__layout.reset.svelte": { "entry": "pages/dashboard/__layout.reset.svelte-9db017bd.js", "css": [], "js": ["pages/dashboard/__layout.reset.svelte-9db017bd.js", "chunks/vendor-ecad28c9.js", "chunks/authListener-bfc5ab65.js", "chunks/firebase-b7699a84.js"], "styles": [] }, "src/routes/dashboard/index.svelte": { "entry": "pages/dashboard/index.svelte-6b6412bd.js", "css": ["assets/pages/dashboard/index.svelte-3837a45b.css", "assets/dashboard.navbar-b79d810d.css"], "js": ["pages/dashboard/index.svelte-6b6412bd.js", "chunks/vendor-ecad28c9.js", "chunks/dashboard.navbar-91895d2a.js", "chunks/authListener-bfc5ab65.js", "chunks/firebase-b7699a84.js", "chunks/profile_picture-0bd2acdc.js", "chunks/firebase.apis-84dd0dfe.js", "chunks/localStorage-cc15a467.js"], "styles": [] }, "src/routes/dashboard/all-posts.svelte": { "entry": "pages/dashboard/all-posts.svelte-5da2affb.js", "css": ["assets/pages/dashboard/all-posts.svelte-9c45c725.css", "assets/dashboard.navbar-b79d810d.css"], "js": ["pages/dashboard/all-posts.svelte-5da2affb.js", "chunks/vendor-ecad28c9.js", "chunks/firebase.apis-84dd0dfe.js", "chunks/firebase-b7699a84.js", "chunks/dashboard.navbar-91895d2a.js", "chunks/authListener-bfc5ab65.js", "chunks/profile_picture-0bd2acdc.js", "chunks/localStorage-cc15a467.js"], "styles": [] }, "src/routes/dashboard/resources.svelte": { "entry": "pages/dashboard/resources.svelte-76f4422e.js", "css": ["assets/pages/dashboard/settings.svelte-b2568ca7.css", "assets/dashboard.navbar-b79d810d.css"], "js": ["pages/dashboard/resources.svelte-76f4422e.js", "chunks/vendor-ecad28c9.js", "chunks/dashboard.navbar-91895d2a.js", "chunks/authListener-bfc5ab65.js", "chunks/firebase-b7699a84.js", "chunks/profile_picture-0bd2acdc.js", "chunks/firebase.apis-84dd0dfe.js", "chunks/localStorage-cc15a467.js"], "styles": [] }, "src/routes/dashboard/writepost/[slug].svelte": { "entry": "pages/dashboard/writepost/[slug].svelte-2e3dc91c.js", "css": ["assets/pages/dashboard/writepost/[slug].svelte-91306e7e.css", "assets/tags.svelte_svelte&type=style&lang-0831af0c.css", "assets/dashboard.navbar-b79d810d.css"], "js": ["pages/dashboard/writepost/[slug].svelte-2e3dc91c.js", "chunks/vendor-ecad28c9.js", "chunks/dashboard.navbar-91895d2a.js", "chunks/authListener-bfc5ab65.js", "chunks/firebase-b7699a84.js", "chunks/profile_picture-0bd2acdc.js", "chunks/firebase.apis-84dd0dfe.js", "chunks/localStorage-cc15a467.js"], "styles": [] }, "src/routes/dashboard/writepost.svelte": { "entry": "pages/dashboard/writepost.svelte-383cf9d9.js", "css": ["assets/pages/dashboard/writepost.svelte-fe56d384.css", "assets/dashboard.navbar-b79d810d.css"], "js": ["pages/dashboard/writepost.svelte-383cf9d9.js", "chunks/vendor-ecad28c9.js", "chunks/dashboard.navbar-91895d2a.js", "chunks/authListener-bfc5ab65.js", "chunks/firebase-b7699a84.js", "chunks/profile_picture-0bd2acdc.js", "chunks/firebase.apis-84dd0dfe.js", "chunks/localStorage-cc15a467.js"], "styles": [] }, "src/routes/dashboard/settings.svelte": { "entry": "pages/dashboard/settings.svelte-c8326981.js", "css": ["assets/pages/dashboard/settings.svelte-b2568ca7.css", "assets/dashboard.navbar-b79d810d.css"], "js": ["pages/dashboard/settings.svelte-c8326981.js", "chunks/vendor-ecad28c9.js", "chunks/dashboard.navbar-91895d2a.js", "chunks/authListener-bfc5ab65.js", "chunks/firebase-b7699a84.js", "chunks/profile_picture-0bd2acdc.js", "chunks/firebase.apis-84dd0dfe.js", "chunks/localStorage-cc15a467.js"], "styles": [] }, "src/routes/dashboard/profile.svelte": { "entry": "pages/dashboard/profile.svelte-ceece636.js", "css": ["assets/pages/dashboard/settings.svelte-b2568ca7.css", "assets/dashboard.navbar-b79d810d.css"], "js": ["pages/dashboard/profile.svelte-ceece636.js", "chunks/vendor-ecad28c9.js", "chunks/dashboard.navbar-91895d2a.js", "chunks/authListener-bfc5ab65.js", "chunks/firebase-b7699a84.js", "chunks/profile_picture-0bd2acdc.js", "chunks/firebase.apis-84dd0dfe.js", "chunks/localStorage-cc15a467.js"], "styles": [] }, "src/routes/about.svelte": { "entry": "pages/about.svelte-227dba01.js", "css": ["assets/pages/about.svelte-44f12770.css"], "js": ["pages/about.svelte-227dba01.js", "chunks/vendor-ecad28c9.js", "chunks/profile_picture-0bd2acdc.js"], "styles": [] }, "src/routes/login.svelte": { "entry": "pages/login.svelte-1c4e05d5.js", "css": ["assets/pages/login.svelte-088009b3.css"], "js": ["pages/login.svelte-1c4e05d5.js", "chunks/vendor-ecad28c9.js", "chunks/authListener-bfc5ab65.js", "chunks/firebase-b7699a84.js", "chunks/localStorage-cc15a467.js", "chunks/firebase.apis-84dd0dfe.js"], "styles": [] }, "src/routes/tags.svelte": { "entry": "pages/tags.svelte-32cc255a.js", "css": ["assets/tags.svelte_svelte&type=style&lang-0831af0c.css"], "js": ["pages/tags.svelte-32cc255a.js", "chunks/vendor-ecad28c9.js"], "styles": [] } };
async function load_component(file) {
  const { entry, css: css2, js, styles } = metadata_lookup[file];
  return {
    module: await module_lookup[file](),
    entry: assets + "/_app/" + entry,
    css: css2.map((dep) => assets + "/_app/" + dep),
    js: js.map((dep) => assets + "/_app/" + dep),
    styles
  };
}
function render(request, {
  prerender
} = {}) {
  const host = request.headers["host"];
  return respond({ ...request, host }, options, { prerender });
}
var stringToByteArray$1 = function(str) {
  const out = [];
  let p = 0;
  for (let i = 0; i < str.length; i++) {
    let c = str.charCodeAt(i);
    if (c < 128) {
      out[p++] = c;
    } else if (c < 2048) {
      out[p++] = c >> 6 | 192;
      out[p++] = c & 63 | 128;
    } else if ((c & 64512) === 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) === 56320) {
      c = 65536 + ((c & 1023) << 10) + (str.charCodeAt(++i) & 1023);
      out[p++] = c >> 18 | 240;
      out[p++] = c >> 12 & 63 | 128;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    } else {
      out[p++] = c >> 12 | 224;
      out[p++] = c >> 6 & 63 | 128;
      out[p++] = c & 63 | 128;
    }
  }
  return out;
};
var byteArrayToString = function(bytes) {
  const out = [];
  let pos = 0, c = 0;
  while (pos < bytes.length) {
    const c1 = bytes[pos++];
    if (c1 < 128) {
      out[c++] = String.fromCharCode(c1);
    } else if (c1 > 191 && c1 < 224) {
      const c2 = bytes[pos++];
      out[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);
    } else if (c1 > 239 && c1 < 365) {
      const c2 = bytes[pos++];
      const c3 = bytes[pos++];
      const c4 = bytes[pos++];
      const u = ((c1 & 7) << 18 | (c2 & 63) << 12 | (c3 & 63) << 6 | c4 & 63) - 65536;
      out[c++] = String.fromCharCode(55296 + (u >> 10));
      out[c++] = String.fromCharCode(56320 + (u & 1023));
    } else {
      const c2 = bytes[pos++];
      const c3 = bytes[pos++];
      out[c++] = String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
    }
  }
  return out.join("");
};
var base64 = {
  byteToCharMap_: null,
  charToByteMap_: null,
  byteToCharMapWebSafe_: null,
  charToByteMapWebSafe_: null,
  ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
  get ENCODED_VALS() {
    return this.ENCODED_VALS_BASE + "+/=";
  },
  get ENCODED_VALS_WEBSAFE() {
    return this.ENCODED_VALS_BASE + "-_.";
  },
  HAS_NATIVE_SUPPORT: typeof atob === "function",
  encodeByteArray(input, webSafe) {
    if (!Array.isArray(input)) {
      throw Error("encodeByteArray takes an array as a parameter");
    }
    this.init_();
    const byteToCharMap = webSafe ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;
    const output = [];
    for (let i = 0; i < input.length; i += 3) {
      const byte1 = input[i];
      const haveByte2 = i + 1 < input.length;
      const byte2 = haveByte2 ? input[i + 1] : 0;
      const haveByte3 = i + 2 < input.length;
      const byte3 = haveByte3 ? input[i + 2] : 0;
      const outByte1 = byte1 >> 2;
      const outByte2 = (byte1 & 3) << 4 | byte2 >> 4;
      let outByte3 = (byte2 & 15) << 2 | byte3 >> 6;
      let outByte4 = byte3 & 63;
      if (!haveByte3) {
        outByte4 = 64;
        if (!haveByte2) {
          outByte3 = 64;
        }
      }
      output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);
    }
    return output.join("");
  },
  encodeString(input, webSafe) {
    if (this.HAS_NATIVE_SUPPORT && !webSafe) {
      return btoa(input);
    }
    return this.encodeByteArray(stringToByteArray$1(input), webSafe);
  },
  decodeString(input, webSafe) {
    if (this.HAS_NATIVE_SUPPORT && !webSafe) {
      return atob(input);
    }
    return byteArrayToString(this.decodeStringToByteArray(input, webSafe));
  },
  decodeStringToByteArray(input, webSafe) {
    this.init_();
    const charToByteMap = webSafe ? this.charToByteMapWebSafe_ : this.charToByteMap_;
    const output = [];
    for (let i = 0; i < input.length; ) {
      const byte1 = charToByteMap[input.charAt(i++)];
      const haveByte2 = i < input.length;
      const byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;
      ++i;
      const haveByte3 = i < input.length;
      const byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;
      ++i;
      const haveByte4 = i < input.length;
      const byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;
      ++i;
      if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {
        throw Error();
      }
      const outByte1 = byte1 << 2 | byte2 >> 4;
      output.push(outByte1);
      if (byte3 !== 64) {
        const outByte2 = byte2 << 4 & 240 | byte3 >> 2;
        output.push(outByte2);
        if (byte4 !== 64) {
          const outByte3 = byte3 << 6 & 192 | byte4;
          output.push(outByte3);
        }
      }
    }
    return output;
  },
  init_() {
    if (!this.byteToCharMap_) {
      this.byteToCharMap_ = {};
      this.charToByteMap_ = {};
      this.byteToCharMapWebSafe_ = {};
      this.charToByteMapWebSafe_ = {};
      for (let i = 0; i < this.ENCODED_VALS.length; i++) {
        this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);
        this.charToByteMap_[this.byteToCharMap_[i]] = i;
        this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);
        this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;
        if (i >= this.ENCODED_VALS_BASE.length) {
          this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;
          this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;
        }
      }
    }
  }
};
var base64Decode = function(str) {
  try {
    return base64.decodeString(str, true);
  } catch (e) {
    console.error("base64Decode failed: ", e);
  }
  return null;
};
var Deferred = class {
  constructor() {
    this.reject = () => {
    };
    this.resolve = () => {
    };
    this.promise = new Promise((resolve2, reject) => {
      this.resolve = resolve2;
      this.reject = reject;
    });
  }
  wrapCallback(callback) {
    return (error2, value) => {
      if (error2) {
        this.reject(error2);
      } else {
        this.resolve(value);
      }
      if (typeof callback === "function") {
        this.promise.catch(() => {
        });
        if (callback.length === 1) {
          callback(error2);
        } else {
          callback(error2, value);
        }
      }
    };
  }
};
function getUA() {
  if (typeof navigator !== "undefined" && typeof navigator["userAgent"] === "string") {
    return navigator["userAgent"];
  } else {
    return "";
  }
}
function isMobileCordova() {
  return typeof window !== "undefined" && !!(window["cordova"] || window["phonegap"] || window["PhoneGap"]) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA());
}
function isBrowserExtension() {
  const runtime = typeof chrome === "object" ? chrome.runtime : typeof browser === "object" ? browser.runtime : void 0;
  return typeof runtime === "object" && runtime.id !== void 0;
}
function isReactNative() {
  return typeof navigator === "object" && navigator["product"] === "ReactNative";
}
function isIE() {
  const ua = getUA();
  return ua.indexOf("MSIE ") >= 0 || ua.indexOf("Trident/") >= 0;
}
function isIndexedDBAvailable() {
  return typeof indexedDB === "object";
}
function validateIndexedDBOpenable() {
  return new Promise((resolve2, reject) => {
    try {
      let preExist = true;
      const DB_CHECK_NAME = "validate-browser-context-for-indexeddb-analytics-module";
      const request = self.indexedDB.open(DB_CHECK_NAME);
      request.onsuccess = () => {
        request.result.close();
        if (!preExist) {
          self.indexedDB.deleteDatabase(DB_CHECK_NAME);
        }
        resolve2(true);
      };
      request.onupgradeneeded = () => {
        preExist = false;
      };
      request.onerror = () => {
        var _a;
        reject(((_a = request.error) === null || _a === void 0 ? void 0 : _a.message) || "");
      };
    } catch (error2) {
      reject(error2);
    }
  });
}
function areCookiesEnabled() {
  if (typeof navigator === "undefined" || !navigator.cookieEnabled) {
    return false;
  }
  return true;
}
var ERROR_NAME = "FirebaseError";
var FirebaseError = class extends Error {
  constructor(code, message, customData) {
    super(message);
    this.code = code;
    this.customData = customData;
    this.name = ERROR_NAME;
    Object.setPrototypeOf(this, FirebaseError.prototype);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ErrorFactory.prototype.create);
    }
  }
};
var ErrorFactory = class {
  constructor(service, serviceName, errors) {
    this.service = service;
    this.serviceName = serviceName;
    this.errors = errors;
  }
  create(code, ...data) {
    const customData = data[0] || {};
    const fullCode = `${this.service}/${code}`;
    const template2 = this.errors[code];
    const message = template2 ? replaceTemplate(template2, customData) : "Error";
    const fullMessage = `${this.serviceName}: ${message} (${fullCode}).`;
    const error2 = new FirebaseError(fullCode, fullMessage, customData);
    return error2;
  }
};
function replaceTemplate(template2, data) {
  return template2.replace(PATTERN, (_, key) => {
    const value = data[key];
    return value != null ? String(value) : `<${key}?>`;
  });
}
var PATTERN = /\{\$([^}]+)}/g;
function isEmpty(obj) {
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      return false;
    }
  }
  return true;
}
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  const aKeys = Object.keys(a);
  const bKeys = Object.keys(b);
  for (const k of aKeys) {
    if (!bKeys.includes(k)) {
      return false;
    }
    const aProp = a[k];
    const bProp = b[k];
    if (isObject(aProp) && isObject(bProp)) {
      if (!deepEqual(aProp, bProp)) {
        return false;
      }
    } else if (aProp !== bProp) {
      return false;
    }
  }
  for (const k of bKeys) {
    if (!aKeys.includes(k)) {
      return false;
    }
  }
  return true;
}
function isObject(thing) {
  return thing !== null && typeof thing === "object";
}
function querystring(querystringParams) {
  const params = [];
  for (const [key, value] of Object.entries(querystringParams)) {
    if (Array.isArray(value)) {
      value.forEach((arrayVal) => {
        params.push(encodeURIComponent(key) + "=" + encodeURIComponent(arrayVal));
      });
    } else {
      params.push(encodeURIComponent(key) + "=" + encodeURIComponent(value));
    }
  }
  return params.length ? "&" + params.join("&") : "";
}
function createSubscribe(executor, onNoObservers) {
  const proxy = new ObserverProxy(executor, onNoObservers);
  return proxy.subscribe.bind(proxy);
}
var ObserverProxy = class {
  constructor(executor, onNoObservers) {
    this.observers = [];
    this.unsubscribes = [];
    this.observerCount = 0;
    this.task = Promise.resolve();
    this.finalized = false;
    this.onNoObservers = onNoObservers;
    this.task.then(() => {
      executor(this);
    }).catch((e) => {
      this.error(e);
    });
  }
  next(value) {
    this.forEachObserver((observer) => {
      observer.next(value);
    });
  }
  error(error2) {
    this.forEachObserver((observer) => {
      observer.error(error2);
    });
    this.close(error2);
  }
  complete() {
    this.forEachObserver((observer) => {
      observer.complete();
    });
    this.close();
  }
  subscribe(nextOrObserver, error2, complete) {
    let observer;
    if (nextOrObserver === void 0 && error2 === void 0 && complete === void 0) {
      throw new Error("Missing Observer.");
    }
    if (implementsAnyMethods(nextOrObserver, [
      "next",
      "error",
      "complete"
    ])) {
      observer = nextOrObserver;
    } else {
      observer = {
        next: nextOrObserver,
        error: error2,
        complete
      };
    }
    if (observer.next === void 0) {
      observer.next = noop;
    }
    if (observer.error === void 0) {
      observer.error = noop;
    }
    if (observer.complete === void 0) {
      observer.complete = noop;
    }
    const unsub = this.unsubscribeOne.bind(this, this.observers.length);
    if (this.finalized) {
      this.task.then(() => {
        try {
          if (this.finalError) {
            observer.error(this.finalError);
          } else {
            observer.complete();
          }
        } catch (e) {
        }
        return;
      });
    }
    this.observers.push(observer);
    return unsub;
  }
  unsubscribeOne(i) {
    if (this.observers === void 0 || this.observers[i] === void 0) {
      return;
    }
    delete this.observers[i];
    this.observerCount -= 1;
    if (this.observerCount === 0 && this.onNoObservers !== void 0) {
      this.onNoObservers(this);
    }
  }
  forEachObserver(fn) {
    if (this.finalized) {
      return;
    }
    for (let i = 0; i < this.observers.length; i++) {
      this.sendOne(i, fn);
    }
  }
  sendOne(i, fn) {
    this.task.then(() => {
      if (this.observers !== void 0 && this.observers[i] !== void 0) {
        try {
          fn(this.observers[i]);
        } catch (e) {
          if (typeof console !== "undefined" && console.error) {
            console.error(e);
          }
        }
      }
    });
  }
  close(err) {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    if (err !== void 0) {
      this.finalError = err;
    }
    this.task.then(() => {
      this.observers = void 0;
      this.onNoObservers = void 0;
    });
  }
};
function implementsAnyMethods(obj, methods) {
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  for (const method of methods) {
    if (method in obj && typeof obj[method] === "function") {
      return true;
    }
  }
  return false;
}
function noop() {
}
var DEFAULT_INTERVAL_MILLIS = 1e3;
var DEFAULT_BACKOFF_FACTOR = 2;
var MAX_VALUE_MILLIS = 4 * 60 * 60 * 1e3;
var RANDOM_FACTOR = 0.5;
function calculateBackoffMillis(backoffCount, intervalMillis = DEFAULT_INTERVAL_MILLIS, backoffFactor = DEFAULT_BACKOFF_FACTOR) {
  const currBaseValue = intervalMillis * Math.pow(backoffFactor, backoffCount);
  const randomWait = Math.round(RANDOM_FACTOR * currBaseValue * (Math.random() - 0.5) * 2);
  return Math.min(MAX_VALUE_MILLIS, currBaseValue + randomWait);
}
function getModularInstance(service) {
  if (service && service._delegate) {
    return service._delegate;
  } else {
    return service;
  }
}
var Component = function() {
  function Component2(name2, instanceFactory, type) {
    this.name = name2;
    this.instanceFactory = instanceFactory;
    this.type = type;
    this.multipleInstances = false;
    this.serviceProps = {};
    this.instantiationMode = "LAZY";
    this.onInstanceCreated = null;
  }
  Component2.prototype.setInstantiationMode = function(mode) {
    this.instantiationMode = mode;
    return this;
  };
  Component2.prototype.setMultipleInstances = function(multipleInstances) {
    this.multipleInstances = multipleInstances;
    return this;
  };
  Component2.prototype.setServiceProps = function(props) {
    this.serviceProps = props;
    return this;
  };
  Component2.prototype.setInstanceCreatedCallback = function(callback) {
    this.onInstanceCreated = callback;
    return this;
  };
  return Component2;
}();
var DEFAULT_ENTRY_NAME$1 = "[DEFAULT]";
var Provider = function() {
  function Provider2(name2, container) {
    this.name = name2;
    this.container = container;
    this.component = null;
    this.instances = new Map();
    this.instancesDeferred = new Map();
    this.instancesOptions = new Map();
    this.onInitCallbacks = new Map();
  }
  Provider2.prototype.get = function(identifier) {
    var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
    if (!this.instancesDeferred.has(normalizedIdentifier)) {
      var deferred = new Deferred();
      this.instancesDeferred.set(normalizedIdentifier, deferred);
      if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {
        try {
          var instance = this.getOrInitializeService({
            instanceIdentifier: normalizedIdentifier
          });
          if (instance) {
            deferred.resolve(instance);
          }
        } catch (e) {
        }
      }
    }
    return this.instancesDeferred.get(normalizedIdentifier).promise;
  };
  Provider2.prototype.getImmediate = function(options2) {
    var _a;
    var normalizedIdentifier = this.normalizeInstanceIdentifier(options2 === null || options2 === void 0 ? void 0 : options2.identifier);
    var optional = (_a = options2 === null || options2 === void 0 ? void 0 : options2.optional) !== null && _a !== void 0 ? _a : false;
    if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {
      try {
        return this.getOrInitializeService({
          instanceIdentifier: normalizedIdentifier
        });
      } catch (e) {
        if (optional) {
          return null;
        } else {
          throw e;
        }
      }
    } else {
      if (optional) {
        return null;
      } else {
        throw Error("Service " + this.name + " is not available");
      }
    }
  };
  Provider2.prototype.getComponent = function() {
    return this.component;
  };
  Provider2.prototype.setComponent = function(component) {
    var e_1, _a;
    if (component.name !== this.name) {
      throw Error("Mismatching Component " + component.name + " for Provider " + this.name + ".");
    }
    if (this.component) {
      throw Error("Component for " + this.name + " has already been provided");
    }
    this.component = component;
    if (!this.shouldAutoInitialize()) {
      return;
    }
    if (isComponentEager(component)) {
      try {
        this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME$1 });
      } catch (e) {
      }
    }
    try {
      for (var _b = __values(this.instancesDeferred.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
        var _d = __read(_c.value, 2), instanceIdentifier = _d[0], instanceDeferred = _d[1];
        var normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
        try {
          var instance = this.getOrInitializeService({
            instanceIdentifier: normalizedIdentifier
          });
          instanceDeferred.resolve(instance);
        } catch (e) {
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return))
          _a.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  };
  Provider2.prototype.clearInstance = function(identifier) {
    if (identifier === void 0) {
      identifier = DEFAULT_ENTRY_NAME$1;
    }
    this.instancesDeferred.delete(identifier);
    this.instancesOptions.delete(identifier);
    this.instances.delete(identifier);
  };
  Provider2.prototype.delete = function() {
    return __awaiter(this, void 0, void 0, function() {
      var services;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            services = Array.from(this.instances.values());
            return [4, Promise.all(__spreadArray(__spreadArray([], __read(services.filter(function(service) {
              return "INTERNAL" in service;
            }).map(function(service) {
              return service.INTERNAL.delete();
            }))), __read(services.filter(function(service) {
              return "_delete" in service;
            }).map(function(service) {
              return service._delete();
            }))))];
          case 1:
            _a.sent();
            return [2];
        }
      });
    });
  };
  Provider2.prototype.isComponentSet = function() {
    return this.component != null;
  };
  Provider2.prototype.isInitialized = function(identifier) {
    if (identifier === void 0) {
      identifier = DEFAULT_ENTRY_NAME$1;
    }
    return this.instances.has(identifier);
  };
  Provider2.prototype.getOptions = function(identifier) {
    if (identifier === void 0) {
      identifier = DEFAULT_ENTRY_NAME$1;
    }
    return this.instancesOptions.get(identifier) || {};
  };
  Provider2.prototype.initialize = function(opts) {
    var e_2, _a;
    if (opts === void 0) {
      opts = {};
    }
    var _b = opts.options, options2 = _b === void 0 ? {} : _b;
    var normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);
    if (this.isInitialized(normalizedIdentifier)) {
      throw Error(this.name + "(" + normalizedIdentifier + ") has already been initialized");
    }
    if (!this.isComponentSet()) {
      throw Error("Component " + this.name + " has not been registered yet");
    }
    var instance = this.getOrInitializeService({
      instanceIdentifier: normalizedIdentifier,
      options: options2
    });
    try {
      for (var _c = __values(this.instancesDeferred.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {
        var _e = __read(_d.value, 2), instanceIdentifier = _e[0], instanceDeferred = _e[1];
        var normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
        if (normalizedIdentifier === normalizedDeferredIdentifier) {
          instanceDeferred.resolve(instance);
        }
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        if (_d && !_d.done && (_a = _c.return))
          _a.call(_c);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    return instance;
  };
  Provider2.prototype.onInit = function(callback, identifier) {
    var _a;
    var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
    var existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();
    existingCallbacks.add(callback);
    this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);
    var existingInstance = this.instances.get(normalizedIdentifier);
    if (existingInstance) {
      callback(existingInstance, normalizedIdentifier);
    }
    return function() {
      existingCallbacks.delete(callback);
    };
  };
  Provider2.prototype.invokeOnInitCallbacks = function(instance, identifier) {
    var e_3, _a;
    var callbacks = this.onInitCallbacks.get(identifier);
    if (!callbacks) {
      return;
    }
    try {
      for (var callbacks_1 = __values(callbacks), callbacks_1_1 = callbacks_1.next(); !callbacks_1_1.done; callbacks_1_1 = callbacks_1.next()) {
        var callback = callbacks_1_1.value;
        try {
          callback(instance, identifier);
        } catch (_b) {
        }
      }
    } catch (e_3_1) {
      e_3 = { error: e_3_1 };
    } finally {
      try {
        if (callbacks_1_1 && !callbacks_1_1.done && (_a = callbacks_1.return))
          _a.call(callbacks_1);
      } finally {
        if (e_3)
          throw e_3.error;
      }
    }
  };
  Provider2.prototype.getOrInitializeService = function(_a) {
    var instanceIdentifier = _a.instanceIdentifier, _b = _a.options, options2 = _b === void 0 ? {} : _b;
    var instance = this.instances.get(instanceIdentifier);
    if (!instance && this.component) {
      instance = this.component.instanceFactory(this.container, {
        instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),
        options: options2
      });
      this.instances.set(instanceIdentifier, instance);
      this.instancesOptions.set(instanceIdentifier, options2);
      this.invokeOnInitCallbacks(instance, instanceIdentifier);
      if (this.component.onInstanceCreated) {
        try {
          this.component.onInstanceCreated(this.container, instanceIdentifier, instance);
        } catch (_c) {
        }
      }
    }
    return instance || null;
  };
  Provider2.prototype.normalizeInstanceIdentifier = function(identifier) {
    if (identifier === void 0) {
      identifier = DEFAULT_ENTRY_NAME$1;
    }
    if (this.component) {
      return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME$1;
    } else {
      return identifier;
    }
  };
  Provider2.prototype.shouldAutoInitialize = function() {
    return !!this.component && this.component.instantiationMode !== "EXPLICIT";
  };
  return Provider2;
}();
function normalizeIdentifierForFactory(identifier) {
  return identifier === DEFAULT_ENTRY_NAME$1 ? void 0 : identifier;
}
function isComponentEager(component) {
  return component.instantiationMode === "EAGER";
}
var ComponentContainer = function() {
  function ComponentContainer2(name2) {
    this.name = name2;
    this.providers = new Map();
  }
  ComponentContainer2.prototype.addComponent = function(component) {
    var provider = this.getProvider(component.name);
    if (provider.isComponentSet()) {
      throw new Error("Component " + component.name + " has already been registered with " + this.name);
    }
    provider.setComponent(component);
  };
  ComponentContainer2.prototype.addOrOverwriteComponent = function(component) {
    var provider = this.getProvider(component.name);
    if (provider.isComponentSet()) {
      this.providers.delete(component.name);
    }
    this.addComponent(component);
  };
  ComponentContainer2.prototype.getProvider = function(name2) {
    if (this.providers.has(name2)) {
      return this.providers.get(name2);
    }
    var provider = new Provider(name2, this);
    this.providers.set(name2, provider);
    return provider;
  };
  ComponentContainer2.prototype.getProviders = function() {
    return Array.from(this.providers.values());
  };
  return ComponentContainer2;
}();
var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
  LogLevel2[LogLevel2["VERBOSE"] = 1] = "VERBOSE";
  LogLevel2[LogLevel2["INFO"] = 2] = "INFO";
  LogLevel2[LogLevel2["WARN"] = 3] = "WARN";
  LogLevel2[LogLevel2["ERROR"] = 4] = "ERROR";
  LogLevel2[LogLevel2["SILENT"] = 5] = "SILENT";
})(LogLevel || (LogLevel = {}));
var levelStringToEnum = {
  "debug": LogLevel.DEBUG,
  "verbose": LogLevel.VERBOSE,
  "info": LogLevel.INFO,
  "warn": LogLevel.WARN,
  "error": LogLevel.ERROR,
  "silent": LogLevel.SILENT
};
var defaultLogLevel = LogLevel.INFO;
var ConsoleMethod = {
  [LogLevel.DEBUG]: "log",
  [LogLevel.VERBOSE]: "log",
  [LogLevel.INFO]: "info",
  [LogLevel.WARN]: "warn",
  [LogLevel.ERROR]: "error"
};
var defaultLogHandler = (instance, logType, ...args) => {
  if (logType < instance.logLevel) {
    return;
  }
  const now = new Date().toISOString();
  const method = ConsoleMethod[logType];
  if (method) {
    console[method](`[${now}]  ${instance.name}:`, ...args);
  } else {
    throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`);
  }
};
var Logger = class {
  constructor(name2) {
    this.name = name2;
    this._logLevel = defaultLogLevel;
    this._logHandler = defaultLogHandler;
    this._userLogHandler = null;
  }
  get logLevel() {
    return this._logLevel;
  }
  set logLevel(val) {
    if (!(val in LogLevel)) {
      throw new TypeError(`Invalid value "${val}" assigned to \`logLevel\``);
    }
    this._logLevel = val;
  }
  setLogLevel(val) {
    this._logLevel = typeof val === "string" ? levelStringToEnum[val] : val;
  }
  get logHandler() {
    return this._logHandler;
  }
  set logHandler(val) {
    if (typeof val !== "function") {
      throw new TypeError("Value assigned to `logHandler` must be a function");
    }
    this._logHandler = val;
  }
  get userLogHandler() {
    return this._userLogHandler;
  }
  set userLogHandler(val) {
    this._userLogHandler = val;
  }
  debug(...args) {
    this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...args);
    this._logHandler(this, LogLevel.DEBUG, ...args);
  }
  log(...args) {
    this._userLogHandler && this._userLogHandler(this, LogLevel.VERBOSE, ...args);
    this._logHandler(this, LogLevel.VERBOSE, ...args);
  }
  info(...args) {
    this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...args);
    this._logHandler(this, LogLevel.INFO, ...args);
  }
  warn(...args) {
    this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...args);
    this._logHandler(this, LogLevel.WARN, ...args);
  }
  error(...args) {
    this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...args);
    this._logHandler(this, LogLevel.ERROR, ...args);
  }
};
var PlatformLoggerServiceImpl = class {
  constructor(container) {
    this.container = container;
  }
  getPlatformInfoString() {
    const providers = this.container.getProviders();
    return providers.map((provider) => {
      if (isVersionServiceProvider(provider)) {
        const service = provider.getImmediate();
        return `${service.library}/${service.version}`;
      } else {
        return null;
      }
    }).filter((logString) => logString).join(" ");
  }
};
function isVersionServiceProvider(provider) {
  const component = provider.getComponent();
  return (component === null || component === void 0 ? void 0 : component.type) === "VERSION";
}
var name$o = "@firebase/app";
var version$1$1 = "0.7.3";
var logger$1 = new Logger("@firebase/app");
var name$n = "@firebase/app-compat";
var name$m = "@firebase/analytics-compat";
var name$l = "@firebase/analytics";
var name$k = "@firebase/app-check-compat";
var name$j = "@firebase/app-check";
var name$i = "@firebase/auth";
var name$h = "@firebase/auth-compat";
var name$g = "@firebase/database";
var name$f = "@firebase/database-compat";
var name$e = "@firebase/functions";
var name$d = "@firebase/functions-compat";
var name$c = "@firebase/installations";
var name$b = "@firebase/installations-compat";
var name$a = "@firebase/messaging";
var name$9 = "@firebase/messaging-compat";
var name$8 = "@firebase/performance";
var name$7 = "@firebase/performance-compat";
var name$6 = "@firebase/remote-config";
var name$5 = "@firebase/remote-config-compat";
var name$4$1 = "@firebase/storage";
var name$3$1 = "@firebase/storage-compat";
var name$2$1 = "@firebase/firestore";
var name$1$1 = "@firebase/firestore-compat";
var name$p = "firebase";
var version$5 = "9.1.2";
var DEFAULT_ENTRY_NAME = "[DEFAULT]";
var PLATFORM_LOG_STRING = {
  [name$o]: "fire-core",
  [name$n]: "fire-core-compat",
  [name$l]: "fire-analytics",
  [name$m]: "fire-analytics-compat",
  [name$j]: "fire-app-check",
  [name$k]: "fire-app-check-compat",
  [name$i]: "fire-auth",
  [name$h]: "fire-auth-compat",
  [name$g]: "fire-rtdb",
  [name$f]: "fire-rtdb-compat",
  [name$e]: "fire-fn",
  [name$d]: "fire-fn-compat",
  [name$c]: "fire-iid",
  [name$b]: "fire-iid-compat",
  [name$a]: "fire-fcm",
  [name$9]: "fire-fcm-compat",
  [name$8]: "fire-perf",
  [name$7]: "fire-perf-compat",
  [name$6]: "fire-rc",
  [name$5]: "fire-rc-compat",
  [name$4$1]: "fire-gcs",
  [name$3$1]: "fire-gcs-compat",
  [name$2$1]: "fire-fst",
  [name$1$1]: "fire-fst-compat",
  "fire-js": "fire-js",
  [name$p]: "fire-js-all"
};
var _apps = new Map();
var _components = new Map();
function _addComponent(app, component) {
  try {
    app.container.addComponent(component);
  } catch (e) {
    logger$1.debug(`Component ${component.name} failed to register with FirebaseApp ${app.name}`, e);
  }
}
function _registerComponent(component) {
  const componentName = component.name;
  if (_components.has(componentName)) {
    logger$1.debug(`There were multiple attempts to register component ${componentName}.`);
    return false;
  }
  _components.set(componentName, component);
  for (const app of _apps.values()) {
    _addComponent(app, component);
  }
  return true;
}
function _getProvider(app, name2) {
  return app.container.getProvider(name2);
}
var ERRORS$1 = {
  ["no-app"]: "No Firebase App '{$appName}' has been created - call Firebase App.initializeApp()",
  ["bad-app-name"]: "Illegal App name: '{$appName}",
  ["duplicate-app"]: "Firebase App named '{$appName}' already exists with different options or config",
  ["app-deleted"]: "Firebase App named '{$appName}' already deleted",
  ["invalid-app-argument"]: "firebase.{$appName}() takes either no argument or a Firebase App instance.",
  ["invalid-log-argument"]: "First argument to `onLog` must be null or a function."
};
var ERROR_FACTORY$2 = new ErrorFactory("app", "Firebase", ERRORS$1);
var FirebaseAppImpl = class {
  constructor(options2, config2, container) {
    this._isDeleted = false;
    this._options = Object.assign({}, options2);
    this._config = Object.assign({}, config2);
    this._name = config2.name;
    this._automaticDataCollectionEnabled = config2.automaticDataCollectionEnabled;
    this._container = container;
    this.container.addComponent(new Component("app", () => this, "PUBLIC"));
  }
  get automaticDataCollectionEnabled() {
    this.checkDestroyed();
    return this._automaticDataCollectionEnabled;
  }
  set automaticDataCollectionEnabled(val) {
    this.checkDestroyed();
    this._automaticDataCollectionEnabled = val;
  }
  get name() {
    this.checkDestroyed();
    return this._name;
  }
  get options() {
    this.checkDestroyed();
    return this._options;
  }
  get config() {
    this.checkDestroyed();
    return this._config;
  }
  get container() {
    return this._container;
  }
  get isDeleted() {
    return this._isDeleted;
  }
  set isDeleted(val) {
    this._isDeleted = val;
  }
  checkDestroyed() {
    if (this.isDeleted) {
      throw ERROR_FACTORY$2.create("app-deleted", { appName: this._name });
    }
  }
};
var SDK_VERSION = version$5;
function initializeApp(options2, rawConfig = {}) {
  if (typeof rawConfig !== "object") {
    const name3 = rawConfig;
    rawConfig = { name: name3 };
  }
  const config2 = Object.assign({ name: DEFAULT_ENTRY_NAME, automaticDataCollectionEnabled: false }, rawConfig);
  const name2 = config2.name;
  if (typeof name2 !== "string" || !name2) {
    throw ERROR_FACTORY$2.create("bad-app-name", {
      appName: String(name2)
    });
  }
  const existingApp = _apps.get(name2);
  if (existingApp) {
    if (deepEqual(options2, existingApp.options) && deepEqual(config2, existingApp.config)) {
      return existingApp;
    } else {
      throw ERROR_FACTORY$2.create("duplicate-app", { appName: name2 });
    }
  }
  const container = new ComponentContainer(name2);
  for (const component of _components.values()) {
    container.addComponent(component);
  }
  const newApp = new FirebaseAppImpl(options2, config2, container);
  _apps.set(name2, newApp);
  return newApp;
}
function getApp(name2 = DEFAULT_ENTRY_NAME) {
  const app = _apps.get(name2);
  if (!app) {
    throw ERROR_FACTORY$2.create("no-app", { appName: name2 });
  }
  return app;
}
function registerVersion(libraryKeyOrName, version2, variant) {
  var _a;
  let library = (_a = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a !== void 0 ? _a : libraryKeyOrName;
  if (variant) {
    library += `-${variant}`;
  }
  const libraryMismatch = library.match(/\s|\//);
  const versionMismatch = version2.match(/\s|\//);
  if (libraryMismatch || versionMismatch) {
    const warning = [
      `Unable to register library "${library}" with version "${version2}":`
    ];
    if (libraryMismatch) {
      warning.push(`library name "${library}" contains illegal characters (whitespace or "/")`);
    }
    if (libraryMismatch && versionMismatch) {
      warning.push("and");
    }
    if (versionMismatch) {
      warning.push(`version name "${version2}" contains illegal characters (whitespace or "/")`);
    }
    logger$1.warn(warning.join(" "));
    return;
  }
  _registerComponent(new Component(`${library}-version`, () => ({ library, version: version2 }), "VERSION"));
}
function registerCoreComponents(variant) {
  _registerComponent(new Component("platform-logger", (container) => new PlatformLoggerServiceImpl(container), "PRIVATE"));
  registerVersion(name$o, version$1$1, variant);
  registerVersion("fire-js", "");
}
registerCoreComponents();
var name$4 = "firebase";
var version$4 = "9.1.2";
registerVersion(name$4, version$4, "app");
var config = {
  apiKey: "AIzaSyBnhgdczxRfn9aCH0NJz0tzI1aOnR_E-Dw",
  authDomain: "my-blog-a3adb.firebaseapp.com",
  projectId: "my-blog-a3adb",
  storageBucket: "my-blog-a3adb.appspot.com",
  messagingSenderId: "537552324296",
  appId: "1:537552324296:web:88caa00997d01d1e8d07fd",
  measurementId: "G-HGF1L6M6GC"
};
initializeApp(config);
var db$1 = (0, import_firestore.getFirestore)();
async function getPosts$1() {
  const querySnapshot = await (0, import_firestore.getDocs)((0, import_firestore.collection)(db$1, "posts"));
  console.log(querySnapshot, "query");
  return querySnapshot;
}
var getPosts$2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  getPosts: getPosts$1
});
function _prodErrorMap() {
  return {
    ["dependent-sdk-initialized-before-auth"]: "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK."
  };
}
var prodErrorMap = _prodErrorMap;
var _DEFAULT_AUTH_ERROR_FACTORY = new ErrorFactory("auth", "Firebase", _prodErrorMap());
var logClient = new Logger("@firebase/auth");
function _logError(msg, ...args) {
  if (logClient.logLevel <= LogLevel.ERROR) {
    logClient.error(`Auth (${SDK_VERSION}): ${msg}`, ...args);
  }
}
function _fail(authOrCode, ...rest) {
  throw createErrorInternal(authOrCode, ...rest);
}
function _createError(authOrCode, ...rest) {
  return createErrorInternal(authOrCode, ...rest);
}
function _errorWithCustomMessage(auth2, code, message) {
  const errorMap = Object.assign(Object.assign({}, prodErrorMap()), { [code]: message });
  const factory2 = new ErrorFactory("auth", "Firebase", errorMap);
  return factory2.create(code, {
    appName: auth2.name
  });
}
function createErrorInternal(authOrCode, ...rest) {
  if (typeof authOrCode !== "string") {
    const code = rest[0];
    const fullParams = [...rest.slice(1)];
    if (fullParams[0]) {
      fullParams[0].appName = authOrCode.name;
    }
    return authOrCode._errorFactory.create(code, ...fullParams);
  }
  return _DEFAULT_AUTH_ERROR_FACTORY.create(authOrCode, ...rest);
}
function _assert(assertion, authOrCode, ...rest) {
  if (!assertion) {
    throw createErrorInternal(authOrCode, ...rest);
  }
}
function debugFail(failure) {
  const message = `INTERNAL ASSERTION FAILED: ` + failure;
  _logError(message);
  throw new Error(message);
}
function debugAssert(assertion, message) {
  if (!assertion) {
    debugFail(message);
  }
}
var instanceCache = new Map();
function _getInstance(cls) {
  debugAssert(cls instanceof Function, "Expected a class definition");
  let instance = instanceCache.get(cls);
  if (instance) {
    debugAssert(instance instanceof cls, "Instance stored in cache mismatched with class");
    return instance;
  }
  instance = new cls();
  instanceCache.set(cls, instance);
  return instance;
}
function initializeAuth(app, deps) {
  const provider = _getProvider(app, "auth");
  if (provider.isInitialized()) {
    const auth3 = provider.getImmediate();
    const initialOptions = provider.getOptions();
    if (deepEqual(initialOptions, deps !== null && deps !== void 0 ? deps : {})) {
      return auth3;
    } else {
      _fail(auth3, "already-initialized");
    }
  }
  const auth2 = provider.initialize({ options: deps });
  return auth2;
}
function _initializeAuthInstance(auth2, deps) {
  const persistence = (deps === null || deps === void 0 ? void 0 : deps.persistence) || [];
  const hierarchy = (Array.isArray(persistence) ? persistence : [persistence]).map(_getInstance);
  if (deps === null || deps === void 0 ? void 0 : deps.errorMap) {
    auth2._updateErrorMap(deps.errorMap);
  }
  auth2._initializeWithPersistence(hierarchy, deps === null || deps === void 0 ? void 0 : deps.popupRedirectResolver);
}
function _getCurrentUrl() {
  var _a;
  return typeof self !== "undefined" && ((_a = self.location) === null || _a === void 0 ? void 0 : _a.href) || "";
}
function _isHttpOrHttps() {
  return _getCurrentScheme() === "http:" || _getCurrentScheme() === "https:";
}
function _getCurrentScheme() {
  var _a;
  return typeof self !== "undefined" && ((_a = self.location) === null || _a === void 0 ? void 0 : _a.protocol) || null;
}
function _isOnline() {
  if (typeof navigator !== "undefined" && navigator && "onLine" in navigator && typeof navigator.onLine === "boolean" && (_isHttpOrHttps() || isBrowserExtension() || "connection" in navigator)) {
    return navigator.onLine;
  }
  return true;
}
function _getUserLanguage() {
  if (typeof navigator === "undefined") {
    return null;
  }
  const navigatorLanguage = navigator;
  return navigatorLanguage.languages && navigatorLanguage.languages[0] || navigatorLanguage.language || null;
}
var Delay = class {
  constructor(shortDelay, longDelay) {
    this.shortDelay = shortDelay;
    this.longDelay = longDelay;
    debugAssert(longDelay > shortDelay, "Short delay should be less than long delay!");
    this.isMobile = isMobileCordova() || isReactNative();
  }
  get() {
    if (!_isOnline()) {
      return Math.min(5e3, this.shortDelay);
    }
    return this.isMobile ? this.longDelay : this.shortDelay;
  }
};
function _emulatorUrl(config2, path) {
  debugAssert(config2.emulator, "Emulator should always be set here");
  const { url } = config2.emulator;
  if (!path) {
    return url;
  }
  return `${url}${path.startsWith("/") ? path.slice(1) : path}`;
}
var FetchProvider = class {
  static initialize(fetchImpl, headersImpl, responseImpl) {
    this.fetchImpl = fetchImpl;
    if (headersImpl) {
      this.headersImpl = headersImpl;
    }
    if (responseImpl) {
      this.responseImpl = responseImpl;
    }
  }
  static fetch() {
    if (this.fetchImpl) {
      return this.fetchImpl;
    }
    if (typeof self !== "undefined" && "fetch" in self) {
      return self.fetch;
    }
    debugFail("Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
  }
  static headers() {
    if (this.headersImpl) {
      return this.headersImpl;
    }
    if (typeof self !== "undefined" && "Headers" in self) {
      return self.Headers;
    }
    debugFail("Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
  }
  static response() {
    if (this.responseImpl) {
      return this.responseImpl;
    }
    if (typeof self !== "undefined" && "Response" in self) {
      return self.Response;
    }
    debugFail("Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill");
  }
};
var SERVER_ERROR_MAP = {
  ["CREDENTIAL_MISMATCH"]: "custom-token-mismatch",
  ["MISSING_CUSTOM_TOKEN"]: "internal-error",
  ["INVALID_IDENTIFIER"]: "invalid-email",
  ["MISSING_CONTINUE_URI"]: "internal-error",
  ["INVALID_PASSWORD"]: "wrong-password",
  ["MISSING_PASSWORD"]: "internal-error",
  ["EMAIL_EXISTS"]: "email-already-in-use",
  ["PASSWORD_LOGIN_DISABLED"]: "operation-not-allowed",
  ["INVALID_IDP_RESPONSE"]: "invalid-credential",
  ["INVALID_PENDING_TOKEN"]: "invalid-credential",
  ["FEDERATED_USER_ID_ALREADY_LINKED"]: "credential-already-in-use",
  ["MISSING_REQ_TYPE"]: "internal-error",
  ["EMAIL_NOT_FOUND"]: "user-not-found",
  ["RESET_PASSWORD_EXCEED_LIMIT"]: "too-many-requests",
  ["EXPIRED_OOB_CODE"]: "expired-action-code",
  ["INVALID_OOB_CODE"]: "invalid-action-code",
  ["MISSING_OOB_CODE"]: "internal-error",
  ["CREDENTIAL_TOO_OLD_LOGIN_AGAIN"]: "requires-recent-login",
  ["INVALID_ID_TOKEN"]: "invalid-user-token",
  ["TOKEN_EXPIRED"]: "user-token-expired",
  ["USER_NOT_FOUND"]: "user-token-expired",
  ["TOO_MANY_ATTEMPTS_TRY_LATER"]: "too-many-requests",
  ["INVALID_CODE"]: "invalid-verification-code",
  ["INVALID_SESSION_INFO"]: "invalid-verification-id",
  ["INVALID_TEMPORARY_PROOF"]: "invalid-credential",
  ["MISSING_SESSION_INFO"]: "missing-verification-id",
  ["SESSION_EXPIRED"]: "code-expired",
  ["MISSING_ANDROID_PACKAGE_NAME"]: "missing-android-pkg-name",
  ["UNAUTHORIZED_DOMAIN"]: "unauthorized-continue-uri",
  ["INVALID_OAUTH_CLIENT_ID"]: "invalid-oauth-client-id",
  ["ADMIN_ONLY_OPERATION"]: "admin-restricted-operation",
  ["INVALID_MFA_PENDING_CREDENTIAL"]: "invalid-multi-factor-session",
  ["MFA_ENROLLMENT_NOT_FOUND"]: "multi-factor-info-not-found",
  ["MISSING_MFA_ENROLLMENT_ID"]: "missing-multi-factor-info",
  ["MISSING_MFA_PENDING_CREDENTIAL"]: "missing-multi-factor-session",
  ["SECOND_FACTOR_EXISTS"]: "second-factor-already-in-use",
  ["SECOND_FACTOR_LIMIT_EXCEEDED"]: "maximum-second-factor-count-exceeded",
  ["BLOCKING_FUNCTION_ERROR_RESPONSE"]: "internal-error"
};
var DEFAULT_API_TIMEOUT_MS = new Delay(3e4, 6e4);
function _addTidIfNecessary(auth2, request) {
  if (auth2.tenantId && !request.tenantId) {
    return Object.assign(Object.assign({}, request), { tenantId: auth2.tenantId });
  }
  return request;
}
async function _performApiRequest(auth2, method, path, request, customErrorMap = {}) {
  return _performFetchWithErrorHandling(auth2, customErrorMap, () => {
    let body = {};
    let params = {};
    if (request) {
      if (method === "GET") {
        params = request;
      } else {
        body = {
          body: JSON.stringify(request)
        };
      }
    }
    const query = querystring(Object.assign({ key: auth2.config.apiKey }, params)).slice(1);
    const headers = new (FetchProvider.headers())();
    headers.set("Content-Type", "application/json");
    headers.set("X-Client-Version", auth2._getSdkClientVersion());
    if (auth2.languageCode) {
      headers.set("X-Firebase-Locale", auth2.languageCode);
    }
    return FetchProvider.fetch()(_getFinalTarget(auth2, auth2.config.apiHost, path, query), Object.assign({
      method,
      headers,
      referrerPolicy: "no-referrer"
    }, body));
  });
}
async function _performFetchWithErrorHandling(auth2, customErrorMap, fetchFn) {
  auth2._canInitEmulator = false;
  const errorMap = Object.assign(Object.assign({}, SERVER_ERROR_MAP), customErrorMap);
  try {
    const networkTimeout = new NetworkTimeout(auth2);
    const response = await Promise.race([
      fetchFn(),
      networkTimeout.promise
    ]);
    networkTimeout.clearNetworkTimeout();
    const json = await response.json();
    if ("needConfirmation" in json) {
      throw _makeTaggedError(auth2, "account-exists-with-different-credential", json);
    }
    if (response.ok && !("errorMessage" in json)) {
      return json;
    } else {
      const errorMessage = response.ok ? json.errorMessage : json.error.message;
      const [serverErrorCode, serverErrorMessage] = errorMessage.split(" : ");
      if (serverErrorCode === "FEDERATED_USER_ID_ALREADY_LINKED") {
        throw _makeTaggedError(auth2, "credential-already-in-use", json);
      } else if (serverErrorCode === "EMAIL_EXISTS") {
        throw _makeTaggedError(auth2, "email-already-in-use", json);
      }
      const authError = errorMap[serverErrorCode] || serverErrorCode.toLowerCase().replace(/[_\s]+/g, "-");
      if (serverErrorMessage) {
        throw _errorWithCustomMessage(auth2, authError, serverErrorMessage);
      } else {
        _fail(auth2, authError);
      }
    }
  } catch (e) {
    if (e instanceof FirebaseError) {
      throw e;
    }
    _fail(auth2, "network-request-failed");
  }
}
async function _performSignInRequest(auth2, method, path, request, customErrorMap = {}) {
  const serverResponse = await _performApiRequest(auth2, method, path, request, customErrorMap);
  if ("mfaPendingCredential" in serverResponse) {
    _fail(auth2, "multi-factor-auth-required", {
      serverResponse
    });
  }
  return serverResponse;
}
function _getFinalTarget(auth2, host, path, query) {
  const base2 = `${host}${path}?${query}`;
  if (!auth2.config.emulator) {
    return `${auth2.config.apiScheme}://${base2}`;
  }
  return _emulatorUrl(auth2.config, base2);
}
var NetworkTimeout = class {
  constructor(auth2) {
    this.auth = auth2;
    this.timer = null;
    this.promise = new Promise((_, reject) => {
      this.timer = setTimeout(() => {
        return reject(_createError(this.auth, "timeout"));
      }, DEFAULT_API_TIMEOUT_MS.get());
    });
  }
  clearNetworkTimeout() {
    clearTimeout(this.timer);
  }
};
function _makeTaggedError(auth2, code, response) {
  const errorParams = {
    appName: auth2.name
  };
  if (response.email) {
    errorParams.email = response.email;
  }
  if (response.phoneNumber) {
    errorParams.phoneNumber = response.phoneNumber;
  }
  const error2 = _createError(auth2, code, errorParams);
  error2.customData._tokenResponse = response;
  return error2;
}
async function deleteAccount(auth2, request) {
  return _performApiRequest(auth2, "POST", "/v1/accounts:delete", request);
}
async function getAccountInfo(auth2, request) {
  return _performApiRequest(auth2, "POST", "/v1/accounts:lookup", request);
}
function utcTimestampToDateString(utcTimestamp) {
  if (!utcTimestamp) {
    return void 0;
  }
  try {
    const date = new Date(Number(utcTimestamp));
    if (!isNaN(date.getTime())) {
      return date.toUTCString();
    }
  } catch (e) {
  }
  return void 0;
}
async function getIdTokenResult(user2, forceRefresh = false) {
  const userInternal = getModularInstance(user2);
  const token = await userInternal.getIdToken(forceRefresh);
  const claims = _parseToken(token);
  _assert(claims && claims.exp && claims.auth_time && claims.iat, userInternal.auth, "internal-error");
  const firebase2 = typeof claims.firebase === "object" ? claims.firebase : void 0;
  const signInProvider = firebase2 === null || firebase2 === void 0 ? void 0 : firebase2["sign_in_provider"];
  return {
    claims,
    token,
    authTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.auth_time)),
    issuedAtTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.iat)),
    expirationTime: utcTimestampToDateString(secondsStringToMilliseconds(claims.exp)),
    signInProvider: signInProvider || null,
    signInSecondFactor: (firebase2 === null || firebase2 === void 0 ? void 0 : firebase2["sign_in_second_factor"]) || null
  };
}
function secondsStringToMilliseconds(seconds) {
  return Number(seconds) * 1e3;
}
function _parseToken(token) {
  const [algorithm, payload, signature] = token.split(".");
  if (algorithm === void 0 || payload === void 0 || signature === void 0) {
    _logError("JWT malformed, contained fewer than 3 sections");
    return null;
  }
  try {
    const decoded = base64Decode(payload);
    if (!decoded) {
      _logError("Failed to decode base64 JWT payload");
      return null;
    }
    return JSON.parse(decoded);
  } catch (e) {
    _logError("Caught error parsing JWT payload as JSON", e);
    return null;
  }
}
function _tokenExpiresIn(token) {
  const parsedToken = _parseToken(token);
  _assert(parsedToken, "internal-error");
  _assert(typeof parsedToken.exp !== "undefined", "internal-error");
  _assert(typeof parsedToken.iat !== "undefined", "internal-error");
  return Number(parsedToken.exp) - Number(parsedToken.iat);
}
async function _logoutIfInvalidated(user2, promise, bypassAuthState = false) {
  if (bypassAuthState) {
    return promise;
  }
  try {
    return await promise;
  } catch (e) {
    if (e instanceof FirebaseError && isUserInvalidated(e)) {
      if (user2.auth.currentUser === user2) {
        await user2.auth.signOut();
      }
    }
    throw e;
  }
}
function isUserInvalidated({ code }) {
  return code === `auth/${"user-disabled"}` || code === `auth/${"user-token-expired"}`;
}
var ProactiveRefresh = class {
  constructor(user2) {
    this.user = user2;
    this.isRunning = false;
    this.timerId = null;
    this.errorBackoff = 3e4;
  }
  _start() {
    if (this.isRunning) {
      return;
    }
    this.isRunning = true;
    this.schedule();
  }
  _stop() {
    if (!this.isRunning) {
      return;
    }
    this.isRunning = false;
    if (this.timerId !== null) {
      clearTimeout(this.timerId);
    }
  }
  getInterval(wasError) {
    var _a;
    if (wasError) {
      const interval = this.errorBackoff;
      this.errorBackoff = Math.min(this.errorBackoff * 2, 96e4);
      return interval;
    } else {
      this.errorBackoff = 3e4;
      const expTime = (_a = this.user.stsTokenManager.expirationTime) !== null && _a !== void 0 ? _a : 0;
      const interval = expTime - Date.now() - 3e5;
      return Math.max(0, interval);
    }
  }
  schedule(wasError = false) {
    if (!this.isRunning) {
      return;
    }
    const interval = this.getInterval(wasError);
    this.timerId = setTimeout(async () => {
      await this.iteration();
    }, interval);
  }
  async iteration() {
    try {
      await this.user.getIdToken(true);
    } catch (e) {
      if (e.code === `auth/${"network-request-failed"}`) {
        this.schedule(true);
      }
      return;
    }
    this.schedule();
  }
};
var UserMetadata = class {
  constructor(createdAt, lastLoginAt) {
    this.createdAt = createdAt;
    this.lastLoginAt = lastLoginAt;
    this._initializeTime();
  }
  _initializeTime() {
    this.lastSignInTime = utcTimestampToDateString(this.lastLoginAt);
    this.creationTime = utcTimestampToDateString(this.createdAt);
  }
  _copy(metadata) {
    this.createdAt = metadata.createdAt;
    this.lastLoginAt = metadata.lastLoginAt;
    this._initializeTime();
  }
  toJSON() {
    return {
      createdAt: this.createdAt,
      lastLoginAt: this.lastLoginAt
    };
  }
};
async function _reloadWithoutSaving(user2) {
  var _a;
  const auth2 = user2.auth;
  const idToken = await user2.getIdToken();
  const response = await _logoutIfInvalidated(user2, getAccountInfo(auth2, { idToken }));
  _assert(response === null || response === void 0 ? void 0 : response.users.length, auth2, "internal-error");
  const coreAccount = response.users[0];
  user2._notifyReloadListener(coreAccount);
  const newProviderData = ((_a = coreAccount.providerUserInfo) === null || _a === void 0 ? void 0 : _a.length) ? extractProviderData(coreAccount.providerUserInfo) : [];
  const providerData = mergeProviderData(user2.providerData, newProviderData);
  const oldIsAnonymous = user2.isAnonymous;
  const newIsAnonymous = !(user2.email && coreAccount.passwordHash) && !(providerData === null || providerData === void 0 ? void 0 : providerData.length);
  const isAnonymous = !oldIsAnonymous ? false : newIsAnonymous;
  const updates = {
    uid: coreAccount.localId,
    displayName: coreAccount.displayName || null,
    photoURL: coreAccount.photoUrl || null,
    email: coreAccount.email || null,
    emailVerified: coreAccount.emailVerified || false,
    phoneNumber: coreAccount.phoneNumber || null,
    tenantId: coreAccount.tenantId || null,
    providerData,
    metadata: new UserMetadata(coreAccount.createdAt, coreAccount.lastLoginAt),
    isAnonymous
  };
  Object.assign(user2, updates);
}
async function reload(user2) {
  const userInternal = getModularInstance(user2);
  await _reloadWithoutSaving(userInternal);
  await userInternal.auth._persistUserIfCurrent(userInternal);
  userInternal.auth._notifyListenersIfCurrent(userInternal);
}
function mergeProviderData(original, newData) {
  const deduped = original.filter((o) => !newData.some((n) => n.providerId === o.providerId));
  return [...deduped, ...newData];
}
function extractProviderData(providers) {
  return providers.map((_a) => {
    var { providerId } = _a, provider = __rest(_a, ["providerId"]);
    return {
      providerId,
      uid: provider.rawId || "",
      displayName: provider.displayName || null,
      email: provider.email || null,
      phoneNumber: provider.phoneNumber || null,
      photoURL: provider.photoUrl || null
    };
  });
}
async function requestStsToken(auth2, refreshToken) {
  const response = await _performFetchWithErrorHandling(auth2, {}, () => {
    const body = querystring({
      "grant_type": "refresh_token",
      "refresh_token": refreshToken
    }).slice(1);
    const { tokenApiHost, apiKey } = auth2.config;
    const url = _getFinalTarget(auth2, tokenApiHost, "/v1/token", `key=${apiKey}`);
    return FetchProvider.fetch()(url, {
      method: "POST",
      headers: {
        "X-Client-Version": auth2._getSdkClientVersion(),
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body
    });
  });
  return {
    accessToken: response.access_token,
    expiresIn: response.expires_in,
    refreshToken: response.refresh_token
  };
}
var StsTokenManager = class {
  constructor() {
    this.refreshToken = null;
    this.accessToken = null;
    this.expirationTime = null;
  }
  get isExpired() {
    return !this.expirationTime || Date.now() > this.expirationTime - 3e4;
  }
  updateFromServerResponse(response) {
    _assert(response.idToken, "internal-error");
    _assert(typeof response.idToken !== "undefined", "internal-error");
    _assert(typeof response.refreshToken !== "undefined", "internal-error");
    const expiresIn = "expiresIn" in response && typeof response.expiresIn !== "undefined" ? Number(response.expiresIn) : _tokenExpiresIn(response.idToken);
    this.updateTokensAndExpiration(response.idToken, response.refreshToken, expiresIn);
  }
  async getToken(auth2, forceRefresh = false) {
    _assert(!this.accessToken || this.refreshToken, auth2, "user-token-expired");
    if (!forceRefresh && this.accessToken && !this.isExpired) {
      return this.accessToken;
    }
    if (this.refreshToken) {
      await this.refresh(auth2, this.refreshToken);
      return this.accessToken;
    }
    return null;
  }
  clearRefreshToken() {
    this.refreshToken = null;
  }
  async refresh(auth2, oldToken) {
    const { accessToken, refreshToken, expiresIn } = await requestStsToken(auth2, oldToken);
    this.updateTokensAndExpiration(accessToken, refreshToken, Number(expiresIn));
  }
  updateTokensAndExpiration(accessToken, refreshToken, expiresInSec) {
    this.refreshToken = refreshToken || null;
    this.accessToken = accessToken || null;
    this.expirationTime = Date.now() + expiresInSec * 1e3;
  }
  static fromJSON(appName, object) {
    const { refreshToken, accessToken, expirationTime } = object;
    const manager = new StsTokenManager();
    if (refreshToken) {
      _assert(typeof refreshToken === "string", "internal-error", {
        appName
      });
      manager.refreshToken = refreshToken;
    }
    if (accessToken) {
      _assert(typeof accessToken === "string", "internal-error", {
        appName
      });
      manager.accessToken = accessToken;
    }
    if (expirationTime) {
      _assert(typeof expirationTime === "number", "internal-error", {
        appName
      });
      manager.expirationTime = expirationTime;
    }
    return manager;
  }
  toJSON() {
    return {
      refreshToken: this.refreshToken,
      accessToken: this.accessToken,
      expirationTime: this.expirationTime
    };
  }
  _assign(stsTokenManager) {
    this.accessToken = stsTokenManager.accessToken;
    this.refreshToken = stsTokenManager.refreshToken;
    this.expirationTime = stsTokenManager.expirationTime;
  }
  _clone() {
    return Object.assign(new StsTokenManager(), this.toJSON());
  }
  _performRefresh() {
    return debugFail("not implemented");
  }
};
function assertStringOrUndefined(assertion, appName) {
  _assert(typeof assertion === "string" || typeof assertion === "undefined", "internal-error", { appName });
}
var UserImpl = class {
  constructor(_a) {
    var { uid, auth: auth2, stsTokenManager } = _a, opt = __rest(_a, ["uid", "auth", "stsTokenManager"]);
    this.providerId = "firebase";
    this.emailVerified = false;
    this.isAnonymous = false;
    this.tenantId = null;
    this.providerData = [];
    this.proactiveRefresh = new ProactiveRefresh(this);
    this.reloadUserInfo = null;
    this.reloadListener = null;
    this.uid = uid;
    this.auth = auth2;
    this.stsTokenManager = stsTokenManager;
    this.accessToken = stsTokenManager.accessToken;
    this.displayName = opt.displayName || null;
    this.email = opt.email || null;
    this.emailVerified = opt.emailVerified || false;
    this.phoneNumber = opt.phoneNumber || null;
    this.photoURL = opt.photoURL || null;
    this.isAnonymous = opt.isAnonymous || false;
    this.tenantId = opt.tenantId || null;
    this.metadata = new UserMetadata(opt.createdAt || void 0, opt.lastLoginAt || void 0);
  }
  async getIdToken(forceRefresh) {
    const accessToken = await _logoutIfInvalidated(this, this.stsTokenManager.getToken(this.auth, forceRefresh));
    _assert(accessToken, this.auth, "internal-error");
    if (this.accessToken !== accessToken) {
      this.accessToken = accessToken;
      await this.auth._persistUserIfCurrent(this);
      this.auth._notifyListenersIfCurrent(this);
    }
    return accessToken;
  }
  getIdTokenResult(forceRefresh) {
    return getIdTokenResult(this, forceRefresh);
  }
  reload() {
    return reload(this);
  }
  _assign(user2) {
    if (this === user2) {
      return;
    }
    _assert(this.uid === user2.uid, this.auth, "internal-error");
    this.displayName = user2.displayName;
    this.photoURL = user2.photoURL;
    this.email = user2.email;
    this.emailVerified = user2.emailVerified;
    this.phoneNumber = user2.phoneNumber;
    this.isAnonymous = user2.isAnonymous;
    this.tenantId = user2.tenantId;
    this.providerData = user2.providerData.map((userInfo) => Object.assign({}, userInfo));
    this.metadata._copy(user2.metadata);
    this.stsTokenManager._assign(user2.stsTokenManager);
  }
  _clone(auth2) {
    return new UserImpl(Object.assign(Object.assign({}, this), { auth: auth2, stsTokenManager: this.stsTokenManager._clone() }));
  }
  _onReload(callback) {
    _assert(!this.reloadListener, this.auth, "internal-error");
    this.reloadListener = callback;
    if (this.reloadUserInfo) {
      this._notifyReloadListener(this.reloadUserInfo);
      this.reloadUserInfo = null;
    }
  }
  _notifyReloadListener(userInfo) {
    if (this.reloadListener) {
      this.reloadListener(userInfo);
    } else {
      this.reloadUserInfo = userInfo;
    }
  }
  _startProactiveRefresh() {
    this.proactiveRefresh._start();
  }
  _stopProactiveRefresh() {
    this.proactiveRefresh._stop();
  }
  async _updateTokensIfNecessary(response, reload2 = false) {
    let tokensRefreshed = false;
    if (response.idToken && response.idToken !== this.stsTokenManager.accessToken) {
      this.stsTokenManager.updateFromServerResponse(response);
      tokensRefreshed = true;
    }
    if (reload2) {
      await _reloadWithoutSaving(this);
    }
    await this.auth._persistUserIfCurrent(this);
    if (tokensRefreshed) {
      this.auth._notifyListenersIfCurrent(this);
    }
  }
  async delete() {
    const idToken = await this.getIdToken();
    await _logoutIfInvalidated(this, deleteAccount(this.auth, { idToken }));
    this.stsTokenManager.clearRefreshToken();
    return this.auth.signOut();
  }
  toJSON() {
    return Object.assign(Object.assign({
      uid: this.uid,
      email: this.email || void 0,
      emailVerified: this.emailVerified,
      displayName: this.displayName || void 0,
      isAnonymous: this.isAnonymous,
      photoURL: this.photoURL || void 0,
      phoneNumber: this.phoneNumber || void 0,
      tenantId: this.tenantId || void 0,
      providerData: this.providerData.map((userInfo) => Object.assign({}, userInfo)),
      stsTokenManager: this.stsTokenManager.toJSON(),
      _redirectEventId: this._redirectEventId
    }, this.metadata.toJSON()), {
      apiKey: this.auth.config.apiKey,
      appName: this.auth.name
    });
  }
  get refreshToken() {
    return this.stsTokenManager.refreshToken || "";
  }
  static _fromJSON(auth2, object) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const displayName = (_a = object.displayName) !== null && _a !== void 0 ? _a : void 0;
    const email = (_b = object.email) !== null && _b !== void 0 ? _b : void 0;
    const phoneNumber = (_c = object.phoneNumber) !== null && _c !== void 0 ? _c : void 0;
    const photoURL = (_d = object.photoURL) !== null && _d !== void 0 ? _d : void 0;
    const tenantId = (_e = object.tenantId) !== null && _e !== void 0 ? _e : void 0;
    const _redirectEventId = (_f = object._redirectEventId) !== null && _f !== void 0 ? _f : void 0;
    const createdAt = (_g = object.createdAt) !== null && _g !== void 0 ? _g : void 0;
    const lastLoginAt = (_h = object.lastLoginAt) !== null && _h !== void 0 ? _h : void 0;
    const { uid, emailVerified, isAnonymous, providerData, stsTokenManager: plainObjectTokenManager } = object;
    _assert(uid && plainObjectTokenManager, auth2, "internal-error");
    const stsTokenManager = StsTokenManager.fromJSON(this.name, plainObjectTokenManager);
    _assert(typeof uid === "string", auth2, "internal-error");
    assertStringOrUndefined(displayName, auth2.name);
    assertStringOrUndefined(email, auth2.name);
    _assert(typeof emailVerified === "boolean", auth2, "internal-error");
    _assert(typeof isAnonymous === "boolean", auth2, "internal-error");
    assertStringOrUndefined(phoneNumber, auth2.name);
    assertStringOrUndefined(photoURL, auth2.name);
    assertStringOrUndefined(tenantId, auth2.name);
    assertStringOrUndefined(_redirectEventId, auth2.name);
    assertStringOrUndefined(createdAt, auth2.name);
    assertStringOrUndefined(lastLoginAt, auth2.name);
    const user2 = new UserImpl({
      uid,
      auth: auth2,
      email,
      emailVerified,
      displayName,
      isAnonymous,
      photoURL,
      phoneNumber,
      tenantId,
      stsTokenManager,
      createdAt,
      lastLoginAt
    });
    if (providerData && Array.isArray(providerData)) {
      user2.providerData = providerData.map((userInfo) => Object.assign({}, userInfo));
    }
    if (_redirectEventId) {
      user2._redirectEventId = _redirectEventId;
    }
    return user2;
  }
  static async _fromIdTokenResponse(auth2, idTokenResponse, isAnonymous = false) {
    const stsTokenManager = new StsTokenManager();
    stsTokenManager.updateFromServerResponse(idTokenResponse);
    const user2 = new UserImpl({
      uid: idTokenResponse.localId,
      auth: auth2,
      stsTokenManager,
      isAnonymous
    });
    await _reloadWithoutSaving(user2);
    return user2;
  }
};
var InMemoryPersistence = class {
  constructor() {
    this.type = "NONE";
    this.storage = {};
  }
  async _isAvailable() {
    return true;
  }
  async _set(key, value) {
    this.storage[key] = value;
  }
  async _get(key) {
    const value = this.storage[key];
    return value === void 0 ? null : value;
  }
  async _remove(key) {
    delete this.storage[key];
  }
  _addListener(_key, _listener) {
    return;
  }
  _removeListener(_key, _listener) {
    return;
  }
};
InMemoryPersistence.type = "NONE";
var inMemoryPersistence = InMemoryPersistence;
function _persistenceKeyName(key, apiKey, appName) {
  return `${"firebase"}:${key}:${apiKey}:${appName}`;
}
var PersistenceUserManager = class {
  constructor(persistence, auth2, userKey) {
    this.persistence = persistence;
    this.auth = auth2;
    this.userKey = userKey;
    const { config: config2, name: name2 } = this.auth;
    this.fullUserKey = _persistenceKeyName(this.userKey, config2.apiKey, name2);
    this.fullPersistenceKey = _persistenceKeyName("persistence", config2.apiKey, name2);
    this.boundEventHandler = auth2._onStorageEvent.bind(auth2);
    this.persistence._addListener(this.fullUserKey, this.boundEventHandler);
  }
  setCurrentUser(user2) {
    return this.persistence._set(this.fullUserKey, user2.toJSON());
  }
  async getCurrentUser() {
    const blob = await this.persistence._get(this.fullUserKey);
    return blob ? UserImpl._fromJSON(this.auth, blob) : null;
  }
  removeCurrentUser() {
    return this.persistence._remove(this.fullUserKey);
  }
  savePersistenceForRedirect() {
    return this.persistence._set(this.fullPersistenceKey, this.persistence.type);
  }
  async setPersistence(newPersistence) {
    if (this.persistence === newPersistence) {
      return;
    }
    const currentUser = await this.getCurrentUser();
    await this.removeCurrentUser();
    this.persistence = newPersistence;
    if (currentUser) {
      return this.setCurrentUser(currentUser);
    }
  }
  delete() {
    this.persistence._removeListener(this.fullUserKey, this.boundEventHandler);
  }
  static async create(auth2, persistenceHierarchy, userKey = "authUser") {
    if (!persistenceHierarchy.length) {
      return new PersistenceUserManager(_getInstance(inMemoryPersistence), auth2, userKey);
    }
    const availablePersistences = (await Promise.all(persistenceHierarchy.map(async (persistence) => {
      if (await persistence._isAvailable()) {
        return persistence;
      }
      return void 0;
    }))).filter((persistence) => persistence);
    let selectedPersistence = availablePersistences[0] || _getInstance(inMemoryPersistence);
    const key = _persistenceKeyName(userKey, auth2.config.apiKey, auth2.name);
    let userToMigrate = null;
    for (const persistence of persistenceHierarchy) {
      try {
        const blob = await persistence._get(key);
        if (blob) {
          const user2 = UserImpl._fromJSON(auth2, blob);
          if (persistence !== selectedPersistence) {
            userToMigrate = user2;
          }
          selectedPersistence = persistence;
          break;
        }
      } catch (_a) {
      }
    }
    const migrationHierarchy = availablePersistences.filter((p) => p._shouldAllowMigration);
    if (!selectedPersistence._shouldAllowMigration || !migrationHierarchy.length) {
      return new PersistenceUserManager(selectedPersistence, auth2, userKey);
    }
    selectedPersistence = migrationHierarchy[0];
    if (userToMigrate) {
      await selectedPersistence._set(key, userToMigrate.toJSON());
    }
    await Promise.all(persistenceHierarchy.map(async (persistence) => {
      if (persistence !== selectedPersistence) {
        try {
          await persistence._remove(key);
        } catch (_a) {
        }
      }
    }));
    return new PersistenceUserManager(selectedPersistence, auth2, userKey);
  }
};
function _getBrowserName(userAgent) {
  const ua = userAgent.toLowerCase();
  if (ua.includes("opera/") || ua.includes("opr/") || ua.includes("opios/")) {
    return "Opera";
  } else if (_isIEMobile(ua)) {
    return "IEMobile";
  } else if (ua.includes("msie") || ua.includes("trident/")) {
    return "IE";
  } else if (ua.includes("edge/")) {
    return "Edge";
  } else if (_isFirefox(ua)) {
    return "Firefox";
  } else if (ua.includes("silk/")) {
    return "Silk";
  } else if (_isBlackBerry(ua)) {
    return "Blackberry";
  } else if (_isWebOS(ua)) {
    return "Webos";
  } else if (_isSafari(ua)) {
    return "Safari";
  } else if ((ua.includes("chrome/") || _isChromeIOS(ua)) && !ua.includes("edge/")) {
    return "Chrome";
  } else if (_isAndroid(ua)) {
    return "Android";
  } else {
    const re = /([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/;
    const matches = userAgent.match(re);
    if ((matches === null || matches === void 0 ? void 0 : matches.length) === 2) {
      return matches[1];
    }
  }
  return "Other";
}
function _isFirefox(ua = getUA()) {
  return /firefox\//i.test(ua);
}
function _isSafari(userAgent = getUA()) {
  const ua = userAgent.toLowerCase();
  return ua.includes("safari/") && !ua.includes("chrome/") && !ua.includes("crios/") && !ua.includes("android");
}
function _isChromeIOS(ua = getUA()) {
  return /crios\//i.test(ua);
}
function _isIEMobile(ua = getUA()) {
  return /iemobile/i.test(ua);
}
function _isAndroid(ua = getUA()) {
  return /android/i.test(ua);
}
function _isBlackBerry(ua = getUA()) {
  return /blackberry/i.test(ua);
}
function _isWebOS(ua = getUA()) {
  return /webos/i.test(ua);
}
function _isIOS(ua = getUA()) {
  return /iphone|ipad|ipod/i.test(ua);
}
function _isIOSStandalone(ua = getUA()) {
  var _a;
  return _isIOS(ua) && !!((_a = window.navigator) === null || _a === void 0 ? void 0 : _a.standalone);
}
function _isIE10() {
  return isIE() && document.documentMode === 10;
}
function _isMobileBrowser(ua = getUA()) {
  return _isIOS(ua) || _isAndroid(ua) || _isWebOS(ua) || _isBlackBerry(ua) || /windows phone/i.test(ua) || _isIEMobile(ua);
}
function _isIframe() {
  try {
    return !!(window && window !== window.top);
  } catch (e) {
    return false;
  }
}
function _getClientVersion(clientPlatform, frameworks = []) {
  let reportedPlatform;
  switch (clientPlatform) {
    case "Browser":
      reportedPlatform = _getBrowserName(getUA());
      break;
    case "Worker":
      reportedPlatform = `${_getBrowserName(getUA())}-${clientPlatform}`;
      break;
    default:
      reportedPlatform = clientPlatform;
  }
  const reportedFrameworks = frameworks.length ? frameworks.join(",") : "FirebaseCore-web";
  return `${reportedPlatform}/${"JsCore"}/${SDK_VERSION}/${reportedFrameworks}`;
}
var AuthImpl = class {
  constructor(app, config2) {
    this.app = app;
    this.config = config2;
    this.currentUser = null;
    this.emulatorConfig = null;
    this.operations = Promise.resolve();
    this.authStateSubscription = new Subscription(this);
    this.idTokenSubscription = new Subscription(this);
    this.redirectUser = null;
    this.isProactiveRefreshEnabled = false;
    this._canInitEmulator = true;
    this._isInitialized = false;
    this._deleted = false;
    this._initializationPromise = null;
    this._popupRedirectResolver = null;
    this._errorFactory = _DEFAULT_AUTH_ERROR_FACTORY;
    this.lastNotifiedUid = void 0;
    this.languageCode = null;
    this.tenantId = null;
    this.settings = { appVerificationDisabledForTesting: false };
    this.frameworks = [];
    this.name = app.name;
    this.clientVersion = config2.sdkClientVersion;
  }
  _initializeWithPersistence(persistenceHierarchy, popupRedirectResolver) {
    if (popupRedirectResolver) {
      this._popupRedirectResolver = _getInstance(popupRedirectResolver);
    }
    this._initializationPromise = this.queue(async () => {
      var _a;
      if (this._deleted) {
        return;
      }
      this.persistenceManager = await PersistenceUserManager.create(this, persistenceHierarchy);
      if (this._deleted) {
        return;
      }
      if ((_a = this._popupRedirectResolver) === null || _a === void 0 ? void 0 : _a._shouldInitProactively) {
        await this._popupRedirectResolver._initialize(this);
      }
      await this.initializeCurrentUser(popupRedirectResolver);
      if (this._deleted) {
        return;
      }
      this._isInitialized = true;
    });
    return this._initializationPromise;
  }
  async _onStorageEvent() {
    if (this._deleted) {
      return;
    }
    const user2 = await this.assertedPersistence.getCurrentUser();
    if (!this.currentUser && !user2) {
      return;
    }
    if (this.currentUser && user2 && this.currentUser.uid === user2.uid) {
      this._currentUser._assign(user2);
      await this.currentUser.getIdToken();
      return;
    }
    await this._updateCurrentUser(user2);
  }
  async initializeCurrentUser(popupRedirectResolver) {
    var _a;
    let storedUser = await this.assertedPersistence.getCurrentUser();
    if (popupRedirectResolver && this.config.authDomain) {
      await this.getOrInitRedirectPersistenceManager();
      const redirectUserEventId = (_a = this.redirectUser) === null || _a === void 0 ? void 0 : _a._redirectEventId;
      const storedUserEventId = storedUser === null || storedUser === void 0 ? void 0 : storedUser._redirectEventId;
      const result = await this.tryRedirectSignIn(popupRedirectResolver);
      if ((!redirectUserEventId || redirectUserEventId === storedUserEventId) && (result === null || result === void 0 ? void 0 : result.user)) {
        storedUser = result.user;
      }
    }
    if (!storedUser) {
      return this.directlySetCurrentUser(null);
    }
    if (!storedUser._redirectEventId) {
      return this.reloadAndSetCurrentUserOrClear(storedUser);
    }
    _assert(this._popupRedirectResolver, this, "argument-error");
    await this.getOrInitRedirectPersistenceManager();
    if (this.redirectUser && this.redirectUser._redirectEventId === storedUser._redirectEventId) {
      return this.directlySetCurrentUser(storedUser);
    }
    return this.reloadAndSetCurrentUserOrClear(storedUser);
  }
  async tryRedirectSignIn(redirectResolver) {
    let result = null;
    try {
      result = await this._popupRedirectResolver._completeRedirectFn(this, redirectResolver, true);
    } catch (e) {
      await this._setRedirectUser(null);
    }
    return result;
  }
  async reloadAndSetCurrentUserOrClear(user2) {
    try {
      await _reloadWithoutSaving(user2);
    } catch (e) {
      if (e.code !== `auth/${"network-request-failed"}`) {
        return this.directlySetCurrentUser(null);
      }
    }
    return this.directlySetCurrentUser(user2);
  }
  useDeviceLanguage() {
    this.languageCode = _getUserLanguage();
  }
  async _delete() {
    this._deleted = true;
  }
  async updateCurrentUser(userExtern) {
    const user2 = userExtern ? getModularInstance(userExtern) : null;
    if (user2) {
      _assert(user2.auth.config.apiKey === this.config.apiKey, this, "invalid-user-token");
    }
    return this._updateCurrentUser(user2 && user2._clone(this));
  }
  async _updateCurrentUser(user2) {
    if (this._deleted) {
      return;
    }
    if (user2) {
      _assert(this.tenantId === user2.tenantId, this, "tenant-id-mismatch");
    }
    return this.queue(async () => {
      await this.directlySetCurrentUser(user2);
      this.notifyAuthListeners();
    });
  }
  async signOut() {
    if (this.redirectPersistenceManager || this._popupRedirectResolver) {
      await this._setRedirectUser(null);
    }
    return this._updateCurrentUser(null);
  }
  setPersistence(persistence) {
    return this.queue(async () => {
      await this.assertedPersistence.setPersistence(_getInstance(persistence));
    });
  }
  _getPersistence() {
    return this.assertedPersistence.persistence.type;
  }
  _updateErrorMap(errorMap) {
    this._errorFactory = new ErrorFactory("auth", "Firebase", errorMap());
  }
  onAuthStateChanged(nextOrObserver, error2, completed) {
    return this.registerStateListener(this.authStateSubscription, nextOrObserver, error2, completed);
  }
  onIdTokenChanged(nextOrObserver, error2, completed) {
    return this.registerStateListener(this.idTokenSubscription, nextOrObserver, error2, completed);
  }
  toJSON() {
    var _a;
    return {
      apiKey: this.config.apiKey,
      authDomain: this.config.authDomain,
      appName: this.name,
      currentUser: (_a = this._currentUser) === null || _a === void 0 ? void 0 : _a.toJSON()
    };
  }
  async _setRedirectUser(user2, popupRedirectResolver) {
    const redirectManager = await this.getOrInitRedirectPersistenceManager(popupRedirectResolver);
    return user2 === null ? redirectManager.removeCurrentUser() : redirectManager.setCurrentUser(user2);
  }
  async getOrInitRedirectPersistenceManager(popupRedirectResolver) {
    if (!this.redirectPersistenceManager) {
      const resolver = popupRedirectResolver && _getInstance(popupRedirectResolver) || this._popupRedirectResolver;
      _assert(resolver, this, "argument-error");
      this.redirectPersistenceManager = await PersistenceUserManager.create(this, [_getInstance(resolver._redirectPersistence)], "redirectUser");
      this.redirectUser = await this.redirectPersistenceManager.getCurrentUser();
    }
    return this.redirectPersistenceManager;
  }
  async _redirectUserForId(id) {
    var _a, _b;
    if (this._isInitialized) {
      await this.queue(async () => {
      });
    }
    if (((_a = this._currentUser) === null || _a === void 0 ? void 0 : _a._redirectEventId) === id) {
      return this._currentUser;
    }
    if (((_b = this.redirectUser) === null || _b === void 0 ? void 0 : _b._redirectEventId) === id) {
      return this.redirectUser;
    }
    return null;
  }
  async _persistUserIfCurrent(user2) {
    if (user2 === this.currentUser) {
      return this.queue(async () => this.directlySetCurrentUser(user2));
    }
  }
  _notifyListenersIfCurrent(user2) {
    if (user2 === this.currentUser) {
      this.notifyAuthListeners();
    }
  }
  _key() {
    return `${this.config.authDomain}:${this.config.apiKey}:${this.name}`;
  }
  _startProactiveRefresh() {
    this.isProactiveRefreshEnabled = true;
    if (this.currentUser) {
      this._currentUser._startProactiveRefresh();
    }
  }
  _stopProactiveRefresh() {
    this.isProactiveRefreshEnabled = false;
    if (this.currentUser) {
      this._currentUser._stopProactiveRefresh();
    }
  }
  get _currentUser() {
    return this.currentUser;
  }
  notifyAuthListeners() {
    var _a, _b;
    if (!this._isInitialized) {
      return;
    }
    this.idTokenSubscription.next(this.currentUser);
    const currentUid = (_b = (_a = this.currentUser) === null || _a === void 0 ? void 0 : _a.uid) !== null && _b !== void 0 ? _b : null;
    if (this.lastNotifiedUid !== currentUid) {
      this.lastNotifiedUid = currentUid;
      this.authStateSubscription.next(this.currentUser);
    }
  }
  registerStateListener(subscription, nextOrObserver, error2, completed) {
    if (this._deleted) {
      return () => {
      };
    }
    const cb = typeof nextOrObserver === "function" ? nextOrObserver : nextOrObserver.next.bind(nextOrObserver);
    const promise = this._isInitialized ? Promise.resolve() : this._initializationPromise;
    _assert(promise, this, "internal-error");
    promise.then(() => cb(this.currentUser));
    if (typeof nextOrObserver === "function") {
      return subscription.addObserver(nextOrObserver, error2, completed);
    } else {
      return subscription.addObserver(nextOrObserver);
    }
  }
  async directlySetCurrentUser(user2) {
    if (this.currentUser && this.currentUser !== user2) {
      this._currentUser._stopProactiveRefresh();
      if (user2 && this.isProactiveRefreshEnabled) {
        user2._startProactiveRefresh();
      }
    }
    this.currentUser = user2;
    if (user2) {
      await this.assertedPersistence.setCurrentUser(user2);
    } else {
      await this.assertedPersistence.removeCurrentUser();
    }
  }
  queue(action) {
    this.operations = this.operations.then(action, action);
    return this.operations;
  }
  get assertedPersistence() {
    _assert(this.persistenceManager, this, "internal-error");
    return this.persistenceManager;
  }
  _logFramework(framework) {
    if (!framework || this.frameworks.includes(framework)) {
      return;
    }
    this.frameworks.push(framework);
    this.frameworks.sort();
    this.clientVersion = _getClientVersion(this.config.clientPlatform, this._getFrameworks());
  }
  _getFrameworks() {
    return this.frameworks;
  }
  _getSdkClientVersion() {
    return this.clientVersion;
  }
};
function _castAuth(auth2) {
  return getModularInstance(auth2);
}
var Subscription = class {
  constructor(auth2) {
    this.auth = auth2;
    this.observer = null;
    this.addObserver = createSubscribe((observer) => this.observer = observer);
  }
  get next() {
    _assert(this.observer, this.auth, "internal-error");
    return this.observer.next.bind(this.observer);
  }
};
var AuthCredential = class {
  constructor(providerId, signInMethod) {
    this.providerId = providerId;
    this.signInMethod = signInMethod;
  }
  toJSON() {
    return debugFail("not implemented");
  }
  _getIdTokenResponse(_auth) {
    return debugFail("not implemented");
  }
  _linkToIdToken(_auth, _idToken) {
    return debugFail("not implemented");
  }
  _getReauthenticationResolver(_auth) {
    return debugFail("not implemented");
  }
};
async function signInWithIdp(auth2, request) {
  return _performSignInRequest(auth2, "POST", "/v1/accounts:signInWithIdp", _addTidIfNecessary(auth2, request));
}
var IDP_REQUEST_URI$1 = "http://localhost";
var OAuthCredential = class extends AuthCredential {
  constructor() {
    super(...arguments);
    this.pendingToken = null;
  }
  static _fromParams(params) {
    const cred = new OAuthCredential(params.providerId, params.signInMethod);
    if (params.idToken || params.accessToken) {
      if (params.idToken) {
        cred.idToken = params.idToken;
      }
      if (params.accessToken) {
        cred.accessToken = params.accessToken;
      }
      if (params.nonce && !params.pendingToken) {
        cred.nonce = params.nonce;
      }
      if (params.pendingToken) {
        cred.pendingToken = params.pendingToken;
      }
    } else if (params.oauthToken && params.oauthTokenSecret) {
      cred.accessToken = params.oauthToken;
      cred.secret = params.oauthTokenSecret;
    } else {
      _fail("argument-error");
    }
    return cred;
  }
  toJSON() {
    return {
      idToken: this.idToken,
      accessToken: this.accessToken,
      secret: this.secret,
      nonce: this.nonce,
      pendingToken: this.pendingToken,
      providerId: this.providerId,
      signInMethod: this.signInMethod
    };
  }
  static fromJSON(json) {
    const obj = typeof json === "string" ? JSON.parse(json) : json;
    const { providerId, signInMethod } = obj, rest = __rest(obj, ["providerId", "signInMethod"]);
    if (!providerId || !signInMethod) {
      return null;
    }
    const cred = new OAuthCredential(providerId, signInMethod);
    cred.idToken = rest.idToken || void 0;
    cred.accessToken = rest.accessToken || void 0;
    cred.secret = rest.secret;
    cred.nonce = rest.nonce;
    cred.pendingToken = rest.pendingToken || null;
    return cred;
  }
  _getIdTokenResponse(auth2) {
    const request = this.buildRequest();
    return signInWithIdp(auth2, request);
  }
  _linkToIdToken(auth2, idToken) {
    const request = this.buildRequest();
    request.idToken = idToken;
    return signInWithIdp(auth2, request);
  }
  _getReauthenticationResolver(auth2) {
    const request = this.buildRequest();
    request.autoCreate = false;
    return signInWithIdp(auth2, request);
  }
  buildRequest() {
    const request = {
      requestUri: IDP_REQUEST_URI$1,
      returnSecureToken: true
    };
    if (this.pendingToken) {
      request.pendingToken = this.pendingToken;
    } else {
      const postBody = {};
      if (this.idToken) {
        postBody["id_token"] = this.idToken;
      }
      if (this.accessToken) {
        postBody["access_token"] = this.accessToken;
      }
      if (this.secret) {
        postBody["oauth_token_secret"] = this.secret;
      }
      postBody["providerId"] = this.providerId;
      if (this.nonce && !this.pendingToken) {
        postBody["nonce"] = this.nonce;
      }
      request.postBody = querystring(postBody);
    }
    return request;
  }
};
var FederatedAuthProvider = class {
  constructor(providerId) {
    this.providerId = providerId;
    this.defaultLanguageCode = null;
    this.customParameters = {};
  }
  setDefaultLanguage(languageCode) {
    this.defaultLanguageCode = languageCode;
  }
  setCustomParameters(customOAuthParameters) {
    this.customParameters = customOAuthParameters;
    return this;
  }
  getCustomParameters() {
    return this.customParameters;
  }
};
var BaseOAuthProvider = class extends FederatedAuthProvider {
  constructor() {
    super(...arguments);
    this.scopes = [];
  }
  addScope(scope) {
    if (!this.scopes.includes(scope)) {
      this.scopes.push(scope);
    }
    return this;
  }
  getScopes() {
    return [...this.scopes];
  }
};
var FacebookAuthProvider = class extends BaseOAuthProvider {
  constructor() {
    super("facebook.com");
  }
  static credential(accessToken) {
    return OAuthCredential._fromParams({
      providerId: FacebookAuthProvider.PROVIDER_ID,
      signInMethod: FacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD,
      accessToken
    });
  }
  static credentialFromResult(userCredential) {
    return FacebookAuthProvider.credentialFromTaggedObject(userCredential);
  }
  static credentialFromError(error2) {
    return FacebookAuthProvider.credentialFromTaggedObject(error2.customData || {});
  }
  static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {
    if (!tokenResponse || !("oauthAccessToken" in tokenResponse)) {
      return null;
    }
    if (!tokenResponse.oauthAccessToken) {
      return null;
    }
    try {
      return FacebookAuthProvider.credential(tokenResponse.oauthAccessToken);
    } catch (_a) {
      return null;
    }
  }
};
FacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD = "facebook.com";
FacebookAuthProvider.PROVIDER_ID = "facebook.com";
var GoogleAuthProvider = class extends BaseOAuthProvider {
  constructor() {
    super("google.com");
    this.addScope("profile");
  }
  static credential(idToken, accessToken) {
    return OAuthCredential._fromParams({
      providerId: GoogleAuthProvider.PROVIDER_ID,
      signInMethod: GoogleAuthProvider.GOOGLE_SIGN_IN_METHOD,
      idToken,
      accessToken
    });
  }
  static credentialFromResult(userCredential) {
    return GoogleAuthProvider.credentialFromTaggedObject(userCredential);
  }
  static credentialFromError(error2) {
    return GoogleAuthProvider.credentialFromTaggedObject(error2.customData || {});
  }
  static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {
    if (!tokenResponse) {
      return null;
    }
    const { oauthIdToken, oauthAccessToken } = tokenResponse;
    if (!oauthIdToken && !oauthAccessToken) {
      return null;
    }
    try {
      return GoogleAuthProvider.credential(oauthIdToken, oauthAccessToken);
    } catch (_a) {
      return null;
    }
  }
};
GoogleAuthProvider.GOOGLE_SIGN_IN_METHOD = "google.com";
GoogleAuthProvider.PROVIDER_ID = "google.com";
var GithubAuthProvider = class extends BaseOAuthProvider {
  constructor() {
    super("github.com");
  }
  static credential(accessToken) {
    return OAuthCredential._fromParams({
      providerId: GithubAuthProvider.PROVIDER_ID,
      signInMethod: GithubAuthProvider.GITHUB_SIGN_IN_METHOD,
      accessToken
    });
  }
  static credentialFromResult(userCredential) {
    return GithubAuthProvider.credentialFromTaggedObject(userCredential);
  }
  static credentialFromError(error2) {
    return GithubAuthProvider.credentialFromTaggedObject(error2.customData || {});
  }
  static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {
    if (!tokenResponse || !("oauthAccessToken" in tokenResponse)) {
      return null;
    }
    if (!tokenResponse.oauthAccessToken) {
      return null;
    }
    try {
      return GithubAuthProvider.credential(tokenResponse.oauthAccessToken);
    } catch (_a) {
      return null;
    }
  }
};
GithubAuthProvider.GITHUB_SIGN_IN_METHOD = "github.com";
GithubAuthProvider.PROVIDER_ID = "github.com";
var TwitterAuthProvider = class extends BaseOAuthProvider {
  constructor() {
    super("twitter.com");
  }
  static credential(token, secret) {
    return OAuthCredential._fromParams({
      providerId: TwitterAuthProvider.PROVIDER_ID,
      signInMethod: TwitterAuthProvider.TWITTER_SIGN_IN_METHOD,
      oauthToken: token,
      oauthTokenSecret: secret
    });
  }
  static credentialFromResult(userCredential) {
    return TwitterAuthProvider.credentialFromTaggedObject(userCredential);
  }
  static credentialFromError(error2) {
    return TwitterAuthProvider.credentialFromTaggedObject(error2.customData || {});
  }
  static credentialFromTaggedObject({ _tokenResponse: tokenResponse }) {
    if (!tokenResponse) {
      return null;
    }
    const { oauthAccessToken, oauthTokenSecret } = tokenResponse;
    if (!oauthAccessToken || !oauthTokenSecret) {
      return null;
    }
    try {
      return TwitterAuthProvider.credential(oauthAccessToken, oauthTokenSecret);
    } catch (_a) {
      return null;
    }
  }
};
TwitterAuthProvider.TWITTER_SIGN_IN_METHOD = "twitter.com";
TwitterAuthProvider.PROVIDER_ID = "twitter.com";
var UserCredentialImpl = class {
  constructor(params) {
    this.user = params.user;
    this.providerId = params.providerId;
    this._tokenResponse = params._tokenResponse;
    this.operationType = params.operationType;
  }
  static async _fromIdTokenResponse(auth2, operationType, idTokenResponse, isAnonymous = false) {
    const user2 = await UserImpl._fromIdTokenResponse(auth2, idTokenResponse, isAnonymous);
    const providerId = providerIdForResponse(idTokenResponse);
    const userCred = new UserCredentialImpl({
      user: user2,
      providerId,
      _tokenResponse: idTokenResponse,
      operationType
    });
    return userCred;
  }
  static async _forOperation(user2, operationType, response) {
    await user2._updateTokensIfNecessary(response, true);
    const providerId = providerIdForResponse(response);
    return new UserCredentialImpl({
      user: user2,
      providerId,
      _tokenResponse: response,
      operationType
    });
  }
};
function providerIdForResponse(response) {
  if (response.providerId) {
    return response.providerId;
  }
  if ("phoneNumber" in response) {
    return "phone";
  }
  return null;
}
var MultiFactorError = class extends FirebaseError {
  constructor(auth2, error2, operationType, user2) {
    var _a;
    super(error2.code, error2.message);
    this.operationType = operationType;
    this.user = user2;
    this.name = "FirebaseError";
    Object.setPrototypeOf(this, MultiFactorError.prototype);
    this.appName = auth2.name;
    this.code = error2.code;
    this.tenantId = (_a = auth2.tenantId) !== null && _a !== void 0 ? _a : void 0;
    this.serverResponse = error2.customData.serverResponse;
  }
  static _fromErrorAndOperation(auth2, error2, operationType, user2) {
    return new MultiFactorError(auth2, error2, operationType, user2);
  }
};
function _processCredentialSavingMfaContextIfNecessary(auth2, operationType, credential, user2) {
  const idTokenProvider = operationType === "reauthenticate" ? credential._getReauthenticationResolver(auth2) : credential._getIdTokenResponse(auth2);
  return idTokenProvider.catch((error2) => {
    if (error2.code === `auth/${"multi-factor-auth-required"}`) {
      throw MultiFactorError._fromErrorAndOperation(auth2, error2, operationType, user2);
    }
    throw error2;
  });
}
async function _link$1(user2, credential, bypassAuthState = false) {
  const response = await _logoutIfInvalidated(user2, credential._linkToIdToken(user2.auth, await user2.getIdToken()), bypassAuthState);
  return UserCredentialImpl._forOperation(user2, "link", response);
}
async function _reauthenticate(user2, credential, bypassAuthState = false) {
  const { auth: auth2 } = user2;
  const operationType = "reauthenticate";
  try {
    const response = await _logoutIfInvalidated(user2, _processCredentialSavingMfaContextIfNecessary(auth2, operationType, credential, user2), bypassAuthState);
    _assert(response.idToken, auth2, "internal-error");
    const parsed = _parseToken(response.idToken);
    _assert(parsed, auth2, "internal-error");
    const { sub: localId } = parsed;
    _assert(user2.uid === localId, auth2, "user-mismatch");
    return UserCredentialImpl._forOperation(user2, operationType, response);
  } catch (e) {
    if ((e === null || e === void 0 ? void 0 : e.code) === `auth/${"user-not-found"}`) {
      _fail(auth2, "user-mismatch");
    }
    throw e;
  }
}
async function _signInWithCredential(auth2, credential, bypassAuthState = false) {
  const operationType = "signIn";
  const response = await _processCredentialSavingMfaContextIfNecessary(auth2, operationType, credential);
  const userCredential = await UserCredentialImpl._fromIdTokenResponse(auth2, operationType, response);
  if (!bypassAuthState) {
    await auth2._updateCurrentUser(userCredential.user);
  }
  return userCredential;
}
function onAuthStateChanged(auth2, nextOrObserver, error2, completed) {
  return getModularInstance(auth2).onAuthStateChanged(nextOrObserver, error2, completed);
}
var STORAGE_AVAILABLE_KEY = "__sak";
var BrowserPersistenceClass = class {
  constructor(storage2, type) {
    this.storage = storage2;
    this.type = type;
  }
  _isAvailable() {
    try {
      if (!this.storage) {
        return Promise.resolve(false);
      }
      this.storage.setItem(STORAGE_AVAILABLE_KEY, "1");
      this.storage.removeItem(STORAGE_AVAILABLE_KEY);
      return Promise.resolve(true);
    } catch (_a) {
      return Promise.resolve(false);
    }
  }
  _set(key, value) {
    this.storage.setItem(key, JSON.stringify(value));
    return Promise.resolve();
  }
  _get(key) {
    const json = this.storage.getItem(key);
    return Promise.resolve(json ? JSON.parse(json) : null);
  }
  _remove(key) {
    this.storage.removeItem(key);
    return Promise.resolve();
  }
};
function _iframeCannotSyncWebStorage() {
  const ua = getUA();
  return _isSafari(ua) || _isIOS(ua);
}
var _POLLING_INTERVAL_MS$1 = 1e3;
var IE10_LOCAL_STORAGE_SYNC_DELAY = 10;
var BrowserLocalPersistence = class extends BrowserPersistenceClass {
  constructor() {
    super(window.localStorage, "LOCAL");
    this.boundEventHandler = (event, poll) => this.onStorageEvent(event, poll);
    this.listeners = {};
    this.localCache = {};
    this.pollTimer = null;
    this.safariLocalStorageNotSynced = _iframeCannotSyncWebStorage() && _isIframe();
    this.fallbackToPolling = _isMobileBrowser();
    this._shouldAllowMigration = true;
  }
  forAllChangedKeys(cb) {
    for (const key of Object.keys(this.listeners)) {
      const newValue = this.storage.getItem(key);
      const oldValue = this.localCache[key];
      if (newValue !== oldValue) {
        cb(key, oldValue, newValue);
      }
    }
  }
  onStorageEvent(event, poll = false) {
    if (!event.key) {
      this.forAllChangedKeys((key2, _oldValue, newValue) => {
        this.notifyListeners(key2, newValue);
      });
      return;
    }
    const key = event.key;
    if (poll) {
      this.detachListener();
    } else {
      this.stopPolling();
    }
    if (this.safariLocalStorageNotSynced) {
      const storedValue2 = this.storage.getItem(key);
      if (event.newValue !== storedValue2) {
        if (event.newValue !== null) {
          this.storage.setItem(key, event.newValue);
        } else {
          this.storage.removeItem(key);
        }
      } else if (this.localCache[key] === event.newValue && !poll) {
        return;
      }
    }
    const triggerListeners = () => {
      const storedValue2 = this.storage.getItem(key);
      if (!poll && this.localCache[key] === storedValue2) {
        return;
      }
      this.notifyListeners(key, storedValue2);
    };
    const storedValue = this.storage.getItem(key);
    if (_isIE10() && storedValue !== event.newValue && event.newValue !== event.oldValue) {
      setTimeout(triggerListeners, IE10_LOCAL_STORAGE_SYNC_DELAY);
    } else {
      triggerListeners();
    }
  }
  notifyListeners(key, value) {
    this.localCache[key] = value;
    const listeners = this.listeners[key];
    if (listeners) {
      for (const listener of Array.from(listeners)) {
        listener(value ? JSON.parse(value) : value);
      }
    }
  }
  startPolling() {
    this.stopPolling();
    this.pollTimer = setInterval(() => {
      this.forAllChangedKeys((key, oldValue, newValue) => {
        this.onStorageEvent(new StorageEvent("storage", {
          key,
          oldValue,
          newValue
        }), true);
      });
    }, _POLLING_INTERVAL_MS$1);
  }
  stopPolling() {
    if (this.pollTimer) {
      clearInterval(this.pollTimer);
      this.pollTimer = null;
    }
  }
  attachListener() {
    window.addEventListener("storage", this.boundEventHandler);
  }
  detachListener() {
    window.removeEventListener("storage", this.boundEventHandler);
  }
  _addListener(key, listener) {
    if (Object.keys(this.listeners).length === 0) {
      if (this.fallbackToPolling) {
        this.startPolling();
      } else {
        this.attachListener();
      }
    }
    if (!this.listeners[key]) {
      this.listeners[key] = new Set();
      this.localCache[key] = this.storage.getItem(key);
    }
    this.listeners[key].add(listener);
  }
  _removeListener(key, listener) {
    if (this.listeners[key]) {
      this.listeners[key].delete(listener);
      if (this.listeners[key].size === 0) {
        delete this.listeners[key];
      }
    }
    if (Object.keys(this.listeners).length === 0) {
      this.detachListener();
      this.stopPolling();
    }
  }
  async _set(key, value) {
    await super._set(key, value);
    this.localCache[key] = JSON.stringify(value);
  }
  async _get(key) {
    const value = await super._get(key);
    this.localCache[key] = JSON.stringify(value);
    return value;
  }
  async _remove(key) {
    await super._remove(key);
    delete this.localCache[key];
  }
};
BrowserLocalPersistence.type = "LOCAL";
var browserLocalPersistence = BrowserLocalPersistence;
var BrowserSessionPersistence = class extends BrowserPersistenceClass {
  constructor() {
    super(window.sessionStorage, "SESSION");
  }
  _addListener(_key, _listener) {
    return;
  }
  _removeListener(_key, _listener) {
    return;
  }
};
BrowserSessionPersistence.type = "SESSION";
var browserSessionPersistence = BrowserSessionPersistence;
function _allSettled(promises) {
  return Promise.all(promises.map(async (promise) => {
    try {
      const value = await promise;
      return {
        fulfilled: true,
        value
      };
    } catch (reason) {
      return {
        fulfilled: false,
        reason
      };
    }
  }));
}
var Receiver = class {
  constructor(eventTarget) {
    this.eventTarget = eventTarget;
    this.handlersMap = {};
    this.boundEventHandler = this.handleEvent.bind(this);
  }
  static _getInstance(eventTarget) {
    const existingInstance = this.receivers.find((receiver) => receiver.isListeningto(eventTarget));
    if (existingInstance) {
      return existingInstance;
    }
    const newInstance = new Receiver(eventTarget);
    this.receivers.push(newInstance);
    return newInstance;
  }
  isListeningto(eventTarget) {
    return this.eventTarget === eventTarget;
  }
  async handleEvent(event) {
    const messageEvent = event;
    const { eventId, eventType, data } = messageEvent.data;
    const handlers = this.handlersMap[eventType];
    if (!(handlers === null || handlers === void 0 ? void 0 : handlers.size)) {
      return;
    }
    messageEvent.ports[0].postMessage({
      status: "ack",
      eventId,
      eventType
    });
    const promises = Array.from(handlers).map(async (handler2) => handler2(messageEvent.origin, data));
    const response = await _allSettled(promises);
    messageEvent.ports[0].postMessage({
      status: "done",
      eventId,
      eventType,
      response
    });
  }
  _subscribe(eventType, eventHandler) {
    if (Object.keys(this.handlersMap).length === 0) {
      this.eventTarget.addEventListener("message", this.boundEventHandler);
    }
    if (!this.handlersMap[eventType]) {
      this.handlersMap[eventType] = new Set();
    }
    this.handlersMap[eventType].add(eventHandler);
  }
  _unsubscribe(eventType, eventHandler) {
    if (this.handlersMap[eventType] && eventHandler) {
      this.handlersMap[eventType].delete(eventHandler);
    }
    if (!eventHandler || this.handlersMap[eventType].size === 0) {
      delete this.handlersMap[eventType];
    }
    if (Object.keys(this.handlersMap).length === 0) {
      this.eventTarget.removeEventListener("message", this.boundEventHandler);
    }
  }
};
Receiver.receivers = [];
function _generateEventId(prefix = "", digits = 10) {
  let random = "";
  for (let i = 0; i < digits; i++) {
    random += Math.floor(Math.random() * 10);
  }
  return prefix + random;
}
var Sender = class {
  constructor(target) {
    this.target = target;
    this.handlers = new Set();
  }
  removeMessageHandler(handler2) {
    if (handler2.messageChannel) {
      handler2.messageChannel.port1.removeEventListener("message", handler2.onMessage);
      handler2.messageChannel.port1.close();
    }
    this.handlers.delete(handler2);
  }
  async _send(eventType, data, timeout = 50) {
    const messageChannel = typeof MessageChannel !== "undefined" ? new MessageChannel() : null;
    if (!messageChannel) {
      throw new Error("connection_unavailable");
    }
    let completionTimer;
    let handler2;
    return new Promise((resolve2, reject) => {
      const eventId = _generateEventId("", 20);
      messageChannel.port1.start();
      const ackTimer = setTimeout(() => {
        reject(new Error("unsupported_event"));
      }, timeout);
      handler2 = {
        messageChannel,
        onMessage(event) {
          const messageEvent = event;
          if (messageEvent.data.eventId !== eventId) {
            return;
          }
          switch (messageEvent.data.status) {
            case "ack":
              clearTimeout(ackTimer);
              completionTimer = setTimeout(() => {
                reject(new Error("timeout"));
              }, 3e3);
              break;
            case "done":
              clearTimeout(completionTimer);
              resolve2(messageEvent.data.response);
              break;
            default:
              clearTimeout(ackTimer);
              clearTimeout(completionTimer);
              reject(new Error("invalid_response"));
              break;
          }
        }
      };
      this.handlers.add(handler2);
      messageChannel.port1.addEventListener("message", handler2.onMessage);
      this.target.postMessage({
        eventType,
        eventId,
        data
      }, [messageChannel.port2]);
    }).finally(() => {
      if (handler2) {
        this.removeMessageHandler(handler2);
      }
    });
  }
};
function _window() {
  return window;
}
function _setWindowLocation(url) {
  _window().location.href = url;
}
function _isWorker() {
  return typeof _window()["WorkerGlobalScope"] !== "undefined" && typeof _window()["importScripts"] === "function";
}
async function _getActiveServiceWorker() {
  if (!(navigator === null || navigator === void 0 ? void 0 : navigator.serviceWorker)) {
    return null;
  }
  try {
    const registration = await navigator.serviceWorker.ready;
    return registration.active;
  } catch (_a) {
    return null;
  }
}
function _getServiceWorkerController() {
  var _a;
  return ((_a = navigator === null || navigator === void 0 ? void 0 : navigator.serviceWorker) === null || _a === void 0 ? void 0 : _a.controller) || null;
}
function _getWorkerGlobalScope() {
  return _isWorker() ? self : null;
}
var DB_NAME = "firebaseLocalStorageDb";
var DB_VERSION = 1;
var DB_OBJECTSTORE_NAME = "firebaseLocalStorage";
var DB_DATA_KEYPATH = "fbase_key";
var DBPromise = class {
  constructor(request) {
    this.request = request;
  }
  toPromise() {
    return new Promise((resolve2, reject) => {
      this.request.addEventListener("success", () => {
        resolve2(this.request.result);
      });
      this.request.addEventListener("error", () => {
        reject(this.request.error);
      });
    });
  }
};
function getObjectStore(db2, isReadWrite) {
  return db2.transaction([DB_OBJECTSTORE_NAME], isReadWrite ? "readwrite" : "readonly").objectStore(DB_OBJECTSTORE_NAME);
}
function _deleteDatabase() {
  const request = indexedDB.deleteDatabase(DB_NAME);
  return new DBPromise(request).toPromise();
}
function _openDatabase() {
  const request = indexedDB.open(DB_NAME, DB_VERSION);
  return new Promise((resolve2, reject) => {
    request.addEventListener("error", () => {
      reject(request.error);
    });
    request.addEventListener("upgradeneeded", () => {
      const db2 = request.result;
      try {
        db2.createObjectStore(DB_OBJECTSTORE_NAME, { keyPath: DB_DATA_KEYPATH });
      } catch (e) {
        reject(e);
      }
    });
    request.addEventListener("success", async () => {
      const db2 = request.result;
      if (!db2.objectStoreNames.contains(DB_OBJECTSTORE_NAME)) {
        db2.close();
        await _deleteDatabase();
        resolve2(await _openDatabase());
      } else {
        resolve2(db2);
      }
    });
  });
}
async function _putObject(db2, key, value) {
  const request = getObjectStore(db2, true).put({
    [DB_DATA_KEYPATH]: key,
    value
  });
  return new DBPromise(request).toPromise();
}
async function getObject(db2, key) {
  const request = getObjectStore(db2, false).get(key);
  const data = await new DBPromise(request).toPromise();
  return data === void 0 ? null : data.value;
}
function _deleteObject(db2, key) {
  const request = getObjectStore(db2, true).delete(key);
  return new DBPromise(request).toPromise();
}
var _POLLING_INTERVAL_MS = 800;
var _TRANSACTION_RETRY_COUNT = 3;
var IndexedDBLocalPersistence = class {
  constructor() {
    this.type = "LOCAL";
    this._shouldAllowMigration = true;
    this.listeners = {};
    this.localCache = {};
    this.pollTimer = null;
    this.pendingWrites = 0;
    this.receiver = null;
    this.sender = null;
    this.serviceWorkerReceiverAvailable = false;
    this.activeServiceWorker = null;
    this._workerInitializationPromise = this.initializeServiceWorkerMessaging().then(() => {
    }, () => {
    });
  }
  async _openDb() {
    if (this.db) {
      return this.db;
    }
    this.db = await _openDatabase();
    return this.db;
  }
  async _withRetries(op) {
    let numAttempts = 0;
    while (true) {
      try {
        const db2 = await this._openDb();
        return await op(db2);
      } catch (e) {
        if (numAttempts++ > _TRANSACTION_RETRY_COUNT) {
          throw e;
        }
        if (this.db) {
          this.db.close();
          this.db = void 0;
        }
      }
    }
  }
  async initializeServiceWorkerMessaging() {
    return _isWorker() ? this.initializeReceiver() : this.initializeSender();
  }
  async initializeReceiver() {
    this.receiver = Receiver._getInstance(_getWorkerGlobalScope());
    this.receiver._subscribe("keyChanged", async (_origin, data) => {
      const keys = await this._poll();
      return {
        keyProcessed: keys.includes(data.key)
      };
    });
    this.receiver._subscribe("ping", async (_origin, _data) => {
      return ["keyChanged"];
    });
  }
  async initializeSender() {
    var _a, _b;
    this.activeServiceWorker = await _getActiveServiceWorker();
    if (!this.activeServiceWorker) {
      return;
    }
    this.sender = new Sender(this.activeServiceWorker);
    const results = await this.sender._send("ping", {}, 800);
    if (!results) {
      return;
    }
    if (((_a = results[0]) === null || _a === void 0 ? void 0 : _a.fulfilled) && ((_b = results[0]) === null || _b === void 0 ? void 0 : _b.value.includes("keyChanged"))) {
      this.serviceWorkerReceiverAvailable = true;
    }
  }
  async notifyServiceWorker(key) {
    if (!this.sender || !this.activeServiceWorker || _getServiceWorkerController() !== this.activeServiceWorker) {
      return;
    }
    try {
      await this.sender._send("keyChanged", { key }, this.serviceWorkerReceiverAvailable ? 800 : 50);
    } catch (_a) {
    }
  }
  async _isAvailable() {
    try {
      if (!indexedDB) {
        return false;
      }
      const db2 = await _openDatabase();
      await _putObject(db2, STORAGE_AVAILABLE_KEY, "1");
      await _deleteObject(db2, STORAGE_AVAILABLE_KEY);
      return true;
    } catch (_a) {
    }
    return false;
  }
  async _withPendingWrite(write) {
    this.pendingWrites++;
    try {
      await write();
    } finally {
      this.pendingWrites--;
    }
  }
  async _set(key, value) {
    return this._withPendingWrite(async () => {
      await this._withRetries((db2) => _putObject(db2, key, value));
      this.localCache[key] = value;
      return this.notifyServiceWorker(key);
    });
  }
  async _get(key) {
    const obj = await this._withRetries((db2) => getObject(db2, key));
    this.localCache[key] = obj;
    return obj;
  }
  async _remove(key) {
    return this._withPendingWrite(async () => {
      await this._withRetries((db2) => _deleteObject(db2, key));
      delete this.localCache[key];
      return this.notifyServiceWorker(key);
    });
  }
  async _poll() {
    const result = await this._withRetries((db2) => {
      const getAllRequest = getObjectStore(db2, false).getAll();
      return new DBPromise(getAllRequest).toPromise();
    });
    if (!result) {
      return [];
    }
    if (this.pendingWrites !== 0) {
      return [];
    }
    const keys = [];
    const keysInResult = new Set();
    for (const { fbase_key: key, value } of result) {
      keysInResult.add(key);
      if (JSON.stringify(this.localCache[key]) !== JSON.stringify(value)) {
        this.notifyListeners(key, value);
        keys.push(key);
      }
    }
    for (const localKey of Object.keys(this.localCache)) {
      if (this.localCache[localKey] && !keysInResult.has(localKey)) {
        this.notifyListeners(localKey, null);
        keys.push(localKey);
      }
    }
    return keys;
  }
  notifyListeners(key, newValue) {
    this.localCache[key] = newValue;
    const listeners = this.listeners[key];
    if (listeners) {
      for (const listener of Array.from(listeners)) {
        listener(newValue);
      }
    }
  }
  startPolling() {
    this.stopPolling();
    this.pollTimer = setInterval(async () => this._poll(), _POLLING_INTERVAL_MS);
  }
  stopPolling() {
    if (this.pollTimer) {
      clearInterval(this.pollTimer);
      this.pollTimer = null;
    }
  }
  _addListener(key, listener) {
    if (Object.keys(this.listeners).length === 0) {
      this.startPolling();
    }
    if (!this.listeners[key]) {
      this.listeners[key] = new Set();
      void this._get(key);
    }
    this.listeners[key].add(listener);
  }
  _removeListener(key, listener) {
    if (this.listeners[key]) {
      this.listeners[key].delete(listener);
      if (this.listeners[key].size === 0) {
        delete this.listeners[key];
      }
    }
    if (Object.keys(this.listeners).length === 0) {
      this.stopPolling();
    }
  }
};
IndexedDBLocalPersistence.type = "LOCAL";
var indexedDBLocalPersistence = IndexedDBLocalPersistence;
function getScriptParentElement() {
  var _a, _b;
  return (_b = (_a = document.getElementsByTagName("head")) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : document;
}
function _loadJS(url) {
  return new Promise((resolve2, reject) => {
    const el = document.createElement("script");
    el.setAttribute("src", url);
    el.onload = resolve2;
    el.onerror = (e) => {
      const error2 = _createError("internal-error");
      error2.customData = e;
      reject(error2);
    };
    el.type = "text/javascript";
    el.charset = "UTF-8";
    getScriptParentElement().appendChild(el);
  });
}
function _generateCallbackName(prefix) {
  return `__${prefix}${Math.floor(Math.random() * 1e6)}`;
}
new Delay(3e4, 6e4);
function _withDefaultResolver(auth2, resolverOverride) {
  if (resolverOverride) {
    return _getInstance(resolverOverride);
  }
  _assert(auth2._popupRedirectResolver, auth2, "argument-error");
  return auth2._popupRedirectResolver;
}
var IdpCredential = class extends AuthCredential {
  constructor(params) {
    super("custom", "custom");
    this.params = params;
  }
  _getIdTokenResponse(auth2) {
    return signInWithIdp(auth2, this._buildIdpRequest());
  }
  _linkToIdToken(auth2, idToken) {
    return signInWithIdp(auth2, this._buildIdpRequest(idToken));
  }
  _getReauthenticationResolver(auth2) {
    return signInWithIdp(auth2, this._buildIdpRequest());
  }
  _buildIdpRequest(idToken) {
    const request = {
      requestUri: this.params.requestUri,
      sessionId: this.params.sessionId,
      postBody: this.params.postBody,
      tenantId: this.params.tenantId,
      pendingToken: this.params.pendingToken,
      returnSecureToken: true,
      returnIdpCredential: true
    };
    if (idToken) {
      request.idToken = idToken;
    }
    return request;
  }
};
function _signIn(params) {
  return _signInWithCredential(params.auth, new IdpCredential(params), params.bypassAuthState);
}
function _reauth(params) {
  const { auth: auth2, user: user2 } = params;
  _assert(user2, auth2, "internal-error");
  return _reauthenticate(user2, new IdpCredential(params), params.bypassAuthState);
}
async function _link(params) {
  const { auth: auth2, user: user2 } = params;
  _assert(user2, auth2, "internal-error");
  return _link$1(user2, new IdpCredential(params), params.bypassAuthState);
}
var AbstractPopupRedirectOperation = class {
  constructor(auth2, filter2, resolver, user2, bypassAuthState = false) {
    this.auth = auth2;
    this.resolver = resolver;
    this.user = user2;
    this.bypassAuthState = bypassAuthState;
    this.pendingPromise = null;
    this.eventManager = null;
    this.filter = Array.isArray(filter2) ? filter2 : [filter2];
  }
  execute() {
    return new Promise(async (resolve2, reject) => {
      this.pendingPromise = { resolve: resolve2, reject };
      try {
        this.eventManager = await this.resolver._initialize(this.auth);
        await this.onExecution();
        this.eventManager.registerConsumer(this);
      } catch (e) {
        this.reject(e);
      }
    });
  }
  async onAuthEvent(event) {
    const { urlResponse, sessionId, postBody, tenantId, error: error2, type } = event;
    if (error2) {
      this.reject(error2);
      return;
    }
    const params = {
      auth: this.auth,
      requestUri: urlResponse,
      sessionId,
      tenantId: tenantId || void 0,
      postBody: postBody || void 0,
      user: this.user,
      bypassAuthState: this.bypassAuthState
    };
    try {
      this.resolve(await this.getIdpTask(type)(params));
    } catch (e) {
      this.reject(e);
    }
  }
  onError(error2) {
    this.reject(error2);
  }
  getIdpTask(type) {
    switch (type) {
      case "signInViaPopup":
      case "signInViaRedirect":
        return _signIn;
      case "linkViaPopup":
      case "linkViaRedirect":
        return _link;
      case "reauthViaPopup":
      case "reauthViaRedirect":
        return _reauth;
      default:
        _fail(this.auth, "internal-error");
    }
  }
  resolve(cred) {
    debugAssert(this.pendingPromise, "Pending promise was never set");
    this.pendingPromise.resolve(cred);
    this.unregisterAndCleanUp();
  }
  reject(error2) {
    debugAssert(this.pendingPromise, "Pending promise was never set");
    this.pendingPromise.reject(error2);
    this.unregisterAndCleanUp();
  }
  unregisterAndCleanUp() {
    if (this.eventManager) {
      this.eventManager.unregisterConsumer(this);
    }
    this.pendingPromise = null;
    this.cleanUp();
  }
};
var _POLL_WINDOW_CLOSE_TIMEOUT = new Delay(2e3, 1e4);
var PopupOperation = class extends AbstractPopupRedirectOperation {
  constructor(auth2, filter2, provider, resolver, user2) {
    super(auth2, filter2, resolver, user2);
    this.provider = provider;
    this.authWindow = null;
    this.pollId = null;
    if (PopupOperation.currentPopupAction) {
      PopupOperation.currentPopupAction.cancel();
    }
    PopupOperation.currentPopupAction = this;
  }
  async executeNotNull() {
    const result = await this.execute();
    _assert(result, this.auth, "internal-error");
    return result;
  }
  async onExecution() {
    debugAssert(this.filter.length === 1, "Popup operations only handle one event");
    const eventId = _generateEventId();
    this.authWindow = await this.resolver._openPopup(this.auth, this.provider, this.filter[0], eventId);
    this.authWindow.associatedEvent = eventId;
    this.resolver._originValidation(this.auth).catch((e) => {
      this.reject(e);
    });
    this.resolver._isIframeWebStorageSupported(this.auth, (isSupported) => {
      if (!isSupported) {
        this.reject(_createError(this.auth, "web-storage-unsupported"));
      }
    });
    this.pollUserCancellation();
  }
  get eventId() {
    var _a;
    return ((_a = this.authWindow) === null || _a === void 0 ? void 0 : _a.associatedEvent) || null;
  }
  cancel() {
    this.reject(_createError(this.auth, "cancelled-popup-request"));
  }
  cleanUp() {
    if (this.authWindow) {
      this.authWindow.close();
    }
    if (this.pollId) {
      window.clearTimeout(this.pollId);
    }
    this.authWindow = null;
    this.pollId = null;
    PopupOperation.currentPopupAction = null;
  }
  pollUserCancellation() {
    const poll = () => {
      var _a, _b;
      if ((_b = (_a = this.authWindow) === null || _a === void 0 ? void 0 : _a.window) === null || _b === void 0 ? void 0 : _b.closed) {
        this.pollId = window.setTimeout(() => {
          this.pollId = null;
          this.reject(_createError(this.auth, "popup-closed-by-user"));
        }, 2e3);
        return;
      }
      this.pollId = window.setTimeout(poll, _POLL_WINDOW_CLOSE_TIMEOUT.get());
    };
    poll();
  }
};
PopupOperation.currentPopupAction = null;
var PENDING_REDIRECT_KEY = "pendingRedirect";
var redirectOutcomeMap = new Map();
var RedirectAction = class extends AbstractPopupRedirectOperation {
  constructor(auth2, resolver, bypassAuthState = false) {
    super(auth2, [
      "signInViaRedirect",
      "linkViaRedirect",
      "reauthViaRedirect",
      "unknown"
    ], resolver, void 0, bypassAuthState);
    this.eventId = null;
  }
  async execute() {
    let readyOutcome = redirectOutcomeMap.get(this.auth._key());
    if (!readyOutcome) {
      try {
        const hasPendingRedirect = await _getAndClearPendingRedirectStatus(this.resolver, this.auth);
        const result = hasPendingRedirect ? await super.execute() : null;
        readyOutcome = () => Promise.resolve(result);
      } catch (e) {
        readyOutcome = () => Promise.reject(e);
      }
      redirectOutcomeMap.set(this.auth._key(), readyOutcome);
    }
    return readyOutcome();
  }
  async onAuthEvent(event) {
    if (event.type === "signInViaRedirect") {
      return super.onAuthEvent(event);
    } else if (event.type === "unknown") {
      this.resolve(null);
      return;
    }
    if (event.eventId) {
      const user2 = await this.auth._redirectUserForId(event.eventId);
      if (user2) {
        this.user = user2;
        return super.onAuthEvent(event);
      } else {
        this.resolve(null);
      }
    }
  }
  async onExecution() {
  }
  cleanUp() {
  }
};
async function _getAndClearPendingRedirectStatus(resolver, auth2) {
  const key = pendingRedirectKey(auth2);
  const hasPendingRedirect = await resolverPersistence(resolver)._get(key) === "true";
  await resolverPersistence(resolver)._remove(key);
  return hasPendingRedirect;
}
function resolverPersistence(resolver) {
  return _getInstance(resolver._redirectPersistence);
}
function pendingRedirectKey(auth2) {
  return _persistenceKeyName(PENDING_REDIRECT_KEY, auth2.config.apiKey, auth2.name);
}
async function _getRedirectResult(auth2, resolverExtern, bypassAuthState = false) {
  const authInternal = _castAuth(auth2);
  const resolver = _withDefaultResolver(authInternal, resolverExtern);
  const action = new RedirectAction(authInternal, resolver, bypassAuthState);
  const result = await action.execute();
  if (result && !bypassAuthState) {
    delete result.user._redirectEventId;
    await authInternal._persistUserIfCurrent(result.user);
    await authInternal._setRedirectUser(null, resolverExtern);
  }
  return result;
}
var EVENT_DUPLICATION_CACHE_DURATION_MS = 10 * 60 * 1e3;
var AuthEventManager = class {
  constructor(auth2) {
    this.auth = auth2;
    this.cachedEventUids = new Set();
    this.consumers = new Set();
    this.queuedRedirectEvent = null;
    this.hasHandledPotentialRedirect = false;
    this.lastProcessedEventTime = Date.now();
  }
  registerConsumer(authEventConsumer) {
    this.consumers.add(authEventConsumer);
    if (this.queuedRedirectEvent && this.isEventForConsumer(this.queuedRedirectEvent, authEventConsumer)) {
      this.sendToConsumer(this.queuedRedirectEvent, authEventConsumer);
      this.saveEventToCache(this.queuedRedirectEvent);
      this.queuedRedirectEvent = null;
    }
  }
  unregisterConsumer(authEventConsumer) {
    this.consumers.delete(authEventConsumer);
  }
  onEvent(event) {
    if (this.hasEventBeenHandled(event)) {
      return false;
    }
    let handled = false;
    this.consumers.forEach((consumer) => {
      if (this.isEventForConsumer(event, consumer)) {
        handled = true;
        this.sendToConsumer(event, consumer);
        this.saveEventToCache(event);
      }
    });
    if (this.hasHandledPotentialRedirect || !isRedirectEvent(event)) {
      return handled;
    }
    this.hasHandledPotentialRedirect = true;
    if (!handled) {
      this.queuedRedirectEvent = event;
      handled = true;
    }
    return handled;
  }
  sendToConsumer(event, consumer) {
    var _a;
    if (event.error && !isNullRedirectEvent(event)) {
      const code = ((_a = event.error.code) === null || _a === void 0 ? void 0 : _a.split("auth/")[1]) || "internal-error";
      consumer.onError(_createError(this.auth, code));
    } else {
      consumer.onAuthEvent(event);
    }
  }
  isEventForConsumer(event, consumer) {
    const eventIdMatches = consumer.eventId === null || !!event.eventId && event.eventId === consumer.eventId;
    return consumer.filter.includes(event.type) && eventIdMatches;
  }
  hasEventBeenHandled(event) {
    if (Date.now() - this.lastProcessedEventTime >= EVENT_DUPLICATION_CACHE_DURATION_MS) {
      this.cachedEventUids.clear();
    }
    return this.cachedEventUids.has(eventUid(event));
  }
  saveEventToCache(event) {
    this.cachedEventUids.add(eventUid(event));
    this.lastProcessedEventTime = Date.now();
  }
};
function eventUid(e) {
  return [e.type, e.eventId, e.sessionId, e.tenantId].filter((v) => v).join("-");
}
function isNullRedirectEvent({ type, error: error2 }) {
  return type === "unknown" && (error2 === null || error2 === void 0 ? void 0 : error2.code) === `auth/${"no-auth-event"}`;
}
function isRedirectEvent(event) {
  switch (event.type) {
    case "signInViaRedirect":
    case "linkViaRedirect":
    case "reauthViaRedirect":
      return true;
    case "unknown":
      return isNullRedirectEvent(event);
    default:
      return false;
  }
}
async function _getProjectConfig(auth2, request = {}) {
  return _performApiRequest(auth2, "GET", "/v1/projects", request);
}
var IP_ADDRESS_REGEX = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
var HTTP_REGEX = /^https?/;
async function _validateOrigin(auth2) {
  if (auth2.config.emulator) {
    return;
  }
  const { authorizedDomains } = await _getProjectConfig(auth2);
  for (const domain of authorizedDomains) {
    try {
      if (matchDomain(domain)) {
        return;
      }
    } catch (_a) {
    }
  }
  _fail(auth2, "unauthorized-domain");
}
function matchDomain(expected) {
  const currentUrl = _getCurrentUrl();
  const { protocol, hostname } = new URL(currentUrl);
  if (expected.startsWith("chrome-extension://")) {
    const ceUrl = new URL(expected);
    if (ceUrl.hostname === "" && hostname === "") {
      return protocol === "chrome-extension:" && expected.replace("chrome-extension://", "") === currentUrl.replace("chrome-extension://", "");
    }
    return protocol === "chrome-extension:" && ceUrl.hostname === hostname;
  }
  if (!HTTP_REGEX.test(protocol)) {
    return false;
  }
  if (IP_ADDRESS_REGEX.test(expected)) {
    return hostname === expected;
  }
  const escapedDomainPattern = expected.replace(/\./g, "\\.");
  const re = new RegExp("^(.+\\." + escapedDomainPattern + "|" + escapedDomainPattern + ")$", "i");
  return re.test(hostname);
}
var NETWORK_TIMEOUT = new Delay(3e4, 6e4);
function resetUnloadedGapiModules() {
  const beacon = _window().___jsl;
  if (beacon === null || beacon === void 0 ? void 0 : beacon.H) {
    for (const hint of Object.keys(beacon.H)) {
      beacon.H[hint].r = beacon.H[hint].r || [];
      beacon.H[hint].L = beacon.H[hint].L || [];
      beacon.H[hint].r = [...beacon.H[hint].L];
      if (beacon.CP) {
        for (let i = 0; i < beacon.CP.length; i++) {
          beacon.CP[i] = null;
        }
      }
    }
  }
}
function loadGapi(auth2) {
  return new Promise((resolve2, reject) => {
    var _a, _b, _c;
    function loadGapiIframe() {
      resetUnloadedGapiModules();
      gapi.load("gapi.iframes", {
        callback: () => {
          resolve2(gapi.iframes.getContext());
        },
        ontimeout: () => {
          resetUnloadedGapiModules();
          reject(_createError(auth2, "network-request-failed"));
        },
        timeout: NETWORK_TIMEOUT.get()
      });
    }
    if ((_b = (_a = _window().gapi) === null || _a === void 0 ? void 0 : _a.iframes) === null || _b === void 0 ? void 0 : _b.Iframe) {
      resolve2(gapi.iframes.getContext());
    } else if (!!((_c = _window().gapi) === null || _c === void 0 ? void 0 : _c.load)) {
      loadGapiIframe();
    } else {
      const cbName = _generateCallbackName("iframefcb");
      _window()[cbName] = () => {
        if (!!gapi.load) {
          loadGapiIframe();
        } else {
          reject(_createError(auth2, "network-request-failed"));
        }
      };
      return _loadJS(`https://apis.google.com/js/api.js?onload=${cbName}`);
    }
  }).catch((error2) => {
    cachedGApiLoader = null;
    throw error2;
  });
}
var cachedGApiLoader = null;
function _loadGapi(auth2) {
  cachedGApiLoader = cachedGApiLoader || loadGapi(auth2);
  return cachedGApiLoader;
}
var PING_TIMEOUT = new Delay(5e3, 15e3);
var IFRAME_PATH = "__/auth/iframe";
var EMULATED_IFRAME_PATH = "emulator/auth/iframe";
var IFRAME_ATTRIBUTES = {
  style: {
    position: "absolute",
    top: "-100px",
    width: "1px",
    height: "1px"
  }
};
var EID_FROM_APIHOST = new Map([
  ["identitytoolkit.googleapis.com", "p"],
  ["staging-identitytoolkit.sandbox.googleapis.com", "s"],
  ["test-identitytoolkit.sandbox.googleapis.com", "t"]
]);
function getIframeUrl(auth2) {
  const config2 = auth2.config;
  _assert(config2.authDomain, auth2, "auth-domain-config-required");
  const url = config2.emulator ? _emulatorUrl(config2, EMULATED_IFRAME_PATH) : `https://${auth2.config.authDomain}/${IFRAME_PATH}`;
  const params = {
    apiKey: config2.apiKey,
    appName: auth2.name,
    v: SDK_VERSION
  };
  const eid = EID_FROM_APIHOST.get(auth2.config.apiHost);
  if (eid) {
    params.eid = eid;
  }
  const frameworks = auth2._getFrameworks();
  if (frameworks.length) {
    params.fw = frameworks.join(",");
  }
  return `${url}?${querystring(params).slice(1)}`;
}
async function _openIframe(auth2) {
  const context = await _loadGapi(auth2);
  const gapi2 = _window().gapi;
  _assert(gapi2, auth2, "internal-error");
  return context.open({
    where: document.body,
    url: getIframeUrl(auth2),
    messageHandlersFilter: gapi2.iframes.CROSS_ORIGIN_IFRAMES_FILTER,
    attributes: IFRAME_ATTRIBUTES,
    dontclear: true
  }, (iframe) => new Promise(async (resolve2, reject) => {
    await iframe.restyle({
      setHideOnLeave: false
    });
    const networkError = _createError(auth2, "network-request-failed");
    const networkErrorTimer = _window().setTimeout(() => {
      reject(networkError);
    }, PING_TIMEOUT.get());
    function clearTimerAndResolve() {
      _window().clearTimeout(networkErrorTimer);
      resolve2(iframe);
    }
    iframe.ping(clearTimerAndResolve).then(clearTimerAndResolve, () => {
      reject(networkError);
    });
  }));
}
var BASE_POPUP_OPTIONS = {
  location: "yes",
  resizable: "yes",
  statusbar: "yes",
  toolbar: "no"
};
var DEFAULT_WIDTH = 500;
var DEFAULT_HEIGHT = 600;
var TARGET_BLANK = "_blank";
var FIREFOX_EMPTY_URL = "http://localhost";
var AuthPopup = class {
  constructor(window2) {
    this.window = window2;
    this.associatedEvent = null;
  }
  close() {
    if (this.window) {
      try {
        this.window.close();
      } catch (e) {
      }
    }
  }
};
function _open(auth2, url, name2, width = DEFAULT_WIDTH, height = DEFAULT_HEIGHT) {
  const top = Math.max((window.screen.availHeight - height) / 2, 0).toString();
  const left = Math.max((window.screen.availWidth - width) / 2, 0).toString();
  let target = "";
  const options2 = Object.assign(Object.assign({}, BASE_POPUP_OPTIONS), {
    width: width.toString(),
    height: height.toString(),
    top,
    left
  });
  const ua = getUA().toLowerCase();
  if (name2) {
    target = _isChromeIOS(ua) ? TARGET_BLANK : name2;
  }
  if (_isFirefox(ua)) {
    url = url || FIREFOX_EMPTY_URL;
    options2.scrollbars = "yes";
  }
  const optionsString = Object.entries(options2).reduce((accum, [key, value]) => `${accum}${key}=${value},`, "");
  if (_isIOSStandalone(ua) && target !== "_self") {
    openAsNewWindowIOS(url || "", target);
    return new AuthPopup(null);
  }
  const newWin = window.open(url || "", target, optionsString);
  _assert(newWin, auth2, "popup-blocked");
  try {
    newWin.focus();
  } catch (e) {
  }
  return new AuthPopup(newWin);
}
function openAsNewWindowIOS(url, target) {
  const el = document.createElement("a");
  el.href = url;
  el.target = target;
  const click = document.createEvent("MouseEvent");
  click.initMouseEvent("click", true, true, window, 1, 0, 0, 0, 0, false, false, false, false, 1, null);
  el.dispatchEvent(click);
}
var WIDGET_PATH = "__/auth/handler";
var EMULATOR_WIDGET_PATH = "emulator/auth/handler";
function _getRedirectUrl(auth2, provider, authType, redirectUrl, eventId, additionalParams) {
  _assert(auth2.config.authDomain, auth2, "auth-domain-config-required");
  _assert(auth2.config.apiKey, auth2, "invalid-api-key");
  const params = {
    apiKey: auth2.config.apiKey,
    appName: auth2.name,
    authType,
    redirectUrl,
    v: SDK_VERSION,
    eventId
  };
  if (provider instanceof FederatedAuthProvider) {
    provider.setDefaultLanguage(auth2.languageCode);
    params.providerId = provider.providerId || "";
    if (!isEmpty(provider.getCustomParameters())) {
      params.customParameters = JSON.stringify(provider.getCustomParameters());
    }
    for (const [key, value] of Object.entries(additionalParams || {})) {
      params[key] = value;
    }
  }
  if (provider instanceof BaseOAuthProvider) {
    const scopes = provider.getScopes().filter((scope) => scope !== "");
    if (scopes.length > 0) {
      params.scopes = scopes.join(",");
    }
  }
  if (auth2.tenantId) {
    params.tid = auth2.tenantId;
  }
  const paramsDict = params;
  for (const key of Object.keys(paramsDict)) {
    if (paramsDict[key] === void 0) {
      delete paramsDict[key];
    }
  }
  return `${getHandlerBase(auth2)}?${querystring(paramsDict).slice(1)}`;
}
function getHandlerBase({ config: config2 }) {
  if (!config2.emulator) {
    return `https://${config2.authDomain}/${WIDGET_PATH}`;
  }
  return _emulatorUrl(config2, EMULATOR_WIDGET_PATH);
}
var WEB_STORAGE_SUPPORT_KEY = "webStorageSupport";
var BrowserPopupRedirectResolver = class {
  constructor() {
    this.eventManagers = {};
    this.iframes = {};
    this.originValidationPromises = {};
    this._redirectPersistence = browserSessionPersistence;
    this._completeRedirectFn = _getRedirectResult;
  }
  async _openPopup(auth2, provider, authType, eventId) {
    var _a;
    debugAssert((_a = this.eventManagers[auth2._key()]) === null || _a === void 0 ? void 0 : _a.manager, "_initialize() not called before _openPopup()");
    const url = _getRedirectUrl(auth2, provider, authType, _getCurrentUrl(), eventId);
    return _open(auth2, url, _generateEventId());
  }
  async _openRedirect(auth2, provider, authType, eventId) {
    await this._originValidation(auth2);
    _setWindowLocation(_getRedirectUrl(auth2, provider, authType, _getCurrentUrl(), eventId));
    return new Promise(() => {
    });
  }
  _initialize(auth2) {
    const key = auth2._key();
    if (this.eventManagers[key]) {
      const { manager, promise: promise2 } = this.eventManagers[key];
      if (manager) {
        return Promise.resolve(manager);
      } else {
        debugAssert(promise2, "If manager is not set, promise should be");
        return promise2;
      }
    }
    const promise = this.initAndGetManager(auth2);
    this.eventManagers[key] = { promise };
    return promise;
  }
  async initAndGetManager(auth2) {
    const iframe = await _openIframe(auth2);
    const manager = new AuthEventManager(auth2);
    iframe.register("authEvent", (iframeEvent) => {
      _assert(iframeEvent === null || iframeEvent === void 0 ? void 0 : iframeEvent.authEvent, auth2, "invalid-auth-event");
      const handled = manager.onEvent(iframeEvent.authEvent);
      return { status: handled ? "ACK" : "ERROR" };
    }, gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER);
    this.eventManagers[auth2._key()] = { manager };
    this.iframes[auth2._key()] = iframe;
    return manager;
  }
  _isIframeWebStorageSupported(auth2, cb) {
    const iframe = this.iframes[auth2._key()];
    iframe.send(WEB_STORAGE_SUPPORT_KEY, { type: WEB_STORAGE_SUPPORT_KEY }, (result) => {
      var _a;
      const isSupported = (_a = result === null || result === void 0 ? void 0 : result[0]) === null || _a === void 0 ? void 0 : _a[WEB_STORAGE_SUPPORT_KEY];
      if (isSupported !== void 0) {
        cb(!!isSupported);
      }
      _fail(auth2, "internal-error");
    }, gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER);
  }
  _originValidation(auth2) {
    const key = auth2._key();
    if (!this.originValidationPromises[key]) {
      this.originValidationPromises[key] = _validateOrigin(auth2);
    }
    return this.originValidationPromises[key];
  }
  get _shouldInitProactively() {
    return _isMobileBrowser() || _isSafari() || _isIOS();
  }
};
var browserPopupRedirectResolver = BrowserPopupRedirectResolver;
var name$3 = "@firebase/auth";
var version$3 = "0.18.2";
var AuthInterop = class {
  constructor(auth2) {
    this.auth = auth2;
    this.internalListeners = new Map();
  }
  getUid() {
    var _a;
    this.assertAuthConfigured();
    return ((_a = this.auth.currentUser) === null || _a === void 0 ? void 0 : _a.uid) || null;
  }
  async getToken(forceRefresh) {
    this.assertAuthConfigured();
    await this.auth._initializationPromise;
    if (!this.auth.currentUser) {
      return null;
    }
    const accessToken = await this.auth.currentUser.getIdToken(forceRefresh);
    return { accessToken };
  }
  addAuthTokenListener(listener) {
    this.assertAuthConfigured();
    if (this.internalListeners.has(listener)) {
      return;
    }
    const unsubscribe = this.auth.onIdTokenChanged((user2) => {
      var _a;
      listener(((_a = user2) === null || _a === void 0 ? void 0 : _a.stsTokenManager.accessToken) || null);
    });
    this.internalListeners.set(listener, unsubscribe);
    this.updateProactiveRefresh();
  }
  removeAuthTokenListener(listener) {
    this.assertAuthConfigured();
    const unsubscribe = this.internalListeners.get(listener);
    if (!unsubscribe) {
      return;
    }
    this.internalListeners.delete(listener);
    unsubscribe();
    this.updateProactiveRefresh();
  }
  assertAuthConfigured() {
    _assert(this.auth._initializationPromise, "dependent-sdk-initialized-before-auth");
  }
  updateProactiveRefresh() {
    if (this.internalListeners.size > 0) {
      this.auth._startProactiveRefresh();
    } else {
      this.auth._stopProactiveRefresh();
    }
  }
};
function getVersionForPlatform(clientPlatform) {
  switch (clientPlatform) {
    case "Node":
      return "node";
    case "ReactNative":
      return "rn";
    case "Worker":
      return "webworker";
    case "Cordova":
      return "cordova";
    default:
      return void 0;
  }
}
function registerAuth(clientPlatform) {
  _registerComponent(new Component("auth", (container, { options: deps }) => {
    const app = container.getProvider("app").getImmediate();
    const { apiKey, authDomain } = app.options;
    return ((app2) => {
      _assert(apiKey && !apiKey.includes(":"), "invalid-api-key", { appName: app2.name });
      _assert(!(authDomain === null || authDomain === void 0 ? void 0 : authDomain.includes(":")), "argument-error", {
        appName: app2.name
      });
      const config2 = {
        apiKey,
        authDomain,
        clientPlatform,
        apiHost: "identitytoolkit.googleapis.com",
        tokenApiHost: "securetoken.googleapis.com",
        apiScheme: "https",
        sdkClientVersion: _getClientVersion(clientPlatform)
      };
      const authInstance = new AuthImpl(app2, config2);
      _initializeAuthInstance(authInstance, deps);
      return authInstance;
    })(app);
  }, "PUBLIC").setInstantiationMode("EXPLICIT").setInstanceCreatedCallback((container, _instanceIdentifier, _instance) => {
    const authInternalProvider = container.getProvider("auth-internal");
    authInternalProvider.initialize();
  }));
  _registerComponent(new Component("auth-internal", (container) => {
    const auth2 = _castAuth(container.getProvider("auth").getImmediate());
    return ((auth3) => new AuthInterop(auth3))(auth2);
  }, "PRIVATE").setInstantiationMode("EXPLICIT"));
  registerVersion(name$3, version$3, getVersionForPlatform(clientPlatform));
}
function getAuth(app = getApp()) {
  const provider = _getProvider(app, "auth");
  if (provider.isInitialized()) {
    return provider.getImmediate();
  }
  return initializeAuth(app, {
    popupRedirectResolver: browserPopupRedirectResolver,
    persistence: [
      indexedDBLocalPersistence,
      browserLocalPersistence,
      browserSessionPersistence
    ]
  });
}
registerAuth("Browser");
initializeApp(config);
var auth = getAuth();
function useAuthListener() {
  let user2 = JSON.parse(localStorage.getItem("user"));
  const listener = () => {
    onAuthStateChanged(auth, (authUser) => {
      if (authUser) {
        localStorage.setItem("user", JSON.stringify(authUser));
        user2 = authUser;
      } else {
        localStorage.removeItem("user");
        user2 = null;
      }
    });
  };
  listener();
  return user2;
}
var profile$1 = "/_app/assets/profile_picture-8dbdb29d.jpg";
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2[ErrorCode2["NO_ERROR"] = 0] = "NO_ERROR";
  ErrorCode2[ErrorCode2["NETWORK_ERROR"] = 1] = "NETWORK_ERROR";
  ErrorCode2[ErrorCode2["ABORT"] = 2] = "ABORT";
})(ErrorCode || (ErrorCode = {}));
var DEFAULT_HOST = "firebasestorage.googleapis.com";
var CONFIG_STORAGE_BUCKET_KEY = "storageBucket";
var DEFAULT_MAX_OPERATION_RETRY_TIME = 2 * 60 * 1e3;
var DEFAULT_MAX_UPLOAD_RETRY_TIME = 10 * 60 * 1e3;
var StorageError = class extends FirebaseError {
  constructor(code, message) {
    super(prependCode(code), `Firebase Storage: ${message} (${prependCode(code)})`);
    this.customData = { serverResponse: null };
    this._baseMessage = this.message;
    Object.setPrototypeOf(this, StorageError.prototype);
  }
  _codeEquals(code) {
    return prependCode(code) === this.code;
  }
  get serverResponse() {
    return this.customData.serverResponse;
  }
  set serverResponse(serverResponse) {
    this.customData.serverResponse = serverResponse;
    if (this.customData.serverResponse) {
      this.message = `${this._baseMessage}
${this.customData.serverResponse}`;
    } else {
      this.message = this._baseMessage;
    }
  }
};
function prependCode(code) {
  return "storage/" + code;
}
function unknown() {
  const message = "An unknown error occurred, please check the error payload for server response.";
  return new StorageError("unknown", message);
}
function objectNotFound(path) {
  return new StorageError("object-not-found", "Object '" + path + "' does not exist.");
}
function quotaExceeded(bucket) {
  return new StorageError("quota-exceeded", "Quota for bucket '" + bucket + "' exceeded, please view quota on https://firebase.google.com/pricing/.");
}
function unauthenticated() {
  const message = "User is not authenticated, please authenticate using Firebase Authentication and try again.";
  return new StorageError("unauthenticated", message);
}
function unauthorizedApp() {
  return new StorageError("unauthorized-app", "This app does not have permission to access Firebase Storage on this project.");
}
function unauthorized(path) {
  return new StorageError("unauthorized", "User does not have permission to access '" + path + "'.");
}
function retryLimitExceeded() {
  return new StorageError("retry-limit-exceeded", "Max retry time for operation exceeded, please try again.");
}
function canceled() {
  return new StorageError("canceled", "User canceled the upload/download.");
}
function invalidUrl(url) {
  return new StorageError("invalid-url", "Invalid URL '" + url + "'.");
}
function invalidDefaultBucket(bucket) {
  return new StorageError("invalid-default-bucket", "Invalid default bucket '" + bucket + "'.");
}
function noDefaultBucket() {
  return new StorageError("no-default-bucket", "No default bucket found. Did you set the '" + CONFIG_STORAGE_BUCKET_KEY + "' property when initializing the app?");
}
function noDownloadURL() {
  return new StorageError("no-download-url", "The given file does not have any download URLs.");
}
function invalidArgument(message) {
  return new StorageError("invalid-argument", message);
}
function appDeleted() {
  return new StorageError("app-deleted", "The Firebase app was deleted.");
}
function invalidRootOperation(name2) {
  return new StorageError("invalid-root-operation", "The operation '" + name2 + "' cannot be performed on a root reference, create a non-root reference using child, such as .child('file.png').");
}
function internalError(message) {
  throw new StorageError("internal-error", "Internal error: " + message);
}
var XhrConnection = class {
  constructor() {
    this.sent_ = false;
    this.xhr_ = new XMLHttpRequest();
    this.errorCode_ = ErrorCode.NO_ERROR;
    this.sendPromise_ = new Promise((resolve2) => {
      this.xhr_.addEventListener("abort", () => {
        this.errorCode_ = ErrorCode.ABORT;
        resolve2();
      });
      this.xhr_.addEventListener("error", () => {
        this.errorCode_ = ErrorCode.NETWORK_ERROR;
        resolve2();
      });
      this.xhr_.addEventListener("load", () => {
        resolve2();
      });
    });
  }
  send(url, method, body, headers) {
    if (this.sent_) {
      throw internalError("cannot .send() more than once");
    }
    this.sent_ = true;
    this.xhr_.open(method, url, true);
    if (headers !== void 0) {
      for (const key in headers) {
        if (headers.hasOwnProperty(key)) {
          this.xhr_.setRequestHeader(key, headers[key].toString());
        }
      }
    }
    if (body !== void 0) {
      this.xhr_.send(body);
    } else {
      this.xhr_.send();
    }
    return this.sendPromise_;
  }
  getErrorCode() {
    if (!this.sent_) {
      throw internalError("cannot .getErrorCode() before sending");
    }
    return this.errorCode_;
  }
  getStatus() {
    if (!this.sent_) {
      throw internalError("cannot .getStatus() before sending");
    }
    try {
      return this.xhr_.status;
    } catch (e) {
      return -1;
    }
  }
  getResponseText() {
    if (!this.sent_) {
      throw internalError("cannot .getResponseText() before sending");
    }
    return this.xhr_.responseText;
  }
  abort() {
    this.xhr_.abort();
  }
  getResponseHeader(header) {
    return this.xhr_.getResponseHeader(header);
  }
  addUploadProgressListener(listener) {
    if (this.xhr_.upload != null) {
      this.xhr_.upload.addEventListener("progress", listener);
    }
  }
  removeUploadProgressListener(listener) {
    if (this.xhr_.upload != null) {
      this.xhr_.upload.removeEventListener("progress", listener);
    }
  }
};
function newConnection() {
  return new XhrConnection();
}
var ConnectionPool = class {
  createConnection() {
    return newConnection();
  }
};
var Location = class {
  constructor(bucket, path) {
    this.bucket = bucket;
    this.path_ = path;
  }
  get path() {
    return this.path_;
  }
  get isRoot() {
    return this.path.length === 0;
  }
  fullServerUrl() {
    const encode2 = encodeURIComponent;
    return "/b/" + encode2(this.bucket) + "/o/" + encode2(this.path);
  }
  bucketOnlyServerUrl() {
    const encode2 = encodeURIComponent;
    return "/b/" + encode2(this.bucket) + "/o";
  }
  static makeFromBucketSpec(bucketString, host) {
    let bucketLocation;
    try {
      bucketLocation = Location.makeFromUrl(bucketString, host);
    } catch (e) {
      return new Location(bucketString, "");
    }
    if (bucketLocation.path === "") {
      return bucketLocation;
    } else {
      throw invalidDefaultBucket(bucketString);
    }
  }
  static makeFromUrl(url, host) {
    let location = null;
    const bucketDomain = "([A-Za-z0-9.\\-_]+)";
    function gsModify(loc) {
      if (loc.path.charAt(loc.path.length - 1) === "/") {
        loc.path_ = loc.path_.slice(0, -1);
      }
    }
    const gsPath = "(/(.*))?$";
    const gsRegex = new RegExp("^gs://" + bucketDomain + gsPath, "i");
    const gsIndices = { bucket: 1, path: 3 };
    function httpModify(loc) {
      loc.path_ = decodeURIComponent(loc.path);
    }
    const version2 = "v[A-Za-z0-9_]+";
    const firebaseStorageHost = host.replace(/[.]/g, "\\.");
    const firebaseStoragePath = "(/([^?#]*).*)?$";
    const firebaseStorageRegExp = new RegExp(`^https?://${firebaseStorageHost}/${version2}/b/${bucketDomain}/o${firebaseStoragePath}`, "i");
    const firebaseStorageIndices = { bucket: 1, path: 3 };
    const cloudStorageHost = host === DEFAULT_HOST ? "(?:storage.googleapis.com|storage.cloud.google.com)" : host;
    const cloudStoragePath = "([^?#]*)";
    const cloudStorageRegExp = new RegExp(`^https?://${cloudStorageHost}/${bucketDomain}/${cloudStoragePath}`, "i");
    const cloudStorageIndices = { bucket: 1, path: 2 };
    const groups = [
      { regex: gsRegex, indices: gsIndices, postModify: gsModify },
      {
        regex: firebaseStorageRegExp,
        indices: firebaseStorageIndices,
        postModify: httpModify
      },
      {
        regex: cloudStorageRegExp,
        indices: cloudStorageIndices,
        postModify: httpModify
      }
    ];
    for (let i = 0; i < groups.length; i++) {
      const group = groups[i];
      const captures = group.regex.exec(url);
      if (captures) {
        const bucketValue = captures[group.indices.bucket];
        let pathValue = captures[group.indices.path];
        if (!pathValue) {
          pathValue = "";
        }
        location = new Location(bucketValue, pathValue);
        group.postModify(location);
        break;
      }
    }
    if (location == null) {
      throw invalidUrl(url);
    }
    return location;
  }
};
var FailRequest = class {
  constructor(error2) {
    this.promise_ = Promise.reject(error2);
  }
  getPromise() {
    return this.promise_;
  }
  cancel(_appDelete = false) {
  }
};
function start(f, callback, timeout) {
  let waitSeconds = 1;
  let timeoutId = null;
  let hitTimeout = false;
  let cancelState = 0;
  function canceled2() {
    return cancelState === 2;
  }
  let triggeredCallback = false;
  function triggerCallback(...args) {
    if (!triggeredCallback) {
      triggeredCallback = true;
      callback.apply(null, args);
    }
  }
  function callWithDelay(millis) {
    timeoutId = setTimeout(() => {
      timeoutId = null;
      f(handler2, canceled2());
    }, millis);
  }
  function handler2(success, ...args) {
    if (triggeredCallback) {
      return;
    }
    if (success) {
      triggerCallback.call(null, success, ...args);
      return;
    }
    const mustStop = canceled2() || hitTimeout;
    if (mustStop) {
      triggerCallback.call(null, success, ...args);
      return;
    }
    if (waitSeconds < 64) {
      waitSeconds *= 2;
    }
    let waitMillis;
    if (cancelState === 1) {
      cancelState = 2;
      waitMillis = 0;
    } else {
      waitMillis = (waitSeconds + Math.random()) * 1e3;
    }
    callWithDelay(waitMillis);
  }
  let stopped = false;
  function stop2(wasTimeout) {
    if (stopped) {
      return;
    }
    stopped = true;
    if (triggeredCallback) {
      return;
    }
    if (timeoutId !== null) {
      if (!wasTimeout) {
        cancelState = 2;
      }
      clearTimeout(timeoutId);
      callWithDelay(0);
    } else {
      if (!wasTimeout) {
        cancelState = 1;
      }
    }
  }
  callWithDelay(0);
  setTimeout(() => {
    hitTimeout = true;
    stop2(true);
  }, timeout);
  return stop2;
}
function stop(id) {
  id(false);
}
function isJustDef(p) {
  return p !== void 0;
}
function isNonArrayObject(p) {
  return typeof p === "object" && !Array.isArray(p);
}
function isString(p) {
  return typeof p === "string" || p instanceof String;
}
function validateNumber(argument, minValue, maxValue, value) {
  if (value < minValue) {
    throw invalidArgument(`Invalid value for '${argument}'. Expected ${minValue} or greater.`);
  }
  if (value > maxValue) {
    throw invalidArgument(`Invalid value for '${argument}'. Expected ${maxValue} or less.`);
  }
}
function makeUrl(urlPart, host, protocol) {
  let origin = host;
  if (protocol == null) {
    origin = `https://${host}`;
  }
  return `${protocol}://${origin}/v0${urlPart}`;
}
function makeQueryString(params) {
  const encode2 = encodeURIComponent;
  let queryPart = "?";
  for (const key in params) {
    if (params.hasOwnProperty(key)) {
      const nextPart = encode2(key) + "=" + encode2(params[key]);
      queryPart = queryPart + nextPart + "&";
    }
  }
  queryPart = queryPart.slice(0, -1);
  return queryPart;
}
var NetworkRequest = class {
  constructor(url, method, headers, body, successCodes, additionalRetryCodes, callback, errorCallback, timeout, progressCallback, pool) {
    this.pendingConnection_ = null;
    this.backoffId_ = null;
    this.canceled_ = false;
    this.appDelete_ = false;
    this.url_ = url;
    this.method_ = method;
    this.headers_ = headers;
    this.body_ = body;
    this.successCodes_ = successCodes.slice();
    this.additionalRetryCodes_ = additionalRetryCodes.slice();
    this.callback_ = callback;
    this.errorCallback_ = errorCallback;
    this.progressCallback_ = progressCallback;
    this.timeout_ = timeout;
    this.pool_ = pool;
    this.promise_ = new Promise((resolve2, reject) => {
      this.resolve_ = resolve2;
      this.reject_ = reject;
      this.start_();
    });
  }
  start_() {
    const self2 = this;
    function doTheRequest(backoffCallback, canceled2) {
      if (canceled2) {
        backoffCallback(false, new RequestEndStatus(false, null, true));
        return;
      }
      const connection = self2.pool_.createConnection();
      self2.pendingConnection_ = connection;
      function progressListener(progressEvent) {
        const loaded = progressEvent.loaded;
        const total = progressEvent.lengthComputable ? progressEvent.total : -1;
        if (self2.progressCallback_ !== null) {
          self2.progressCallback_(loaded, total);
        }
      }
      if (self2.progressCallback_ !== null) {
        connection.addUploadProgressListener(progressListener);
      }
      connection.send(self2.url_, self2.method_, self2.body_, self2.headers_).then(() => {
        if (self2.progressCallback_ !== null) {
          connection.removeUploadProgressListener(progressListener);
        }
        self2.pendingConnection_ = null;
        const hitServer = connection.getErrorCode() === ErrorCode.NO_ERROR;
        const status = connection.getStatus();
        if (!hitServer || self2.isRetryStatusCode_(status)) {
          const wasCanceled = connection.getErrorCode() === ErrorCode.ABORT;
          backoffCallback(false, new RequestEndStatus(false, null, wasCanceled));
          return;
        }
        const successCode = self2.successCodes_.indexOf(status) !== -1;
        backoffCallback(true, new RequestEndStatus(successCode, connection));
      });
    }
    function backoffDone(requestWentThrough, status) {
      const resolve2 = self2.resolve_;
      const reject = self2.reject_;
      const connection = status.connection;
      if (status.wasSuccessCode) {
        try {
          const result = self2.callback_(connection, connection.getResponseText());
          if (isJustDef(result)) {
            resolve2(result);
          } else {
            resolve2();
          }
        } catch (e) {
          reject(e);
        }
      } else {
        if (connection !== null) {
          const err = unknown();
          err.serverResponse = connection.getResponseText();
          if (self2.errorCallback_) {
            reject(self2.errorCallback_(connection, err));
          } else {
            reject(err);
          }
        } else {
          if (status.canceled) {
            const err = self2.appDelete_ ? appDeleted() : canceled();
            reject(err);
          } else {
            const err = retryLimitExceeded();
            reject(err);
          }
        }
      }
    }
    if (this.canceled_) {
      backoffDone(false, new RequestEndStatus(false, null, true));
    } else {
      this.backoffId_ = start(doTheRequest, backoffDone, this.timeout_);
    }
  }
  getPromise() {
    return this.promise_;
  }
  cancel(appDelete) {
    this.canceled_ = true;
    this.appDelete_ = appDelete || false;
    if (this.backoffId_ !== null) {
      stop(this.backoffId_);
    }
    if (this.pendingConnection_ !== null) {
      this.pendingConnection_.abort();
    }
  }
  isRetryStatusCode_(status) {
    const isFiveHundredCode = status >= 500 && status < 600;
    const extraRetryCodes = [
      408,
      429
    ];
    const isExtraRetryCode = extraRetryCodes.indexOf(status) !== -1;
    const isRequestSpecificRetryCode = this.additionalRetryCodes_.indexOf(status) !== -1;
    return isFiveHundredCode || isExtraRetryCode || isRequestSpecificRetryCode;
  }
};
var RequestEndStatus = class {
  constructor(wasSuccessCode, connection, canceled2) {
    this.wasSuccessCode = wasSuccessCode;
    this.connection = connection;
    this.canceled = !!canceled2;
  }
};
function addAuthHeader_(headers, authToken) {
  if (authToken !== null && authToken.length > 0) {
    headers["Authorization"] = "Firebase " + authToken;
  }
}
function addVersionHeader_(headers, firebaseVersion) {
  headers["X-Firebase-Storage-Version"] = "webjs/" + (firebaseVersion !== null && firebaseVersion !== void 0 ? firebaseVersion : "AppManager");
}
function addGmpidHeader_(headers, appId) {
  if (appId) {
    headers["X-Firebase-GMPID"] = appId;
  }
}
function addAppCheckHeader_(headers, appCheckToken) {
  if (appCheckToken !== null) {
    headers["X-Firebase-AppCheck"] = appCheckToken;
  }
}
function makeRequest(requestInfo, appId, authToken, appCheckToken, pool, firebaseVersion) {
  const queryPart = makeQueryString(requestInfo.urlParams);
  const url = requestInfo.url + queryPart;
  const headers = Object.assign({}, requestInfo.headers);
  addGmpidHeader_(headers, appId);
  addAuthHeader_(headers, authToken);
  addVersionHeader_(headers, firebaseVersion);
  addAppCheckHeader_(headers, appCheckToken);
  return new NetworkRequest(url, requestInfo.method, headers, requestInfo.body, requestInfo.successCodes, requestInfo.additionalRetryCodes, requestInfo.handler, requestInfo.errorHandler, requestInfo.timeout, requestInfo.progressCallback, pool);
}
function jsonObjectOrNull(s2) {
  let obj;
  try {
    obj = JSON.parse(s2);
  } catch (e) {
    return null;
  }
  if (isNonArrayObject(obj)) {
    return obj;
  } else {
    return null;
  }
}
function parent(path) {
  if (path.length === 0) {
    return null;
  }
  const index2 = path.lastIndexOf("/");
  if (index2 === -1) {
    return "";
  }
  const newPath = path.slice(0, index2);
  return newPath;
}
function child(path, childPath) {
  const canonicalChildPath = childPath.split("/").filter((component) => component.length > 0).join("/");
  if (path.length === 0) {
    return canonicalChildPath;
  } else {
    return path + "/" + canonicalChildPath;
  }
}
function lastComponent(path) {
  const index2 = path.lastIndexOf("/", path.length - 2);
  if (index2 === -1) {
    return path;
  } else {
    return path.slice(index2 + 1);
  }
}
function noXform_(metadata, value) {
  return value;
}
var Mapping = class {
  constructor(server, local, writable2, xform) {
    this.server = server;
    this.local = local || server;
    this.writable = !!writable2;
    this.xform = xform || noXform_;
  }
};
var mappings_ = null;
function xformPath(fullPath) {
  if (!isString(fullPath) || fullPath.length < 2) {
    return fullPath;
  } else {
    return lastComponent(fullPath);
  }
}
function getMappings() {
  if (mappings_) {
    return mappings_;
  }
  const mappings = [];
  mappings.push(new Mapping("bucket"));
  mappings.push(new Mapping("generation"));
  mappings.push(new Mapping("metageneration"));
  mappings.push(new Mapping("name", "fullPath", true));
  function mappingsXformPath(_metadata, fullPath) {
    return xformPath(fullPath);
  }
  const nameMapping = new Mapping("name");
  nameMapping.xform = mappingsXformPath;
  mappings.push(nameMapping);
  function xformSize(_metadata, size) {
    if (size !== void 0) {
      return Number(size);
    } else {
      return size;
    }
  }
  const sizeMapping = new Mapping("size");
  sizeMapping.xform = xformSize;
  mappings.push(sizeMapping);
  mappings.push(new Mapping("timeCreated"));
  mappings.push(new Mapping("updated"));
  mappings.push(new Mapping("md5Hash", null, true));
  mappings.push(new Mapping("cacheControl", null, true));
  mappings.push(new Mapping("contentDisposition", null, true));
  mappings.push(new Mapping("contentEncoding", null, true));
  mappings.push(new Mapping("contentLanguage", null, true));
  mappings.push(new Mapping("contentType", null, true));
  mappings.push(new Mapping("metadata", "customMetadata", true));
  mappings_ = mappings;
  return mappings_;
}
function addRef(metadata, service) {
  function generateRef() {
    const bucket = metadata["bucket"];
    const path = metadata["fullPath"];
    const loc = new Location(bucket, path);
    return service._makeStorageReference(loc);
  }
  Object.defineProperty(metadata, "ref", { get: generateRef });
}
function fromResource(service, resource, mappings) {
  const metadata = {};
  metadata["type"] = "file";
  const len = mappings.length;
  for (let i = 0; i < len; i++) {
    const mapping = mappings[i];
    metadata[mapping.local] = mapping.xform(metadata, resource[mapping.server]);
  }
  addRef(metadata, service);
  return metadata;
}
function fromResourceString(service, resourceString, mappings) {
  const obj = jsonObjectOrNull(resourceString);
  if (obj === null) {
    return null;
  }
  const resource = obj;
  return fromResource(service, resource, mappings);
}
function downloadUrlFromResourceString(metadata, resourceString, host, protocol) {
  const obj = jsonObjectOrNull(resourceString);
  if (obj === null) {
    return null;
  }
  if (!isString(obj["downloadTokens"])) {
    return null;
  }
  const tokens = obj["downloadTokens"];
  if (tokens.length === 0) {
    return null;
  }
  const encode2 = encodeURIComponent;
  const tokensList = tokens.split(",");
  const urls = tokensList.map((token) => {
    const bucket = metadata["bucket"];
    const path = metadata["fullPath"];
    const urlPart = "/b/" + encode2(bucket) + "/o/" + encode2(path);
    const base2 = makeUrl(urlPart, host, protocol);
    const queryString = makeQueryString({
      alt: "media",
      token
    });
    return base2 + queryString;
  });
  return urls[0];
}
var RequestInfo = class {
  constructor(url, method, handler2, timeout) {
    this.url = url;
    this.method = method;
    this.handler = handler2;
    this.timeout = timeout;
    this.urlParams = {};
    this.headers = {};
    this.body = null;
    this.errorHandler = null;
    this.progressCallback = null;
    this.successCodes = [200];
    this.additionalRetryCodes = [];
  }
};
function handlerCheck(cndn) {
  if (!cndn) {
    throw unknown();
  }
}
function downloadUrlHandler(service, mappings) {
  function handler2(xhr, text) {
    const metadata = fromResourceString(service, text, mappings);
    handlerCheck(metadata !== null);
    return downloadUrlFromResourceString(metadata, text, service.host, service._protocol);
  }
  return handler2;
}
function sharedErrorHandler(location) {
  function errorHandler(xhr, err) {
    let newErr;
    if (xhr.getStatus() === 401) {
      if (xhr.getResponseText().includes("Firebase App Check token is invalid")) {
        newErr = unauthorizedApp();
      } else {
        newErr = unauthenticated();
      }
    } else {
      if (xhr.getStatus() === 402) {
        newErr = quotaExceeded(location.bucket);
      } else {
        if (xhr.getStatus() === 403) {
          newErr = unauthorized(location.path);
        } else {
          newErr = err;
        }
      }
    }
    newErr.serverResponse = err.serverResponse;
    return newErr;
  }
  return errorHandler;
}
function objectErrorHandler(location) {
  const shared = sharedErrorHandler(location);
  function errorHandler(xhr, err) {
    let newErr = shared(xhr, err);
    if (xhr.getStatus() === 404) {
      newErr = objectNotFound(location.path);
    }
    newErr.serverResponse = err.serverResponse;
    return newErr;
  }
  return errorHandler;
}
function getDownloadUrl(service, location, mappings) {
  const urlPart = location.fullServerUrl();
  const url = makeUrl(urlPart, service.host, service._protocol);
  const method = "GET";
  const timeout = service.maxOperationRetryTime;
  const requestInfo = new RequestInfo(url, method, downloadUrlHandler(service, mappings), timeout);
  requestInfo.errorHandler = objectErrorHandler(location);
  return requestInfo;
}
var Reference = class {
  constructor(_service, location) {
    this._service = _service;
    if (location instanceof Location) {
      this._location = location;
    } else {
      this._location = Location.makeFromUrl(location, _service.host);
    }
  }
  toString() {
    return "gs://" + this._location.bucket + "/" + this._location.path;
  }
  _newRef(service, location) {
    return new Reference(service, location);
  }
  get root() {
    const location = new Location(this._location.bucket, "");
    return this._newRef(this._service, location);
  }
  get bucket() {
    return this._location.bucket;
  }
  get fullPath() {
    return this._location.path;
  }
  get name() {
    return lastComponent(this._location.path);
  }
  get storage() {
    return this._service;
  }
  get parent() {
    const newPath = parent(this._location.path);
    if (newPath === null) {
      return null;
    }
    const location = new Location(this._location.bucket, newPath);
    return new Reference(this._service, location);
  }
  _throwIfRoot(name2) {
    if (this._location.path === "") {
      throw invalidRootOperation(name2);
    }
  }
};
async function getDownloadURL$1(ref2) {
  ref2._throwIfRoot("getDownloadURL");
  const requestInfo = getDownloadUrl(ref2.storage, ref2._location, getMappings());
  return (await ref2.storage.makeRequestWithTokens(requestInfo)).getPromise().then((url) => {
    if (url === null) {
      throw noDownloadURL();
    }
    return url;
  });
}
function _getChild$1(ref2, childPath) {
  const newPath = child(ref2._location.path, childPath);
  const location = new Location(ref2._location.bucket, newPath);
  return new Reference(ref2.storage, location);
}
function isUrl(path) {
  return /^[A-Za-z]+:\/\//.test(path);
}
function refFromURL(service, url) {
  return new Reference(service, url);
}
function refFromPath(ref2, path) {
  if (ref2 instanceof FirebaseStorageImpl) {
    const service = ref2;
    if (service._bucket == null) {
      throw noDefaultBucket();
    }
    const reference = new Reference(service, service._bucket);
    if (path != null) {
      return refFromPath(reference, path);
    } else {
      return reference;
    }
  } else {
    if (path !== void 0) {
      return _getChild$1(ref2, path);
    } else {
      return ref2;
    }
  }
}
function ref$1(serviceOrRef, pathOrUrl) {
  if (pathOrUrl && isUrl(pathOrUrl)) {
    if (serviceOrRef instanceof FirebaseStorageImpl) {
      return refFromURL(serviceOrRef, pathOrUrl);
    } else {
      throw invalidArgument("To use ref(service, url), the first argument must be a Storage instance.");
    }
  } else {
    return refFromPath(serviceOrRef, pathOrUrl);
  }
}
function extractBucket(host, config2) {
  const bucketString = config2 === null || config2 === void 0 ? void 0 : config2[CONFIG_STORAGE_BUCKET_KEY];
  if (bucketString == null) {
    return null;
  }
  return Location.makeFromBucketSpec(bucketString, host);
}
var FirebaseStorageImpl = class {
  constructor(app, _authProvider, _appCheckProvider, _pool, _url, _firebaseVersion) {
    this.app = app;
    this._authProvider = _authProvider;
    this._appCheckProvider = _appCheckProvider;
    this._pool = _pool;
    this._url = _url;
    this._firebaseVersion = _firebaseVersion;
    this._bucket = null;
    this._host = DEFAULT_HOST;
    this._protocol = "https";
    this._appId = null;
    this._deleted = false;
    this._maxOperationRetryTime = DEFAULT_MAX_OPERATION_RETRY_TIME;
    this._maxUploadRetryTime = DEFAULT_MAX_UPLOAD_RETRY_TIME;
    this._requests = new Set();
    if (_url != null) {
      this._bucket = Location.makeFromBucketSpec(_url, this._host);
    } else {
      this._bucket = extractBucket(this._host, this.app.options);
    }
  }
  get host() {
    return this._host;
  }
  set host(host) {
    this._host = host;
    if (this._url != null) {
      this._bucket = Location.makeFromBucketSpec(this._url, host);
    } else {
      this._bucket = extractBucket(host, this.app.options);
    }
  }
  get maxUploadRetryTime() {
    return this._maxUploadRetryTime;
  }
  set maxUploadRetryTime(time) {
    validateNumber("time", 0, Number.POSITIVE_INFINITY, time);
    this._maxUploadRetryTime = time;
  }
  get maxOperationRetryTime() {
    return this._maxOperationRetryTime;
  }
  set maxOperationRetryTime(time) {
    validateNumber("time", 0, Number.POSITIVE_INFINITY, time);
    this._maxOperationRetryTime = time;
  }
  async _getAuthToken() {
    if (this._overrideAuthToken) {
      return this._overrideAuthToken;
    }
    const auth2 = this._authProvider.getImmediate({ optional: true });
    if (auth2) {
      const tokenData = await auth2.getToken();
      if (tokenData !== null) {
        return tokenData.accessToken;
      }
    }
    return null;
  }
  async _getAppCheckToken() {
    const appCheck = this._appCheckProvider.getImmediate({ optional: true });
    if (appCheck) {
      const result = await appCheck.getToken();
      return result.token;
    }
    return null;
  }
  _delete() {
    if (!this._deleted) {
      this._deleted = true;
      this._requests.forEach((request) => request.cancel());
      this._requests.clear();
    }
    return Promise.resolve();
  }
  _makeStorageReference(loc) {
    return new Reference(this, loc);
  }
  _makeRequest(requestInfo, authToken, appCheckToken) {
    if (!this._deleted) {
      const request = makeRequest(requestInfo, this._appId, authToken, appCheckToken, this._pool, this._firebaseVersion);
      this._requests.add(request);
      request.getPromise().then(() => this._requests.delete(request), () => this._requests.delete(request));
      return request;
    } else {
      return new FailRequest(appDeleted());
    }
  }
  async makeRequestWithTokens(requestInfo) {
    const [authToken, appCheckToken] = await Promise.all([
      this._getAuthToken(),
      this._getAppCheckToken()
    ]);
    return this._makeRequest(requestInfo, authToken, appCheckToken);
  }
};
var name$2 = "@firebase/storage";
var version$2 = "0.8.3";
var STORAGE_TYPE = "storage";
function getDownloadURL(ref2) {
  ref2 = getModularInstance(ref2);
  return getDownloadURL$1(ref2);
}
function ref(serviceOrRef, pathOrUrl) {
  serviceOrRef = getModularInstance(serviceOrRef);
  return ref$1(serviceOrRef, pathOrUrl);
}
function getStorage(app = getApp(), bucketUrl) {
  app = getModularInstance(app);
  const storageProvider = _getProvider(app, STORAGE_TYPE);
  const storageInstance = storageProvider.getImmediate({
    identifier: bucketUrl
  });
  return storageInstance;
}
function factory$1(container, { instanceIdentifier: url }) {
  const app = container.getProvider("app").getImmediate();
  const authProvider = container.getProvider("auth-internal");
  const appCheckProvider = container.getProvider("app-check-internal");
  return new FirebaseStorageImpl(app, authProvider, appCheckProvider, new ConnectionPool(), url, SDK_VERSION);
}
function registerStorage() {
  _registerComponent(new Component(STORAGE_TYPE, factory$1, "PUBLIC").setMultipleInstances(true));
  registerVersion(name$2, version$2);
}
registerStorage();
function toArray(arr) {
  return Array.prototype.slice.call(arr);
}
function promisifyRequest(request) {
  return new Promise(function(resolve2, reject) {
    request.onsuccess = function() {
      resolve2(request.result);
    };
    request.onerror = function() {
      reject(request.error);
    };
  });
}
function promisifyRequestCall(obj, method, args) {
  var request;
  var p = new Promise(function(resolve2, reject) {
    request = obj[method].apply(obj, args);
    promisifyRequest(request).then(resolve2, reject);
  });
  p.request = request;
  return p;
}
function promisifyCursorRequestCall(obj, method, args) {
  var p = promisifyRequestCall(obj, method, args);
  return p.then(function(value) {
    if (!value)
      return;
    return new Cursor(value, p.request);
  });
}
function proxyProperties(ProxyClass, targetProp, properties) {
  properties.forEach(function(prop) {
    Object.defineProperty(ProxyClass.prototype, prop, {
      get: function() {
        return this[targetProp][prop];
      },
      set: function(val) {
        this[targetProp][prop] = val;
      }
    });
  });
}
function proxyRequestMethods(ProxyClass, targetProp, Constructor, properties) {
  properties.forEach(function(prop) {
    if (!(prop in Constructor.prototype))
      return;
    ProxyClass.prototype[prop] = function() {
      return promisifyRequestCall(this[targetProp], prop, arguments);
    };
  });
}
function proxyMethods(ProxyClass, targetProp, Constructor, properties) {
  properties.forEach(function(prop) {
    if (!(prop in Constructor.prototype))
      return;
    ProxyClass.prototype[prop] = function() {
      return this[targetProp][prop].apply(this[targetProp], arguments);
    };
  });
}
function proxyCursorRequestMethods(ProxyClass, targetProp, Constructor, properties) {
  properties.forEach(function(prop) {
    if (!(prop in Constructor.prototype))
      return;
    ProxyClass.prototype[prop] = function() {
      return promisifyCursorRequestCall(this[targetProp], prop, arguments);
    };
  });
}
function Index(index2) {
  this._index = index2;
}
proxyProperties(Index, "_index", [
  "name",
  "keyPath",
  "multiEntry",
  "unique"
]);
proxyRequestMethods(Index, "_index", IDBIndex, [
  "get",
  "getKey",
  "getAll",
  "getAllKeys",
  "count"
]);
proxyCursorRequestMethods(Index, "_index", IDBIndex, [
  "openCursor",
  "openKeyCursor"
]);
function Cursor(cursor, request) {
  this._cursor = cursor;
  this._request = request;
}
proxyProperties(Cursor, "_cursor", [
  "direction",
  "key",
  "primaryKey",
  "value"
]);
proxyRequestMethods(Cursor, "_cursor", IDBCursor, [
  "update",
  "delete"
]);
["advance", "continue", "continuePrimaryKey"].forEach(function(methodName) {
  if (!(methodName in IDBCursor.prototype))
    return;
  Cursor.prototype[methodName] = function() {
    var cursor = this;
    var args = arguments;
    return Promise.resolve().then(function() {
      cursor._cursor[methodName].apply(cursor._cursor, args);
      return promisifyRequest(cursor._request).then(function(value) {
        if (!value)
          return;
        return new Cursor(value, cursor._request);
      });
    });
  };
});
function ObjectStore(store) {
  this._store = store;
}
ObjectStore.prototype.createIndex = function() {
  return new Index(this._store.createIndex.apply(this._store, arguments));
};
ObjectStore.prototype.index = function() {
  return new Index(this._store.index.apply(this._store, arguments));
};
proxyProperties(ObjectStore, "_store", [
  "name",
  "keyPath",
  "indexNames",
  "autoIncrement"
]);
proxyRequestMethods(ObjectStore, "_store", IDBObjectStore, [
  "put",
  "add",
  "delete",
  "clear",
  "get",
  "getAll",
  "getKey",
  "getAllKeys",
  "count"
]);
proxyCursorRequestMethods(ObjectStore, "_store", IDBObjectStore, [
  "openCursor",
  "openKeyCursor"
]);
proxyMethods(ObjectStore, "_store", IDBObjectStore, [
  "deleteIndex"
]);
function Transaction(idbTransaction) {
  this._tx = idbTransaction;
  this.complete = new Promise(function(resolve2, reject) {
    idbTransaction.oncomplete = function() {
      resolve2();
    };
    idbTransaction.onerror = function() {
      reject(idbTransaction.error);
    };
    idbTransaction.onabort = function() {
      reject(idbTransaction.error);
    };
  });
}
Transaction.prototype.objectStore = function() {
  return new ObjectStore(this._tx.objectStore.apply(this._tx, arguments));
};
proxyProperties(Transaction, "_tx", [
  "objectStoreNames",
  "mode"
]);
proxyMethods(Transaction, "_tx", IDBTransaction, [
  "abort"
]);
function UpgradeDB(db2, oldVersion, transaction) {
  this._db = db2;
  this.oldVersion = oldVersion;
  this.transaction = new Transaction(transaction);
}
UpgradeDB.prototype.createObjectStore = function() {
  return new ObjectStore(this._db.createObjectStore.apply(this._db, arguments));
};
proxyProperties(UpgradeDB, "_db", [
  "name",
  "version",
  "objectStoreNames"
]);
proxyMethods(UpgradeDB, "_db", IDBDatabase, [
  "deleteObjectStore",
  "close"
]);
function DB(db2) {
  this._db = db2;
}
DB.prototype.transaction = function() {
  return new Transaction(this._db.transaction.apply(this._db, arguments));
};
proxyProperties(DB, "_db", [
  "name",
  "version",
  "objectStoreNames"
]);
proxyMethods(DB, "_db", IDBDatabase, [
  "close"
]);
["openCursor", "openKeyCursor"].forEach(function(funcName) {
  [ObjectStore, Index].forEach(function(Constructor) {
    if (!(funcName in Constructor.prototype))
      return;
    Constructor.prototype[funcName.replace("open", "iterate")] = function() {
      var args = toArray(arguments);
      var callback = args[args.length - 1];
      var nativeObject = this._store || this._index;
      var request = nativeObject[funcName].apply(nativeObject, args.slice(0, -1));
      request.onsuccess = function() {
        callback(request.result);
      };
    };
  });
});
[Index, ObjectStore].forEach(function(Constructor) {
  if (Constructor.prototype.getAll)
    return;
  Constructor.prototype.getAll = function(query, count) {
    var instance = this;
    var items = [];
    return new Promise(function(resolve2) {
      instance.iterateCursor(query, function(cursor) {
        if (!cursor) {
          resolve2(items);
          return;
        }
        items.push(cursor.value);
        if (count !== void 0 && items.length == count) {
          resolve2(items);
          return;
        }
        cursor.continue();
      });
    });
  };
});
function openDb(name2, version2, upgradeCallback) {
  var p = promisifyRequestCall(indexedDB, "open", [name2, version2]);
  var request = p.request;
  if (request) {
    request.onupgradeneeded = function(event) {
      if (upgradeCallback) {
        upgradeCallback(new UpgradeDB(request.result, event.oldVersion, request.transaction));
      }
    };
  }
  return p.then(function(db2) {
    return new DB(db2);
  });
}
var name$1 = "@firebase/installations";
var version$1 = "0.5.1";
var PENDING_TIMEOUT_MS = 1e4;
var PACKAGE_VERSION = `w:${version$1}`;
var INTERNAL_AUTH_VERSION = "FIS_v2";
var INSTALLATIONS_API_URL = "https://firebaseinstallations.googleapis.com/v1";
var TOKEN_EXPIRATION_BUFFER = 60 * 60 * 1e3;
var SERVICE = "installations";
var SERVICE_NAME = "Installations";
var ERROR_DESCRIPTION_MAP = {
  ["missing-app-config-values"]: 'Missing App configuration value: "{$valueName}"',
  ["not-registered"]: "Firebase Installation is not registered.",
  ["installation-not-found"]: "Firebase Installation not found.",
  ["request-failed"]: '{$requestName} request failed with error "{$serverCode} {$serverStatus}: {$serverMessage}"',
  ["app-offline"]: "Could not process request. Application offline.",
  ["delete-pending-registration"]: "Can't delete installation while there is a pending registration request."
};
var ERROR_FACTORY$1 = new ErrorFactory(SERVICE, SERVICE_NAME, ERROR_DESCRIPTION_MAP);
function isServerError(error2) {
  return error2 instanceof FirebaseError && error2.code.includes("request-failed");
}
function getInstallationsEndpoint({ projectId }) {
  return `${INSTALLATIONS_API_URL}/projects/${projectId}/installations`;
}
function extractAuthTokenInfoFromResponse(response) {
  return {
    token: response.token,
    requestStatus: 2,
    expiresIn: getExpiresInFromResponseExpiresIn(response.expiresIn),
    creationTime: Date.now()
  };
}
async function getErrorFromResponse(requestName, response) {
  const responseJson = await response.json();
  const errorData = responseJson.error;
  return ERROR_FACTORY$1.create("request-failed", {
    requestName,
    serverCode: errorData.code,
    serverMessage: errorData.message,
    serverStatus: errorData.status
  });
}
function getHeaders$1({ apiKey }) {
  return new Headers({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-goog-api-key": apiKey
  });
}
function getHeadersWithAuth(appConfig, { refreshToken }) {
  const headers = getHeaders$1(appConfig);
  headers.append("Authorization", getAuthorizationHeader(refreshToken));
  return headers;
}
async function retryIfServerError(fn) {
  const result = await fn();
  if (result.status >= 500 && result.status < 600) {
    return fn();
  }
  return result;
}
function getExpiresInFromResponseExpiresIn(responseExpiresIn) {
  return Number(responseExpiresIn.replace("s", "000"));
}
function getAuthorizationHeader(refreshToken) {
  return `${INTERNAL_AUTH_VERSION} ${refreshToken}`;
}
async function createInstallationRequest(appConfig, { fid }) {
  const endpoint = getInstallationsEndpoint(appConfig);
  const headers = getHeaders$1(appConfig);
  const body = {
    fid,
    authVersion: INTERNAL_AUTH_VERSION,
    appId: appConfig.appId,
    sdkVersion: PACKAGE_VERSION
  };
  const request = {
    method: "POST",
    headers,
    body: JSON.stringify(body)
  };
  const response = await retryIfServerError(() => fetch(endpoint, request));
  if (response.ok) {
    const responseValue = await response.json();
    const registeredInstallationEntry = {
      fid: responseValue.fid || fid,
      registrationStatus: 2,
      refreshToken: responseValue.refreshToken,
      authToken: extractAuthTokenInfoFromResponse(responseValue.authToken)
    };
    return registeredInstallationEntry;
  } else {
    throw await getErrorFromResponse("Create Installation", response);
  }
}
function sleep(ms) {
  return new Promise((resolve2) => {
    setTimeout(resolve2, ms);
  });
}
function bufferToBase64UrlSafe(array) {
  const b64 = btoa(String.fromCharCode(...array));
  return b64.replace(/\+/g, "-").replace(/\//g, "_");
}
var VALID_FID_PATTERN = /^[cdef][\w-]{21}$/;
var INVALID_FID = "";
function generateFid() {
  try {
    const fidByteArray = new Uint8Array(17);
    const crypto = self.crypto || self.msCrypto;
    crypto.getRandomValues(fidByteArray);
    fidByteArray[0] = 112 + fidByteArray[0] % 16;
    const fid = encode(fidByteArray);
    return VALID_FID_PATTERN.test(fid) ? fid : INVALID_FID;
  } catch (_a) {
    return INVALID_FID;
  }
}
function encode(fidByteArray) {
  const b64String = bufferToBase64UrlSafe(fidByteArray);
  return b64String.substr(0, 22);
}
function getKey(appConfig) {
  return `${appConfig.appName}!${appConfig.appId}`;
}
var fidChangeCallbacks = new Map();
function fidChanged(appConfig, fid) {
  const key = getKey(appConfig);
  callFidChangeCallbacks(key, fid);
  broadcastFidChange(key, fid);
}
function callFidChangeCallbacks(key, fid) {
  const callbacks = fidChangeCallbacks.get(key);
  if (!callbacks) {
    return;
  }
  for (const callback of callbacks) {
    callback(fid);
  }
}
function broadcastFidChange(key, fid) {
  const channel = getBroadcastChannel();
  if (channel) {
    channel.postMessage({ key, fid });
  }
  closeBroadcastChannel();
}
var broadcastChannel = null;
function getBroadcastChannel() {
  if (!broadcastChannel && "BroadcastChannel" in self) {
    broadcastChannel = new BroadcastChannel("[Firebase] FID Change");
    broadcastChannel.onmessage = (e) => {
      callFidChangeCallbacks(e.data.key, e.data.fid);
    };
  }
  return broadcastChannel;
}
function closeBroadcastChannel() {
  if (fidChangeCallbacks.size === 0 && broadcastChannel) {
    broadcastChannel.close();
    broadcastChannel = null;
  }
}
var DATABASE_NAME = "firebase-installations-database";
var DATABASE_VERSION = 1;
var OBJECT_STORE_NAME = "firebase-installations-store";
var dbPromise = null;
function getDbPromise() {
  if (!dbPromise) {
    dbPromise = openDb(DATABASE_NAME, DATABASE_VERSION, (upgradeDB) => {
      switch (upgradeDB.oldVersion) {
        case 0:
          upgradeDB.createObjectStore(OBJECT_STORE_NAME);
      }
    });
  }
  return dbPromise;
}
async function set(appConfig, value) {
  const key = getKey(appConfig);
  const db2 = await getDbPromise();
  const tx = db2.transaction(OBJECT_STORE_NAME, "readwrite");
  const objectStore = tx.objectStore(OBJECT_STORE_NAME);
  const oldValue = await objectStore.get(key);
  await objectStore.put(value, key);
  await tx.complete;
  if (!oldValue || oldValue.fid !== value.fid) {
    fidChanged(appConfig, value.fid);
  }
  return value;
}
async function remove(appConfig) {
  const key = getKey(appConfig);
  const db2 = await getDbPromise();
  const tx = db2.transaction(OBJECT_STORE_NAME, "readwrite");
  await tx.objectStore(OBJECT_STORE_NAME).delete(key);
  await tx.complete;
}
async function update(appConfig, updateFn) {
  const key = getKey(appConfig);
  const db2 = await getDbPromise();
  const tx = db2.transaction(OBJECT_STORE_NAME, "readwrite");
  const store = tx.objectStore(OBJECT_STORE_NAME);
  const oldValue = await store.get(key);
  const newValue = updateFn(oldValue);
  if (newValue === void 0) {
    await store.delete(key);
  } else {
    await store.put(newValue, key);
  }
  await tx.complete;
  if (newValue && (!oldValue || oldValue.fid !== newValue.fid)) {
    fidChanged(appConfig, newValue.fid);
  }
  return newValue;
}
async function getInstallationEntry(appConfig) {
  let registrationPromise;
  const installationEntry = await update(appConfig, (oldEntry) => {
    const installationEntry2 = updateOrCreateInstallationEntry(oldEntry);
    const entryWithPromise = triggerRegistrationIfNecessary(appConfig, installationEntry2);
    registrationPromise = entryWithPromise.registrationPromise;
    return entryWithPromise.installationEntry;
  });
  if (installationEntry.fid === INVALID_FID) {
    return { installationEntry: await registrationPromise };
  }
  return {
    installationEntry,
    registrationPromise
  };
}
function updateOrCreateInstallationEntry(oldEntry) {
  const entry = oldEntry || {
    fid: generateFid(),
    registrationStatus: 0
  };
  return clearTimedOutRequest(entry);
}
function triggerRegistrationIfNecessary(appConfig, installationEntry) {
  if (installationEntry.registrationStatus === 0) {
    if (!navigator.onLine) {
      const registrationPromiseWithError = Promise.reject(ERROR_FACTORY$1.create("app-offline"));
      return {
        installationEntry,
        registrationPromise: registrationPromiseWithError
      };
    }
    const inProgressEntry = {
      fid: installationEntry.fid,
      registrationStatus: 1,
      registrationTime: Date.now()
    };
    const registrationPromise = registerInstallation(appConfig, inProgressEntry);
    return { installationEntry: inProgressEntry, registrationPromise };
  } else if (installationEntry.registrationStatus === 1) {
    return {
      installationEntry,
      registrationPromise: waitUntilFidRegistration(appConfig)
    };
  } else {
    return { installationEntry };
  }
}
async function registerInstallation(appConfig, installationEntry) {
  try {
    const registeredInstallationEntry = await createInstallationRequest(appConfig, installationEntry);
    return set(appConfig, registeredInstallationEntry);
  } catch (e) {
    if (isServerError(e) && e.customData.serverCode === 409) {
      await remove(appConfig);
    } else {
      await set(appConfig, {
        fid: installationEntry.fid,
        registrationStatus: 0
      });
    }
    throw e;
  }
}
async function waitUntilFidRegistration(appConfig) {
  let entry = await updateInstallationRequest(appConfig);
  while (entry.registrationStatus === 1) {
    await sleep(100);
    entry = await updateInstallationRequest(appConfig);
  }
  if (entry.registrationStatus === 0) {
    const { installationEntry, registrationPromise } = await getInstallationEntry(appConfig);
    if (registrationPromise) {
      return registrationPromise;
    } else {
      return installationEntry;
    }
  }
  return entry;
}
function updateInstallationRequest(appConfig) {
  return update(appConfig, (oldEntry) => {
    if (!oldEntry) {
      throw ERROR_FACTORY$1.create("installation-not-found");
    }
    return clearTimedOutRequest(oldEntry);
  });
}
function clearTimedOutRequest(entry) {
  if (hasInstallationRequestTimedOut(entry)) {
    return {
      fid: entry.fid,
      registrationStatus: 0
    };
  }
  return entry;
}
function hasInstallationRequestTimedOut(installationEntry) {
  return installationEntry.registrationStatus === 1 && installationEntry.registrationTime + PENDING_TIMEOUT_MS < Date.now();
}
async function generateAuthTokenRequest({ appConfig, platformLoggerProvider }, installationEntry) {
  const endpoint = getGenerateAuthTokenEndpoint(appConfig, installationEntry);
  const headers = getHeadersWithAuth(appConfig, installationEntry);
  const platformLogger = platformLoggerProvider.getImmediate({
    optional: true
  });
  if (platformLogger) {
    headers.append("x-firebase-client", platformLogger.getPlatformInfoString());
  }
  const body = {
    installation: {
      sdkVersion: PACKAGE_VERSION
    }
  };
  const request = {
    method: "POST",
    headers,
    body: JSON.stringify(body)
  };
  const response = await retryIfServerError(() => fetch(endpoint, request));
  if (response.ok) {
    const responseValue = await response.json();
    const completedAuthToken = extractAuthTokenInfoFromResponse(responseValue);
    return completedAuthToken;
  } else {
    throw await getErrorFromResponse("Generate Auth Token", response);
  }
}
function getGenerateAuthTokenEndpoint(appConfig, { fid }) {
  return `${getInstallationsEndpoint(appConfig)}/${fid}/authTokens:generate`;
}
async function refreshAuthToken(installations, forceRefresh = false) {
  let tokenPromise;
  const entry = await update(installations.appConfig, (oldEntry) => {
    if (!isEntryRegistered(oldEntry)) {
      throw ERROR_FACTORY$1.create("not-registered");
    }
    const oldAuthToken = oldEntry.authToken;
    if (!forceRefresh && isAuthTokenValid(oldAuthToken)) {
      return oldEntry;
    } else if (oldAuthToken.requestStatus === 1) {
      tokenPromise = waitUntilAuthTokenRequest(installations, forceRefresh);
      return oldEntry;
    } else {
      if (!navigator.onLine) {
        throw ERROR_FACTORY$1.create("app-offline");
      }
      const inProgressEntry = makeAuthTokenRequestInProgressEntry(oldEntry);
      tokenPromise = fetchAuthTokenFromServer(installations, inProgressEntry);
      return inProgressEntry;
    }
  });
  const authToken = tokenPromise ? await tokenPromise : entry.authToken;
  return authToken;
}
async function waitUntilAuthTokenRequest(installations, forceRefresh) {
  let entry = await updateAuthTokenRequest(installations.appConfig);
  while (entry.authToken.requestStatus === 1) {
    await sleep(100);
    entry = await updateAuthTokenRequest(installations.appConfig);
  }
  const authToken = entry.authToken;
  if (authToken.requestStatus === 0) {
    return refreshAuthToken(installations, forceRefresh);
  } else {
    return authToken;
  }
}
function updateAuthTokenRequest(appConfig) {
  return update(appConfig, (oldEntry) => {
    if (!isEntryRegistered(oldEntry)) {
      throw ERROR_FACTORY$1.create("not-registered");
    }
    const oldAuthToken = oldEntry.authToken;
    if (hasAuthTokenRequestTimedOut(oldAuthToken)) {
      return Object.assign(Object.assign({}, oldEntry), { authToken: { requestStatus: 0 } });
    }
    return oldEntry;
  });
}
async function fetchAuthTokenFromServer(installations, installationEntry) {
  try {
    const authToken = await generateAuthTokenRequest(installations, installationEntry);
    const updatedInstallationEntry = Object.assign(Object.assign({}, installationEntry), { authToken });
    await set(installations.appConfig, updatedInstallationEntry);
    return authToken;
  } catch (e) {
    if (isServerError(e) && (e.customData.serverCode === 401 || e.customData.serverCode === 404)) {
      await remove(installations.appConfig);
    } else {
      const updatedInstallationEntry = Object.assign(Object.assign({}, installationEntry), { authToken: { requestStatus: 0 } });
      await set(installations.appConfig, updatedInstallationEntry);
    }
    throw e;
  }
}
function isEntryRegistered(installationEntry) {
  return installationEntry !== void 0 && installationEntry.registrationStatus === 2;
}
function isAuthTokenValid(authToken) {
  return authToken.requestStatus === 2 && !isAuthTokenExpired(authToken);
}
function isAuthTokenExpired(authToken) {
  const now = Date.now();
  return now < authToken.creationTime || authToken.creationTime + authToken.expiresIn < now + TOKEN_EXPIRATION_BUFFER;
}
function makeAuthTokenRequestInProgressEntry(oldEntry) {
  const inProgressAuthToken = {
    requestStatus: 1,
    requestTime: Date.now()
  };
  return Object.assign(Object.assign({}, oldEntry), { authToken: inProgressAuthToken });
}
function hasAuthTokenRequestTimedOut(authToken) {
  return authToken.requestStatus === 1 && authToken.requestTime + PENDING_TIMEOUT_MS < Date.now();
}
async function getId(installations) {
  const installationsImpl = installations;
  const { installationEntry, registrationPromise } = await getInstallationEntry(installationsImpl.appConfig);
  if (registrationPromise) {
    registrationPromise.catch(console.error);
  } else {
    refreshAuthToken(installationsImpl).catch(console.error);
  }
  return installationEntry.fid;
}
async function getToken(installations, forceRefresh = false) {
  const installationsImpl = installations;
  await completeInstallationRegistration(installationsImpl.appConfig);
  const authToken = await refreshAuthToken(installationsImpl, forceRefresh);
  return authToken.token;
}
async function completeInstallationRegistration(appConfig) {
  const { registrationPromise } = await getInstallationEntry(appConfig);
  if (registrationPromise) {
    await registrationPromise;
  }
}
function extractAppConfig(app) {
  if (!app || !app.options) {
    throw getMissingValueError("App Configuration");
  }
  if (!app.name) {
    throw getMissingValueError("App Name");
  }
  const configKeys = [
    "projectId",
    "apiKey",
    "appId"
  ];
  for (const keyName of configKeys) {
    if (!app.options[keyName]) {
      throw getMissingValueError(keyName);
    }
  }
  return {
    appName: app.name,
    projectId: app.options.projectId,
    apiKey: app.options.apiKey,
    appId: app.options.appId
  };
}
function getMissingValueError(valueName) {
  return ERROR_FACTORY$1.create("missing-app-config-values", {
    valueName
  });
}
var INSTALLATIONS_NAME = "installations";
var INSTALLATIONS_NAME_INTERNAL = "installations-internal";
var publicFactory = (container) => {
  const app = container.getProvider("app").getImmediate();
  const appConfig = extractAppConfig(app);
  const platformLoggerProvider = _getProvider(app, "platform-logger");
  const installationsImpl = {
    app,
    appConfig,
    platformLoggerProvider,
    _delete: () => Promise.resolve()
  };
  return installationsImpl;
};
var internalFactory = (container) => {
  const app = container.getProvider("app").getImmediate();
  const installations = _getProvider(app, INSTALLATIONS_NAME).getImmediate();
  const installationsInternal = {
    getId: () => getId(installations),
    getToken: (forceRefresh) => getToken(installations, forceRefresh)
  };
  return installationsInternal;
};
function registerInstallations() {
  _registerComponent(new Component(INSTALLATIONS_NAME, publicFactory, "PUBLIC"));
  _registerComponent(new Component(INSTALLATIONS_NAME_INTERNAL, internalFactory, "PRIVATE"));
}
registerInstallations();
registerVersion(name$1, version$1);
var ANALYTICS_TYPE = "analytics";
var GA_FID_KEY = "firebase_id";
var ORIGIN_KEY = "origin";
var FETCH_TIMEOUT_MILLIS = 60 * 1e3;
var DYNAMIC_CONFIG_URL = "https://firebase.googleapis.com/v1alpha/projects/-/apps/{app-id}/webConfig";
var GTAG_URL = "https://www.googletagmanager.com/gtag/js";
var logger = new Logger("@firebase/analytics");
function promiseAllSettled(promises) {
  return Promise.all(promises.map((promise) => promise.catch((e) => e)));
}
function insertScriptTag(dataLayerName2, measurementId) {
  const script = document.createElement("script");
  script.src = `${GTAG_URL}?l=${dataLayerName2}&id=${measurementId}`;
  script.async = true;
  document.head.appendChild(script);
}
function getOrCreateDataLayer(dataLayerName2) {
  let dataLayer = [];
  if (Array.isArray(window[dataLayerName2])) {
    dataLayer = window[dataLayerName2];
  } else {
    window[dataLayerName2] = dataLayer;
  }
  return dataLayer;
}
async function gtagOnConfig(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementIdToAppId2, measurementId, gtagParams) {
  const correspondingAppId = measurementIdToAppId2[measurementId];
  try {
    if (correspondingAppId) {
      await initializationPromisesMap2[correspondingAppId];
    } else {
      const dynamicConfigResults = await promiseAllSettled(dynamicConfigPromisesList2);
      const foundConfig = dynamicConfigResults.find((config2) => config2.measurementId === measurementId);
      if (foundConfig) {
        await initializationPromisesMap2[foundConfig.appId];
      }
    }
  } catch (e) {
    logger.error(e);
  }
  gtagCore("config", measurementId, gtagParams);
}
async function gtagOnEvent(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementId, gtagParams) {
  try {
    let initializationPromisesToWaitFor = [];
    if (gtagParams && gtagParams["send_to"]) {
      let gaSendToList = gtagParams["send_to"];
      if (!Array.isArray(gaSendToList)) {
        gaSendToList = [gaSendToList];
      }
      const dynamicConfigResults = await promiseAllSettled(dynamicConfigPromisesList2);
      for (const sendToId of gaSendToList) {
        const foundConfig = dynamicConfigResults.find((config2) => config2.measurementId === sendToId);
        const initializationPromise = foundConfig && initializationPromisesMap2[foundConfig.appId];
        if (initializationPromise) {
          initializationPromisesToWaitFor.push(initializationPromise);
        } else {
          initializationPromisesToWaitFor = [];
          break;
        }
      }
    }
    if (initializationPromisesToWaitFor.length === 0) {
      initializationPromisesToWaitFor = Object.values(initializationPromisesMap2);
    }
    await Promise.all(initializationPromisesToWaitFor);
    gtagCore("event", measurementId, gtagParams || {});
  } catch (e) {
    logger.error(e);
  }
}
function wrapGtag(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementIdToAppId2) {
  async function gtagWrapper(command, idOrNameOrParams, gtagParams) {
    try {
      if (command === "event") {
        await gtagOnEvent(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, idOrNameOrParams, gtagParams);
      } else if (command === "config") {
        await gtagOnConfig(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementIdToAppId2, idOrNameOrParams, gtagParams);
      } else {
        gtagCore("set", idOrNameOrParams);
      }
    } catch (e) {
      logger.error(e);
    }
  }
  return gtagWrapper;
}
function wrapOrCreateGtag(initializationPromisesMap2, dynamicConfigPromisesList2, measurementIdToAppId2, dataLayerName2, gtagFunctionName) {
  let gtagCore = function(..._args) {
    window[dataLayerName2].push(arguments);
  };
  if (window[gtagFunctionName] && typeof window[gtagFunctionName] === "function") {
    gtagCore = window[gtagFunctionName];
  }
  window[gtagFunctionName] = wrapGtag(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementIdToAppId2);
  return {
    gtagCore,
    wrappedGtag: window[gtagFunctionName]
  };
}
function findGtagScriptOnPage() {
  const scriptTags = window.document.getElementsByTagName("script");
  for (const tag of Object.values(scriptTags)) {
    if (tag.src && tag.src.includes(GTAG_URL)) {
      return tag;
    }
  }
  return null;
}
var ERRORS = {
  ["already-exists"]: "A Firebase Analytics instance with the appId {$id}  already exists. Only one Firebase Analytics instance can be created for each appId.",
  ["already-initialized"]: "initializeAnalytics() cannot be called again with different options than those it was initially called with. It can be called again with the same options to return the existing instance, or getAnalytics() can be used to get a reference to the already-intialized instance.",
  ["already-initialized-settings"]: "Firebase Analytics has already been initialized.settings() must be called before initializing any Analytics instanceor it will have no effect.",
  ["interop-component-reg-failed"]: "Firebase Analytics Interop Component failed to instantiate: {$reason}",
  ["invalid-analytics-context"]: "Firebase Analytics is not supported in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}",
  ["indexeddb-unavailable"]: "IndexedDB unavailable or restricted in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}",
  ["fetch-throttle"]: "The config fetch request timed out while in an exponential backoff state. Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.",
  ["config-fetch-failed"]: "Dynamic config fetch failed: [{$httpStatus}] {$responseMessage}",
  ["no-api-key"]: 'The "apiKey" field is empty in the local Firebase config. Firebase Analytics requires this field tocontain a valid API key.',
  ["no-app-id"]: 'The "appId" field is empty in the local Firebase config. Firebase Analytics requires this field tocontain a valid app ID.'
};
var ERROR_FACTORY = new ErrorFactory("analytics", "Analytics", ERRORS);
var LONG_RETRY_FACTOR = 30;
var BASE_INTERVAL_MILLIS = 1e3;
var RetryData = class {
  constructor(throttleMetadata = {}, intervalMillis = BASE_INTERVAL_MILLIS) {
    this.throttleMetadata = throttleMetadata;
    this.intervalMillis = intervalMillis;
  }
  getThrottleMetadata(appId) {
    return this.throttleMetadata[appId];
  }
  setThrottleMetadata(appId, metadata) {
    this.throttleMetadata[appId] = metadata;
  }
  deleteThrottleMetadata(appId) {
    delete this.throttleMetadata[appId];
  }
};
var defaultRetryData = new RetryData();
function getHeaders(apiKey) {
  return new Headers({
    Accept: "application/json",
    "x-goog-api-key": apiKey
  });
}
async function fetchDynamicConfig(appFields) {
  var _a;
  const { appId, apiKey } = appFields;
  const request = {
    method: "GET",
    headers: getHeaders(apiKey)
  };
  const appUrl = DYNAMIC_CONFIG_URL.replace("{app-id}", appId);
  const response = await fetch(appUrl, request);
  if (response.status !== 200 && response.status !== 304) {
    let errorMessage = "";
    try {
      const jsonResponse = await response.json();
      if ((_a = jsonResponse.error) === null || _a === void 0 ? void 0 : _a.message) {
        errorMessage = jsonResponse.error.message;
      }
    } catch (_ignored) {
    }
    throw ERROR_FACTORY.create("config-fetch-failed", {
      httpStatus: response.status,
      responseMessage: errorMessage
    });
  }
  return response.json();
}
async function fetchDynamicConfigWithRetry(app, retryData = defaultRetryData, timeoutMillis) {
  const { appId, apiKey, measurementId } = app.options;
  if (!appId) {
    throw ERROR_FACTORY.create("no-app-id");
  }
  if (!apiKey) {
    if (measurementId) {
      return {
        measurementId,
        appId
      };
    }
    throw ERROR_FACTORY.create("no-api-key");
  }
  const throttleMetadata = retryData.getThrottleMetadata(appId) || {
    backoffCount: 0,
    throttleEndTimeMillis: Date.now()
  };
  const signal = new AnalyticsAbortSignal();
  setTimeout(async () => {
    signal.abort();
  }, timeoutMillis !== void 0 ? timeoutMillis : FETCH_TIMEOUT_MILLIS);
  return attemptFetchDynamicConfigWithRetry({ appId, apiKey, measurementId }, throttleMetadata, signal, retryData);
}
async function attemptFetchDynamicConfigWithRetry(appFields, { throttleEndTimeMillis, backoffCount }, signal, retryData = defaultRetryData) {
  const { appId, measurementId } = appFields;
  try {
    await setAbortableTimeout(signal, throttleEndTimeMillis);
  } catch (e) {
    if (measurementId) {
      logger.warn(`Timed out fetching this Firebase app's measurement ID from the server. Falling back to the measurement ID ${measurementId} provided in the "measurementId" field in the local Firebase config. [${e.message}]`);
      return { appId, measurementId };
    }
    throw e;
  }
  try {
    const response = await fetchDynamicConfig(appFields);
    retryData.deleteThrottleMetadata(appId);
    return response;
  } catch (e) {
    if (!isRetriableError(e)) {
      retryData.deleteThrottleMetadata(appId);
      if (measurementId) {
        logger.warn(`Failed to fetch this Firebase app's measurement ID from the server. Falling back to the measurement ID ${measurementId} provided in the "measurementId" field in the local Firebase config. [${e.message}]`);
        return { appId, measurementId };
      } else {
        throw e;
      }
    }
    const backoffMillis = Number(e.customData.httpStatus) === 503 ? calculateBackoffMillis(backoffCount, retryData.intervalMillis, LONG_RETRY_FACTOR) : calculateBackoffMillis(backoffCount, retryData.intervalMillis);
    const throttleMetadata = {
      throttleEndTimeMillis: Date.now() + backoffMillis,
      backoffCount: backoffCount + 1
    };
    retryData.setThrottleMetadata(appId, throttleMetadata);
    logger.debug(`Calling attemptFetch again in ${backoffMillis} millis`);
    return attemptFetchDynamicConfigWithRetry(appFields, throttleMetadata, signal, retryData);
  }
}
function setAbortableTimeout(signal, throttleEndTimeMillis) {
  return new Promise((resolve2, reject) => {
    const backoffMillis = Math.max(throttleEndTimeMillis - Date.now(), 0);
    const timeout = setTimeout(resolve2, backoffMillis);
    signal.addEventListener(() => {
      clearTimeout(timeout);
      reject(ERROR_FACTORY.create("fetch-throttle", {
        throttleEndTimeMillis
      }));
    });
  });
}
function isRetriableError(e) {
  if (!(e instanceof FirebaseError) || !e.customData) {
    return false;
  }
  const httpStatus = Number(e.customData["httpStatus"]);
  return httpStatus === 429 || httpStatus === 500 || httpStatus === 503 || httpStatus === 504;
}
var AnalyticsAbortSignal = class {
  constructor() {
    this.listeners = [];
  }
  addEventListener(listener) {
    this.listeners.push(listener);
  }
  abort() {
    this.listeners.forEach((listener) => listener());
  }
};
async function validateIndexedDB() {
  if (!isIndexedDBAvailable()) {
    logger.warn(ERROR_FACTORY.create("indexeddb-unavailable", {
      errorInfo: "IndexedDB is not available in this environment."
    }).message);
    return false;
  } else {
    try {
      await validateIndexedDBOpenable();
    } catch (e) {
      logger.warn(ERROR_FACTORY.create("indexeddb-unavailable", {
        errorInfo: e
      }).message);
      return false;
    }
  }
  return true;
}
async function _initializeAnalytics(app, dynamicConfigPromisesList2, measurementIdToAppId2, installations, gtagCore, dataLayerName2, options2) {
  var _a;
  const dynamicConfigPromise = fetchDynamicConfigWithRetry(app);
  dynamicConfigPromise.then((config2) => {
    measurementIdToAppId2[config2.measurementId] = config2.appId;
    if (app.options.measurementId && config2.measurementId !== app.options.measurementId) {
      logger.warn(`The measurement ID in the local Firebase config (${app.options.measurementId}) does not match the measurement ID fetched from the server (${config2.measurementId}). To ensure analytics events are always sent to the correct Analytics property, update the measurement ID field in the local config or remove it from the local config.`);
    }
  }).catch((e) => logger.error(e));
  dynamicConfigPromisesList2.push(dynamicConfigPromise);
  const fidPromise = validateIndexedDB().then((envIsValid) => {
    if (envIsValid) {
      return installations.getId();
    } else {
      return void 0;
    }
  });
  const [dynamicConfig, fid] = await Promise.all([
    dynamicConfigPromise,
    fidPromise
  ]);
  if (!findGtagScriptOnPage()) {
    insertScriptTag(dataLayerName2, dynamicConfig.measurementId);
  }
  gtagCore("js", new Date());
  const configProperties = (_a = options2 === null || options2 === void 0 ? void 0 : options2.config) !== null && _a !== void 0 ? _a : {};
  configProperties[ORIGIN_KEY] = "firebase";
  configProperties.update = true;
  if (fid != null) {
    configProperties[GA_FID_KEY] = fid;
  }
  gtagCore("config", dynamicConfig.measurementId, configProperties);
  return dynamicConfig.measurementId;
}
var AnalyticsService = class {
  constructor(app) {
    this.app = app;
  }
  _delete() {
    delete initializationPromisesMap[this.app.options.appId];
    return Promise.resolve();
  }
};
var initializationPromisesMap = {};
var dynamicConfigPromisesList = [];
var measurementIdToAppId = {};
var dataLayerName = "dataLayer";
var gtagName = "gtag";
var gtagCoreFunction;
var wrappedGtagFunction;
var globalInitDone = false;
function warnOnBrowserContextMismatch() {
  const mismatchedEnvMessages = [];
  if (isBrowserExtension()) {
    mismatchedEnvMessages.push("This is a browser extension environment.");
  }
  if (!areCookiesEnabled()) {
    mismatchedEnvMessages.push("Cookies are not available.");
  }
  if (mismatchedEnvMessages.length > 0) {
    const details = mismatchedEnvMessages.map((message, index2) => `(${index2 + 1}) ${message}`).join(" ");
    const err = ERROR_FACTORY.create("invalid-analytics-context", {
      errorInfo: details
    });
    logger.warn(err.message);
  }
}
function factory(app, installations, options2) {
  warnOnBrowserContextMismatch();
  const appId = app.options.appId;
  if (!appId) {
    throw ERROR_FACTORY.create("no-app-id");
  }
  if (!app.options.apiKey) {
    if (app.options.measurementId) {
      logger.warn(`The "apiKey" field is empty in the local Firebase config. This is needed to fetch the latest measurement ID for this Firebase app. Falling back to the measurement ID ${app.options.measurementId} provided in the "measurementId" field in the local Firebase config.`);
    } else {
      throw ERROR_FACTORY.create("no-api-key");
    }
  }
  if (initializationPromisesMap[appId] != null) {
    throw ERROR_FACTORY.create("already-exists", {
      id: appId
    });
  }
  if (!globalInitDone) {
    getOrCreateDataLayer(dataLayerName);
    const { wrappedGtag, gtagCore } = wrapOrCreateGtag(initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, dataLayerName, gtagName);
    wrappedGtagFunction = wrappedGtag;
    gtagCoreFunction = gtagCore;
    globalInitDone = true;
  }
  initializationPromisesMap[appId] = _initializeAnalytics(app, dynamicConfigPromisesList, measurementIdToAppId, installations, gtagCoreFunction, dataLayerName, options2);
  const analyticsInstance = new AnalyticsService(app);
  return analyticsInstance;
}
async function logEvent$1(gtagFunction, initializationPromise, eventName, eventParams, options2) {
  if (options2 && options2.global) {
    gtagFunction("event", eventName, eventParams);
    return;
  } else {
    const measurementId = await initializationPromise;
    const params = Object.assign(Object.assign({}, eventParams), { "send_to": measurementId });
    gtagFunction("event", eventName, params);
  }
}
function getAnalytics(app = getApp()) {
  app = getModularInstance(app);
  const analyticsProvider = _getProvider(app, ANALYTICS_TYPE);
  if (analyticsProvider.isInitialized()) {
    return analyticsProvider.getImmediate();
  }
  return initializeAnalytics(app);
}
function initializeAnalytics(app, options2 = {}) {
  const analyticsProvider = _getProvider(app, ANALYTICS_TYPE);
  if (analyticsProvider.isInitialized()) {
    const existingInstance = analyticsProvider.getImmediate();
    if (deepEqual(options2, analyticsProvider.getOptions())) {
      return existingInstance;
    } else {
      throw ERROR_FACTORY.create("already-initialized");
    }
  }
  const analyticsInstance = analyticsProvider.initialize({ options: options2 });
  return analyticsInstance;
}
function logEvent(analyticsInstance, eventName, eventParams, options2) {
  analyticsInstance = getModularInstance(analyticsInstance);
  logEvent$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], eventName, eventParams, options2).catch((e) => logger.error(e));
}
var name = "@firebase/analytics";
var version = "0.7.1";
function registerAnalytics() {
  _registerComponent(new Component(ANALYTICS_TYPE, (container, { options: analyticsOptions }) => {
    const app = container.getProvider("app").getImmediate();
    const installations = container.getProvider("installations-internal").getImmediate();
    return factory(app, installations, analyticsOptions);
  }, "PUBLIC"));
  _registerComponent(new Component("analytics-internal", internalFactory2, "PRIVATE"));
  registerVersion(name, version);
  function internalFactory2(container) {
    try {
      const analytics = container.getProvider(ANALYTICS_TYPE).getImmediate();
      return {
        logEvent: (eventName, eventParams, options2) => logEvent(analytics, eventName, eventParams, options2)
      };
    } catch (e) {
      throw ERROR_FACTORY.create("interop-component-reg-failed", {
        reason: e
      });
    }
  }
}
registerAnalytics();
var firebase = initializeApp(config);
var db = (0, import_firestore.getFirestore)();
var storage = getStorage(firebase);
getAuth();
ref(storage, "posts");
getAnalytics(firebase);
async function getPosts() {
  const temp = [];
  const querySnapshot = await (0, import_firestore.getDocs)((0, import_firestore.collection)(db, "posts"));
  querySnapshot.forEach((doc2) => {
    temp.push({ id: doc2.id, data: doc2.data() });
  });
  return temp;
}
async function getImageUrl(img) {
  let imgUrl;
  await getDownloadURL(ref(storage, img)).then((url) => {
    imgUrl = url;
  });
  return imgUrl;
}
var subscriber_queue = [];
function writable(value, start2 = noop$1) {
  let stop2;
  const subscribers = new Set();
  function set2(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop2) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set2(fn(value));
  }
  function subscribe(run2, invalidate = noop$1) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop2 = start2(set2) || noop$1;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0) {
        stop2();
        stop2 = null;
      }
    };
  }
  return { set: set2, update: update2, subscribe };
}
var localStore = writable();
localStore.set(localStorage.getItem("user") ? localStorage.getItem("user") : null);
var css$d = {
  code: "@import url('https://fonts.googleapis.com/css2?family=Libre+Baskerville:wght@400;700&display=swap');a.svelte-148upnq{text-decoration:none}a.svelte-148upnq,.svelte-148upnq{font-family:'Libre Baskerville', serif}button.svelte-148upnq,a.svelte-148upnq{cursor:pointer;transform:scale(1)}a.svelte-148upnq:hover,button.svelte-148upnq:hover{transition:transform 400ms;transform:scale(1.05)}.navbar.svelte-148upnq{margin-top:35px;display:flex;flex-direction:column;justify-content:space-evenly;align-items:center;width:100%}.navbar-block.svelte-148upnq{display:flex;flex-direction:column;justify-content:space-between;align-items:center}.navbar-logo.svelte-148upnq{font-size:30px;font-weight:bold;color:#1c1c1c}.navbar_item.svelte-148upnq{margin:10px 0}.navbar-logo_span.svelte-148upnq{color:#f1f1f1;background-color:#000;padding:10px 0 5px 5px}.active.svelte-148upnq{font-weight:700}.navbar_link.svelte-148upnq{color:#000;font-size:20px;margin:5px 0}.navbar-search.svelte-148upnq{display:flex;margin-right:10px;height:44px;overflow:hidden;border-radius:10px}.navbar-input.svelte-148upnq{width:340px;outline:0;box-sizing:border-box;border:0;transition:width 500ms;font-size:20px;padding-left:10px}.navbar-icon-button.svelte-148upnq{padding:5px;background-color:transparent;outline:0;border:0;margin:0}.navbar-login-button.svelte-148upnq{border:1.5px solid black;border-radius:10px;width:135px;height:46px;background-color:transparent;font-size:20px}.user.svelte-148upnq{width:145px;display:flex;justify-content:space-around}.user-bell.svelte-148upnq{outline:0;border:0;background-color:transparent}.user-image-button.svelte-148upnq{border-radius:50%;overflow:hidden;width:60px;height:60px;position:relative;cursor:pointer}.profile-img.svelte-148upnq{object-position:center;object-fit:contain;width:100%;height:100%}.user-dropdown-options.svelte-148upnq{flex-direction:column;position:absolute;width:171px;height:223px;background-color:#fefefe;top:90px;right:20px;border-radius:0 0 10px 10px;filter:drop-shadow(0px 0px 5px rgba(228, 228, 228, 0.25))}.container-top.svelte-148upnq{border-bottom:1px solid #c4c4c4;padding:1em 1.5em;height:20%}.user-name.svelte-148upnq{font-size:16px;color:#000;margin:0;margin-top:10px;font-weight:bold}.user-username.svelte-148upnq{font-size:14px;color:rgba(28, 28, 28, 0.8);margin:0;margin:0;font-family:-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell,\r\n			'Open Sans', 'Helvetica Neue', sans-serif}.container-bottom.svelte-148upnq{display:flex;flex-direction:column;justify-content:space-evenly;height:80%;padding-left:1.5em}.dropdown-link.svelte-148upnq{text-decoration:none;color:#000}.sign-out-button.svelte-148upnq{padding:0;outline:0;border:0;font-size:16px;background-color:transparent;width:70px}@media(min-width: 600px){.navbar.svelte-148upnq{flex-direction:row;justify-content:space-between}.navbar-block.svelte-148upnq{flex-direction:row}.navbar_item.svelte-148upnq{margin:0 20px 0 0}.navbar_link.svelte-148upnq{color:#000;font-size:20px;margin:0 20px}.navbar-icon-button.svelte-148upnq{padding:5px;background-color:transparent;outline:0;border:0;margin:0}.navbar-login-button.svelte-148upnq{border:1.5px solid black;border-radius:10px;width:135px;height:46px;background-color:transparent;font-size:20px}}",
  map: `{"version":3,"file":"__layout.svelte","sources":["__layout.svelte"],"sourcesContent":["<script context=\\"module\\" >\\r\\n\\timport {useAuthListener}  from '../utils/authListener';\\r\\n\\tlet userDetails;\\r\\n\\tuserDetails = useAuthListener();\\r\\n<\/script>\\r\\n\\r\\n<script lang=\\"ts\\">import profile from '../assets/images/user/profile_picture.jpg';\\r\\nimport { userSignout } from '../utils/firebase.apis';\\r\\nimport { localStore } from '../services/localStorage';\\r\\nexport let active;\\r\\nexport let search = false;\\r\\nlocalStore.subscribe((value) => value && (userDetails = JSON.parse(value)));\\r\\nlet user = {\\r\\n    loggedIn: userDetails ? true : false,\\r\\n    user: userDetails,\\r\\n    dropdown: false\\r\\n};\\r\\nfunction handleClick(e) {\\r\\n    e.preventDefault();\\r\\n    search = !search;\\r\\n}\\r\\nfunction handleSubmit(e) {\\r\\n    e.preventDefault();\\r\\n}\\r\\nfunction handleSignout() {\\r\\n    const message = userSignout();\\r\\n    console.log(message);\\r\\n}\\r\\n<\/script>\\r\\n\\r\\n<nav\\r\\n\\ton:click={() => {\\r\\n\\t\\tsearch = false;\\r\\n\\t\\tuser.dropdown = false;\\r\\n\\t}}\\r\\n\\tclass=\\"navbar\\"\\r\\n>\\r\\n\\t<div class=\\"navbar-block\\">\\r\\n\\t\\t<div class=\\"navbar_item\\">\\r\\n\\t\\t\\t<a class=\\"navbar-logo\\" href=\\"/\\"><span class=\\"navbar-logo_span\\">nu</span>ntium.</a>\\r\\n\\t\\t</div>\\r\\n\\t\\t<a href=\\"/\\" class={\`navbar_link \${active === 'home' && 'active'}\`}>Home</a>\\r\\n\\t\\t<a href=\\"/tags\\" class={\`navbar_link \${active === 'tags' && 'active'}\`}>Tags</a>\\r\\n\\t\\t<a href=\\"/about\\" class={\`navbar_link \${active === 'about' && 'active'}\`}>About</a>\\r\\n\\t</div>\\r\\n\\t<div class=\\"navbar-block\\">\\r\\n\\t\\t<form\\r\\n\\t\\t\\ton:submit={handleSubmit}\\r\\n\\t\\t\\tstyle=\\"border: {search ? '1.5px solid #000' : 0}\\"\\r\\n\\t\\t\\tclass=\\"navbar-search\\"\\r\\n\\t\\t>\\r\\n\\t\\t\\t<input\\r\\n\\t\\t\\t\\ton:click={(e) => e.stopPropagation()}\\r\\n\\t\\t\\t\\tstyle=\\"display: {search ? 'block' : 'none'}\\"\\r\\n\\t\\t\\t\\tclass=\\"navbar-input\\"\\r\\n\\t\\t\\t\\ttype=\\"text\\"\\r\\n\\t\\t\\t/>\\r\\n\\t\\t\\t<button\\r\\n\\t\\t\\t\\ton:click={(e) => {\\r\\n\\t\\t\\t\\t\\te.stopPropagation();\\r\\n\\t\\t\\t\\t\\thandleClick(e);\\r\\n\\t\\t\\t\\t}}\\r\\n\\t\\t\\t\\tclass=\\"navbar-icon-button\\"\\r\\n\\t\\t\\t>\\r\\n\\t\\t\\t\\t<svg\\r\\n\\t\\t\\t\\t\\twidth=\\"30\\"\\r\\n\\t\\t\\t\\t\\theight=\\"30\\"\\r\\n\\t\\t\\t\\t\\tviewBox=\\"0 0 30 30\\"\\r\\n\\t\\t\\t\\t\\tfill=\\"none\\"\\r\\n\\t\\t\\t\\t\\txmlns=\\"http://www.w3.org/2000/svg\\"\\r\\n\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\td=\\"M13.75 23.75C19.2728 23.75 23.75 19.2728 23.75 13.75C23.75 8.22715 19.2728 3.75 13.75 3.75C8.22715 3.75 3.75 8.22715 3.75 13.75C3.75 19.2728 8.22715 23.75 13.75 23.75Z\\"\\r\\n\\t\\t\\t\\t\\t\\tstroke=\\"black\\"\\r\\n\\t\\t\\t\\t\\t\\tstroke-width=\\"2\\"\\r\\n\\t\\t\\t\\t\\t\\tstroke-linecap=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\tstroke-linejoin=\\"round\\"\\r\\n\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\td=\\"M26.25 26.25L20.8125 20.8125\\"\\r\\n\\t\\t\\t\\t\\t\\tstroke=\\"black\\"\\r\\n\\t\\t\\t\\t\\t\\tstroke-width=\\"2\\"\\r\\n\\t\\t\\t\\t\\t\\tstroke-linecap=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\tstroke-linejoin=\\"round\\"\\r\\n\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t</svg>\\r\\n\\t\\t\\t</button>\\r\\n\\t\\t</form>\\r\\n\\t\\t{#if user.loggedIn}\\r\\n\\t\\t\\t<div class=\\"user\\">\\r\\n\\t\\t\\t\\t<button class=\\"user-bell\\">\\r\\n\\t\\t\\t\\t\\t<svg\\r\\n\\t\\t\\t\\t\\t\\twidth=\\"30\\"\\r\\n\\t\\t\\t\\t\\t\\theight=\\"30\\"\\r\\n\\t\\t\\t\\t\\t\\tviewBox=\\"0 0 30 30\\"\\r\\n\\t\\t\\t\\t\\t\\tfill=\\"none\\"\\r\\n\\t\\t\\t\\t\\t\\txmlns=\\"http://www.w3.org/2000/svg\\"\\r\\n\\t\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\t\\td=\\"M22.5 10C22.5 8.01088 21.7098 6.10322 20.3033 4.6967C18.8968 3.29018 16.9891 2.5 15 2.5C13.0109 2.5 11.1032 3.29018 9.6967 4.6967C8.29018 6.10322 7.5 8.01088 7.5 10C7.5 18.75 3.75 21.25 3.75 21.25H26.25C26.25 21.25 22.5 18.75 22.5 10Z\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke=\\"black\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke-width=\\"2\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke-linecap=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke-linejoin=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\t\\td=\\"M17.1625 26.25C16.9428 26.6288 16.6273 26.9433 16.2478 27.1619C15.8683 27.3805 15.438 27.4956 15 27.4956C14.5621 27.4956 14.1318 27.3805 13.7522 27.1619C13.3727 26.9433 13.0573 26.6288 12.8375 26.25\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke=\\"black\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke-width=\\"2\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke-linecap=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke-linejoin=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t</svg>\\r\\n\\t\\t\\t\\t</button>\\r\\n\\t\\t\\t\\t<div\\r\\n\\t\\t\\t\\t\\ton:click={(e) => {\\r\\n\\t\\t\\t\\t\\t\\tuser.dropdown = true;\\r\\n\\t\\t\\t\\t\\t\\te.stopPropagation();\\r\\n\\t\\t\\t\\t\\t}}\\r\\n\\t\\t\\t\\t\\tclass=\\"user-image-button\\"\\r\\n\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t\\t<img class=\\"profile-img\\" src={profile} alt=\\"user's profile\\" />\\r\\n\\t\\t\\t\\t</div>\\r\\n\\t\\t\\t</div>\\r\\n\\t\\t{:else}\\r\\n\\t\\t\\t<button on:click={(e) => (location.href = '/login')} class=\\"navbar-login-button\\">Login</button\\r\\n\\t\\t\\t>\\r\\n\\t\\t{/if}\\r\\n\\t\\t<div style=\\"display: {user.dropdown ? 'flex' : 'none'}\\" class=\\"user-dropdown-options\\">\\r\\n\\t\\t\\t<div class=\\"container-top\\">\\r\\n\\t\\t\\t\\t<h2 class=\\"user-name\\">Aslam Idrisi</h2>\\r\\n\\t\\t\\t\\t<p class=\\"user-username gray\\">@willtheastro</p>\\r\\n\\t\\t\\t</div>\\r\\n\\t\\t\\t<div class=\\"container-bottom\\">\\r\\n\\t\\t\\t\\t<a href=\\"/dashboard\\" class=\\"dropdown-link\\">Dashboard</a>\\r\\n\\t\\t\\t\\t<a href=\\"/dashboard/writepost\\" class=\\"dropdown-link\\">Write a Post</a>\\r\\n\\t\\t\\t\\t<a href=\\"/dashboard/settings\\" class=\\"dropdown-link\\">Settings</a>\\r\\n\\t\\t\\t\\t<a href=\\"/helps\\" class=\\"dropdown-link\\">Help</a>\\r\\n\\t\\t\\t\\t<button on:click={handleSignout} class=\\"dropdown-link sign-out-button\\">Sign out</button>\\r\\n\\t\\t\\t</div>\\r\\n\\t\\t</div>\\r\\n\\t</div>\\r\\n</nav>\\r\\n\\r\\n<slot></slot>\\r\\n\\r\\n<style>\\r\\n\\t@import url('https://fonts.googleapis.com/css2?family=Libre+Baskerville:wght@400;700&display=swap');\\r\\n\\ta {\\r\\n\\t\\ttext-decoration: none;\\r\\n\\t}\\r\\n\\r\\n\\ta,\\r\\n\\t* {\\r\\n\\t\\tfont-family: 'Libre Baskerville', serif;\\r\\n\\t}\\r\\n\\r\\n\\tbutton,\\r\\n\\ta {\\r\\n\\t\\tcursor: pointer;\\r\\n\\t\\ttransform: scale(1);\\r\\n\\t}\\r\\n\\r\\n\\ta:hover,\\r\\n\\tbutton:hover {\\r\\n\\t\\ttransition: transform 400ms;\\r\\n\\t\\ttransform: scale(1.05);\\r\\n\\t}\\r\\n\\r\\n\\t.navbar {\\r\\n\\t\\tmargin-top: 35px;\\r\\n\\t\\tdisplay: flex;\\r\\n\\t\\tflex-direction: column;\\r\\n\\t\\tjustify-content: space-evenly;\\r\\n\\t\\talign-items: center;\\r\\n\\t\\twidth: 100%;\\r\\n\\t}\\r\\n\\r\\n\\t.navbar-block {\\r\\n\\t\\tdisplay: flex;\\r\\n\\t\\tflex-direction: column;\\r\\n\\t\\tjustify-content: space-between;\\r\\n\\t\\talign-items: center;\\r\\n\\t}\\r\\n\\t.navbar-logo {\\r\\n\\t\\tfont-size: 30px;\\r\\n\\t\\tfont-weight: bold;\\r\\n\\t\\tcolor: #1c1c1c;\\r\\n\\t}\\r\\n\\r\\n\\t.navbar_item {\\r\\n\\t\\tmargin: 10px 0;\\r\\n\\t}\\r\\n\\r\\n\\t.navbar-logo_span {\\r\\n\\t\\tcolor: #f1f1f1;\\r\\n\\t\\tbackground-color: #000;\\r\\n\\t\\tpadding: 10px 0 5px 5px;\\r\\n\\t}\\r\\n\\r\\n\\t.active {\\r\\n\\t\\tfont-weight: 700;\\r\\n\\t}\\r\\n\\r\\n\\t.navbar_link {\\r\\n\\t\\tcolor: #000;\\r\\n\\t\\tfont-size: 20px;\\r\\n\\t\\tmargin: 5px 0;\\r\\n\\t}\\r\\n\\r\\n\\t.navbar-search {\\r\\n\\t\\tdisplay: flex;\\r\\n\\r\\n\\t\\tmargin-right: 10px;\\r\\n\\t\\theight: 44px;\\r\\n\\t\\toverflow: hidden;\\r\\n\\t\\tborder-radius: 10px;\\r\\n\\t}\\r\\n\\r\\n\\t.navbar-input {\\r\\n\\t\\twidth: 340px;\\r\\n\\t\\toutline: 0;\\r\\n\\t\\tbox-sizing: border-box;\\r\\n\\t\\tborder: 0;\\r\\n\\t\\ttransition: width 500ms;\\r\\n\\t\\tfont-size: 20px;\\r\\n\\t\\tpadding-left: 10px;\\r\\n\\t}\\r\\n\\r\\n\\t.navbar-icon-button {\\r\\n\\t\\tpadding: 5px;\\r\\n\\t\\tbackground-color: transparent;\\r\\n\\t\\toutline: 0;\\r\\n\\t\\tborder: 0;\\r\\n\\t\\tmargin: 0;\\r\\n\\t}\\r\\n\\r\\n\\t.navbar-login-button {\\r\\n\\t\\tborder: 1.5px solid black;\\r\\n\\t\\tborder-radius: 10px;\\r\\n\\t\\twidth: 135px;\\r\\n\\t\\theight: 46px;\\r\\n\\t\\tbackground-color: transparent;\\r\\n\\t\\tfont-size: 20px;\\r\\n\\t}\\r\\n\\r\\n\\t.user {\\r\\n\\t\\twidth: 145px;\\r\\n\\t\\tdisplay: flex;\\r\\n\\t\\tjustify-content: space-around;\\r\\n\\t}\\r\\n\\r\\n\\t.user-bell {\\r\\n\\t\\toutline: 0;\\r\\n\\t\\tborder: 0;\\r\\n\\t\\tbackground-color: transparent;\\r\\n\\t}\\r\\n\\r\\n\\t.user-image-button {\\r\\n\\t\\tborder-radius: 50%;\\r\\n\\t\\toverflow: hidden;\\r\\n\\t\\twidth: 60px;\\r\\n\\t\\theight: 60px;\\r\\n\\t\\tposition: relative;\\r\\n\\t\\tcursor: pointer;\\r\\n\\t}\\r\\n\\r\\n\\t.profile-img {\\r\\n\\t\\tobject-position: center;\\r\\n\\t\\tobject-fit: contain;\\r\\n\\t\\twidth: 100%;\\r\\n\\t\\theight: 100%;\\r\\n\\t}\\r\\n\\r\\n\\t.user-dropdown-options {\\r\\n\\t\\tflex-direction: column;\\r\\n\\t\\tposition: absolute;\\r\\n\\t\\twidth: 171px;\\r\\n\\t\\theight: 223px;\\r\\n\\t\\tbackground-color: #fefefe;\\r\\n\\t\\ttop: 90px;\\r\\n\\t\\tright: 20px;\\r\\n\\t\\tborder-radius: 0 0 10px 10px;\\r\\n\\t\\tfilter: drop-shadow(0px 0px 5px rgba(228, 228, 228, 0.25));\\r\\n\\t}\\r\\n\\r\\n\\t.container-top {\\r\\n\\t\\tborder-bottom: 1px solid #c4c4c4;\\r\\n\\t\\tpadding: 1em 1.5em;\\r\\n\\t\\theight: 20%;\\r\\n\\t}\\r\\n\\r\\n\\t.user-name {\\r\\n\\t\\tfont-size: 16px;\\r\\n\\t\\tcolor: #000;\\r\\n\\t\\tmargin: 0;\\r\\n\\t\\tmargin-top: 10px;\\r\\n\\t\\tfont-weight: bold;\\r\\n\\t}\\r\\n\\r\\n\\t.user-username {\\r\\n\\t\\tfont-size: 14px;\\r\\n\\t\\tcolor: rgba(28, 28, 28, 0.8);\\r\\n\\t\\tmargin: 0;\\r\\n\\t\\tmargin: 0;\\r\\n\\t\\tfont-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell,\\r\\n\\t\\t\\t'Open Sans', 'Helvetica Neue', sans-serif;\\r\\n\\t}\\r\\n\\r\\n\\t.container-bottom {\\r\\n\\t\\tdisplay: flex;\\r\\n\\t\\tflex-direction: column;\\r\\n\\t\\tjustify-content: space-evenly;\\r\\n\\t\\theight: 80%;\\r\\n\\t\\tpadding-left: 1.5em;\\r\\n\\t}\\r\\n\\r\\n\\t.dropdown-link {\\r\\n\\t\\ttext-decoration: none;\\r\\n\\t\\tcolor: #000;\\r\\n\\t}\\r\\n\\r\\n\\t.sign-out-button {\\r\\n\\t\\tpadding: 0;\\r\\n\\t\\toutline: 0;\\r\\n\\t\\tborder: 0;\\r\\n\\t\\tfont-size: 16px;\\r\\n\\t\\tbackground-color: transparent;\\r\\n\\t\\twidth: 70px;\\r\\n\\t}\\r\\n\\r\\n\\t@media (min-width: 600px) {\\r\\n\\t\\t.navbar {\\r\\n\\t\\t\\tflex-direction: row;\\r\\n\\t\\t\\tjustify-content: space-between;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t.navbar-block {\\r\\n\\t\\t\\tflex-direction: row;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t.navbar_item {\\r\\n\\t\\t\\tmargin: 0 20px 0 0;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t.navbar_link {\\r\\n\\t\\t\\tcolor: #000;\\r\\n\\t\\t\\tfont-size: 20px;\\r\\n\\t\\t\\tmargin: 0 20px;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t.navbar-icon-button {\\r\\n\\t\\t\\tpadding: 5px;\\r\\n\\t\\t\\tbackground-color: transparent;\\r\\n\\t\\t\\toutline: 0;\\r\\n\\t\\t\\tborder: 0;\\r\\n\\t\\t\\tmargin: 0;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t.navbar-login-button {\\r\\n\\t\\t\\tborder: 1.5px solid black;\\r\\n\\t\\t\\tborder-radius: 10px;\\r\\n\\t\\t\\twidth: 135px;\\r\\n\\t\\t\\theight: 46px;\\r\\n\\t\\t\\tbackground-color: transparent;\\r\\n\\t\\t\\tfont-size: 20px;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n</style>\\r\\n"],"names":[],"mappings":"AAmJC,QAAQ,IAAI,sFAAsF,CAAC,CAAC,AACpG,CAAC,eAAC,CAAC,AACF,eAAe,CAAE,IAAI,AACtB,CAAC,AAED,gBAAC,CACD,eAAE,CAAC,AACF,WAAW,CAAE,mBAAmB,CAAC,CAAC,KAAK,AACxC,CAAC,AAED,qBAAM,CACN,CAAC,eAAC,CAAC,AACF,MAAM,CAAE,OAAO,CACf,SAAS,CAAE,MAAM,CAAC,CAAC,AACpB,CAAC,AAED,gBAAC,MAAM,CACP,qBAAM,MAAM,AAAC,CAAC,AACb,UAAU,CAAE,SAAS,CAAC,KAAK,CAC3B,SAAS,CAAE,MAAM,IAAI,CAAC,AACvB,CAAC,AAED,OAAO,eAAC,CAAC,AACR,UAAU,CAAE,IAAI,CAChB,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,eAAe,CAAE,YAAY,CAC7B,WAAW,CAAE,MAAM,CACnB,KAAK,CAAE,IAAI,AACZ,CAAC,AAED,aAAa,eAAC,CAAC,AACd,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,eAAe,CAAE,aAAa,CAC9B,WAAW,CAAE,MAAM,AACpB,CAAC,AACD,YAAY,eAAC,CAAC,AACb,SAAS,CAAE,IAAI,CACf,WAAW,CAAE,IAAI,CACjB,KAAK,CAAE,OAAO,AACf,CAAC,AAED,YAAY,eAAC,CAAC,AACb,MAAM,CAAE,IAAI,CAAC,CAAC,AACf,CAAC,AAED,iBAAiB,eAAC,CAAC,AAClB,KAAK,CAAE,OAAO,CACd,gBAAgB,CAAE,IAAI,CACtB,OAAO,CAAE,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,AACxB,CAAC,AAED,OAAO,eAAC,CAAC,AACR,WAAW,CAAE,GAAG,AACjB,CAAC,AAED,YAAY,eAAC,CAAC,AACb,KAAK,CAAE,IAAI,CACX,SAAS,CAAE,IAAI,CACf,MAAM,CAAE,GAAG,CAAC,CAAC,AACd,CAAC,AAED,cAAc,eAAC,CAAC,AACf,OAAO,CAAE,IAAI,CAEb,YAAY,CAAE,IAAI,CAClB,MAAM,CAAE,IAAI,CACZ,QAAQ,CAAE,MAAM,CAChB,aAAa,CAAE,IAAI,AACpB,CAAC,AAED,aAAa,eAAC,CAAC,AACd,KAAK,CAAE,KAAK,CACZ,OAAO,CAAE,CAAC,CACV,UAAU,CAAE,UAAU,CACtB,MAAM,CAAE,CAAC,CACT,UAAU,CAAE,KAAK,CAAC,KAAK,CACvB,SAAS,CAAE,IAAI,CACf,YAAY,CAAE,IAAI,AACnB,CAAC,AAED,mBAAmB,eAAC,CAAC,AACpB,OAAO,CAAE,GAAG,CACZ,gBAAgB,CAAE,WAAW,CAC7B,OAAO,CAAE,CAAC,CACV,MAAM,CAAE,CAAC,CACT,MAAM,CAAE,CAAC,AACV,CAAC,AAED,oBAAoB,eAAC,CAAC,AACrB,MAAM,CAAE,KAAK,CAAC,KAAK,CAAC,KAAK,CACzB,aAAa,CAAE,IAAI,CACnB,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,IAAI,CACZ,gBAAgB,CAAE,WAAW,CAC7B,SAAS,CAAE,IAAI,AAChB,CAAC,AAED,KAAK,eAAC,CAAC,AACN,KAAK,CAAE,KAAK,CACZ,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,YAAY,AAC9B,CAAC,AAED,UAAU,eAAC,CAAC,AACX,OAAO,CAAE,CAAC,CACV,MAAM,CAAE,CAAC,CACT,gBAAgB,CAAE,WAAW,AAC9B,CAAC,AAED,kBAAkB,eAAC,CAAC,AACnB,aAAa,CAAE,GAAG,CAClB,QAAQ,CAAE,MAAM,CAChB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,QAAQ,CAAE,QAAQ,CAClB,MAAM,CAAE,OAAO,AAChB,CAAC,AAED,YAAY,eAAC,CAAC,AACb,eAAe,CAAE,MAAM,CACvB,UAAU,CAAE,OAAO,CACnB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,AACb,CAAC,AAED,sBAAsB,eAAC,CAAC,AACvB,cAAc,CAAE,MAAM,CACtB,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,CACb,gBAAgB,CAAE,OAAO,CACzB,GAAG,CAAE,IAAI,CACT,KAAK,CAAE,IAAI,CACX,aAAa,CAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAC5B,MAAM,CAAE,YAAY,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,AAC3D,CAAC,AAED,cAAc,eAAC,CAAC,AACf,aAAa,CAAE,GAAG,CAAC,KAAK,CAAC,OAAO,CAChC,OAAO,CAAE,GAAG,CAAC,KAAK,CAClB,MAAM,CAAE,GAAG,AACZ,CAAC,AAED,UAAU,eAAC,CAAC,AACX,SAAS,CAAE,IAAI,CACf,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,CAAC,CACT,UAAU,CAAE,IAAI,CAChB,WAAW,CAAE,IAAI,AAClB,CAAC,AAED,cAAc,eAAC,CAAC,AACf,SAAS,CAAE,IAAI,CACf,KAAK,CAAE,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAC5B,MAAM,CAAE,CAAC,CACT,MAAM,CAAE,CAAC,CACT,WAAW,CAAE,aAAa,CAAC,CAAC,kBAAkB,CAAC,CAAC,UAAU,CAAC,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC;GAC7F,WAAW,CAAC,CAAC,gBAAgB,CAAC,CAAC,UAAU,AAC3C,CAAC,AAED,iBAAiB,eAAC,CAAC,AAClB,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,eAAe,CAAE,YAAY,CAC7B,MAAM,CAAE,GAAG,CACX,YAAY,CAAE,KAAK,AACpB,CAAC,AAED,cAAc,eAAC,CAAC,AACf,eAAe,CAAE,IAAI,CACrB,KAAK,CAAE,IAAI,AACZ,CAAC,AAED,gBAAgB,eAAC,CAAC,AACjB,OAAO,CAAE,CAAC,CACV,OAAO,CAAE,CAAC,CACV,MAAM,CAAE,CAAC,CACT,SAAS,CAAE,IAAI,CACf,gBAAgB,CAAE,WAAW,CAC7B,KAAK,CAAE,IAAI,AACZ,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AAC1B,OAAO,eAAC,CAAC,AACR,cAAc,CAAE,GAAG,CACnB,eAAe,CAAE,aAAa,AAC/B,CAAC,AAED,aAAa,eAAC,CAAC,AACd,cAAc,CAAE,GAAG,AACpB,CAAC,AAED,YAAY,eAAC,CAAC,AACb,MAAM,CAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,AACnB,CAAC,AAED,YAAY,eAAC,CAAC,AACb,KAAK,CAAE,IAAI,CACX,SAAS,CAAE,IAAI,CACf,MAAM,CAAE,CAAC,CAAC,IAAI,AACf,CAAC,AAED,mBAAmB,eAAC,CAAC,AACpB,OAAO,CAAE,GAAG,CACZ,gBAAgB,CAAE,WAAW,CAC7B,OAAO,CAAE,CAAC,CACV,MAAM,CAAE,CAAC,CACT,MAAM,CAAE,CAAC,AACV,CAAC,AAED,oBAAoB,eAAC,CAAC,AACrB,MAAM,CAAE,KAAK,CAAC,KAAK,CAAC,KAAK,CACzB,aAAa,CAAE,IAAI,CACnB,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,IAAI,CACZ,gBAAgB,CAAE,WAAW,CAC7B,SAAS,CAAE,IAAI,AAChB,CAAC,AACF,CAAC"}`
};
var userDetails$1;
userDetails$1 = useAuthListener();
var _layout = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { active } = $$props;
  let { search = false } = $$props;
  localStore.subscribe((value) => value && (userDetails$1 = JSON.parse(value)));
  let user2 = {
    loggedIn: userDetails$1 ? true : false,
    user: userDetails$1,
    dropdown: false
  };
  if ($$props.active === void 0 && $$bindings.active && active !== void 0)
    $$bindings.active(active);
  if ($$props.search === void 0 && $$bindings.search && search !== void 0)
    $$bindings.search(search);
  $$result.css.add(css$d);
  return `<nav class="${"navbar svelte-148upnq"}"><div class="${"navbar-block svelte-148upnq"}"><div class="${"navbar_item svelte-148upnq"}"><a class="${"navbar-logo svelte-148upnq"}" href="${"/"}"><span class="${"navbar-logo_span svelte-148upnq"}">nu</span>ntium.</a></div>
		<a href="${"/"}" class="${escape(null_to_empty(`navbar_link ${active === "home" && "active"}`)) + " svelte-148upnq"}">Home</a>
		<a href="${"/tags"}" class="${escape(null_to_empty(`navbar_link ${active === "tags" && "active"}`)) + " svelte-148upnq"}">Tags</a>
		<a href="${"/about"}" class="${escape(null_to_empty(`navbar_link ${active === "about" && "active"}`)) + " svelte-148upnq"}">About</a></div>
	<div class="${"navbar-block svelte-148upnq"}"><form style="${"border: " + escape(search ? "1.5px solid #000" : 0)}" class="${"navbar-search svelte-148upnq"}"><input style="${"display: " + escape(search ? "block" : "none")}" class="${"navbar-input svelte-148upnq"}" type="${"text"}">
			<button class="${"navbar-icon-button svelte-148upnq"}"><svg width="${"30"}" height="${"30"}" viewBox="${"0 0 30 30"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}" class="${"svelte-148upnq"}"><path d="${"M13.75 23.75C19.2728 23.75 23.75 19.2728 23.75 13.75C23.75 8.22715 19.2728 3.75 13.75 3.75C8.22715 3.75 3.75 8.22715 3.75 13.75C3.75 19.2728 8.22715 23.75 13.75 23.75Z"}" stroke="${"black"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-148upnq"}"></path><path d="${"M26.25 26.25L20.8125 20.8125"}" stroke="${"black"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-148upnq"}"></path></svg></button></form>
		${user2.loggedIn ? `<div class="${"user svelte-148upnq"}"><button class="${"user-bell svelte-148upnq"}"><svg width="${"30"}" height="${"30"}" viewBox="${"0 0 30 30"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}" class="${"svelte-148upnq"}"><path d="${"M22.5 10C22.5 8.01088 21.7098 6.10322 20.3033 4.6967C18.8968 3.29018 16.9891 2.5 15 2.5C13.0109 2.5 11.1032 3.29018 9.6967 4.6967C8.29018 6.10322 7.5 8.01088 7.5 10C7.5 18.75 3.75 21.25 3.75 21.25H26.25C26.25 21.25 22.5 18.75 22.5 10Z"}" stroke="${"black"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-148upnq"}"></path><path d="${"M17.1625 26.25C16.9428 26.6288 16.6273 26.9433 16.2478 27.1619C15.8683 27.3805 15.438 27.4956 15 27.4956C14.5621 27.4956 14.1318 27.3805 13.7522 27.1619C13.3727 26.9433 13.0573 26.6288 12.8375 26.25"}" stroke="${"black"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-148upnq"}"></path></svg></button>
				<div class="${"user-image-button svelte-148upnq"}"><img class="${"profile-img svelte-148upnq"}"${add_attribute("src", profile$1, 0)} alt="${"user's profile"}"></div></div>` : `<button class="${"navbar-login-button svelte-148upnq"}">Login</button>`}
		<div style="${"display: " + escape("none")}" class="${"user-dropdown-options svelte-148upnq"}"><div class="${"container-top svelte-148upnq"}"><h2 class="${"user-name svelte-148upnq"}">Aslam Idrisi</h2>
				<p class="${"user-username gray svelte-148upnq"}">@willtheastro</p></div>
			<div class="${"container-bottom svelte-148upnq"}"><a href="${"/dashboard"}" class="${"dropdown-link svelte-148upnq"}">Dashboard</a>
				<a href="${"/dashboard/writepost"}" class="${"dropdown-link svelte-148upnq"}">Write a Post</a>
				<a href="${"/dashboard/settings"}" class="${"dropdown-link svelte-148upnq"}">Settings</a>
				<a href="${"/helps"}" class="${"dropdown-link svelte-148upnq"}">Help</a>
				<button class="${"dropdown-link sign-out-button svelte-148upnq"}">Sign out</button></div></div></div></nav>

${slots.default ? slots.default({}) : ``}`;
});
var __layout = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": _layout
});
function load$5({ error: error2, status }) {
  return { props: { error: error2, status } };
}
var Error$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { status } = $$props;
  let { error: error2 } = $$props;
  if ($$props.status === void 0 && $$bindings.status && status !== void 0)
    $$bindings.status(status);
  if ($$props.error === void 0 && $$bindings.error && error2 !== void 0)
    $$bindings.error(error2);
  return `<h1>${escape(status)}</h1>

<pre>${escape(error2.message)}</pre>



${error2.frame ? `<pre>${escape(error2.frame)}</pre>` : ``}
${error2.stack ? `<pre>${escape(error2.stack)}</pre>` : ``}`;
});
var error = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Error$1,
  load: load$5
});
var css$c = {
  code: "@import url('https://fonts.googleapis.com/css2?family=Libre+Baskerville:wght@400;700&display=swap');.svelte-11nf9xw{font-family:'Libre Baskerville', serif}.gray.svelte-11nf9xw{color:rgba(28, 28, 28, 0.5);font-family:-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell,\n			'Open Sans', 'Helvetica Neue', sans-serif}main.svelte-11nf9xw{margin:40px 0}.main_primary.svelte-11nf9xw{background:url('../assets/images/Article.jpg');width:100%;height:592px;display:flex;flex-direction:column;justify-content:center}.primary-header.svelte-11nf9xw{background-color:#fefefe;padding:20px;display:flex;flex-direction:column;justify-content:center;align-items:flex-start;width:509px;height:483px;margin-left:2.2em;margin-top:-4.35em}.header-top.svelte-11nf9xw{text-transform:uppercase;font-size:20px;margin-bottom:0.5em}.header-middle.svelte-11nf9xw{color:#000;font-size:33px;font-weight:bold;margin:0}.header-bottom.svelte-11nf9xw{font-size:16px;margin:0.5em 0}.primary-body.svelte-11nf9xw{margin:1em 0;font-size:16px;color:#000}.editor-pick.svelte-11nf9xw{display:flex;flex-direction:column;justify-content:space-between;align-items:center;width:858px;margin:1em auto}.editor-pick_title.svelte-11nf9xw{font-size:42px;font-weight:bold}.editor-pick_card.svelte-11nf9xw{width:100%;display:flex;justify-content:space-between;height:311px;margin-bottom:2.5em}.card_img.svelte-11nf9xw{width:45%}.editor-pick_card-block.svelte-11nf9xw{width:50%}.main_secondary.svelte-11nf9xw{background:url('../assets/images/Article2.jpg');width:100%;height:592px;display:flex;flex-direction:column;justify-content:center}.secondary-header.svelte-11nf9xw{background-color:#fff;padding:20px;display:flex;flex-direction:column;justify-content:center;align-items:flex-start;width:509px;height:483px;margin:auto 5% auto 50%}.main_tertiary.svelte-11nf9xw{display:flex;justify-content:space-between;width:90%;margin:2.5em auto 1em auto}.tertiary_cards.svelte-11nf9xw{display:flex;flex-direction:column;justify-content:space-between;margin-bottom:3em}.tertiary_card.svelte-11nf9xw{width:90%;display:flex;justify-content:space-between;height:177px;margin-bottom:2.5em}.tertiary_card-block.svelte-11nf9xw{width:calc(100% - 250px);display:flex;flex-direction:column;justify-content:space-between}.tertiary_card-img.svelte-11nf9xw{width:237px}.tertiary_card_header-top.svelte-11nf9xw{margin:0}.tertiary_card_header-bottom.svelte-11nf9xw{margin:2px 0}.tertiary_card_body.svelte-11nf9xw{margin-bottom:0;margin-top:0}.tag-heading.svelte-11nf9xw{margin:0}",
  map: `{"version":3,"file":"index.svelte","sources":["index.svelte"],"sourcesContent":["<script context=\\"module\\">\\n\\timport { getPosts } from '../utils/firebase.apis';\\n\\texport async function load({ fetch, page, session, stuff }) {\\n\\t\\tlet allPosts;\\n\\t\\ttry {\\n\\t\\t\\tallPosts = await getPosts();\\n\\t\\t} catch (err) {\\n\\t\\t\\tallPosts = err;\\n\\t\\t}\\n\\t\\treturn {\\n\\t\\t\\tprops: {\\n\\t\\t\\t\\tallPosts\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n<\/script>\\n\\n<script lang=\\"ts\\">import { getImageUrl } from '../utils/firebase.apis';\\r\\nimport '../assets/images/cards/1.jpg';\\r\\nimport '../assets/images/cards/2.jpg';\\r\\nimport '../assets/images/cards/3.jpg';\\r\\nexport let allPosts;\\r\\nfunction filter(posts, toBeFiltered) {\\r\\n    return posts.filter(({ data }) => data[toBeFiltered]);\\r\\n}\\r\\nconst featured = filter(allPosts, 'featured');\\r\\nconst editorsPick = filter(allPosts, 'editorsPick');\\r\\nfunction getRestPosts(posts) {\\r\\n    return posts.filter(({ data }) => !data['featured'] && !data['editorsPick']);\\r\\n}\\r\\nconst restPosts = getRestPosts(allPosts);\\r\\nconsole.log(restPosts, 'posts');\\r\\n<\/script>\\n\\n<svelte:head>\\n\\t<title>Home</title>\\n</svelte:head>\\n\\n<main>\\n\\t<div class=\\"main_primary\\">\\n\\t\\t<div class=\\"primary-header\\">\\n\\t\\t\\t<p class=\\"gray header-top\\">Featured article</p>\\n\\t\\t\\t<p class=\\"header-middle\\">{featured[0].data.title}</p>\\n\\t\\t\\t<p class=\\"header-bottom gray\\">\\n\\t\\t\\t\\t{featured[0].data.author} <span>.</span>\\n\\t\\t\\t\\t{\`\${featured[0].data.postDate}(\${featured[0].data.readingTime} mins read)\`}\\n\\t\\t\\t</p>\\n\\t\\t\\t<p class=\\"primary-body\\">\\n\\t\\t\\t\\t{featured[0].data.body[0]}\\n\\t\\t\\t</p>\\n\\t\\t</div>\\n\\t</div>\\n\\t<div class=\\"editor-pick\\">\\n\\t\\t<div class=\\"editor-pick_header\\">\\n\\t\\t\\t<h2 class=\\"editor-pick_title\\">Editor's Picks</h2>\\n\\t\\t</div>\\n\\t\\t{#each editorsPick as { data }}\\n\\t\\t\\t<div class=\\"editor-pick_card\\">\\n\\t\\t\\t\\t{#await getImageUrl(data.imgSrc)}\\n\\t\\t\\t\\t\\t<p>...Loading</p>\\n\\t\\t\\t\\t{:then url}\\n\\t\\t\\t\\t\\t<img class=\\"card_img\\" src={url} alt=\\"card\\" />\\n\\t\\t\\t\\t{/await}\\n\\t\\t\\t\\t<div class=\\"editor-pick_card-block\\">\\n\\t\\t\\t\\t\\t<p class=\\"gray header-top\\">{data.tags[0]}</p>\\n\\t\\t\\t\\t\\t<p class=\\"header-middle\\">{data.title}</p>\\n\\t\\t\\t\\t\\t<p class=\\"header-bottom gray\\">\\n\\t\\t\\t\\t\\t\\t{data.author} <span>.</span>{\` \${data.postDate}(\${data.readingTime} mins read)\`}\\n\\t\\t\\t\\t\\t</p>\\n\\t\\t\\t\\t\\t<p class=\\"primary-body\\">\\n\\t\\t\\t\\t\\t\\t{data.body[0]}\\n\\t\\t\\t\\t\\t</p>\\n\\t\\t\\t\\t</div>\\n\\t\\t\\t</div>\\n\\t\\t{/each}\\n\\t</div>\\n\\t{#if featured.length > 1}\\n\\t\\t<div class=\\"main_secondary\\">\\n\\t\\t\\t<div class=\\"secondary-header\\">\\n\\t\\t\\t\\t<p class=\\"gray header-top\\">Featured article</p>\\n\\t\\t\\t\\t<p class=\\"header-middle\\">{featured[1].data.title}</p>\\n\\t\\t\\t\\t<p class=\\"header-bottom gray\\">\\n\\t\\t\\t\\t\\t{featured[1].data.author} <span>.</span>\\n\\t\\t\\t\\t\\t{\`\${featured[1].data.postDate}(\${featured[1].data.readingTime} mins read)\`}\\n\\t\\t\\t\\t</p>\\n\\t\\t\\t\\t<p class=\\"primary-body\\">\\n\\t\\t\\t\\t\\t{featured[1].data.body[0]}\\n\\t\\t\\t\\t</p>\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\t{/if}\\n\\t<div class=\\"main_tertiary\\">\\n\\t\\t<div class=\\"tertiary_cards\\">\\n\\t\\t\\t{#each restPosts as { data }}\\n\\t\\t\\t\\t<div class=\\"tertiary_card\\">\\n\\t\\t\\t\\t\\t{#await getImageUrl(data.imgSrc)}\\n\\t\\t\\t\\t\\t\\t<p>...Loading</p>\\n\\t\\t\\t\\t\\t{:then url}\\n\\t\\t\\t\\t\\t\\t<img class=\\"card_img tertiary_card-img\\" src={url} alt=\\"card\\" />\\n\\t\\t\\t\\t\\t{/await}\\n\\t\\t\\t\\t\\t<div class=\\"editor-pick_card-block tertiary_card-block\\">\\n\\t\\t\\t\\t\\t\\t<p class=\\"gray header-top tertiary_card_header-top\\">{data.tags[0]}</p>\\n\\t\\t\\t\\t\\t\\t<p class=\\"header-middle tertiary_card_header-middle\\">{data.title}</p>\\n\\t\\t\\t\\t\\t\\t<p class=\\"header-bottom tertiary_card_header-bottom gray\\">\\n\\t\\t\\t\\t\\t\\t\\t{data.author} <span>.</span>\\n\\t\\t\\t\\t\\t\\t\\t{data.postDate}({data.readingTime} mins read)\\n\\t\\t\\t\\t\\t\\t</p>\\n\\t\\t\\t\\t\\t\\t<p class=\\"primary-body tertiary_card_body \\">\\n\\t\\t\\t\\t\\t\\t\\t{data.body[0]}\\n\\t\\t\\t\\t\\t\\t</p>\\n\\t\\t\\t\\t\\t</div>\\n\\t\\t\\t\\t</div>\\n\\t\\t\\t{/each}\\n\\t\\t</div>\\n\\t\\t<div class=\\"tertiary_tags\\">\\n\\t\\t\\t<h3 class=\\"tag-heading\\">tags.</h3>\\n\\t\\t\\t<p class=\\"tag\\">techonology</p>\\n\\t\\t\\t<p class=\\"tag\\">Open source</p>\\n\\t\\t\\t<p class=\\"tag\\">JavaScript</p>\\n\\t\\t\\t<p class=\\"tag\\">Minimalism</p>\\n\\t\\t\\t<p class=\\"tag\\">Self-help</p>\\n\\t\\t\\t<p class=\\"tag\\">Animals</p>\\n\\t\\t\\t<p class=\\"tag\\">Herbivores</p>\\n\\t\\t\\t<p class=\\"tag\\">HTML</p>\\n\\t\\t\\t<p class=\\"tag\\">CSS</p>\\n\\t\\t\\t<p class=\\"tag\\">PHP</p>\\n\\t\\t\\t<p class=\\"tag\\">Web Techonology</p>\\n\\t\\t</div>\\n\\t</div>\\n</main>\\n\\n<style>\\n\\t@import url('https://fonts.googleapis.com/css2?family=Libre+Baskerville:wght@400;700&display=swap');\\n\\ta {\\n\\t\\ttext-decoration: none;\\n\\t}\\n\\n\\ta,\\n\\t* {\\n\\t\\tfont-family: 'Libre Baskerville', serif;\\n\\t}\\n\\n\\tbutton,\\n\\ta {\\n\\t\\tcursor: pointer;\\n\\t\\ttransform: scale(1);\\n\\t}\\n\\n\\ta:hover,\\n\\tbutton:hover {\\n\\t\\ttransition: transform 400ms;\\n\\t\\ttransform: scale(1.05);\\n\\t}\\n\\n\\t.gray {\\n\\t\\tcolor: rgba(28, 28, 28, 0.5);\\n\\t\\tfont-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell,\\n\\t\\t\\t'Open Sans', 'Helvetica Neue', sans-serif;\\n\\t}\\n\\n\\tmain {\\n\\t\\tmargin: 40px 0;\\n\\t}\\n\\n\\t.main_primary {\\n\\t\\tbackground: url('../assets/images/Article.jpg');\\n\\t\\twidth: 100%;\\n\\t\\theight: 592px;\\n\\t\\tdisplay: flex;\\n\\t\\tflex-direction: column;\\n\\t\\tjustify-content: center;\\n\\t}\\n\\n\\t.primary-header {\\n\\t\\tbackground-color: #fefefe;\\n\\t\\tpadding: 20px;\\n\\t\\tdisplay: flex;\\n\\t\\tflex-direction: column;\\n\\t\\tjustify-content: center;\\n\\t\\talign-items: flex-start;\\n\\t\\twidth: 509px;\\n\\t\\theight: 483px;\\n\\t\\tmargin-left: 2.2em;\\n\\t\\tmargin-top: -4.35em;\\n\\t}\\n\\n\\t.header-top {\\n\\t\\ttext-transform: uppercase;\\n\\t\\tfont-size: 20px;\\n\\t\\tmargin-bottom: 0.5em;\\n\\t}\\n\\n\\t.header-middle {\\n\\t\\tcolor: #000;\\n\\t\\tfont-size: 33px;\\n\\t\\tfont-weight: bold;\\n\\t\\tmargin: 0;\\n\\t}\\n\\n\\t.header-bottom {\\n\\t\\tfont-size: 16px;\\n\\t\\tmargin: 0.5em 0;\\n\\t}\\n\\n\\t.primary-body {\\n\\t\\tmargin: 1em 0;\\n\\t\\tfont-size: 16px;\\n\\t\\tcolor: #000;\\n\\t}\\n\\n\\t.editor-pick {\\n\\t\\tdisplay: flex;\\n\\t\\tflex-direction: column;\\n\\t\\tjustify-content: space-between;\\n\\t\\talign-items: center;\\n\\t\\twidth: 858px;\\n\\t\\tmargin: 1em auto;\\n\\t}\\n\\n\\t.editor-pick_title {\\n\\t\\tfont-size: 42px;\\n\\t\\tfont-weight: bold;\\n\\t}\\n\\n\\t.editor-pick_card {\\n\\t\\twidth: 100%;\\n\\t\\tdisplay: flex;\\n\\t\\tjustify-content: space-between;\\n\\t\\theight: 311px;\\n\\t\\tmargin-bottom: 2.5em;\\n\\t}\\n\\n\\t.card_img {\\n\\t\\twidth: 45%;\\n\\t}\\n\\n\\t.editor-pick_card-block {\\n\\t\\twidth: 50%;\\n\\t}\\n\\n\\t.main_secondary {\\n\\t\\tbackground: url('../assets/images/Article2.jpg');\\n\\t\\twidth: 100%;\\n\\t\\theight: 592px;\\n\\t\\tdisplay: flex;\\n\\t\\tflex-direction: column;\\n\\t\\tjustify-content: center;\\n\\t}\\n\\n\\t.secondary-header {\\n\\t\\tbackground-color: #fff;\\n\\t\\tpadding: 20px;\\n\\t\\tdisplay: flex;\\n\\t\\tflex-direction: column;\\n\\t\\tjustify-content: center;\\n\\t\\talign-items: flex-start;\\n\\t\\twidth: 509px;\\n\\t\\theight: 483px;\\n\\t\\tmargin: auto 5% auto 50%;\\n\\t}\\n\\n\\t.main_tertiary {\\n\\t\\tdisplay: flex;\\n\\t\\tjustify-content: space-between;\\n\\t\\twidth: 90%;\\n\\t\\tmargin: 2.5em auto 1em auto;\\n\\t}\\n\\n\\t.tertiary_cards {\\n\\t\\tdisplay: flex;\\n\\t\\tflex-direction: column;\\n\\t\\tjustify-content: space-between;\\n\\t\\tmargin-bottom: 3em;\\n\\t}\\n\\n\\t.tertiary_card {\\n\\t\\twidth: 90%;\\n\\t\\tdisplay: flex;\\n\\t\\tjustify-content: space-between;\\n\\t\\theight: 177px;\\n\\t\\tmargin-bottom: 2.5em;\\n\\t}\\n\\n\\t.tertiary_card-block {\\n\\t\\twidth: calc(100% - 250px);\\n\\t\\tdisplay: flex;\\n\\t\\tflex-direction: column;\\n\\t\\tjustify-content: space-between;\\n\\t}\\n\\n\\t.tertiary_card-img {\\n\\t\\twidth: 237px;\\n\\t}\\n\\n\\t.tertiary_card_header-top {\\n\\t\\tmargin: 0;\\n\\t}\\n\\n\\t.tertiary_card_header-bottom {\\n\\t\\tmargin: 2px 0;\\n\\t}\\n\\n\\t.tertiary_card_body {\\n\\t\\tmargin-bottom: 0;\\n\\t\\tmargin-top: 0;\\n\\t}\\n\\n\\t.tag-heading {\\n\\t\\tmargin: 0;\\n\\t}\\n</style>\\n"],"names":[],"mappings":"AAoIC,QAAQ,IAAI,sFAAsF,CAAC,CAAC,AAMpG,eAAE,CAAC,AACF,WAAW,CAAE,mBAAmB,CAAC,CAAC,KAAK,AACxC,CAAC,AAcD,KAAK,eAAC,CAAC,AACN,KAAK,CAAE,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAC5B,WAAW,CAAE,aAAa,CAAC,CAAC,kBAAkB,CAAC,CAAC,UAAU,CAAC,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC;GAC7F,WAAW,CAAC,CAAC,gBAAgB,CAAC,CAAC,UAAU,AAC3C,CAAC,AAED,IAAI,eAAC,CAAC,AACL,MAAM,CAAE,IAAI,CAAC,CAAC,AACf,CAAC,AAED,aAAa,eAAC,CAAC,AACd,UAAU,CAAE,IAAI,8BAA8B,CAAC,CAC/C,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,KAAK,CACb,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,eAAe,CAAE,MAAM,AACxB,CAAC,AAED,eAAe,eAAC,CAAC,AAChB,gBAAgB,CAAE,OAAO,CACzB,OAAO,CAAE,IAAI,CACb,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,eAAe,CAAE,MAAM,CACvB,WAAW,CAAE,UAAU,CACvB,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,CACb,WAAW,CAAE,KAAK,CAClB,UAAU,CAAE,OAAO,AACpB,CAAC,AAED,WAAW,eAAC,CAAC,AACZ,cAAc,CAAE,SAAS,CACzB,SAAS,CAAE,IAAI,CACf,aAAa,CAAE,KAAK,AACrB,CAAC,AAED,cAAc,eAAC,CAAC,AACf,KAAK,CAAE,IAAI,CACX,SAAS,CAAE,IAAI,CACf,WAAW,CAAE,IAAI,CACjB,MAAM,CAAE,CAAC,AACV,CAAC,AAED,cAAc,eAAC,CAAC,AACf,SAAS,CAAE,IAAI,CACf,MAAM,CAAE,KAAK,CAAC,CAAC,AAChB,CAAC,AAED,aAAa,eAAC,CAAC,AACd,MAAM,CAAE,GAAG,CAAC,CAAC,CACb,SAAS,CAAE,IAAI,CACf,KAAK,CAAE,IAAI,AACZ,CAAC,AAED,YAAY,eAAC,CAAC,AACb,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,eAAe,CAAE,aAAa,CAC9B,WAAW,CAAE,MAAM,CACnB,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,GAAG,CAAC,IAAI,AACjB,CAAC,AAED,kBAAkB,eAAC,CAAC,AACnB,SAAS,CAAE,IAAI,CACf,WAAW,CAAE,IAAI,AAClB,CAAC,AAED,iBAAiB,eAAC,CAAC,AAClB,KAAK,CAAE,IAAI,CACX,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,aAAa,CAC9B,MAAM,CAAE,KAAK,CACb,aAAa,CAAE,KAAK,AACrB,CAAC,AAED,SAAS,eAAC,CAAC,AACV,KAAK,CAAE,GAAG,AACX,CAAC,AAED,uBAAuB,eAAC,CAAC,AACxB,KAAK,CAAE,GAAG,AACX,CAAC,AAED,eAAe,eAAC,CAAC,AAChB,UAAU,CAAE,IAAI,+BAA+B,CAAC,CAChD,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,KAAK,CACb,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,eAAe,CAAE,MAAM,AACxB,CAAC,AAED,iBAAiB,eAAC,CAAC,AAClB,gBAAgB,CAAE,IAAI,CACtB,OAAO,CAAE,IAAI,CACb,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,eAAe,CAAE,MAAM,CACvB,WAAW,CAAE,UAAU,CACvB,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,CACb,MAAM,CAAE,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,GAAG,AACzB,CAAC,AAED,cAAc,eAAC,CAAC,AACf,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,aAAa,CAC9B,KAAK,CAAE,GAAG,CACV,MAAM,CAAE,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,AAC5B,CAAC,AAED,eAAe,eAAC,CAAC,AAChB,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,eAAe,CAAE,aAAa,CAC9B,aAAa,CAAE,GAAG,AACnB,CAAC,AAED,cAAc,eAAC,CAAC,AACf,KAAK,CAAE,GAAG,CACV,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,aAAa,CAC9B,MAAM,CAAE,KAAK,CACb,aAAa,CAAE,KAAK,AACrB,CAAC,AAED,oBAAoB,eAAC,CAAC,AACrB,KAAK,CAAE,KAAK,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CACzB,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,eAAe,CAAE,aAAa,AAC/B,CAAC,AAED,kBAAkB,eAAC,CAAC,AACnB,KAAK,CAAE,KAAK,AACb,CAAC,AAED,yBAAyB,eAAC,CAAC,AAC1B,MAAM,CAAE,CAAC,AACV,CAAC,AAED,4BAA4B,eAAC,CAAC,AAC7B,MAAM,CAAE,GAAG,CAAC,CAAC,AACd,CAAC,AAED,mBAAmB,eAAC,CAAC,AACpB,aAAa,CAAE,CAAC,CAChB,UAAU,CAAE,CAAC,AACd,CAAC,AAED,YAAY,eAAC,CAAC,AACb,MAAM,CAAE,CAAC,AACV,CAAC"}`
};
async function load$4({ fetch: fetch2, page, session, stuff }) {
  let allPosts2;
  try {
    allPosts2 = await getPosts();
  } catch (err) {
    allPosts2 = err;
  }
  return { props: { allPosts: allPosts2 } };
}
function filter(posts, toBeFiltered) {
  return posts.filter(({ data }) => data[toBeFiltered]);
}
function getRestPosts(posts) {
  return posts.filter(({ data }) => !data["featured"] && !data["editorsPick"]);
}
var Routes = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { allPosts: allPosts2 } = $$props;
  const featured = filter(allPosts2, "featured");
  const editorsPick = filter(allPosts2, "editorsPick");
  const restPosts = getRestPosts(allPosts2);
  console.log(restPosts, "posts");
  if ($$props.allPosts === void 0 && $$bindings.allPosts && allPosts2 !== void 0)
    $$bindings.allPosts(allPosts2);
  $$result.css.add(css$c);
  return `${$$result.head += `${$$result.title = `<title>Home</title>`, ""}`, ""}

<main class="${"svelte-11nf9xw"}"><div class="${"main_primary svelte-11nf9xw"}"><div class="${"primary-header svelte-11nf9xw"}"><p class="${"gray header-top svelte-11nf9xw"}">Featured article</p>
			<p class="${"header-middle svelte-11nf9xw"}">${escape(featured[0].data.title)}</p>
			<p class="${"header-bottom gray svelte-11nf9xw"}">${escape(featured[0].data.author)} <span class="${"svelte-11nf9xw"}">.</span>
				${escape(`${featured[0].data.postDate}(${featured[0].data.readingTime} mins read)`)}</p>
			<p class="${"primary-body svelte-11nf9xw"}">${escape(featured[0].data.body[0])}</p></div></div>
	<div class="${"editor-pick svelte-11nf9xw"}"><div class="${"editor-pick_header svelte-11nf9xw"}"><h2 class="${"editor-pick_title svelte-11nf9xw"}">Editor&#39;s Picks</h2></div>
		${each(editorsPick, ({ data }) => `<div class="${"editor-pick_card svelte-11nf9xw"}">${function(__value) {
    if (is_promise(__value)) {
      __value.then(null, noop$1);
      return `
					<p class="${"svelte-11nf9xw"}">...Loading</p>
				`;
    }
    return function(url) {
      return `
					<img class="${"card_img svelte-11nf9xw"}"${add_attribute("src", url, 0)} alt="${"card"}">
				`;
    }(__value);
  }(getImageUrl(data.imgSrc))}
				<div class="${"editor-pick_card-block svelte-11nf9xw"}"><p class="${"gray header-top svelte-11nf9xw"}">${escape(data.tags[0])}</p>
					<p class="${"header-middle svelte-11nf9xw"}">${escape(data.title)}</p>
					<p class="${"header-bottom gray svelte-11nf9xw"}">${escape(data.author)} <span class="${"svelte-11nf9xw"}">.</span>${escape(` ${data.postDate}(${data.readingTime} mins read)`)}</p>
					<p class="${"primary-body svelte-11nf9xw"}">${escape(data.body[0])}
					</p></div>
			</div>`)}</div>
	${featured.length > 1 ? `<div class="${"main_secondary svelte-11nf9xw"}"><div class="${"secondary-header svelte-11nf9xw"}"><p class="${"gray header-top svelte-11nf9xw"}">Featured article</p>
				<p class="${"header-middle svelte-11nf9xw"}">${escape(featured[1].data.title)}</p>
				<p class="${"header-bottom gray svelte-11nf9xw"}">${escape(featured[1].data.author)} <span class="${"svelte-11nf9xw"}">.</span>
					${escape(`${featured[1].data.postDate}(${featured[1].data.readingTime} mins read)`)}</p>
				<p class="${"primary-body svelte-11nf9xw"}">${escape(featured[1].data.body[0])}</p></div></div>` : ``}
	<div class="${"main_tertiary svelte-11nf9xw"}"><div class="${"tertiary_cards svelte-11nf9xw"}">${each(restPosts, ({ data }) => `<div class="${"tertiary_card svelte-11nf9xw"}">${function(__value) {
    if (is_promise(__value)) {
      __value.then(null, noop$1);
      return `
						<p class="${"svelte-11nf9xw"}">...Loading</p>
					`;
    }
    return function(url) {
      return `
						<img class="${"card_img tertiary_card-img svelte-11nf9xw"}"${add_attribute("src", url, 0)} alt="${"card"}">
					`;
    }(__value);
  }(getImageUrl(data.imgSrc))}
					<div class="${"editor-pick_card-block tertiary_card-block svelte-11nf9xw"}"><p class="${"gray header-top tertiary_card_header-top svelte-11nf9xw"}">${escape(data.tags[0])}</p>
						<p class="${"header-middle tertiary_card_header-middle svelte-11nf9xw"}">${escape(data.title)}</p>
						<p class="${"header-bottom tertiary_card_header-bottom gray svelte-11nf9xw"}">${escape(data.author)} <span class="${"svelte-11nf9xw"}">.</span>
							${escape(data.postDate)}(${escape(data.readingTime)} mins read)
						</p>
						<p class="${"primary-body tertiary_card_body  svelte-11nf9xw"}">${escape(data.body[0])}
						</p></div>
				</div>`)}</div>
		<div class="${"tertiary_tags svelte-11nf9xw"}"><h3 class="${"tag-heading svelte-11nf9xw"}">tags.</h3>
			<p class="${"tag svelte-11nf9xw"}">techonology</p>
			<p class="${"tag svelte-11nf9xw"}">Open source</p>
			<p class="${"tag svelte-11nf9xw"}">JavaScript</p>
			<p class="${"tag svelte-11nf9xw"}">Minimalism</p>
			<p class="${"tag svelte-11nf9xw"}">Self-help</p>
			<p class="${"tag svelte-11nf9xw"}">Animals</p>
			<p class="${"tag svelte-11nf9xw"}">Herbivores</p>
			<p class="${"tag svelte-11nf9xw"}">HTML</p>
			<p class="${"tag svelte-11nf9xw"}">CSS</p>
			<p class="${"tag svelte-11nf9xw"}">PHP</p>
			<p class="${"tag svelte-11nf9xw"}">Web Techonology</p></div></div>
</main>`;
});
var index$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Routes,
  load: load$4
});
var user$1;
user$1 = useAuthListener();
async function load$3({ page, fetch: fetch2, session, stuff }) {
  if (!user$1) {
    return { status: 302, redirect: "/" };
  }
}
var _layout_reset = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  return `${slots.default ? slots.default({}) : ``}`;
});
var __layout_reset = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": _layout_reset,
  load: load$3
});
var css$b = {
  code: "body{margin:0;padding:0}@import url('https://fonts.googleapis.com/css2?family=Libre+Baskerville:wght@400;700&display=swap');.svelte-rtap69{font-family:'Libre Baskerville', serif}.gray.svelte-rtap69{color:rgba(28, 28, 28, 0.5);font-family:-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif}.dashboard-sidebar.svelte-rtap69{grid-column:1/2;grid-row:1/-1;height:100vh;width:225px;display:flex;flex-direction:column;justify-content:flex-start;align-items:center;background-color:#3B3F44}.logo-container.svelte-rtap69{height:15%;display:flex;justify-content:center;align-items:center;margin-bottom:1em;cursor:pointer}.logo.svelte-rtap69{color:#fefefe;font-size:30px}.sidebar_navigation.svelte-rtap69{display:flex;flex-direction:column}.navigation-dashboard.svelte-rtap69{box-sizing:border-box;width:225px;padding:8px 0 8px 20px;display:flex;align-items:center;cursor:pointer}.navigation_text.svelte-rtap69{margin-left:10px;color:#fefefe}.active.svelte-rtap69{background-color:#545a61}",
  map: `{"version":3,"file":"dashboard.sidebar.svelte","sources":["dashboard.sidebar.svelte"],"sourcesContent":["<script lang=\\"ts\\" >export let active = 'dashboard';\\r\\n<\/script>\\r\\n\\r\\n<sidebar class=\\"dashboard-sidebar\\" >\\r\\n    <div on:click={e => location.href=\\"/\\"} class=\\"logo-container\\" >\\r\\n        <p class=\\"logo\\" >nuntium</p>\\r\\n    </div>\\r\\n    <div class=\\"sidebar_navigation\\" >\\r\\n        <div on:click={() => location.href=\\"/dashboard\\"} class=\\"navigation-dashboard {active === \\"dashboard\\" && 'active'}\\" >\\r\\n            <svg width=\\"30\\" height=\\"30\\" viewBox=\\"0 0 30 30\\" fill=\\"none\\" xmlns=\\"http://www.w3.org/2000/svg\\">\\r\\n                <path d=\\"M12.5 3.75H3.75V12.5H12.5V3.75Z\\" stroke=\\"white\\" stroke-width=\\"2\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\"/>\\r\\n                <path d=\\"M26.25 3.75H17.5V12.5H26.25V3.75Z\\" stroke=\\"white\\" stroke-width=\\"2\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\"/>\\r\\n                <path d=\\"M26.25 17.5H17.5V26.25H26.25V17.5Z\\" stroke=\\"white\\" stroke-width=\\"2\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\"/>\\r\\n                <path d=\\"M12.5 17.5H3.75V26.25H12.5V17.5Z\\" stroke=\\"white\\" stroke-width=\\"2\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\"/>\\r\\n            </svg>                \\r\\n            <p class=\\"navigation_text\\" >Dashboard</p>\\r\\n        </div>\\r\\n        <div on:click={() => location.href=\\"/dashboard/profile\\"} class=\\"navigation-dashboard {active === \\"profile\\" && 'active'} \\" >\\r\\n            <svg width=\\"30\\" height=\\"30\\" viewBox=\\"0 0 30 30\\" fill=\\"none\\" xmlns=\\"http://www.w3.org/2000/svg\\">\\r\\n                <path d=\\"M25 26.25V23.75C25 22.4239 24.4732 21.1521 23.5355 20.2145C22.5979 19.2768 21.3261 18.75 20 18.75H10C8.67392 18.75 7.40215 19.2768 6.46447 20.2145C5.52678 21.1521 5 22.4239 5 23.75V26.25\\" stroke=\\"white\\" stroke-width=\\"2\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\"/>\\r\\n                <path d=\\"M15 13.75C17.7614 13.75 20 11.5114 20 8.75C20 5.98858 17.7614 3.75 15 3.75C12.2386 3.75 10 5.98858 10 8.75C10 11.5114 12.2386 13.75 15 13.75Z\\" stroke=\\"white\\" stroke-width=\\"2\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\"/>\\r\\n            </svg>                \\r\\n            <p class=\\"navigation_text\\" >Profile</p>\\r\\n        </div>\\r\\n        <div on:click={() => location.href=\\"/dashboard/writepost\\"} class=\\"navigation-dashboard {active === \\"write-a-post\\" && 'active'} \\" >\\r\\n            <svg width=\\"24\\" height=\\"24\\" viewBox=\\"0 0 24 24\\" fill=\\"none\\" xmlns=\\"http://www.w3.org/2000/svg\\">\\r\\n                <path d=\\"M17 2.99981C17.2626 2.73717 17.5744 2.52883 17.9176 2.38669C18.2608 2.24455 18.6286 2.17139 19 2.17139C19.3714 2.17139 19.7392 2.24455 20.0824 2.38669C20.4256 2.52883 20.7374 2.73717 21 2.99981C21.2626 3.26246 21.471 3.57426 21.6131 3.91742C21.7553 4.26058 21.8284 4.62838 21.8284 4.99981C21.8284 5.37125 21.7553 5.73905 21.6131 6.08221C21.471 6.42537 21.2626 6.73717 21 6.99981L7.5 20.4998L2 21.9998L3.5 16.4998L17 2.99981Z\\" stroke=\\"white\\" stroke-width=\\"2\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\"/>\\r\\n            </svg>                \\r\\n            <p class=\\"navigation_text\\" >Write a Post</p>\\r\\n        </div>\\r\\n        <div on:click={() => location.href=\\"/dashboard/all-posts\\"} class=\\"navigation-dashboard {active === \\"all-posts\\" && 'active'} \\" >\\r\\n            <svg width=\\"30\\" height=\\"30\\" viewBox=\\"0 0 30 30\\" fill=\\"none\\" xmlns=\\"http://www.w3.org/2000/svg\\">\\r\\n                <path d=\\"M2.5 3.75H10C11.3261 3.75 12.5979 4.27678 13.5355 5.21447C14.4732 6.15215 15 7.42392 15 8.75V26.25C15 25.2554 14.6049 24.3016 13.9017 23.5983C13.1984 22.8951 12.2446 22.5 11.25 22.5H2.5V3.75Z\\" stroke=\\"white\\" stroke-width=\\"2\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\"/>\\r\\n                <path d=\\"M27.5 3.75H20C18.6739 3.75 17.4021 4.27678 16.4645 5.21447C15.5268 6.15215 15 7.42392 15 8.75V26.25C15 25.2554 15.3951 24.3016 16.0983 23.5983C16.8016 22.8951 17.7554 22.5 18.75 22.5H27.5V3.75Z\\" stroke=\\"white\\" stroke-width=\\"2\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\"/>\\r\\n            </svg>                \\r\\n            <p class=\\"navigation_text\\" >All Posts</p>\\r\\n        </div>\\r\\n        <div on:click={() => location.href=\\"/dashboard/resources\\"} class=\\"navigation-dashboard {active === \\"resources\\" && 'active'} \\" >\\r\\n            <svg width=\\"30\\" height=\\"30\\" viewBox=\\"0 0 30 30\\" fill=\\"none\\" xmlns=\\"http://www.w3.org/2000/svg\\">\\r\\n                <path d=\\"M26.25 19.9999V9.99988C26.2496 9.56147 26.1338 9.13089 25.9144 8.75133C25.695 8.37177 25.3797 8.05658 25 7.83738L16.25 2.83738C15.87 2.61796 15.4388 2.50244 15 2.50244C14.5612 2.50244 14.13 2.61796 13.75 2.83738L5 7.83738C4.62033 8.05658 4.30498 8.37177 4.08558 8.75133C3.86618 9.13089 3.75045 9.56147 3.75 9.99988V19.9999C3.75045 20.4383 3.86618 20.8689 4.08558 21.2484C4.30498 21.628 4.62033 21.9432 5 22.1624L13.75 27.1624C14.13 27.3818 14.5612 27.4973 15 27.4973C15.4388 27.4973 15.87 27.3818 16.25 27.1624L25 22.1624C25.3797 21.9432 25.695 21.628 25.9144 21.2484C26.1338 20.8689 26.2496 20.4383 26.25 19.9999Z\\" stroke=\\"white\\" stroke-width=\\"2\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\"/>\\r\\n                <path d=\\"M4.0874 8.7002L14.9999 15.0127L25.9124 8.7002\\" stroke=\\"white\\" stroke-width=\\"2\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\"/>\\r\\n                <path d=\\"M15 27.6V15\\" stroke=\\"white\\" stroke-width=\\"2\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\"/>\\r\\n            </svg>\\r\\n            <p class=\\"navigation_text\\" >Resources</p>\\r\\n        </div>\\r\\n        <div on:click={() => location.href=\\"/dashboard/settings\\"} class=\\"navigation-dashboard {active === \\"settings\\" && 'active'} \\" >\\r\\n            <svg width=\\"30\\" height=\\"30\\" viewBox=\\"0 0 30 30\\" fill=\\"none\\" xmlns=\\"http://www.w3.org/2000/svg\\">\\r\\n                <path d=\\"M15 18.75C17.0711 18.75 18.75 17.0711 18.75 15C18.75 12.9289 17.0711 11.25 15 11.25C12.9289 11.25 11.25 12.9289 11.25 15C11.25 17.0711 12.9289 18.75 15 18.75Z\\" stroke=\\"white\\" stroke-width=\\"2\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\"/>\\r\\n                <path d=\\"M24.25 18.75C24.0836 19.127 24.034 19.5452 24.1075 19.9507C24.181 20.3562 24.3743 20.7304 24.6625 21.025L24.7375 21.1C24.9699 21.3322 25.1543 21.6079 25.2801 21.9114C25.406 22.2149 25.4707 22.5402 25.4707 22.8688C25.4707 23.1973 25.406 23.5226 25.2801 23.8261C25.1543 24.1296 24.9699 24.4053 24.7375 24.6375C24.5053 24.8699 24.2296 25.0543 23.9261 25.1801C23.6226 25.306 23.2973 25.3707 22.9688 25.3707C22.6402 25.3707 22.3149 25.306 22.0114 25.1801C21.7079 25.0543 21.4322 24.8699 21.2 24.6375L21.125 24.5625C20.8304 24.2743 20.4562 24.081 20.0507 24.0075C19.6452 23.934 19.227 23.9836 18.85 24.15C18.4803 24.3085 18.165 24.5716 17.9429 24.9069C17.7208 25.2423 17.6016 25.6353 17.6 26.0375V26.25C17.6 26.913 17.3366 27.5489 16.8678 28.0178C16.3989 28.4866 15.763 28.75 15.1 28.75C14.437 28.75 13.8011 28.4866 13.3322 28.0178C12.8634 27.5489 12.6 26.913 12.6 26.25V26.1375C12.5903 25.7238 12.4564 25.3225 12.2156 24.9859C11.9749 24.6493 11.6384 24.3929 11.25 24.25C10.873 24.0836 10.4548 24.034 10.0493 24.1075C9.64377 24.181 9.2696 24.3743 8.975 24.6625L8.9 24.7375C8.66782 24.9699 8.3921 25.1543 8.0886 25.2801C7.78511 25.406 7.45979 25.4707 7.13125 25.4707C6.80271 25.4707 6.47739 25.406 6.1739 25.2801C5.8704 25.1543 5.59468 24.9699 5.3625 24.7375C5.13006 24.5053 4.94566 24.2296 4.81985 23.9261C4.69404 23.6226 4.62928 23.2973 4.62928 22.9688C4.62928 22.6402 4.69404 22.3149 4.81985 22.0114C4.94566 21.7079 5.13006 21.4322 5.3625 21.2L5.4375 21.125C5.72567 20.8304 5.91898 20.4562 5.99251 20.0507C6.06603 19.6452 6.01639 19.227 5.85 18.85C5.69155 18.4803 5.42844 18.165 5.09308 17.9429C4.75772 17.7208 4.36473 17.6016 3.9625 17.6H3.75C3.08696 17.6 2.45107 17.3366 1.98223 16.8678C1.51339 16.3989 1.25 15.763 1.25 15.1C1.25 14.437 1.51339 13.8011 1.98223 13.3322C2.45107 12.8634 3.08696 12.6 3.75 12.6H3.8625C4.27624 12.5903 4.67751 12.4564 5.01412 12.2156C5.35074 11.9749 5.60714 11.6384 5.75 11.25C5.91639 10.873 5.96603 10.4548 5.89251 10.0493C5.81898 9.64377 5.62567 9.2696 5.3375 8.975L5.2625 8.9C5.03006 8.66782 4.84566 8.3921 4.71985 8.0886C4.59404 7.78511 4.52928 7.45979 4.52928 7.13125C4.52928 6.80271 4.59404 6.47739 4.71985 6.1739C4.84566 5.8704 5.03006 5.59468 5.2625 5.3625C5.49468 5.13006 5.7704 4.94566 6.0739 4.81985C6.37739 4.69404 6.70271 4.62928 7.03125 4.62928C7.35979 4.62928 7.68511 4.69404 7.9886 4.81985C8.2921 4.94566 8.56782 5.13006 8.8 5.3625L8.875 5.4375C9.1696 5.72567 9.54377 5.91898 9.94926 5.99251C10.3548 6.06603 10.773 6.01639 11.15 5.85H11.25C11.6197 5.69155 11.935 5.42844 12.1571 5.09308C12.3792 4.75772 12.4984 4.36473 12.5 3.9625V3.75C12.5 3.08696 12.7634 2.45107 13.2322 1.98223C13.7011 1.51339 14.337 1.25 15 1.25C15.663 1.25 16.2989 1.51339 16.7678 1.98223C17.2366 2.45107 17.5 3.08696 17.5 3.75V3.8625C17.5016 4.26473 17.6208 4.65772 17.8429 4.99308C18.065 5.32844 18.3803 5.59155 18.75 5.75C19.127 5.91639 19.5452 5.96603 19.9507 5.89251C20.3562 5.81898 20.7304 5.62567 21.025 5.3375L21.1 5.2625C21.3322 5.03006 21.6079 4.84566 21.9114 4.71985C22.2149 4.59404 22.5402 4.52928 22.8688 4.52928C23.1973 4.52928 23.5226 4.59404 23.8261 4.71985C24.1296 4.84566 24.4053 5.03006 24.6375 5.2625C24.8699 5.49468 25.0543 5.7704 25.1801 6.0739C25.306 6.37739 25.3707 6.70271 25.3707 7.03125C25.3707 7.35979 25.306 7.68511 25.1801 7.9886C25.0543 8.2921 24.8699 8.56782 24.6375 8.8L24.5625 8.875C24.2743 9.1696 24.081 9.54377 24.0075 9.94926C23.934 10.3548 23.9836 10.773 24.15 11.15V11.25C24.3085 11.6197 24.5716 11.935 24.9069 12.1571C25.2423 12.3792 25.6353 12.4984 26.0375 12.5H26.25C26.913 12.5 27.5489 12.7634 28.0178 13.2322C28.4866 13.7011 28.75 14.337 28.75 15C28.75 15.663 28.4866 16.2989 28.0178 16.7678C27.5489 17.2366 26.913 17.5 26.25 17.5H26.1375C25.7353 17.5016 25.3423 17.6208 25.0069 17.8429C24.6716 18.065 24.4085 18.3803 24.25 18.75V18.75Z\\" stroke=\\"white\\" stroke-width=\\"2\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\"/>\\r\\n            </svg>                \\r\\n            <p class=\\"navigation_text\\" >Settings</p>\\r\\n        </div>\\r\\n    </div>\\r\\n</sidebar>\\r\\n\\r\\n\\r\\n<style>\\r\\n    :global(body){\\r\\n        margin: 0;\\r\\n        padding: 0;\\r\\n    }\\r\\n    @import url('https://fonts.googleapis.com/css2?family=Libre+Baskerville:wght@400;700&display=swap');\\r\\n    a{\\r\\n        text-decoration: none;\\r\\n    }\\r\\n\\r\\n    *{\\r\\n        font-family: 'Libre Baskerville', serif;\\r\\n    }\\r\\n\\r\\n\\r\\n    button, a{\\r\\n        cursor: pointer;\\r\\n        transform: scale(1);\\r\\n    }\\r\\n\\r\\n    a:hover,\\r\\n    button:hover{\\r\\n        transition: transform 400ms;\\r\\n        transform: scale(1.05);\\r\\n    }\\r\\n\\r\\n    .gray{\\r\\n        color: rgba(28, 28, 28, 0.5);\\r\\n        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\\r\\n    }\\r\\n\\r\\n    .dashboard-sidebar{\\r\\n        grid-column: 1/2;\\r\\n\\t\\tgrid-row: 1/-1;\\r\\n        height: 100vh;\\r\\n        width: 225px;\\r\\n        display: flex;\\r\\n        flex-direction: column;\\r\\n        justify-content: flex-start;\\r\\n        align-items: center;\\r\\n        background-color: #3B3F44;\\r\\n    }\\r\\n\\r\\n    .logo-container{\\r\\n        height: 15%;\\r\\n        display: flex;\\r\\n        justify-content: center;\\r\\n        align-items: center;\\r\\n        margin-bottom: 1em;\\r\\n        cursor:pointer;\\r\\n    }\\r\\n\\r\\n    .logo{\\r\\n        color: #fefefe;\\r\\n        font-size: 30px;\\r\\n    }\\r\\n\\r\\n    .sidebar_navigation{\\r\\n        display: flex;\\r\\n        flex-direction: column;\\r\\n    }\\r\\n\\r\\n    .navigation-dashboard{\\r\\n        box-sizing: border-box;\\r\\n        width: 225px;\\r\\n        padding: 8px 0 8px 20px; \\r\\n        display: flex;\\r\\n        align-items: center;\\r\\n        cursor:pointer;\\r\\n    }\\r\\n\\r\\n    .navigation_text{\\r\\n        margin-left: 10px;\\r\\n        color: #fefefe;\\r\\n    }\\r\\n\\r\\n    .active{\\r\\n        background-color: #545a61;\\r\\n    }\\r\\n</style>"],"names":[],"mappings":"AAyDY,IAAI,AAAC,CAAC,AACV,MAAM,CAAE,CAAC,CACT,OAAO,CAAE,CAAC,AACd,CAAC,AACD,QAAQ,IAAI,sFAAsF,CAAC,CAAC,AAKpG,cAAC,CAAC,AACE,WAAW,CAAE,mBAAmB,CAAC,CAAC,KAAK,AAC3C,CAAC,AAcD,mBAAK,CAAC,AACF,KAAK,CAAE,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAC5B,WAAW,CAAE,aAAa,CAAC,CAAC,kBAAkB,CAAC,CAAC,UAAU,CAAC,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC,CAAC,WAAW,CAAC,CAAC,gBAAgB,CAAC,CAAC,UAAU,AAC5I,CAAC,AAED,gCAAkB,CAAC,AACf,WAAW,CAAE,CAAC,CAAC,CAAC,CACtB,QAAQ,CAAE,CAAC,CAAC,EAAE,CACR,MAAM,CAAE,KAAK,CACb,KAAK,CAAE,KAAK,CACZ,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,eAAe,CAAE,UAAU,CAC3B,WAAW,CAAE,MAAM,CACnB,gBAAgB,CAAE,OAAO,AAC7B,CAAC,AAED,6BAAe,CAAC,AACZ,MAAM,CAAE,GAAG,CACX,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,MAAM,CACvB,WAAW,CAAE,MAAM,CACnB,aAAa,CAAE,GAAG,CAClB,OAAO,OAAO,AAClB,CAAC,AAED,mBAAK,CAAC,AACF,KAAK,CAAE,OAAO,CACd,SAAS,CAAE,IAAI,AACnB,CAAC,AAED,iCAAmB,CAAC,AAChB,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,AAC1B,CAAC,AAED,mCAAqB,CAAC,AAClB,UAAU,CAAE,UAAU,CACtB,KAAK,CAAE,KAAK,CACZ,OAAO,CAAE,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,CACvB,OAAO,CAAE,IAAI,CACb,WAAW,CAAE,MAAM,CACnB,OAAO,OAAO,AAClB,CAAC,AAED,8BAAgB,CAAC,AACb,WAAW,CAAE,IAAI,CACjB,KAAK,CAAE,OAAO,AAClB,CAAC,AAED,qBAAO,CAAC,AACJ,gBAAgB,CAAE,OAAO,AAC7B,CAAC"}`
};
var Dashboard_sidebar = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { active = "dashboard" } = $$props;
  if ($$props.active === void 0 && $$bindings.active && active !== void 0)
    $$bindings.active(active);
  $$result.css.add(css$b);
  return `<sidebar class="${"dashboard-sidebar svelte-rtap69"}"><div class="${"logo-container svelte-rtap69"}"><p class="${"logo svelte-rtap69"}">nuntium</p></div>
    <div class="${"sidebar_navigation svelte-rtap69"}"><div class="${"navigation-dashboard " + escape(active === "dashboard" && "active") + " svelte-rtap69"}"><svg width="${"30"}" height="${"30"}" viewBox="${"0 0 30 30"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}" class="${"svelte-rtap69"}"><path d="${"M12.5 3.75H3.75V12.5H12.5V3.75Z"}" stroke="${"white"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-rtap69"}"></path><path d="${"M26.25 3.75H17.5V12.5H26.25V3.75Z"}" stroke="${"white"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-rtap69"}"></path><path d="${"M26.25 17.5H17.5V26.25H26.25V17.5Z"}" stroke="${"white"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-rtap69"}"></path><path d="${"M12.5 17.5H3.75V26.25H12.5V17.5Z"}" stroke="${"white"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-rtap69"}"></path></svg>                
            <p class="${"navigation_text svelte-rtap69"}">Dashboard</p></div>
        <div class="${"navigation-dashboard " + escape(active === "profile" && "active") + " svelte-rtap69"}"><svg width="${"30"}" height="${"30"}" viewBox="${"0 0 30 30"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}" class="${"svelte-rtap69"}"><path d="${"M25 26.25V23.75C25 22.4239 24.4732 21.1521 23.5355 20.2145C22.5979 19.2768 21.3261 18.75 20 18.75H10C8.67392 18.75 7.40215 19.2768 6.46447 20.2145C5.52678 21.1521 5 22.4239 5 23.75V26.25"}" stroke="${"white"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-rtap69"}"></path><path d="${"M15 13.75C17.7614 13.75 20 11.5114 20 8.75C20 5.98858 17.7614 3.75 15 3.75C12.2386 3.75 10 5.98858 10 8.75C10 11.5114 12.2386 13.75 15 13.75Z"}" stroke="${"white"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-rtap69"}"></path></svg>                
            <p class="${"navigation_text svelte-rtap69"}">Profile</p></div>
        <div class="${"navigation-dashboard " + escape(active === "write-a-post" && "active") + " svelte-rtap69"}"><svg width="${"24"}" height="${"24"}" viewBox="${"0 0 24 24"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}" class="${"svelte-rtap69"}"><path d="${"M17 2.99981C17.2626 2.73717 17.5744 2.52883 17.9176 2.38669C18.2608 2.24455 18.6286 2.17139 19 2.17139C19.3714 2.17139 19.7392 2.24455 20.0824 2.38669C20.4256 2.52883 20.7374 2.73717 21 2.99981C21.2626 3.26246 21.471 3.57426 21.6131 3.91742C21.7553 4.26058 21.8284 4.62838 21.8284 4.99981C21.8284 5.37125 21.7553 5.73905 21.6131 6.08221C21.471 6.42537 21.2626 6.73717 21 6.99981L7.5 20.4998L2 21.9998L3.5 16.4998L17 2.99981Z"}" stroke="${"white"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-rtap69"}"></path></svg>                
            <p class="${"navigation_text svelte-rtap69"}">Write a Post</p></div>
        <div class="${"navigation-dashboard " + escape(active === "all-posts" && "active") + " svelte-rtap69"}"><svg width="${"30"}" height="${"30"}" viewBox="${"0 0 30 30"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}" class="${"svelte-rtap69"}"><path d="${"M2.5 3.75H10C11.3261 3.75 12.5979 4.27678 13.5355 5.21447C14.4732 6.15215 15 7.42392 15 8.75V26.25C15 25.2554 14.6049 24.3016 13.9017 23.5983C13.1984 22.8951 12.2446 22.5 11.25 22.5H2.5V3.75Z"}" stroke="${"white"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-rtap69"}"></path><path d="${"M27.5 3.75H20C18.6739 3.75 17.4021 4.27678 16.4645 5.21447C15.5268 6.15215 15 7.42392 15 8.75V26.25C15 25.2554 15.3951 24.3016 16.0983 23.5983C16.8016 22.8951 17.7554 22.5 18.75 22.5H27.5V3.75Z"}" stroke="${"white"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-rtap69"}"></path></svg>                
            <p class="${"navigation_text svelte-rtap69"}">All Posts</p></div>
        <div class="${"navigation-dashboard " + escape(active === "resources" && "active") + " svelte-rtap69"}"><svg width="${"30"}" height="${"30"}" viewBox="${"0 0 30 30"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}" class="${"svelte-rtap69"}"><path d="${"M26.25 19.9999V9.99988C26.2496 9.56147 26.1338 9.13089 25.9144 8.75133C25.695 8.37177 25.3797 8.05658 25 7.83738L16.25 2.83738C15.87 2.61796 15.4388 2.50244 15 2.50244C14.5612 2.50244 14.13 2.61796 13.75 2.83738L5 7.83738C4.62033 8.05658 4.30498 8.37177 4.08558 8.75133C3.86618 9.13089 3.75045 9.56147 3.75 9.99988V19.9999C3.75045 20.4383 3.86618 20.8689 4.08558 21.2484C4.30498 21.628 4.62033 21.9432 5 22.1624L13.75 27.1624C14.13 27.3818 14.5612 27.4973 15 27.4973C15.4388 27.4973 15.87 27.3818 16.25 27.1624L25 22.1624C25.3797 21.9432 25.695 21.628 25.9144 21.2484C26.1338 20.8689 26.2496 20.4383 26.25 19.9999Z"}" stroke="${"white"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-rtap69"}"></path><path d="${"M4.0874 8.7002L14.9999 15.0127L25.9124 8.7002"}" stroke="${"white"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-rtap69"}"></path><path d="${"M15 27.6V15"}" stroke="${"white"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-rtap69"}"></path></svg>
            <p class="${"navigation_text svelte-rtap69"}">Resources</p></div>
        <div class="${"navigation-dashboard " + escape(active === "settings" && "active") + " svelte-rtap69"}"><svg width="${"30"}" height="${"30"}" viewBox="${"0 0 30 30"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}" class="${"svelte-rtap69"}"><path d="${"M15 18.75C17.0711 18.75 18.75 17.0711 18.75 15C18.75 12.9289 17.0711 11.25 15 11.25C12.9289 11.25 11.25 12.9289 11.25 15C11.25 17.0711 12.9289 18.75 15 18.75Z"}" stroke="${"white"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-rtap69"}"></path><path d="${"M24.25 18.75C24.0836 19.127 24.034 19.5452 24.1075 19.9507C24.181 20.3562 24.3743 20.7304 24.6625 21.025L24.7375 21.1C24.9699 21.3322 25.1543 21.6079 25.2801 21.9114C25.406 22.2149 25.4707 22.5402 25.4707 22.8688C25.4707 23.1973 25.406 23.5226 25.2801 23.8261C25.1543 24.1296 24.9699 24.4053 24.7375 24.6375C24.5053 24.8699 24.2296 25.0543 23.9261 25.1801C23.6226 25.306 23.2973 25.3707 22.9688 25.3707C22.6402 25.3707 22.3149 25.306 22.0114 25.1801C21.7079 25.0543 21.4322 24.8699 21.2 24.6375L21.125 24.5625C20.8304 24.2743 20.4562 24.081 20.0507 24.0075C19.6452 23.934 19.227 23.9836 18.85 24.15C18.4803 24.3085 18.165 24.5716 17.9429 24.9069C17.7208 25.2423 17.6016 25.6353 17.6 26.0375V26.25C17.6 26.913 17.3366 27.5489 16.8678 28.0178C16.3989 28.4866 15.763 28.75 15.1 28.75C14.437 28.75 13.8011 28.4866 13.3322 28.0178C12.8634 27.5489 12.6 26.913 12.6 26.25V26.1375C12.5903 25.7238 12.4564 25.3225 12.2156 24.9859C11.9749 24.6493 11.6384 24.3929 11.25 24.25C10.873 24.0836 10.4548 24.034 10.0493 24.1075C9.64377 24.181 9.2696 24.3743 8.975 24.6625L8.9 24.7375C8.66782 24.9699 8.3921 25.1543 8.0886 25.2801C7.78511 25.406 7.45979 25.4707 7.13125 25.4707C6.80271 25.4707 6.47739 25.406 6.1739 25.2801C5.8704 25.1543 5.59468 24.9699 5.3625 24.7375C5.13006 24.5053 4.94566 24.2296 4.81985 23.9261C4.69404 23.6226 4.62928 23.2973 4.62928 22.9688C4.62928 22.6402 4.69404 22.3149 4.81985 22.0114C4.94566 21.7079 5.13006 21.4322 5.3625 21.2L5.4375 21.125C5.72567 20.8304 5.91898 20.4562 5.99251 20.0507C6.06603 19.6452 6.01639 19.227 5.85 18.85C5.69155 18.4803 5.42844 18.165 5.09308 17.9429C4.75772 17.7208 4.36473 17.6016 3.9625 17.6H3.75C3.08696 17.6 2.45107 17.3366 1.98223 16.8678C1.51339 16.3989 1.25 15.763 1.25 15.1C1.25 14.437 1.51339 13.8011 1.98223 13.3322C2.45107 12.8634 3.08696 12.6 3.75 12.6H3.8625C4.27624 12.5903 4.67751 12.4564 5.01412 12.2156C5.35074 11.9749 5.60714 11.6384 5.75 11.25C5.91639 10.873 5.96603 10.4548 5.89251 10.0493C5.81898 9.64377 5.62567 9.2696 5.3375 8.975L5.2625 8.9C5.03006 8.66782 4.84566 8.3921 4.71985 8.0886C4.59404 7.78511 4.52928 7.45979 4.52928 7.13125C4.52928 6.80271 4.59404 6.47739 4.71985 6.1739C4.84566 5.8704 5.03006 5.59468 5.2625 5.3625C5.49468 5.13006 5.7704 4.94566 6.0739 4.81985C6.37739 4.69404 6.70271 4.62928 7.03125 4.62928C7.35979 4.62928 7.68511 4.69404 7.9886 4.81985C8.2921 4.94566 8.56782 5.13006 8.8 5.3625L8.875 5.4375C9.1696 5.72567 9.54377 5.91898 9.94926 5.99251C10.3548 6.06603 10.773 6.01639 11.15 5.85H11.25C11.6197 5.69155 11.935 5.42844 12.1571 5.09308C12.3792 4.75772 12.4984 4.36473 12.5 3.9625V3.75C12.5 3.08696 12.7634 2.45107 13.2322 1.98223C13.7011 1.51339 14.337 1.25 15 1.25C15.663 1.25 16.2989 1.51339 16.7678 1.98223C17.2366 2.45107 17.5 3.08696 17.5 3.75V3.8625C17.5016 4.26473 17.6208 4.65772 17.8429 4.99308C18.065 5.32844 18.3803 5.59155 18.75 5.75C19.127 5.91639 19.5452 5.96603 19.9507 5.89251C20.3562 5.81898 20.7304 5.62567 21.025 5.3375L21.1 5.2625C21.3322 5.03006 21.6079 4.84566 21.9114 4.71985C22.2149 4.59404 22.5402 4.52928 22.8688 4.52928C23.1973 4.52928 23.5226 4.59404 23.8261 4.71985C24.1296 4.84566 24.4053 5.03006 24.6375 5.2625C24.8699 5.49468 25.0543 5.7704 25.1801 6.0739C25.306 6.37739 25.3707 6.70271 25.3707 7.03125C25.3707 7.35979 25.306 7.68511 25.1801 7.9886C25.0543 8.2921 24.8699 8.56782 24.6375 8.8L24.5625 8.875C24.2743 9.1696 24.081 9.54377 24.0075 9.94926C23.934 10.3548 23.9836 10.773 24.15 11.15V11.25C24.3085 11.6197 24.5716 11.935 24.9069 12.1571C25.2423 12.3792 25.6353 12.4984 26.0375 12.5H26.25C26.913 12.5 27.5489 12.7634 28.0178 13.2322C28.4866 13.7011 28.75 14.337 28.75 15C28.75 15.663 28.4866 16.2989 28.0178 16.7678C27.5489 17.2366 26.913 17.5 26.25 17.5H26.1375C25.7353 17.5016 25.3423 17.6208 25.0069 17.8429C24.6716 18.065 24.4085 18.3803 24.25 18.75V18.75Z"}" stroke="${"white"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-rtap69"}"></path></svg>                
            <p class="${"navigation_text svelte-rtap69"}">Settings</p></div></div>
</sidebar>`;
});
var css$a = {
  code: "@import url('https://fonts.googleapis.com/css2?family=Libre+Baskerville:wght@400;700&display=swap');a.svelte-1hix2gs{text-decoration:none}a.svelte-1hix2gs,.svelte-1hix2gs{font-family:'Libre Baskerville', serif}button.svelte-1hix2gs,a.svelte-1hix2gs{cursor:pointer;transform:scale(1)}a.svelte-1hix2gs:hover,button.svelte-1hix2gs:hover{transition:transform 400ms;transform:scale(1.05)}.navbar.svelte-1hix2gs{margin-top:20px;display:flex;flex-direction:column;justify-content:space-evenly;align-items:center;grid-column:2/3;grid-row:1/2}.navbar-block.svelte-1hix2gs{display:flex;flex-direction:column;justify-content:space-between;align-items:center}.navbar-search.svelte-1hix2gs{display:flex;margin-right:10px;height:44px;overflow:hidden;border-radius:10px}.navbar-input.svelte-1hix2gs{width:340px;outline:0;box-sizing:border-box;border:0;transition:width 500ms;font-size:20px;padding-left:10px}.navbar-icon-button.svelte-1hix2gs{padding:5px;background-color:transparent;outline:0;border:0;margin:0}.navbar-login-button.svelte-1hix2gs{border:1.5px solid black;border-radius:10px;width:135px;height:46px;background-color:transparent;font-size:20px}.user.svelte-1hix2gs{width:145px;display:flex;justify-content:space-around}.user-bell.svelte-1hix2gs{outline:0;border:0;background-color:transparent}.user-image-button.svelte-1hix2gs{border-radius:50%;overflow:hidden;width:60px;height:60px;position:relative;cursor:pointer}.profile-img.svelte-1hix2gs{object-position:center;object-fit:contain;width:100%;height:100%}.user-dropdown-options.svelte-1hix2gs{flex-direction:column;position:absolute;width:171px;height:223px;background-color:#fefefe;top:90px;right:20px;border-radius:0 0 10px 10px;filter:drop-shadow(0px 0px 5px rgba(228, 228, 228, 0.25))}.container-top.svelte-1hix2gs{border-bottom:1px solid #c4c4c4;padding:1em 1.5em;height:20%}.user-name.svelte-1hix2gs{font-size:16px;color:#000;margin:0;margin-top:10px;font-weight:bold}.user-username.svelte-1hix2gs{font-size:14px;color:rgba(28, 28, 28, 0.8);margin:0;margin:0;font-family:-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell,\r\n			'Open Sans', 'Helvetica Neue', sans-serif}.container-bottom.svelte-1hix2gs{display:flex;flex-direction:column;justify-content:space-evenly;height:80%;padding-left:1.5em}.dropdown-link.svelte-1hix2gs{text-decoration:none;color:#000}.sign-out-button.svelte-1hix2gs{padding:0;outline:0;border:0;font-size:16px;background-color:transparent;width:70px}@media(min-width: 600px){.navbar.svelte-1hix2gs{flex-direction:row;justify-content:flex-end}.navbar-block.svelte-1hix2gs{flex-direction:row}.navbar-icon-button.svelte-1hix2gs{padding:5px;background-color:transparent;outline:0;border:0;margin:0}.navbar-login-button.svelte-1hix2gs{border:1.5px solid black;border-radius:10px;width:135px;height:46px;background-color:transparent;font-size:20px}}",
  map: `{"version":3,"file":"dashboard.navbar.svelte","sources":["dashboard.navbar.svelte"],"sourcesContent":["<script context=\\"module\\" >\\r\\n\\timport {useAuthListener}  from '../utils/authListener';\\r\\n\\tlet userDetails;\\r\\n\\tuserDetails = useAuthListener();\\r\\n<\/script>\\r\\n\\r\\n<script lang=\\"ts\\">import profile from '../assets/images/user/profile_picture.jpg';\\r\\nimport { userSignout } from '../utils/firebase.apis';\\r\\nimport { localStore } from '../services/localStorage';\\r\\nexport let active;\\r\\nexport let search = false;\\r\\nlocalStore.subscribe((value) => value && (userDetails = JSON.parse(value)));\\r\\nlet user = {\\r\\n    loggedIn: userDetails ? true : false,\\r\\n    user: userDetails,\\r\\n    dropdown: false\\r\\n};\\r\\nfunction handleClick(e) {\\r\\n    e.preventDefault();\\r\\n    search = !search;\\r\\n}\\r\\nfunction handleSubmit(e) {\\r\\n    e.preventDefault();\\r\\n}\\r\\nfunction handleSignout() {\\r\\n    const message = userSignout();\\r\\n    console.log(message);\\r\\n}\\r\\n<\/script>\\r\\n\\r\\n<nav\\r\\n\\ton:click={() => {\\r\\n\\t\\tsearch = false;\\r\\n\\t\\tuser.dropdown = false;\\r\\n\\t}}\\r\\n\\tclass=\\"navbar\\"\\r\\n>\\r\\n\\t<div class=\\"navbar-block\\">\\r\\n\\t\\t<form\\r\\n\\t\\t\\ton:submit={handleSubmit}\\r\\n\\t\\t\\tstyle=\\"border: {search ? '1.5px solid #000' : 0}\\"\\r\\n\\t\\t\\tclass=\\"navbar-search\\"\\r\\n\\t\\t>\\r\\n\\t\\t\\t<input\\r\\n\\t\\t\\t\\ton:click={(e) => e.stopPropagation()}\\r\\n\\t\\t\\t\\tstyle=\\"display: {search ? 'block' : 'none'}\\"\\r\\n\\t\\t\\t\\tclass=\\"navbar-input\\"\\r\\n\\t\\t\\t\\ttype=\\"text\\"\\r\\n\\t\\t\\t/>\\r\\n\\t\\t\\t<button\\r\\n\\t\\t\\t\\ton:click={(e) => {\\r\\n\\t\\t\\t\\t\\te.stopPropagation();\\r\\n\\t\\t\\t\\t\\thandleClick(e);\\r\\n\\t\\t\\t\\t}}\\r\\n\\t\\t\\t\\tclass=\\"navbar-icon-button\\"\\r\\n\\t\\t\\t>\\r\\n\\t\\t\\t\\t<svg\\r\\n\\t\\t\\t\\t\\twidth=\\"30\\"\\r\\n\\t\\t\\t\\t\\theight=\\"30\\"\\r\\n\\t\\t\\t\\t\\tviewBox=\\"0 0 30 30\\"\\r\\n\\t\\t\\t\\t\\tfill=\\"none\\"\\r\\n\\t\\t\\t\\t\\txmlns=\\"http://www.w3.org/2000/svg\\"\\r\\n\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\td=\\"M13.75 23.75C19.2728 23.75 23.75 19.2728 23.75 13.75C23.75 8.22715 19.2728 3.75 13.75 3.75C8.22715 3.75 3.75 8.22715 3.75 13.75C3.75 19.2728 8.22715 23.75 13.75 23.75Z\\"\\r\\n\\t\\t\\t\\t\\t\\tstroke=\\"black\\"\\r\\n\\t\\t\\t\\t\\t\\tstroke-width=\\"2\\"\\r\\n\\t\\t\\t\\t\\t\\tstroke-linecap=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\tstroke-linejoin=\\"round\\"\\r\\n\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\td=\\"M26.25 26.25L20.8125 20.8125\\"\\r\\n\\t\\t\\t\\t\\t\\tstroke=\\"black\\"\\r\\n\\t\\t\\t\\t\\t\\tstroke-width=\\"2\\"\\r\\n\\t\\t\\t\\t\\t\\tstroke-linecap=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\tstroke-linejoin=\\"round\\"\\r\\n\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t</svg>\\r\\n\\t\\t\\t</button>\\r\\n\\t\\t</form>\\r\\n\\t\\t{#if user.loggedIn}\\r\\n\\t\\t\\t<div class=\\"user\\">\\r\\n\\t\\t\\t\\t<button class=\\"user-bell\\">\\r\\n\\t\\t\\t\\t\\t<svg\\r\\n\\t\\t\\t\\t\\t\\twidth=\\"30\\"\\r\\n\\t\\t\\t\\t\\t\\theight=\\"30\\"\\r\\n\\t\\t\\t\\t\\t\\tviewBox=\\"0 0 30 30\\"\\r\\n\\t\\t\\t\\t\\t\\tfill=\\"none\\"\\r\\n\\t\\t\\t\\t\\t\\txmlns=\\"http://www.w3.org/2000/svg\\"\\r\\n\\t\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\t\\td=\\"M22.5 10C22.5 8.01088 21.7098 6.10322 20.3033 4.6967C18.8968 3.29018 16.9891 2.5 15 2.5C13.0109 2.5 11.1032 3.29018 9.6967 4.6967C8.29018 6.10322 7.5 8.01088 7.5 10C7.5 18.75 3.75 21.25 3.75 21.25H26.25C26.25 21.25 22.5 18.75 22.5 10Z\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke=\\"black\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke-width=\\"2\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke-linecap=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke-linejoin=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\t\\td=\\"M17.1625 26.25C16.9428 26.6288 16.6273 26.9433 16.2478 27.1619C15.8683 27.3805 15.438 27.4956 15 27.4956C14.5621 27.4956 14.1318 27.3805 13.7522 27.1619C13.3727 26.9433 13.0573 26.6288 12.8375 26.25\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke=\\"black\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke-width=\\"2\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke-linecap=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke-linejoin=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t</svg>\\r\\n\\t\\t\\t\\t</button>\\r\\n\\t\\t\\t\\t<div\\r\\n\\t\\t\\t\\t\\ton:click={(e) => {\\r\\n\\t\\t\\t\\t\\t\\tuser.dropdown = true;\\r\\n\\t\\t\\t\\t\\t\\te.stopPropagation();\\r\\n\\t\\t\\t\\t\\t}}\\r\\n\\t\\t\\t\\t\\tclass=\\"user-image-button\\"\\r\\n\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t\\t<img class=\\"profile-img\\" src={profile} alt=\\"user's profile\\" />\\r\\n\\t\\t\\t\\t</div>\\r\\n\\t\\t\\t</div>\\r\\n\\t\\t{:else}\\r\\n\\t\\t\\t<button on:click={(e) => (location.href = '/login')} class=\\"navbar-login-button\\">Login</button\\r\\n\\t\\t\\t>\\r\\n\\t\\t{/if}\\r\\n\\t\\t<div style=\\"display: {user.dropdown ? 'flex' : 'none'}\\" class=\\"user-dropdown-options\\">\\r\\n\\t\\t\\t<div class=\\"container-top\\">\\r\\n\\t\\t\\t\\t<h2 class=\\"user-name\\">Aslam Idrisi</h2>\\r\\n\\t\\t\\t\\t<p class=\\"user-username gray\\">@willtheastro</p>\\r\\n\\t\\t\\t</div>\\r\\n\\t\\t\\t<div class=\\"container-bottom\\">\\r\\n\\t\\t\\t\\t<a href=\\"/dashboard\\" class=\\"dropdown-link\\">Dashboard</a>\\r\\n\\t\\t\\t\\t<a href=\\"/dashboard/writepost\\" class=\\"dropdown-link\\">Write a Post</a>\\r\\n\\t\\t\\t\\t<a href=\\"/dashboard/settings\\" class=\\"dropdown-link\\">Settings</a>\\r\\n\\t\\t\\t\\t<a href=\\"/helps\\" class=\\"dropdown-link\\">Help</a>\\r\\n\\t\\t\\t\\t<button on:click={handleSignout} class=\\"dropdown-link sign-out-button\\">Sign out</button>\\r\\n\\t\\t\\t</div>\\r\\n\\t\\t</div>\\r\\n\\t</div>\\r\\n</nav>\\r\\n\\r\\n<slot></slot>\\r\\n\\r\\n<style>\\r\\n\\t@import url('https://fonts.googleapis.com/css2?family=Libre+Baskerville:wght@400;700&display=swap');\\r\\n\\ta {\\r\\n\\t\\ttext-decoration: none;\\r\\n\\t}\\r\\n\\r\\n    \\r\\n\\r\\n\\ta,\\r\\n\\t* {\\r\\n\\t\\tfont-family: 'Libre Baskerville', serif;\\r\\n\\t}\\r\\n\\r\\n\\tbutton,\\r\\n\\ta {\\r\\n\\t\\tcursor: pointer;\\r\\n\\t\\ttransform: scale(1);\\r\\n\\t}\\r\\n\\r\\n\\ta:hover,\\r\\n\\tbutton:hover {\\r\\n\\t\\ttransition: transform 400ms;\\r\\n\\t\\ttransform: scale(1.05);\\r\\n\\t}\\r\\n\\r\\n\\t.navbar {\\r\\n\\t\\tmargin-top: 20px;\\r\\n\\t\\tdisplay: flex;\\r\\n\\t\\tflex-direction: column;\\r\\n\\t\\tjustify-content: space-evenly;\\r\\n\\t\\talign-items: center;\\r\\n        grid-column: 2/3;\\r\\n\\t\\tgrid-row: 1/2;\\r\\n\\t}\\r\\n\\r\\n\\t.navbar-block {\\r\\n\\t\\tdisplay: flex;\\r\\n\\t\\tflex-direction: column;\\r\\n\\t\\tjustify-content: space-between;\\r\\n\\t\\talign-items: center;\\r\\n\\t}\\r\\n\\t\\r\\n\\r\\n\\t.navbar-search {\\r\\n\\t\\tdisplay: flex;\\r\\n\\r\\n\\t\\tmargin-right: 10px;\\r\\n\\t\\theight: 44px;\\r\\n\\t\\toverflow: hidden;\\r\\n\\t\\tborder-radius: 10px;\\r\\n\\t}\\r\\n\\r\\n\\t.navbar-input {\\r\\n\\t\\twidth: 340px;\\r\\n\\t\\toutline: 0;\\r\\n\\t\\tbox-sizing: border-box;\\r\\n\\t\\tborder: 0;\\r\\n\\t\\ttransition: width 500ms;\\r\\n\\t\\tfont-size: 20px;\\r\\n\\t\\tpadding-left: 10px;\\r\\n\\t}\\r\\n\\r\\n\\t.navbar-icon-button {\\r\\n\\t\\tpadding: 5px;\\r\\n\\t\\tbackground-color: transparent;\\r\\n\\t\\toutline: 0;\\r\\n\\t\\tborder: 0;\\r\\n\\t\\tmargin: 0;\\r\\n\\t}\\r\\n\\r\\n\\t.navbar-login-button {\\r\\n\\t\\tborder: 1.5px solid black;\\r\\n\\t\\tborder-radius: 10px;\\r\\n\\t\\twidth: 135px;\\r\\n\\t\\theight: 46px;\\r\\n\\t\\tbackground-color: transparent;\\r\\n\\t\\tfont-size: 20px;\\r\\n\\t}\\r\\n\\r\\n\\t.user {\\r\\n\\t\\twidth: 145px;\\r\\n\\t\\tdisplay: flex;\\r\\n\\t\\tjustify-content: space-around;\\r\\n\\t}\\r\\n\\r\\n\\t.user-bell {\\r\\n\\t\\toutline: 0;\\r\\n\\t\\tborder: 0;\\r\\n\\t\\tbackground-color: transparent;\\r\\n\\t}\\r\\n\\r\\n\\t.user-image-button {\\r\\n\\t\\tborder-radius: 50%;\\r\\n\\t\\toverflow: hidden;\\r\\n\\t\\twidth: 60px;\\r\\n\\t\\theight: 60px;\\r\\n\\t\\tposition: relative;\\r\\n\\t\\tcursor: pointer;\\r\\n\\t}\\r\\n\\r\\n\\t.profile-img {\\r\\n\\t\\tobject-position: center;\\r\\n\\t\\tobject-fit: contain;\\r\\n\\t\\twidth: 100%;\\r\\n\\t\\theight: 100%;\\r\\n\\t}\\r\\n\\r\\n\\t.user-dropdown-options {\\r\\n\\t\\tflex-direction: column;\\r\\n\\t\\tposition: absolute;\\r\\n\\t\\twidth: 171px;\\r\\n\\t\\theight: 223px;\\r\\n\\t\\tbackground-color: #fefefe;\\r\\n\\t\\ttop: 90px;\\r\\n\\t\\tright: 20px;\\r\\n\\t\\tborder-radius: 0 0 10px 10px;\\r\\n\\t\\tfilter: drop-shadow(0px 0px 5px rgba(228, 228, 228, 0.25));\\r\\n\\t}\\r\\n\\r\\n\\t.container-top {\\r\\n\\t\\tborder-bottom: 1px solid #c4c4c4;\\r\\n\\t\\tpadding: 1em 1.5em;\\r\\n\\t\\theight: 20%;\\r\\n\\t}\\r\\n\\r\\n\\t.user-name {\\r\\n\\t\\tfont-size: 16px;\\r\\n\\t\\tcolor: #000;\\r\\n\\t\\tmargin: 0;\\r\\n\\t\\tmargin-top: 10px;\\r\\n\\t\\tfont-weight: bold;\\r\\n\\t}\\r\\n\\r\\n\\t.user-username {\\r\\n\\t\\tfont-size: 14px;\\r\\n\\t\\tcolor: rgba(28, 28, 28, 0.8);\\r\\n\\t\\tmargin: 0;\\r\\n\\t\\tmargin: 0;\\r\\n\\t\\tfont-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell,\\r\\n\\t\\t\\t'Open Sans', 'Helvetica Neue', sans-serif;\\r\\n\\t}\\r\\n\\r\\n\\t.container-bottom {\\r\\n\\t\\tdisplay: flex;\\r\\n\\t\\tflex-direction: column;\\r\\n\\t\\tjustify-content: space-evenly;\\r\\n\\t\\theight: 80%;\\r\\n\\t\\tpadding-left: 1.5em;\\r\\n\\t}\\r\\n\\r\\n\\t.dropdown-link {\\r\\n\\t\\ttext-decoration: none;\\r\\n\\t\\tcolor: #000;\\r\\n\\t}\\r\\n\\r\\n\\t.sign-out-button {\\r\\n\\t\\tpadding: 0;\\r\\n\\t\\toutline: 0;\\r\\n\\t\\tborder: 0;\\r\\n\\t\\tfont-size: 16px;\\r\\n\\t\\tbackground-color: transparent;\\r\\n\\t\\twidth: 70px;\\r\\n\\t}\\r\\n\\r\\n\\t@media (min-width: 600px) {\\r\\n\\t\\t.navbar {\\r\\n\\t\\t\\tflex-direction: row;\\r\\n\\t\\t\\tjustify-content: flex-end;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t.navbar-block {\\r\\n\\t\\t\\tflex-direction: row;\\r\\n\\t\\t}\\r\\n\\r\\n\\r\\n\\t\\t.navbar-icon-button {\\r\\n\\t\\t\\tpadding: 5px;\\r\\n\\t\\t\\tbackground-color: transparent;\\r\\n\\t\\t\\toutline: 0;\\r\\n\\t\\t\\tborder: 0;\\r\\n\\t\\t\\tmargin: 0;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t.navbar-login-button {\\r\\n\\t\\t\\tborder: 1.5px solid black;\\r\\n\\t\\t\\tborder-radius: 10px;\\r\\n\\t\\t\\twidth: 135px;\\r\\n\\t\\t\\theight: 46px;\\r\\n\\t\\t\\tbackground-color: transparent;\\r\\n\\t\\t\\tfont-size: 20px;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n</style>\\r\\n"],"names":[],"mappings":"AA2IC,QAAQ,IAAI,sFAAsF,CAAC,CAAC,AACpG,CAAC,eAAC,CAAC,AACF,eAAe,CAAE,IAAI,AACtB,CAAC,AAID,gBAAC,CACD,eAAE,CAAC,AACF,WAAW,CAAE,mBAAmB,CAAC,CAAC,KAAK,AACxC,CAAC,AAED,qBAAM,CACN,CAAC,eAAC,CAAC,AACF,MAAM,CAAE,OAAO,CACf,SAAS,CAAE,MAAM,CAAC,CAAC,AACpB,CAAC,AAED,gBAAC,MAAM,CACP,qBAAM,MAAM,AAAC,CAAC,AACb,UAAU,CAAE,SAAS,CAAC,KAAK,CAC3B,SAAS,CAAE,MAAM,IAAI,CAAC,AACvB,CAAC,AAED,OAAO,eAAC,CAAC,AACR,UAAU,CAAE,IAAI,CAChB,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,eAAe,CAAE,YAAY,CAC7B,WAAW,CAAE,MAAM,CACb,WAAW,CAAE,CAAC,CAAC,CAAC,CACtB,QAAQ,CAAE,CAAC,CAAC,CAAC,AACd,CAAC,AAED,aAAa,eAAC,CAAC,AACd,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,eAAe,CAAE,aAAa,CAC9B,WAAW,CAAE,MAAM,AACpB,CAAC,AAGD,cAAc,eAAC,CAAC,AACf,OAAO,CAAE,IAAI,CAEb,YAAY,CAAE,IAAI,CAClB,MAAM,CAAE,IAAI,CACZ,QAAQ,CAAE,MAAM,CAChB,aAAa,CAAE,IAAI,AACpB,CAAC,AAED,aAAa,eAAC,CAAC,AACd,KAAK,CAAE,KAAK,CACZ,OAAO,CAAE,CAAC,CACV,UAAU,CAAE,UAAU,CACtB,MAAM,CAAE,CAAC,CACT,UAAU,CAAE,KAAK,CAAC,KAAK,CACvB,SAAS,CAAE,IAAI,CACf,YAAY,CAAE,IAAI,AACnB,CAAC,AAED,mBAAmB,eAAC,CAAC,AACpB,OAAO,CAAE,GAAG,CACZ,gBAAgB,CAAE,WAAW,CAC7B,OAAO,CAAE,CAAC,CACV,MAAM,CAAE,CAAC,CACT,MAAM,CAAE,CAAC,AACV,CAAC,AAED,oBAAoB,eAAC,CAAC,AACrB,MAAM,CAAE,KAAK,CAAC,KAAK,CAAC,KAAK,CACzB,aAAa,CAAE,IAAI,CACnB,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,IAAI,CACZ,gBAAgB,CAAE,WAAW,CAC7B,SAAS,CAAE,IAAI,AAChB,CAAC,AAED,KAAK,eAAC,CAAC,AACN,KAAK,CAAE,KAAK,CACZ,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,YAAY,AAC9B,CAAC,AAED,UAAU,eAAC,CAAC,AACX,OAAO,CAAE,CAAC,CACV,MAAM,CAAE,CAAC,CACT,gBAAgB,CAAE,WAAW,AAC9B,CAAC,AAED,kBAAkB,eAAC,CAAC,AACnB,aAAa,CAAE,GAAG,CAClB,QAAQ,CAAE,MAAM,CAChB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,QAAQ,CAAE,QAAQ,CAClB,MAAM,CAAE,OAAO,AAChB,CAAC,AAED,YAAY,eAAC,CAAC,AACb,eAAe,CAAE,MAAM,CACvB,UAAU,CAAE,OAAO,CACnB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,AACb,CAAC,AAED,sBAAsB,eAAC,CAAC,AACvB,cAAc,CAAE,MAAM,CACtB,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,CACb,gBAAgB,CAAE,OAAO,CACzB,GAAG,CAAE,IAAI,CACT,KAAK,CAAE,IAAI,CACX,aAAa,CAAE,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAC5B,MAAM,CAAE,YAAY,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,AAC3D,CAAC,AAED,cAAc,eAAC,CAAC,AACf,aAAa,CAAE,GAAG,CAAC,KAAK,CAAC,OAAO,CAChC,OAAO,CAAE,GAAG,CAAC,KAAK,CAClB,MAAM,CAAE,GAAG,AACZ,CAAC,AAED,UAAU,eAAC,CAAC,AACX,SAAS,CAAE,IAAI,CACf,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,CAAC,CACT,UAAU,CAAE,IAAI,CAChB,WAAW,CAAE,IAAI,AAClB,CAAC,AAED,cAAc,eAAC,CAAC,AACf,SAAS,CAAE,IAAI,CACf,KAAK,CAAE,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAC5B,MAAM,CAAE,CAAC,CACT,MAAM,CAAE,CAAC,CACT,WAAW,CAAE,aAAa,CAAC,CAAC,kBAAkB,CAAC,CAAC,UAAU,CAAC,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC;GAC7F,WAAW,CAAC,CAAC,gBAAgB,CAAC,CAAC,UAAU,AAC3C,CAAC,AAED,iBAAiB,eAAC,CAAC,AAClB,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,eAAe,CAAE,YAAY,CAC7B,MAAM,CAAE,GAAG,CACX,YAAY,CAAE,KAAK,AACpB,CAAC,AAED,cAAc,eAAC,CAAC,AACf,eAAe,CAAE,IAAI,CACrB,KAAK,CAAE,IAAI,AACZ,CAAC,AAED,gBAAgB,eAAC,CAAC,AACjB,OAAO,CAAE,CAAC,CACV,OAAO,CAAE,CAAC,CACV,MAAM,CAAE,CAAC,CACT,SAAS,CAAE,IAAI,CACf,gBAAgB,CAAE,WAAW,CAC7B,KAAK,CAAE,IAAI,AACZ,CAAC,AAED,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AAC1B,OAAO,eAAC,CAAC,AACR,cAAc,CAAE,GAAG,CACnB,eAAe,CAAE,QAAQ,AAC1B,CAAC,AAED,aAAa,eAAC,CAAC,AACd,cAAc,CAAE,GAAG,AACpB,CAAC,AAGD,mBAAmB,eAAC,CAAC,AACpB,OAAO,CAAE,GAAG,CACZ,gBAAgB,CAAE,WAAW,CAC7B,OAAO,CAAE,CAAC,CACV,MAAM,CAAE,CAAC,CACT,MAAM,CAAE,CAAC,AACV,CAAC,AAED,oBAAoB,eAAC,CAAC,AACrB,MAAM,CAAE,KAAK,CAAC,KAAK,CAAC,KAAK,CACzB,aAAa,CAAE,IAAI,CACnB,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,IAAI,CACZ,gBAAgB,CAAE,WAAW,CAC7B,SAAS,CAAE,IAAI,AAChB,CAAC,AACF,CAAC"}`
};
var userDetails;
userDetails = useAuthListener();
var Dashboard_navbar = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { active } = $$props;
  let { search = false } = $$props;
  localStore.subscribe((value) => value && (userDetails = JSON.parse(value)));
  let user2 = {
    loggedIn: userDetails ? true : false,
    user: userDetails,
    dropdown: false
  };
  if ($$props.active === void 0 && $$bindings.active && active !== void 0)
    $$bindings.active(active);
  if ($$props.search === void 0 && $$bindings.search && search !== void 0)
    $$bindings.search(search);
  $$result.css.add(css$a);
  return `<nav class="${"navbar svelte-1hix2gs"}"><div class="${"navbar-block svelte-1hix2gs"}"><form style="${"border: " + escape(search ? "1.5px solid #000" : 0)}" class="${"navbar-search svelte-1hix2gs"}"><input style="${"display: " + escape(search ? "block" : "none")}" class="${"navbar-input svelte-1hix2gs"}" type="${"text"}">
			<button class="${"navbar-icon-button svelte-1hix2gs"}"><svg width="${"30"}" height="${"30"}" viewBox="${"0 0 30 30"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}" class="${"svelte-1hix2gs"}"><path d="${"M13.75 23.75C19.2728 23.75 23.75 19.2728 23.75 13.75C23.75 8.22715 19.2728 3.75 13.75 3.75C8.22715 3.75 3.75 8.22715 3.75 13.75C3.75 19.2728 8.22715 23.75 13.75 23.75Z"}" stroke="${"black"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-1hix2gs"}"></path><path d="${"M26.25 26.25L20.8125 20.8125"}" stroke="${"black"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-1hix2gs"}"></path></svg></button></form>
		${user2.loggedIn ? `<div class="${"user svelte-1hix2gs"}"><button class="${"user-bell svelte-1hix2gs"}"><svg width="${"30"}" height="${"30"}" viewBox="${"0 0 30 30"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}" class="${"svelte-1hix2gs"}"><path d="${"M22.5 10C22.5 8.01088 21.7098 6.10322 20.3033 4.6967C18.8968 3.29018 16.9891 2.5 15 2.5C13.0109 2.5 11.1032 3.29018 9.6967 4.6967C8.29018 6.10322 7.5 8.01088 7.5 10C7.5 18.75 3.75 21.25 3.75 21.25H26.25C26.25 21.25 22.5 18.75 22.5 10Z"}" stroke="${"black"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-1hix2gs"}"></path><path d="${"M17.1625 26.25C16.9428 26.6288 16.6273 26.9433 16.2478 27.1619C15.8683 27.3805 15.438 27.4956 15 27.4956C14.5621 27.4956 14.1318 27.3805 13.7522 27.1619C13.3727 26.9433 13.0573 26.6288 12.8375 26.25"}" stroke="${"black"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-1hix2gs"}"></path></svg></button>
				<div class="${"user-image-button svelte-1hix2gs"}"><img class="${"profile-img svelte-1hix2gs"}"${add_attribute("src", profile$1, 0)} alt="${"user's profile"}"></div></div>` : `<button class="${"navbar-login-button svelte-1hix2gs"}">Login</button>`}
		<div style="${"display: " + escape("none")}" class="${"user-dropdown-options svelte-1hix2gs"}"><div class="${"container-top svelte-1hix2gs"}"><h2 class="${"user-name svelte-1hix2gs"}">Aslam Idrisi</h2>
				<p class="${"user-username gray svelte-1hix2gs"}">@willtheastro</p></div>
			<div class="${"container-bottom svelte-1hix2gs"}"><a href="${"/dashboard"}" class="${"dropdown-link svelte-1hix2gs"}">Dashboard</a>
				<a href="${"/dashboard/writepost"}" class="${"dropdown-link svelte-1hix2gs"}">Write a Post</a>
				<a href="${"/dashboard/settings"}" class="${"dropdown-link svelte-1hix2gs"}">Settings</a>
				<a href="${"/helps"}" class="${"dropdown-link svelte-1hix2gs"}">Help</a>
				<button class="${"dropdown-link sign-out-button svelte-1hix2gs"}">Sign out</button></div></div></div></nav>

${slots.default ? slots.default({}) : ``}`;
});
var css$9 = {
  code: "p.svelte-1hqv1mt,h2.svelte-1hqv1mt,h3.svelte-1hqv1mt{margin:0}div.svelte-1hqv1mt{box-sizing:border-box}@import url('https://fonts.googleapis.com/css2?family=Libre+Baskerville:wght@400;700&display=swap');button.svelte-1hqv1mt,.svelte-1hqv1mt{font-family:'Libre Baskerville', serif}button.svelte-1hqv1mt{cursor:pointer;transform:scale(1)}button.svelte-1hqv1mt:hover{transition:transform 400ms;transform:scale(1.05)}.main.svelte-1hqv1mt{display:grid;grid-template-columns:225px calc(100vw - 225px);grid-template-rows:75px calc(100vh - 75px)}.flex.svelte-1hqv1mt{display:flex;justify-content:space-evenly}.dashboard-main.svelte-1hqv1mt{flex-direction:column;grid-column:2/3;grid-row:2/3;justify-content:space-between;padding:1em 3em 0 3em}.dashboard-main_nav.svelte-1hqv1mt{display:flex;flex-direction:row;width:100%;justify-content:space-between;align-items:center}.dashboard-main_body.svelte-1hqv1mt{flex-direction:row;height:110px;justify-content:space-between}.dashboard-main_nav-heading.svelte-1hqv1mt{font-size:26px;font-weight:normal}.dashboard-main_nav-button.svelte-1hqv1mt{border:1.5px solid #000;border-radius:5px;width:112px;height:41px;color:#000;background-color:inherit}div.main-body_card.svelte-1hqv1mt{justify-content:space-between;flex-direction:column;padding:5px 15px;border-radius:5px;border:1px solid #c4c4c4}.card-heading.svelte-1hqv1mt{text-align:left}.card-body.svelte-1hqv1mt{display:flex;justify-content:space-evenly}.card-body-right.svelte-1hqv1mt{font-size:33px}h2.smaller-text.svelte-1hqv1mt{font-size:22px}.card-footer.svelte-1hqv1mt{text-align:right}.card-1.svelte-1hqv1mt,.card-2.svelte-1hqv1mt{width:156px;height:100px}.card-3.svelte-1hqv1mt{width:501px;height:100px}.dashboard-main_graph.svelte-1hqv1mt{width:100%;height:250px;display:flex;justify-content:stretch;align-items:stretch}.myChart.svelte-1hqv1mt{width:100%}",
  map: `{"version":3,"file":"index.svelte","sources":["index.svelte"],"sourcesContent":["<script>\\r\\n\\timport Sidebar from '../../components/dashboard.sidebar.svelte';\\r\\n\\timport Navbar from '../../components/dashboard.navbar.svelte';\\r\\n\\timport Chart from 'chart.js/auto/auto.js';\\r\\n\\timport { onMount } from 'svelte';\\r\\n\\t\\r\\n\\r\\n\\tlet canvas;\\r\\n\\tonMount(() => {\\r\\n\\t\\tconst ctx = canvas.getContext('2d');\\r\\n\\r\\n\\t\\tconst myChart = new Chart(ctx, {\\r\\n\\t\\t\\ttype: 'line',\\r\\n\\t\\t\\tdata: {\\r\\n\\t\\t\\t\\tlabels: ['Red', 'Blue', 'Yellow', 'Green', 'Purple', 'Orange'],\\r\\n\\t\\t\\t\\tdatasets: [\\r\\n\\t\\t\\t\\t\\t{\\r\\n\\t\\t\\t\\t\\t\\tlabel: '# of Votes',\\r\\n\\t\\t\\t\\t\\t\\tdata: [12, 19, 3, 5, 2, 3],\\r\\n\\t\\t\\t\\t\\t\\tbackgroundColor: [\\r\\n\\t\\t\\t\\t\\t\\t\\t'rgba(255, 99, 132, 0.2)',\\r\\n\\t\\t\\t\\t\\t\\t\\t'rgba(54, 162, 235, 0.2)',\\r\\n\\t\\t\\t\\t\\t\\t\\t'rgba(255, 206, 86, 0.2)',\\r\\n\\t\\t\\t\\t\\t\\t\\t'rgba(75, 192, 192, 0.2)',\\r\\n\\t\\t\\t\\t\\t\\t\\t'rgba(153, 102, 255, 0.2)',\\r\\n\\t\\t\\t\\t\\t\\t\\t'rgba(255, 159, 64, 0.2)'\\r\\n\\t\\t\\t\\t\\t\\t],\\r\\n\\t\\t\\t\\t\\t\\tborderColor: [\\r\\n\\t\\t\\t\\t\\t\\t\\t'rgba(255, 99, 132, 1)',\\r\\n\\t\\t\\t\\t\\t\\t\\t'rgba(54, 162, 235, 1)',\\r\\n\\t\\t\\t\\t\\t\\t\\t'rgba(255, 206, 86, 1)',\\r\\n\\t\\t\\t\\t\\t\\t\\t'rgba(75, 192, 192, 1)',\\r\\n\\t\\t\\t\\t\\t\\t\\t'rgba(153, 102, 255, 1)',\\r\\n\\t\\t\\t\\t\\t\\t\\t'rgba(255, 159, 64, 1)'\\r\\n\\t\\t\\t\\t\\t\\t],\\r\\n\\t\\t\\t\\t\\t\\tborderWidth: 1\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t]\\r\\n\\t\\t\\t},\\r\\n\\t\\t\\toptions: {\\r\\n                plugins:{\\r\\n                    legend: {\\r\\n                        display: false\\r\\n                    }\\r\\n                },\\r\\n\\t\\t\\t\\tscales: {\\r\\n\\t\\t\\t\\t\\ty: {\\r\\n\\t\\t\\t\\t\\t\\tbeginAtZero: true\\r\\n\\t\\t\\t\\t\\t},\\r\\n                    \\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t});\\r\\n\\t});\\r\\n<\/script>\\r\\n\\r\\n<main class=\\"main\\">\\r\\n\\t<Sidebar class=\\"sidebar\\" active=\\"dashboard\\" />\\r\\n\\t<Navbar class=\\"navbar\\" />\\r\\n\\t<div class=\\"dashboard-main flex\\">\\r\\n\\t\\t<div class=\\"dashboard-main_nav\\">\\r\\n\\t\\t\\t<h3 class=\\"dashboard-main_nav-heading\\">Dashboard</h3>\\r\\n\\t\\t\\t<button class=\\"dashboard-main_nav-button\\">Customize</button>\\r\\n\\t\\t</div>\\r\\n\\t\\t<div class=\\"dashboard-main_body flex\\">\\r\\n\\t\\t\\t<div class=\\"main-body_card card-1 flex\\">\\r\\n\\t\\t\\t\\t<p class=\\"card-heading\\">Total Posts</p>\\r\\n\\t\\t\\t\\t<div class=\\"card-body flex\\">\\r\\n\\t\\t\\t\\t\\t<svg\\r\\n\\t\\t\\t\\t\\t\\twidth=\\"33\\"\\r\\n\\t\\t\\t\\t\\t\\theight=\\"33\\"\\r\\n\\t\\t\\t\\t\\t\\tviewBox=\\"0 0 33 33\\"\\r\\n\\t\\t\\t\\t\\t\\tfill=\\"none\\"\\r\\n\\t\\t\\t\\t\\t\\txmlns=\\"http://www.w3.org/2000/svg\\"\\r\\n\\t\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\t\\td=\\"M23.375 4.12493C23.7361 3.76379 24.1649 3.47732 24.6367 3.28188C25.1086 3.08643 25.6143 2.98584 26.125 2.98584C26.6357 2.98584 27.1414 3.08643 27.6133 3.28188C28.0851 3.47732 28.5139 3.76379 28.875 4.12493C29.2361 4.48606 29.5226 4.91479 29.718 5.38664C29.9135 5.85848 30.0141 6.3642 30.0141 6.87493C30.0141 7.38565 29.9135 7.89137 29.718 8.36322C29.5226 8.83506 29.2361 9.26379 28.875 9.62493L10.3125 28.1874L2.75 30.2499L4.8125 22.6874L23.375 4.12493Z\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke=\\"#1C1C1C\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke-width=\\"2\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke-linecap=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke-linejoin=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t</svg>\\r\\n\\t\\t\\t\\t\\t<h2 class=\\"card-body-right\\">214</h2>\\r\\n\\t\\t\\t\\t</div>\\r\\n\\t\\t\\t\\t<p class=\\"card-footer\\">This month</p>\\r\\n\\t\\t\\t</div>\\r\\n\\t\\t\\t<div class=\\"main-body_card card-2 flex\\">\\r\\n\\t\\t\\t\\t<p class=\\"card-heading\\">Total Views</p>\\r\\n\\t\\t\\t\\t<div class=\\"card-body flex\\">\\r\\n\\t\\t\\t\\t\\t<svg\\r\\n\\t\\t\\t\\t\\t\\twidth=\\"33\\"\\r\\n\\t\\t\\t\\t\\t\\theight=\\"33\\"\\r\\n\\t\\t\\t\\t\\t\\tviewBox=\\"0 0 33 33\\"\\r\\n\\t\\t\\t\\t\\t\\tfill=\\"none\\"\\r\\n\\t\\t\\t\\t\\t\\txmlns=\\"http://www.w3.org/2000/svg\\"\\r\\n\\t\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t\\t\\t<g clip-path=\\"url(#clip0_18:37)\\">\\r\\n\\t\\t\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\t\\t\\td=\\"M1.375 16.5C1.375 16.5 6.875 5.5 16.5 5.5C26.125 5.5 31.625 16.5 31.625 16.5C31.625 16.5 26.125 27.5 16.5 27.5C6.875 27.5 1.375 16.5 1.375 16.5Z\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke=\\"#1C1C1C\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-width=\\"3.33333\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-linecap=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-linejoin=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\t\\t\\td=\\"M16.5 20.625C18.7782 20.625 20.625 18.7782 20.625 16.5C20.625 14.2218 18.7782 12.375 16.5 12.375C14.2218 12.375 12.375 14.2218 12.375 16.5C12.375 18.7782 14.2218 20.625 16.5 20.625Z\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke=\\"#1C1C1C\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-width=\\"3.33333\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-linecap=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-linejoin=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t\\t</g>\\r\\n\\t\\t\\t\\t\\t\\t<defs>\\r\\n\\t\\t\\t\\t\\t\\t\\t<clipPath id=\\"clip0_18:37\\">\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t<rect width=\\"33\\" height=\\"33\\" fill=\\"white\\" />\\r\\n\\t\\t\\t\\t\\t\\t\\t</clipPath>\\r\\n\\t\\t\\t\\t\\t\\t</defs>\\r\\n\\t\\t\\t\\t\\t</svg>\\r\\n\\t\\t\\t\\t\\t<h2 class=\\"card-body-right\\">130K</h2>\\r\\n\\t\\t\\t\\t</div>\\r\\n\\t\\t\\t\\t<p class=\\"card-footer\\">This month</p>\\r\\n\\t\\t\\t</div>\\r\\n\\t\\t\\t<div class=\\"main-body_card card-3 flex\\">\\r\\n\\t\\t\\t\\t<p class=\\"card-heading\\">Total Views</p>\\r\\n\\t\\t\\t\\t<div class=\\"card-body flex\\">\\r\\n\\t\\t\\t\\t\\t<h2 class=\\"card-body-right smaller-text\\">\\r\\n\\t\\t\\t\\t\\t\\tThe Most Awesome Article Man Has Ever Written\\r\\n\\t\\t\\t\\t\\t</h2>\\r\\n\\t\\t\\t\\t</div>\\r\\n\\t\\t\\t\\t<p class=\\"card-footer\\">This month</p>\\r\\n\\t\\t\\t</div>\\r\\n\\t\\t</div>\\r\\n\\t\\t<div class=\\"dashboard-main_graph\\">\\r\\n\\t\\t\\t<canvas bind:this={canvas} class=\\"myChart\\" height=\\"250\\" />\\r\\n\\t\\t</div>\\r\\n\\t</div>\\r\\n</main>\\r\\n\\r\\n<style>\\r\\n\\tp,\\r\\n\\th1,\\r\\n\\th2,\\r\\n\\th3 {\\r\\n\\t\\tmargin: 0;\\r\\n\\t}\\r\\n\\r\\n    div{\\r\\n        box-sizing: border-box;\\r\\n    }\\r\\n\\r\\n\\t@import url('https://fonts.googleapis.com/css2?family=Libre+Baskerville:wght@400;700&display=swap');\\r\\n\\ta {\\r\\n\\t\\ttext-decoration: none;\\r\\n\\t}\\r\\n\\r\\n\\ta,\\r\\n\\tbutton,\\r\\n\\t* {\\r\\n\\t\\tfont-family: 'Libre Baskerville', serif;\\r\\n\\t}\\r\\n\\r\\n\\tbutton,\\r\\n\\ta {\\r\\n\\t\\tcursor: pointer;\\r\\n\\t\\ttransform: scale(1);\\r\\n\\t}\\r\\n\\r\\n\\ta:hover,\\r\\n\\tbutton:hover {\\r\\n\\t\\ttransition: transform 400ms;\\r\\n\\t\\ttransform: scale(1.05);\\r\\n\\t}\\r\\n\\r\\n\\t.main {\\r\\n\\t\\tdisplay: grid;\\r\\n\\t\\tgrid-template-columns: 225px calc(100vw - 225px);\\r\\n\\t\\tgrid-template-rows: 75px calc(100vh - 75px);\\r\\n\\t}\\r\\n\\r\\n\\t.flex {\\r\\n\\t\\tdisplay: flex;\\r\\n\\t\\tjustify-content: space-evenly;\\r\\n\\t}\\r\\n\\r\\n\\t.dashboard-main {\\r\\n\\t\\tflex-direction: column;\\r\\n\\t\\tgrid-column: 2/3;\\r\\n\\t\\tgrid-row: 2/3;\\r\\n\\t\\tjustify-content: space-between;\\r\\n\\t\\tpadding: 1em 3em 0 3em;\\r\\n\\t}\\r\\n\\r\\n\\t.dashboard-main_nav {\\r\\n\\t\\tdisplay: flex;\\r\\n\\t\\tflex-direction: row;\\r\\n\\t\\twidth: 100%;\\r\\n\\t\\tjustify-content: space-between;\\r\\n\\t\\talign-items: center;\\r\\n\\t}\\r\\n\\r\\n\\t.dashboard-main_body {\\r\\n\\t\\tflex-direction: row;\\r\\n\\t\\theight: 110px;\\r\\n\\t\\tjustify-content: space-between;\\r\\n\\t}\\r\\n\\r\\n\\t.dashboard-main_nav-heading {\\r\\n\\t\\tfont-size: 26px;\\r\\n\\t\\tfont-weight: normal;\\r\\n\\t}\\r\\n\\r\\n\\t.dashboard-main_nav-button {\\r\\n\\t\\tborder: 1.5px solid #000;\\r\\n\\t\\tborder-radius: 5px;\\r\\n\\t\\twidth: 112px;\\r\\n\\t\\theight: 41px;\\r\\n\\t\\tcolor: #000;\\r\\n\\t\\tbackground-color: inherit;\\r\\n\\t}\\r\\n\\r\\n\\tdiv.main-body_card {\\r\\n\\t\\tjustify-content: space-between;\\r\\n\\t\\tflex-direction: column;\\r\\n\\t\\tpadding: 5px 15px;\\r\\n\\t\\tborder-radius: 5px;\\r\\n\\t\\tborder: 1px solid #c4c4c4;\\r\\n\\t}\\r\\n\\r\\n\\t.card-heading {\\r\\n\\t\\ttext-align: left;\\r\\n\\t}\\r\\n\\r\\n\\t.card-body {\\r\\n\\t\\tdisplay: flex;\\r\\n\\t\\tjustify-content: space-evenly;\\r\\n\\t}\\r\\n\\r\\n\\t.card-body-right {\\r\\n\\t\\tfont-size: 33px;\\r\\n\\t}\\r\\n\\r\\n\\th2.smaller-text {\\r\\n\\t\\tfont-size: 22px;\\r\\n\\t}\\r\\n\\r\\n\\t.card-footer {\\r\\n\\t\\ttext-align: right;\\r\\n\\t}\\r\\n\\r\\n\\t.card-1,\\r\\n\\t.card-2 {\\r\\n\\t\\twidth: 156px;\\r\\n\\t\\theight: 100px;\\r\\n\\t}\\r\\n\\r\\n\\t.card-3 {\\r\\n\\t\\twidth: 501px;\\r\\n\\t\\theight: 100px;\\r\\n\\t}\\r\\n\\r\\n\\t.dashboard-main_graph {\\r\\n\\t\\twidth: 100%;\\r\\n\\t\\theight: 250px;\\r\\n\\t\\tdisplay: flex;\\r\\n\\t\\tjustify-content: stretch;\\r\\n\\t\\talign-items: stretch;\\r\\n\\t}\\r\\n\\r\\n\\t.myChart {\\r\\n\\t\\twidth: 100%;\\r\\n\\t}\\r\\n</style>\\r\\n"],"names":[],"mappings":"AA4IC,gBAAC,CAED,iBAAE,CACF,EAAE,eAAC,CAAC,AACH,MAAM,CAAE,CAAC,AACV,CAAC,AAEE,kBAAG,CAAC,AACA,UAAU,CAAE,UAAU,AAC1B,CAAC,AAEJ,QAAQ,IAAI,sFAAsF,CAAC,CAAC,AAMpG,qBAAM,CACN,eAAE,CAAC,AACF,WAAW,CAAE,mBAAmB,CAAC,CAAC,KAAK,AACxC,CAAC,AAED,MAAM,eACJ,CAAC,AACF,MAAM,CAAE,OAAO,CACf,SAAS,CAAE,MAAM,CAAC,CAAC,AACpB,CAAC,AAGD,qBAAM,MAAM,AAAC,CAAC,AACb,UAAU,CAAE,SAAS,CAAC,KAAK,CAC3B,SAAS,CAAE,MAAM,IAAI,CAAC,AACvB,CAAC,AAED,KAAK,eAAC,CAAC,AACN,OAAO,CAAE,IAAI,CACb,qBAAqB,CAAE,KAAK,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAChD,kBAAkB,CAAE,IAAI,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,AAC5C,CAAC,AAED,KAAK,eAAC,CAAC,AACN,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,YAAY,AAC9B,CAAC,AAED,eAAe,eAAC,CAAC,AAChB,cAAc,CAAE,MAAM,CACtB,WAAW,CAAE,CAAC,CAAC,CAAC,CAChB,QAAQ,CAAE,CAAC,CAAC,CAAC,CACb,eAAe,CAAE,aAAa,CAC9B,OAAO,CAAE,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,GAAG,AACvB,CAAC,AAED,mBAAmB,eAAC,CAAC,AACpB,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,GAAG,CACnB,KAAK,CAAE,IAAI,CACX,eAAe,CAAE,aAAa,CAC9B,WAAW,CAAE,MAAM,AACpB,CAAC,AAED,oBAAoB,eAAC,CAAC,AACrB,cAAc,CAAE,GAAG,CACnB,MAAM,CAAE,KAAK,CACb,eAAe,CAAE,aAAa,AAC/B,CAAC,AAED,2BAA2B,eAAC,CAAC,AAC5B,SAAS,CAAE,IAAI,CACf,WAAW,CAAE,MAAM,AACpB,CAAC,AAED,0BAA0B,eAAC,CAAC,AAC3B,MAAM,CAAE,KAAK,CAAC,KAAK,CAAC,IAAI,CACxB,aAAa,CAAE,GAAG,CAClB,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,IAAI,CACX,gBAAgB,CAAE,OAAO,AAC1B,CAAC,AAED,GAAG,eAAe,eAAC,CAAC,AACnB,eAAe,CAAE,aAAa,CAC9B,cAAc,CAAE,MAAM,CACtB,OAAO,CAAE,GAAG,CAAC,IAAI,CACjB,aAAa,CAAE,GAAG,CAClB,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,OAAO,AAC1B,CAAC,AAED,aAAa,eAAC,CAAC,AACd,UAAU,CAAE,IAAI,AACjB,CAAC,AAED,UAAU,eAAC,CAAC,AACX,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,YAAY,AAC9B,CAAC,AAED,gBAAgB,eAAC,CAAC,AACjB,SAAS,CAAE,IAAI,AAChB,CAAC,AAED,EAAE,aAAa,eAAC,CAAC,AAChB,SAAS,CAAE,IAAI,AAChB,CAAC,AAED,YAAY,eAAC,CAAC,AACb,UAAU,CAAE,KAAK,AAClB,CAAC,AAED,sBAAO,CACP,OAAO,eAAC,CAAC,AACR,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,AACd,CAAC,AAED,OAAO,eAAC,CAAC,AACR,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,AACd,CAAC,AAED,qBAAqB,eAAC,CAAC,AACtB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,KAAK,CACb,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,OAAO,CACxB,WAAW,CAAE,OAAO,AACrB,CAAC,AAED,QAAQ,eAAC,CAAC,AACT,KAAK,CAAE,IAAI,AACZ,CAAC"}`
};
var Dashboard = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let canvas;
  $$result.css.add(css$9);
  return `<main class="${"main svelte-1hqv1mt"}">${validate_component(Dashboard_sidebar, "Sidebar").$$render($$result, { class: "sidebar", active: "dashboard" }, {}, {})}
	${validate_component(Dashboard_navbar, "Navbar").$$render($$result, { class: "navbar" }, {}, {})}
	<div class="${"dashboard-main flex svelte-1hqv1mt"}"><div class="${"dashboard-main_nav svelte-1hqv1mt"}"><h3 class="${"dashboard-main_nav-heading svelte-1hqv1mt"}">Dashboard</h3>
			<button class="${"dashboard-main_nav-button svelte-1hqv1mt"}">Customize</button></div>
		<div class="${"dashboard-main_body flex svelte-1hqv1mt"}"><div class="${"main-body_card card-1 flex svelte-1hqv1mt"}"><p class="${"card-heading svelte-1hqv1mt"}">Total Posts</p>
				<div class="${"card-body flex svelte-1hqv1mt"}"><svg width="${"33"}" height="${"33"}" viewBox="${"0 0 33 33"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}" class="${"svelte-1hqv1mt"}"><path d="${"M23.375 4.12493C23.7361 3.76379 24.1649 3.47732 24.6367 3.28188C25.1086 3.08643 25.6143 2.98584 26.125 2.98584C26.6357 2.98584 27.1414 3.08643 27.6133 3.28188C28.0851 3.47732 28.5139 3.76379 28.875 4.12493C29.2361 4.48606 29.5226 4.91479 29.718 5.38664C29.9135 5.85848 30.0141 6.3642 30.0141 6.87493C30.0141 7.38565 29.9135 7.89137 29.718 8.36322C29.5226 8.83506 29.2361 9.26379 28.875 9.62493L10.3125 28.1874L2.75 30.2499L4.8125 22.6874L23.375 4.12493Z"}" stroke="${"#1C1C1C"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-1hqv1mt"}"></path></svg>
					<h2 class="${"card-body-right svelte-1hqv1mt"}">214</h2></div>
				<p class="${"card-footer svelte-1hqv1mt"}">This month</p></div>
			<div class="${"main-body_card card-2 flex svelte-1hqv1mt"}"><p class="${"card-heading svelte-1hqv1mt"}">Total Views</p>
				<div class="${"card-body flex svelte-1hqv1mt"}"><svg width="${"33"}" height="${"33"}" viewBox="${"0 0 33 33"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}" class="${"svelte-1hqv1mt"}"><g clip-path="${"url(#clip0_18:37)"}" class="${"svelte-1hqv1mt"}"><path d="${"M1.375 16.5C1.375 16.5 6.875 5.5 16.5 5.5C26.125 5.5 31.625 16.5 31.625 16.5C31.625 16.5 26.125 27.5 16.5 27.5C6.875 27.5 1.375 16.5 1.375 16.5Z"}" stroke="${"#1C1C1C"}" stroke-width="${"3.33333"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-1hqv1mt"}"></path><path d="${"M16.5 20.625C18.7782 20.625 20.625 18.7782 20.625 16.5C20.625 14.2218 18.7782 12.375 16.5 12.375C14.2218 12.375 12.375 14.2218 12.375 16.5C12.375 18.7782 14.2218 20.625 16.5 20.625Z"}" stroke="${"#1C1C1C"}" stroke-width="${"3.33333"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-1hqv1mt"}"></path></g><defs class="${"svelte-1hqv1mt"}"><clipPath id="${"clip0_18:37"}" class="${"svelte-1hqv1mt"}"><rect width="${"33"}" height="${"33"}" fill="${"white"}" class="${"svelte-1hqv1mt"}"></rect></clipPath></defs></svg>
					<h2 class="${"card-body-right svelte-1hqv1mt"}">130K</h2></div>
				<p class="${"card-footer svelte-1hqv1mt"}">This month</p></div>
			<div class="${"main-body_card card-3 flex svelte-1hqv1mt"}"><p class="${"card-heading svelte-1hqv1mt"}">Total Views</p>
				<div class="${"card-body flex svelte-1hqv1mt"}"><h2 class="${"card-body-right smaller-text svelte-1hqv1mt"}">The Most Awesome Article Man Has Ever Written
					</h2></div>
				<p class="${"card-footer svelte-1hqv1mt"}">This month</p></div></div>
		<div class="${"dashboard-main_graph svelte-1hqv1mt"}"><canvas class="${"myChart svelte-1hqv1mt"}" height="${"250"}"${add_attribute("this", canvas, 0)}></canvas></div></div>
</main>`;
});
var index = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Dashboard
});
var css$8 = {
  code: "@import url('https://fonts.googleapis.com/css2?family=Libre+Baskerville:wght@400;700&display=swap');.svelte-13bh7tz.svelte-13bh7tz.svelte-13bh7tz{font-family:'Libre Baskerville', serif}button.svelte-13bh7tz.svelte-13bh7tz.svelte-13bh7tz{cursor:pointer;transform:scale(1)}button.svelte-13bh7tz.svelte-13bh7tz.svelte-13bh7tz:hover{transition:transform 400ms;transform:scale(1.05)}div.svelte-13bh7tz.svelte-13bh7tz.svelte-13bh7tz{box-sizing:border-box}.main.svelte-13bh7tz.svelte-13bh7tz.svelte-13bh7tz{display:grid;grid-template-columns:225px calc(100vw - 225px);grid-template-rows:75px calc(100vh - 75px);overflow:hidden;height:100vh}.no-post-title.svelte-13bh7tz.svelte-13bh7tz.svelte-13bh7tz{margin-top:3em}.all-posts-container.svelte-13bh7tz.svelte-13bh7tz.svelte-13bh7tz{grid-column:2/3;grid-row:2/3;height:100%;overflow-Y:scroll;padding:0 2em}.container-heading.svelte-13bh7tz.svelte-13bh7tz.svelte-13bh7tz{padding-left:1em}.post-card-container.svelte-13bh7tz.svelte-13bh7tz.svelte-13bh7tz{display:flex;flex-direction:column;width:100%;align-items:center;padding:1em 2em}.post-card.svelte-13bh7tz.svelte-13bh7tz.svelte-13bh7tz{width:100%;height:150px;display:flex;margin-bottom:30px;justify-content:space-between;align-items:center;background-color:rgba(255, 225, 225, 0.5);padding:1em 0.5em;border-radius:5px}.card-img-container.svelte-13bh7tz.svelte-13bh7tz.svelte-13bh7tz{height:120px}.card-img.svelte-13bh7tz.svelte-13bh7tz.svelte-13bh7tz{height:100%;width:200px;border-radius:5px;object-fit:cover}.card-btn.svelte-13bh7tz.svelte-13bh7tz.svelte-13bh7tz{background-color:transparent;outline:0;border:0}.delete-dialog-box-container.svelte-13bh7tz.svelte-13bh7tz.svelte-13bh7tz{height:100vh;width:100%;position:fixed;top:0;left:0;display:flex;justify-content:center;align-items:center;background-color:rgba(28, 28, 28, 0.5)}.delete-dialog-box.svelte-13bh7tz.svelte-13bh7tz.svelte-13bh7tz{width:70%;max-width:500px;min-width:300px;border-radius:5px;background-color:#fff;height:150px;display:flex;flex-direction:column;align-items:center;padding:1.5em;justify-content:space-between}.deleted-dialog-box.svelte-13bh7tz.svelte-13bh7tz.svelte-13bh7tz{width:70%;max-width:500px;min-width:300px;border-radius:5px;background-color:#fff;height:100px;display:flex;flex-direction:column;align-items:center;padding:1.5em;justify-content:center}.delete-dialog-box_text.svelte-13bh7tz.svelte-13bh7tz.svelte-13bh7tz{margin:0}.delete-dialog-box_button-container.svelte-13bh7tz.svelte-13bh7tz.svelte-13bh7tz{width:100%;display:flex;justify-content:space-evenly}.delete-dialog-box_btn.svelte-13bh7tz.svelte-13bh7tz.svelte-13bh7tz{padding:15px 30px;border-radius:5px;outline:0;border:0}.delete-btn.svelte-13bh7tz.svelte-13bh7tz.svelte-13bh7tz{color:red}.preloader.svelte-13bh7tz.svelte-13bh7tz.svelte-13bh7tz{height:100vh;width:100%;background-color:rgba(28, 28, 28, 0.8);position:fixed;top:0;left:0;display:flex;align-items:center;justify-content:center}@keyframes svelte-13bh7tz-ldio-mvluw7e021b-1{0%{transform:rotate(0deg)}50%{transform:rotate(-45deg)}100%{transform:rotate(0deg)}}@keyframes svelte-13bh7tz-ldio-mvluw7e021b-2{0%{transform:rotate(180deg)}50%{transform:rotate(225deg)}100%{transform:rotate(180deg)}}.ldio-mvluw7e021b.svelte-13bh7tz>div.svelte-13bh7tz.svelte-13bh7tz:nth-child(2){transform:translate(-15px, 0)}.ldio-mvluw7e021b.svelte-13bh7tz>div.svelte-13bh7tz:nth-child(2) div.svelte-13bh7tz{position:absolute;top:40px;left:40px;width:120px;height:60px;border-radius:120px 120px 0 0;background:#f8b26a;animation:svelte-13bh7tz-ldio-mvluw7e021b-1 1s linear infinite;transform-origin:60px 60px}.ldio-mvluw7e021b.svelte-13bh7tz>div.svelte-13bh7tz:nth-child(2) div.svelte-13bh7tz:nth-child(2){animation:svelte-13bh7tz-ldio-mvluw7e021b-2 1s linear infinite}.ldio-mvluw7e021b.svelte-13bh7tz>div.svelte-13bh7tz:nth-child(2) div.svelte-13bh7tz:nth-child(3){transform:rotate(-90deg);animation:none}@keyframes svelte-13bh7tz-ldio-mvluw7e021b-3{0%{transform:translate(190px, 0);opacity:0}20%{opacity:1}100%{transform:translate(70px, 0);opacity:1}}.ldio-mvluw7e021b.svelte-13bh7tz>div.svelte-13bh7tz.svelte-13bh7tz:nth-child(1){display:block}.ldio-mvluw7e021b.svelte-13bh7tz>div.svelte-13bh7tz:nth-child(1) div.svelte-13bh7tz{position:absolute;top:92px;left:-8px;width:16px;height:16px;border-radius:50%;background:#e15b64;animation:svelte-13bh7tz-ldio-mvluw7e021b-3 1s linear infinite}.ldio-mvluw7e021b.svelte-13bh7tz>div.svelte-13bh7tz:nth-child(1) div.svelte-13bh7tz:nth-child(1){animation-delay:-0.67s}.ldio-mvluw7e021b.svelte-13bh7tz>div.svelte-13bh7tz:nth-child(1) div.svelte-13bh7tz:nth-child(2){animation-delay:-0.33s}.ldio-mvluw7e021b.svelte-13bh7tz>div.svelte-13bh7tz:nth-child(1) div.svelte-13bh7tz:nth-child(3){animation-delay:0s}.loadingio-spinner-bean-eater-3cordrlrc9.svelte-13bh7tz.svelte-13bh7tz.svelte-13bh7tz{width:200px;height:200px;display:inline-block;overflow:hidden;background:transparent}.ldio-mvluw7e021b.svelte-13bh7tz.svelte-13bh7tz.svelte-13bh7tz{width:100%;height:100%;position:relative;transform:translateZ(0) scale(1);backface-visibility:hidden;transform-origin:0 0}.ldio-mvluw7e021b.svelte-13bh7tz div.svelte-13bh7tz.svelte-13bh7tz{box-sizing:content-box}",
  map: `{"version":3,"file":"all-posts.svelte","sources":["all-posts.svelte"],"sourcesContent":["<script context=\\"module\\">\\r\\n\\timport { getPosts, getImageUrl, deletePost, makeFeatured } from '../../utils/firebase.apis';\\r\\n\\r\\n\\texport async function load({ fetch, page, session, stuff }){\\r\\n\\t\\tlet allPosts;\\r\\n\\t\\ttry{\\r\\n\\t\\t\\tallPosts = await getPosts();\\r\\n\\t\\t} catch(err){\\r\\n\\t\\t\\tallPosts = err;\\r\\n\\t\\t}\\r\\n\\t\\treturn {\\r\\n\\t\\t\\tprops: {\\r\\n\\t\\t\\t\\tallPosts\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n<\/script>\\r\\n\\r\\n<script>\\r\\n\\timport Sidebar from '../../components/dashboard.sidebar.svelte';\\r\\n\\timport Navbar from '../../components/dashboard.navbar.svelte';\\r\\n\\timport { onMount } from 'svelte';\\r\\n\\r\\n\\texport let allPosts;\\r\\n\\tconst images = [];\\r\\n\\tlet deleteDialogBox = false;\\r\\n\\tlet deletedDialogBox = false;\\r\\n\\tlet postTBD = '';\\r\\n\\tlet isLoaderActive = false;\\r\\n\\r\\n\\tfunction handleDeletePost(postName) {\\r\\n\\t\\tisLoaderActive = true;\\r\\n\\t\\tdeletePost(postName).then((res) => {\\r\\n\\t\\t\\tif (res) {\\r\\n\\t\\t\\t\\tdeletedDialogBox = true;\\r\\n\\t\\t\\t\\tdeleteDialogBox = false;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tisLoaderActive = false;\\r\\n\\t\\t});\\r\\n\\t}\\r\\n\\r\\n\\tfunction featured(postId, currentStatus, i){\\r\\n\\t\\tisLoaderActive = true;\\r\\n\\t\\tmakeFeatured(postId, currentStatus).then((res) => {\\r\\n\\t\\t\\tisLoaderActive = false;\\r\\n\\t\\t\\tif(res){\\r\\n\\t\\t\\t\\tallPosts[i].data.featured = !currentStatus;\\r\\n\\t\\t\\t}\\r\\n\\t\\t})\\r\\n\\t}\\r\\n\\r\\n\\tfunction handleEdit(postId){\\r\\n\\t\\twindow.location.assign(\`/dashboard/writepost/\${postId}\`);\\r\\n\\t}\\r\\n\\r\\n\\t// onMount(async () => {\\r\\n\\t// \\tisLoaderActive = true;\\r\\n\\t// \\ttry{\\r\\n\\t// \\t\\tallPosts = await getPosts();\\r\\n\\t// \\t\\tisLoaderActive = false;\\r\\n\\t// \\t}catch(err){\\r\\n\\t// \\t\\tconsole.log(err);\\r\\n\\t// \\t}\\r\\n\\t// \\tconsole.log(allPosts);\\r\\n\\t// });\\r\\n\\tconsole.log(images, 'images');\\r\\n<\/script>\\r\\n\\r\\n<main class=\\"main\\">\\r\\n\\t<Sidebar  active=\\"all-posts\\" />\\r\\n\\t<Navbar />\\r\\n\\t<div class=\\"all-posts-container\\">\\r\\n\\t\\t<h1 class=\\"container-heading\\">All posts</h1>\\r\\n\\r\\n\\t\\t<div class=\\"post-card-container\\">\\r\\n\\t\\t\\t{#if allPosts.length > 0 && images}\\r\\n\\t\\t\\t\\t{#each allPosts as post, index}\\r\\n\\t\\t\\t\\t\\t<div  class=\\"post-card\\">\\r\\n\\t\\t\\t\\t\\t\\t{#await getImageUrl(post.data.imgSrc)}\\r\\n\\t\\t\\t\\t\\t\\t\\t<p>...loading</p>\\r\\n\\t\\t\\t\\t\\t\\t{:then url}\\r\\n\\t\\t\\t\\t\\t\\t\\t<div class=\\"card-img-container\\">\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t<img class=\\"card-img\\" src={url} alt={post.title} />\\r\\n\\t\\t\\t\\t\\t\\t\\t</div>\\r\\n\\t\\t\\t\\t\\t\\t{/await}\\r\\n\\t\\t\\t\\t\\t\\t<h3 class=\\"card-title\\">{post.data.title}</h3>\\r\\n\\t\\t\\t\\t\\t\\t<div class=\\"card-button-container\\">\\r\\n\\t\\t\\t\\t\\t\\t\\t<button on:click={() => handleEdit(post.id)} class=\\"card-btn\\">\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t<svg\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\twidth=\\"29\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\theight=\\"29\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tviewBox=\\"0 0 25 25\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tfill=\\"none\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\txmlns=\\"http://www.w3.org/2000/svg\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\td=\\"M19.7 8.60004L8.9 19.4C8.8 19.5 8.80002 19.5 8.70002 19.5L6.20002 20.3L4.60001 20.8C4.20001 20.9 3.8 20.5 3.9 20.1L5.20002 16.1C5.20002 16 5.3 15.9 5.3 15.9L16.1 5.10004C17.1 4.10004 18.6 4.10004 19.6 5.10004C20.7 6.10004 20.7 7.60004 19.7 8.60004Z\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tstroke=\\"#1A1A1A\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tstroke-width=\\"1.5\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tstroke-miterlimit=\\"10\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tstroke-linecap=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tstroke-linejoin=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfill=\\"yellow\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\td=\\"M14.6 6.90002L18 10.3\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tstroke=\\"#1A1A1A\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tstroke-width=\\"1.5\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tstroke-miterlimit=\\"10\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tstroke-linecap=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfill=\\"yellow\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tstroke-linejoin=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t</svg>\\r\\n\\t\\t\\t\\t\\t\\t\\t</button>\\r\\n\\t\\t\\t\\t\\t\\t\\t<button on:click={() => featured(post.id, post.data.featured, index)} class=\\"card-btn\\">\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t<svg\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\twidth=\\"29\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\theight=\\"29\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tviewBox=\\"0 0 24 24\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tfill=\\"none\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\txmlns=\\"http://www.w3.org/2000/svg\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfill-rule=\\"evenodd\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tclip-rule=\\"evenodd\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tstroke-width=\\"1\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tstroke=\\"#000\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\td=\\"M15.8498 2.50071C16.4808 2.50071 17.1108 2.58971 17.7098 2.79071C21.4008 3.99071 22.7308 8.04071 21.6198 11.5807C20.9898 13.3897 19.9598 15.0407 18.6108 16.3897C16.6798 18.2597 14.5608 19.9197 12.2798 21.3497L12.0298 21.5007L11.7698 21.3397C9.4808 19.9197 7.3498 18.2597 5.4008 16.3797C4.0608 15.0307 3.0298 13.3897 2.3898 11.5807C1.2598 8.04071 2.5898 3.99071 6.3208 2.76971C6.6108 2.66971 6.9098 2.59971 7.2098 2.56071H7.3298C7.6108 2.51971 7.8898 2.50071 8.1698 2.50071H8.2798C8.9098 2.51971 9.5198 2.62971 10.1108 2.83071H10.1698C10.2098 2.84971 10.2398 2.87071 10.2598 2.88971C10.4808 2.96071 10.6898 3.04071 10.8898 3.15071L11.2698 3.32071C11.3616 3.36968 11.4647 3.44451 11.5538 3.50918C11.6102 3.55015 11.661 3.58705 11.6998 3.61071C11.7161 3.62034 11.7327 3.63002 11.7494 3.63978C11.8352 3.68983 11.9245 3.74197 11.9998 3.79971C13.1108 2.95071 14.4598 2.49071 15.8498 2.50071ZM18.5098 9.70071C18.9198 9.68971 19.2698 9.36071 19.2998 8.93971V8.82071C19.3298 7.41971 18.4808 6.15071 17.1898 5.66071C16.7798 5.51971 16.3298 5.74071 16.1798 6.16071C16.0398 6.58071 16.2598 7.04071 16.6798 7.18971C17.3208 7.42971 17.7498 8.06071 17.7498 8.75971V8.79071C17.7308 9.01971 17.7998 9.24071 17.9398 9.41071C18.0798 9.58071 18.2898 9.67971 18.5098 9.70071Z\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfill={post.data.featured ? 'red' : '#fff'}\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t</svg>\\r\\n\\t\\t\\t\\t\\t\\t\\t</button>\\r\\n\\t\\t\\t\\t\\t\\t\\t<button\\r\\n\\t\\t\\t\\t\\t\\t\\t\\ton:click={() => {\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tdeleteDialogBox = true;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tpostTBD = post.id;\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t}}\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tclass=\\"card-btn\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t<svg\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\twidth=\\"29\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\theight=\\"30\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tviewBox=\\"0 0 24 25\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tfill=\\"none\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\txmlns=\\"http://www.w3.org/2000/svg\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\td=\\"M18.9999 6.30002H15.6L15.1 5.49997C14.4 4.39997 13.2999 3.80002 11.9999 3.80002C10.6999 3.80002 9.59996 4.39997 8.89996 5.49997L8.39996 6.30002H4.99994C4.59994 6.30002 4.19995 6.60001 4.19995 7.10001C4.19995 7.60001 4.49994 7.89999 4.99994 7.89999H6.29999V18.1C6.29999 19.8 7.59999 21.1 9.29999 21.1H14.7C16.4 21.1 17.7 19.8 17.7 18.1V7.89999H18.9999C19.3999 7.89999 19.8 7.60001 19.8 7.10001C19.8 6.60001 19.3999 6.30002 18.9999 6.30002ZM10.2 6.30002C10.6 5.70002 11.2999 5.30002 11.9999 5.30002C12.6999 5.30002 13.4 5.70002 13.8 6.30002H10.2ZM10.8 17.2C10.8 17.6 10.4999 18 9.99994 18C9.59994 18 9.19995 17.7 9.19995 17.2V10.8C9.19995 10.4 9.49994 9.99997 9.99994 9.99997C10.3999 9.99997 10.8 10.3 10.8 10.8V17.2ZM14.7 17.2C14.7 17.6 14.4 18 13.9 18C13.5 18 13.1 17.7 13.1 17.2V10.8C13.1 10.4 13.4 9.99997 13.9 9.99997C14.3 9.99997 14.7 10.3 14.7 10.8V17.2Z\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfill=\\"orange\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t</svg>\\r\\n\\t\\t\\t\\t\\t\\t\\t</button>\\r\\n\\t\\t\\t\\t\\t\\t</div>\\r\\n\\t\\t\\t\\t\\t</div>\\r\\n\\t\\t\\t\\t{/each}\\r\\n\\r\\n\\t\\t\\t{:else}\\r\\n\\t\\t\\t\\t\\t<h3 class=\\"no-post-title\\" >You do not have any blog post <a href=\\"/dashboard/write-a-post\\" >click here to create one.</a></h3>\\r\\n\\t\\t\\t{/if}\\r\\n\\t\\t</div>\\r\\n\\t</div>\\r\\n\\t{#if deleteDialogBox}\\r\\n\\t\\t<div class=\\"delete-dialog-box-container\\">\\r\\n\\t\\t\\t<div class=\\"delete-dialog-box\\">\\r\\n\\t\\t\\t\\t<p class=\\"delete-dialog-box_text\\">delete the selected post?</p>\\r\\n\\t\\t\\t\\t<div class=\\"delete-dialog-box_button-container\\">\\r\\n\\t\\t\\t\\t\\t<button\\r\\n\\t\\t\\t\\t\\t\\ton:click={() => {\\r\\n\\t\\t\\t\\t\\t\\t\\tdeleteDialogBox = false;\\r\\n\\t\\t\\t\\t\\t\\t\\tpostTBD = '';\\r\\n\\t\\t\\t\\t\\t\\t}}\\r\\n\\t\\t\\t\\t\\t\\tclass=\\"delete-dialog-box_btn cancel-btn\\">Cancel</button\\r\\n\\t\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t\\t<button\\r\\n\\t\\t\\t\\t\\t\\ton:click={() => handleDeletePost(postTBD)}\\r\\n\\t\\t\\t\\t\\t\\tclass=\\"delete-dialog-box_btn delete-btn\\">Delete</button\\r\\n\\t\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t</div>\\r\\n\\t\\t\\t</div>\\r\\n\\t\\t</div>\\r\\n\\t{/if}\\r\\n\\t{#if deletedDialogBox}\\r\\n\\t\\t<div on:click={() => (deletedDialogBox = false)} class=\\"delete-dialog-box-container\\">\\r\\n\\t\\t\\t<div on:click={(e) => e.stopPropagation()} class=\\"deleted-dialog-box\\">\\r\\n\\t\\t\\t\\t<p class=\\"delete-dialog-box_text\\">Blog post successfully deleted!</p>\\r\\n\\t\\t\\t</div>\\r\\n\\t\\t</div>\\r\\n\\t{/if}\\r\\n\\t{#if isLoaderActive}\\r\\n\\t\\t<div class=\\"preloader\\">\\r\\n\\t\\t\\t<div class=\\"loadingio-spinner-bean-eater-3cordrlrc9\\">\\r\\n\\t\\t\\t\\t<div class=\\"ldio-mvluw7e021b\\">\\r\\n\\t\\t\\t\\t\\t<div>\\r\\n\\t\\t\\t\\t\\t\\t<div />\\r\\n\\t\\t\\t\\t\\t\\t<div />\\r\\n\\t\\t\\t\\t\\t\\t<div />\\r\\n\\t\\t\\t\\t\\t</div>\\r\\n\\t\\t\\t\\t\\t<div>\\r\\n\\t\\t\\t\\t\\t\\t<div />\\r\\n\\t\\t\\t\\t\\t\\t<div />\\r\\n\\t\\t\\t\\t\\t\\t<div />\\r\\n\\t\\t\\t\\t\\t</div>\\r\\n\\t\\t\\t\\t</div>\\r\\n\\t\\t\\t</div>\\r\\n\\t\\t</div>\\r\\n\\t{/if}\\r\\n</main>\\r\\n\\r\\n<style>\\r\\n\\t@import url('https://fonts.googleapis.com/css2?family=Libre+Baskerville:wght@400;700&display=swap');\\r\\n\\r\\n\\t* {\\r\\n\\t\\tfont-family: 'Libre Baskerville', serif;\\r\\n\\t}\\r\\n\\r\\n\\tbutton {\\r\\n\\t\\tcursor: pointer;\\r\\n\\t\\ttransform: scale(1);\\r\\n\\t}\\r\\n\\r\\n\\tbutton:hover {\\r\\n\\t\\ttransition: transform 400ms;\\r\\n\\t\\ttransform: scale(1.05);\\r\\n\\t}\\r\\n\\r\\n\\tdiv {\\r\\n\\t\\tbox-sizing: border-box;\\r\\n\\t}\\r\\n\\r\\n\\t.main {\\r\\n\\t\\tdisplay: grid;\\r\\n\\t\\tgrid-template-columns: 225px calc(100vw - 225px);\\r\\n\\t\\tgrid-template-rows: 75px calc(100vh - 75px);\\r\\n\\t\\toverflow:hidden;\\r\\n\\t\\theight: 100vh;\\r\\n\\t}\\r\\n\\r\\n\\t\\r\\n\\r\\n\\t.no-post-title{\\r\\n\\t\\tmargin-top: 3em;\\r\\n\\t}\\r\\n\\r\\n\\t.all-posts-container {\\r\\n\\t\\tgrid-column: 2/3;\\r\\n\\t\\tgrid-row: 2/3;\\r\\n\\t\\theight: 100%;\\r\\n\\t\\toverflow-Y: scroll;\\r\\n\\t\\tpadding: 0 2em;\\r\\n\\t}\\r\\n\\r\\n\\t.container-heading {\\r\\n\\t\\tpadding-left: 1em;\\r\\n\\t}\\r\\n\\r\\n\\t.post-card-container {\\r\\n\\t\\tdisplay: flex;\\r\\n\\t\\tflex-direction: column;\\r\\n\\t\\twidth: 100%;\\r\\n\\t\\talign-items: center;\\r\\n\\t\\tpadding: 1em 2em;\\r\\n\\t}\\r\\n\\r\\n\\t.post-card {\\r\\n\\t\\twidth: 100%;\\r\\n\\t\\theight: 150px;\\r\\n\\t\\tdisplay: flex;\\r\\n\\t\\tmargin-bottom: 30px;\\r\\n\\t\\tjustify-content: space-between;\\r\\n\\t\\talign-items: center;\\r\\n\\t\\tbackground-color: rgba(255, 225, 225, 0.5);\\r\\n\\t\\tpadding: 1em 0.5em;\\r\\n\\t\\tborder-radius: 5px;\\r\\n\\t}\\r\\n\\r\\n\\t.card-img-container {\\r\\n\\t\\theight: 120px;\\r\\n\\t}\\r\\n\\r\\n\\t.card-img {\\r\\n\\t\\theight: 100%;\\r\\n\\t\\twidth: 200px;\\r\\n\\t\\tborder-radius: 5px;\\r\\n\\t\\tobject-fit: cover;\\r\\n\\t}\\r\\n\\r\\n\\t.card-btn {\\r\\n\\t\\tbackground-color: transparent;\\r\\n\\t\\toutline: 0;\\r\\n\\t\\tborder: 0;\\r\\n\\t}\\r\\n\\r\\n\\t.delete-dialog-box-container {\\r\\n\\t\\theight: 100vh;\\r\\n\\t\\twidth: 100%;\\r\\n\\t\\tposition: fixed;\\r\\n\\t\\ttop: 0;\\r\\n\\t\\tleft: 0;\\r\\n\\t\\tdisplay: flex;\\r\\n\\t\\tjustify-content: center;\\r\\n\\t\\talign-items: center;\\r\\n\\t\\tbackground-color: rgba(28, 28, 28, 0.5);\\r\\n\\t}\\r\\n\\r\\n\\t.delete-dialog-box {\\r\\n\\t\\twidth: 70%;\\r\\n\\t\\tmax-width: 500px;\\r\\n\\t\\tmin-width: 300px;\\r\\n\\t\\tborder-radius: 5px;\\r\\n\\t\\tbackground-color: #fff;\\r\\n\\t\\theight: 150px;\\r\\n\\t\\tdisplay: flex;\\r\\n\\t\\tflex-direction: column;\\r\\n\\t\\talign-items: center;\\r\\n\\t\\tpadding: 1.5em;\\r\\n\\t\\tjustify-content: space-between;\\r\\n\\t}\\r\\n\\r\\n\\t.deleted-dialog-box {\\r\\n\\t\\twidth: 70%;\\r\\n\\t\\tmax-width: 500px;\\r\\n\\t\\tmin-width: 300px;\\r\\n\\t\\tborder-radius: 5px;\\r\\n\\t\\tbackground-color: #fff;\\r\\n\\t\\theight: 100px;\\r\\n\\t\\tdisplay: flex;\\r\\n\\t\\tflex-direction: column;\\r\\n\\t\\talign-items: center;\\r\\n\\t\\tpadding: 1.5em;\\r\\n\\t\\tjustify-content: center;\\r\\n\\t}\\r\\n\\r\\n\\t.delete-dialog-box_text {\\r\\n\\t\\tmargin: 0;\\r\\n\\t}\\r\\n\\r\\n\\t.delete-dialog-box_button-container {\\r\\n\\t\\twidth: 100%;\\r\\n\\t\\tdisplay: flex;\\r\\n\\t\\tjustify-content: space-evenly;\\r\\n\\t}\\r\\n\\r\\n\\t.delete-dialog-box_btn {\\r\\n\\t\\tpadding: 15px 30px;\\r\\n\\t\\tborder-radius: 5px;\\r\\n\\t\\toutline: 0;\\r\\n\\t\\tborder: 0;\\r\\n\\t}\\r\\n\\r\\n\\t.delete-btn {\\r\\n\\t\\tcolor: red;\\r\\n\\t}\\r\\n\\r\\n\\t.preloader {\\r\\n\\t\\theight: 100vh;\\r\\n\\t\\twidth: 100%;\\r\\n\\t\\tbackground-color: rgba(28, 28, 28, 0.8);\\r\\n\\t\\tposition: fixed;\\r\\n\\t\\ttop: 0;\\r\\n\\t\\tleft: 0;\\r\\n\\t\\tdisplay: flex;\\r\\n\\t\\talign-items: center;\\r\\n\\t\\tjustify-content: center;\\r\\n\\t}\\r\\n\\r\\n\\t@keyframes ldio-mvluw7e021b-1 {\\r\\n\\t\\t0% {\\r\\n\\t\\t\\ttransform: rotate(0deg);\\r\\n\\t\\t}\\r\\n\\t\\t50% {\\r\\n\\t\\t\\ttransform: rotate(-45deg);\\r\\n\\t\\t}\\r\\n\\t\\t100% {\\r\\n\\t\\t\\ttransform: rotate(0deg);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t@keyframes ldio-mvluw7e021b-2 {\\r\\n\\t\\t0% {\\r\\n\\t\\t\\ttransform: rotate(180deg);\\r\\n\\t\\t}\\r\\n\\t\\t50% {\\r\\n\\t\\t\\ttransform: rotate(225deg);\\r\\n\\t\\t}\\r\\n\\t\\t100% {\\r\\n\\t\\t\\ttransform: rotate(180deg);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t.ldio-mvluw7e021b > div:nth-child(2) {\\r\\n\\t\\ttransform: translate(-15px, 0);\\r\\n\\t}\\r\\n\\t.ldio-mvluw7e021b > div:nth-child(2) div {\\r\\n\\t\\tposition: absolute;\\r\\n\\t\\ttop: 40px;\\r\\n\\t\\tleft: 40px;\\r\\n\\t\\twidth: 120px;\\r\\n\\t\\theight: 60px;\\r\\n\\t\\tborder-radius: 120px 120px 0 0;\\r\\n\\t\\tbackground: #f8b26a;\\r\\n\\t\\tanimation: ldio-mvluw7e021b-1 1s linear infinite;\\r\\n\\t\\ttransform-origin: 60px 60px;\\r\\n\\t}\\r\\n\\t.ldio-mvluw7e021b > div:nth-child(2) div:nth-child(2) {\\r\\n\\t\\tanimation: ldio-mvluw7e021b-2 1s linear infinite;\\r\\n\\t}\\r\\n\\t.ldio-mvluw7e021b > div:nth-child(2) div:nth-child(3) {\\r\\n\\t\\ttransform: rotate(-90deg);\\r\\n\\t\\tanimation: none;\\r\\n\\t}\\r\\n\\t@keyframes ldio-mvluw7e021b-3 {\\r\\n\\t\\t0% {\\r\\n\\t\\t\\ttransform: translate(190px, 0);\\r\\n\\t\\t\\topacity: 0;\\r\\n\\t\\t}\\r\\n\\t\\t20% {\\r\\n\\t\\t\\topacity: 1;\\r\\n\\t\\t}\\r\\n\\t\\t100% {\\r\\n\\t\\t\\ttransform: translate(70px, 0);\\r\\n\\t\\t\\topacity: 1;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t.ldio-mvluw7e021b > div:nth-child(1) {\\r\\n\\t\\tdisplay: block;\\r\\n\\t}\\r\\n\\t.ldio-mvluw7e021b > div:nth-child(1) div {\\r\\n\\t\\tposition: absolute;\\r\\n\\t\\ttop: 92px;\\r\\n\\t\\tleft: -8px;\\r\\n\\t\\twidth: 16px;\\r\\n\\t\\theight: 16px;\\r\\n\\t\\tborder-radius: 50%;\\r\\n\\t\\tbackground: #e15b64;\\r\\n\\t\\tanimation: ldio-mvluw7e021b-3 1s linear infinite;\\r\\n\\t}\\r\\n\\t.ldio-mvluw7e021b > div:nth-child(1) div:nth-child(1) {\\r\\n\\t\\tanimation-delay: -0.67s;\\r\\n\\t}\\r\\n\\t.ldio-mvluw7e021b > div:nth-child(1) div:nth-child(2) {\\r\\n\\t\\tanimation-delay: -0.33s;\\r\\n\\t}\\r\\n\\t.ldio-mvluw7e021b > div:nth-child(1) div:nth-child(3) {\\r\\n\\t\\tanimation-delay: 0s;\\r\\n\\t}\\r\\n\\t.loadingio-spinner-bean-eater-3cordrlrc9 {\\r\\n\\t\\twidth: 200px;\\r\\n\\t\\theight: 200px;\\r\\n\\t\\tdisplay: inline-block;\\r\\n\\t\\toverflow: hidden;\\r\\n\\t\\tbackground: transparent;\\r\\n\\t}\\r\\n\\t.ldio-mvluw7e021b {\\r\\n\\t\\twidth: 100%;\\r\\n\\t\\theight: 100%;\\r\\n\\t\\tposition: relative;\\r\\n\\t\\ttransform: translateZ(0) scale(1);\\r\\n\\t\\tbackface-visibility: hidden;\\r\\n\\t\\ttransform-origin: 0 0; /* see note above */\\r\\n\\t}\\r\\n\\t.ldio-mvluw7e021b div {\\r\\n\\t\\tbox-sizing: content-box;\\r\\n\\t}\\r\\n\\t/* generated by https://loading.io/ */\\r\\n</style>\\r\\n"],"names":[],"mappings":"AAkNC,QAAQ,IAAI,sFAAsF,CAAC,CAAC,AAEpG,6CAAE,CAAC,AACF,WAAW,CAAE,mBAAmB,CAAC,CAAC,KAAK,AACxC,CAAC,AAED,MAAM,6CAAC,CAAC,AACP,MAAM,CAAE,OAAO,CACf,SAAS,CAAE,MAAM,CAAC,CAAC,AACpB,CAAC,AAED,mDAAM,MAAM,AAAC,CAAC,AACb,UAAU,CAAE,SAAS,CAAC,KAAK,CAC3B,SAAS,CAAE,MAAM,IAAI,CAAC,AACvB,CAAC,AAED,GAAG,6CAAC,CAAC,AACJ,UAAU,CAAE,UAAU,AACvB,CAAC,AAED,KAAK,6CAAC,CAAC,AACN,OAAO,CAAE,IAAI,CACb,qBAAqB,CAAE,KAAK,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAChD,kBAAkB,CAAE,IAAI,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAC3C,SAAS,MAAM,CACf,MAAM,CAAE,KAAK,AACd,CAAC,AAID,2DAAc,CAAC,AACd,UAAU,CAAE,GAAG,AAChB,CAAC,AAED,oBAAoB,6CAAC,CAAC,AACrB,WAAW,CAAE,CAAC,CAAC,CAAC,CAChB,QAAQ,CAAE,CAAC,CAAC,CAAC,CACb,MAAM,CAAE,IAAI,CACZ,UAAU,CAAE,MAAM,CAClB,OAAO,CAAE,CAAC,CAAC,GAAG,AACf,CAAC,AAED,kBAAkB,6CAAC,CAAC,AACnB,YAAY,CAAE,GAAG,AAClB,CAAC,AAED,oBAAoB,6CAAC,CAAC,AACrB,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,KAAK,CAAE,IAAI,CACX,WAAW,CAAE,MAAM,CACnB,OAAO,CAAE,GAAG,CAAC,GAAG,AACjB,CAAC,AAED,UAAU,6CAAC,CAAC,AACX,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,KAAK,CACb,OAAO,CAAE,IAAI,CACb,aAAa,CAAE,IAAI,CACnB,eAAe,CAAE,aAAa,CAC9B,WAAW,CAAE,MAAM,CACnB,gBAAgB,CAAE,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAC1C,OAAO,CAAE,GAAG,CAAC,KAAK,CAClB,aAAa,CAAE,GAAG,AACnB,CAAC,AAED,mBAAmB,6CAAC,CAAC,AACpB,MAAM,CAAE,KAAK,AACd,CAAC,AAED,SAAS,6CAAC,CAAC,AACV,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,KAAK,CACZ,aAAa,CAAE,GAAG,CAClB,UAAU,CAAE,KAAK,AAClB,CAAC,AAED,SAAS,6CAAC,CAAC,AACV,gBAAgB,CAAE,WAAW,CAC7B,OAAO,CAAE,CAAC,CACV,MAAM,CAAE,CAAC,AACV,CAAC,AAED,4BAA4B,6CAAC,CAAC,AAC7B,MAAM,CAAE,KAAK,CACb,KAAK,CAAE,IAAI,CACX,QAAQ,CAAE,KAAK,CACf,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,CAAC,CACP,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,MAAM,CACvB,WAAW,CAAE,MAAM,CACnB,gBAAgB,CAAE,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,AACxC,CAAC,AAED,kBAAkB,6CAAC,CAAC,AACnB,KAAK,CAAE,GAAG,CACV,SAAS,CAAE,KAAK,CAChB,SAAS,CAAE,KAAK,CAChB,aAAa,CAAE,GAAG,CAClB,gBAAgB,CAAE,IAAI,CACtB,MAAM,CAAE,KAAK,CACb,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,WAAW,CAAE,MAAM,CACnB,OAAO,CAAE,KAAK,CACd,eAAe,CAAE,aAAa,AAC/B,CAAC,AAED,mBAAmB,6CAAC,CAAC,AACpB,KAAK,CAAE,GAAG,CACV,SAAS,CAAE,KAAK,CAChB,SAAS,CAAE,KAAK,CAChB,aAAa,CAAE,GAAG,CAClB,gBAAgB,CAAE,IAAI,CACtB,MAAM,CAAE,KAAK,CACb,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,WAAW,CAAE,MAAM,CACnB,OAAO,CAAE,KAAK,CACd,eAAe,CAAE,MAAM,AACxB,CAAC,AAED,uBAAuB,6CAAC,CAAC,AACxB,MAAM,CAAE,CAAC,AACV,CAAC,AAED,mCAAmC,6CAAC,CAAC,AACpC,KAAK,CAAE,IAAI,CACX,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,YAAY,AAC9B,CAAC,AAED,sBAAsB,6CAAC,CAAC,AACvB,OAAO,CAAE,IAAI,CAAC,IAAI,CAClB,aAAa,CAAE,GAAG,CAClB,OAAO,CAAE,CAAC,CACV,MAAM,CAAE,CAAC,AACV,CAAC,AAED,WAAW,6CAAC,CAAC,AACZ,KAAK,CAAE,GAAG,AACX,CAAC,AAED,UAAU,6CAAC,CAAC,AACX,MAAM,CAAE,KAAK,CACb,KAAK,CAAE,IAAI,CACX,gBAAgB,CAAE,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CACvC,QAAQ,CAAE,KAAK,CACf,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,CAAC,CACP,OAAO,CAAE,IAAI,CACb,WAAW,CAAE,MAAM,CACnB,eAAe,CAAE,MAAM,AACxB,CAAC,AAED,WAAW,iCAAmB,CAAC,AAC9B,EAAE,AAAC,CAAC,AACH,SAAS,CAAE,OAAO,IAAI,CAAC,AACxB,CAAC,AACD,GAAG,AAAC,CAAC,AACJ,SAAS,CAAE,OAAO,MAAM,CAAC,AAC1B,CAAC,AACD,IAAI,AAAC,CAAC,AACL,SAAS,CAAE,OAAO,IAAI,CAAC,AACxB,CAAC,AACF,CAAC,AACD,WAAW,iCAAmB,CAAC,AAC9B,EAAE,AAAC,CAAC,AACH,SAAS,CAAE,OAAO,MAAM,CAAC,AAC1B,CAAC,AACD,GAAG,AAAC,CAAC,AACJ,SAAS,CAAE,OAAO,MAAM,CAAC,AAC1B,CAAC,AACD,IAAI,AAAC,CAAC,AACL,SAAS,CAAE,OAAO,MAAM,CAAC,AAC1B,CAAC,AACF,CAAC,AACD,gCAAiB,CAAG,iCAAG,WAAW,CAAC,CAAC,AAAC,CAAC,AACrC,SAAS,CAAE,UAAU,KAAK,CAAC,CAAC,CAAC,CAAC,AAC/B,CAAC,AACD,gCAAiB,CAAG,kBAAG,WAAW,CAAC,CAAC,CAAC,GAAG,eAAC,CAAC,AACzC,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,IAAI,CACT,IAAI,CAAE,IAAI,CACV,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,IAAI,CACZ,aAAa,CAAE,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAC9B,UAAU,CAAE,OAAO,CACnB,SAAS,CAAE,iCAAkB,CAAC,EAAE,CAAC,MAAM,CAAC,QAAQ,CAChD,gBAAgB,CAAE,IAAI,CAAC,IAAI,AAC5B,CAAC,AACD,gCAAiB,CAAG,kBAAG,WAAW,CAAC,CAAC,CAAC,kBAAG,WAAW,CAAC,CAAC,AAAC,CAAC,AACtD,SAAS,CAAE,iCAAkB,CAAC,EAAE,CAAC,MAAM,CAAC,QAAQ,AACjD,CAAC,AACD,gCAAiB,CAAG,kBAAG,WAAW,CAAC,CAAC,CAAC,kBAAG,WAAW,CAAC,CAAC,AAAC,CAAC,AACtD,SAAS,CAAE,OAAO,MAAM,CAAC,CACzB,SAAS,CAAE,IAAI,AAChB,CAAC,AACD,WAAW,iCAAmB,CAAC,AAC9B,EAAE,AAAC,CAAC,AACH,SAAS,CAAE,UAAU,KAAK,CAAC,CAAC,CAAC,CAAC,CAC9B,OAAO,CAAE,CAAC,AACX,CAAC,AACD,GAAG,AAAC,CAAC,AACJ,OAAO,CAAE,CAAC,AACX,CAAC,AACD,IAAI,AAAC,CAAC,AACL,SAAS,CAAE,UAAU,IAAI,CAAC,CAAC,CAAC,CAAC,CAC7B,OAAO,CAAE,CAAC,AACX,CAAC,AACF,CAAC,AACD,gCAAiB,CAAG,iCAAG,WAAW,CAAC,CAAC,AAAC,CAAC,AACrC,OAAO,CAAE,KAAK,AACf,CAAC,AACD,gCAAiB,CAAG,kBAAG,WAAW,CAAC,CAAC,CAAC,GAAG,eAAC,CAAC,AACzC,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,IAAI,CACT,IAAI,CAAE,IAAI,CACV,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,aAAa,CAAE,GAAG,CAClB,UAAU,CAAE,OAAO,CACnB,SAAS,CAAE,iCAAkB,CAAC,EAAE,CAAC,MAAM,CAAC,QAAQ,AACjD,CAAC,AACD,gCAAiB,CAAG,kBAAG,WAAW,CAAC,CAAC,CAAC,kBAAG,WAAW,CAAC,CAAC,AAAC,CAAC,AACtD,eAAe,CAAE,MAAM,AACxB,CAAC,AACD,gCAAiB,CAAG,kBAAG,WAAW,CAAC,CAAC,CAAC,kBAAG,WAAW,CAAC,CAAC,AAAC,CAAC,AACtD,eAAe,CAAE,MAAM,AACxB,CAAC,AACD,gCAAiB,CAAG,kBAAG,WAAW,CAAC,CAAC,CAAC,kBAAG,WAAW,CAAC,CAAC,AAAC,CAAC,AACtD,eAAe,CAAE,EAAE,AACpB,CAAC,AACD,wCAAwC,6CAAC,CAAC,AACzC,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,CACb,OAAO,CAAE,YAAY,CACrB,QAAQ,CAAE,MAAM,CAChB,UAAU,CAAE,WAAW,AACxB,CAAC,AACD,iBAAiB,6CAAC,CAAC,AAClB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,QAAQ,CAAE,QAAQ,CAClB,SAAS,CAAE,WAAW,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CACjC,mBAAmB,CAAE,MAAM,CAC3B,gBAAgB,CAAE,CAAC,CAAC,CAAC,AACtB,CAAC,AACD,gCAAiB,CAAC,GAAG,8BAAC,CAAC,AACtB,UAAU,CAAE,WAAW,AACxB,CAAC"}`
};
async function load$2({ fetch: fetch2, page, session, stuff }) {
  let allPosts2;
  try {
    allPosts2 = await getPosts();
  } catch (err) {
    allPosts2 = err;
  }
  return { props: { allPosts: allPosts2 } };
}
var All_posts = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { allPosts: allPosts2 } = $$props;
  const images = [];
  console.log(images, "images");
  if ($$props.allPosts === void 0 && $$bindings.allPosts && allPosts2 !== void 0)
    $$bindings.allPosts(allPosts2);
  $$result.css.add(css$8);
  return `<main class="${"main svelte-13bh7tz"}">${validate_component(Dashboard_sidebar, "Sidebar").$$render($$result, { active: "all-posts" }, {}, {})}
	${validate_component(Dashboard_navbar, "Navbar").$$render($$result, {}, {}, {})}
	<div class="${"all-posts-container svelte-13bh7tz"}"><h1 class="${"container-heading svelte-13bh7tz"}">All posts</h1>

		<div class="${"post-card-container svelte-13bh7tz"}">${allPosts2.length > 0 && images ? `${each(allPosts2, (post, index2) => `<div class="${"post-card svelte-13bh7tz"}">${function(__value) {
    if (is_promise(__value)) {
      __value.then(null, noop$1);
      return `
							<p class="${"svelte-13bh7tz"}">...loading</p>
						`;
    }
    return function(url) {
      return `
							<div class="${"card-img-container svelte-13bh7tz"}"><img class="${"card-img svelte-13bh7tz"}"${add_attribute("src", url, 0)}${add_attribute("alt", post.title, 0)}></div>
						`;
    }(__value);
  }(getImageUrl(post.data.imgSrc))}
						<h3 class="${"card-title svelte-13bh7tz"}">${escape(post.data.title)}</h3>
						<div class="${"card-button-container svelte-13bh7tz"}"><button class="${"card-btn svelte-13bh7tz"}"><svg width="${"29"}" height="${"29"}" viewBox="${"0 0 25 25"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}" class="${"svelte-13bh7tz"}"><path d="${"M19.7 8.60004L8.9 19.4C8.8 19.5 8.80002 19.5 8.70002 19.5L6.20002 20.3L4.60001 20.8C4.20001 20.9 3.8 20.5 3.9 20.1L5.20002 16.1C5.20002 16 5.3 15.9 5.3 15.9L16.1 5.10004C17.1 4.10004 18.6 4.10004 19.6 5.10004C20.7 6.10004 20.7 7.60004 19.7 8.60004Z"}" stroke="${"#1A1A1A"}" stroke-width="${"1.5"}" stroke-miterlimit="${"10"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" fill="${"yellow"}" class="${"svelte-13bh7tz"}"></path><path d="${"M14.6 6.90002L18 10.3"}" stroke="${"#1A1A1A"}" stroke-width="${"1.5"}" stroke-miterlimit="${"10"}" stroke-linecap="${"round"}" fill="${"yellow"}" stroke-linejoin="${"round"}" class="${"svelte-13bh7tz"}"></path></svg></button>
							<button class="${"card-btn svelte-13bh7tz"}"><svg width="${"29"}" height="${"29"}" viewBox="${"0 0 24 24"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}" class="${"svelte-13bh7tz"}"><path fill-rule="${"evenodd"}" clip-rule="${"evenodd"}" stroke-width="${"1"}" stroke="${"#000"}" d="${"M15.8498 2.50071C16.4808 2.50071 17.1108 2.58971 17.7098 2.79071C21.4008 3.99071 22.7308 8.04071 21.6198 11.5807C20.9898 13.3897 19.9598 15.0407 18.6108 16.3897C16.6798 18.2597 14.5608 19.9197 12.2798 21.3497L12.0298 21.5007L11.7698 21.3397C9.4808 19.9197 7.3498 18.2597 5.4008 16.3797C4.0608 15.0307 3.0298 13.3897 2.3898 11.5807C1.2598 8.04071 2.5898 3.99071 6.3208 2.76971C6.6108 2.66971 6.9098 2.59971 7.2098 2.56071H7.3298C7.6108 2.51971 7.8898 2.50071 8.1698 2.50071H8.2798C8.9098 2.51971 9.5198 2.62971 10.1108 2.83071H10.1698C10.2098 2.84971 10.2398 2.87071 10.2598 2.88971C10.4808 2.96071 10.6898 3.04071 10.8898 3.15071L11.2698 3.32071C11.3616 3.36968 11.4647 3.44451 11.5538 3.50918C11.6102 3.55015 11.661 3.58705 11.6998 3.61071C11.7161 3.62034 11.7327 3.63002 11.7494 3.63978C11.8352 3.68983 11.9245 3.74197 11.9998 3.79971C13.1108 2.95071 14.4598 2.49071 15.8498 2.50071ZM18.5098 9.70071C18.9198 9.68971 19.2698 9.36071 19.2998 8.93971V8.82071C19.3298 7.41971 18.4808 6.15071 17.1898 5.66071C16.7798 5.51971 16.3298 5.74071 16.1798 6.16071C16.0398 6.58071 16.2598 7.04071 16.6798 7.18971C17.3208 7.42971 17.7498 8.06071 17.7498 8.75971V8.79071C17.7308 9.01971 17.7998 9.24071 17.9398 9.41071C18.0798 9.58071 18.2898 9.67971 18.5098 9.70071Z"}"${add_attribute("fill", post.data.featured ? "red" : "#fff", 0)} class="${"svelte-13bh7tz"}"></path></svg></button>
							<button class="${"card-btn svelte-13bh7tz"}"><svg width="${"29"}" height="${"30"}" viewBox="${"0 0 24 25"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}" class="${"svelte-13bh7tz"}"><path d="${"M18.9999 6.30002H15.6L15.1 5.49997C14.4 4.39997 13.2999 3.80002 11.9999 3.80002C10.6999 3.80002 9.59996 4.39997 8.89996 5.49997L8.39996 6.30002H4.99994C4.59994 6.30002 4.19995 6.60001 4.19995 7.10001C4.19995 7.60001 4.49994 7.89999 4.99994 7.89999H6.29999V18.1C6.29999 19.8 7.59999 21.1 9.29999 21.1H14.7C16.4 21.1 17.7 19.8 17.7 18.1V7.89999H18.9999C19.3999 7.89999 19.8 7.60001 19.8 7.10001C19.8 6.60001 19.3999 6.30002 18.9999 6.30002ZM10.2 6.30002C10.6 5.70002 11.2999 5.30002 11.9999 5.30002C12.6999 5.30002 13.4 5.70002 13.8 6.30002H10.2ZM10.8 17.2C10.8 17.6 10.4999 18 9.99994 18C9.59994 18 9.19995 17.7 9.19995 17.2V10.8C9.19995 10.4 9.49994 9.99997 9.99994 9.99997C10.3999 9.99997 10.8 10.3 10.8 10.8V17.2ZM14.7 17.2C14.7 17.6 14.4 18 13.9 18C13.5 18 13.1 17.7 13.1 17.2V10.8C13.1 10.4 13.4 9.99997 13.9 9.99997C14.3 9.99997 14.7 10.3 14.7 10.8V17.2Z"}" fill="${"orange"}" class="${"svelte-13bh7tz"}"></path></svg>
							</button></div>
					</div>`)}` : `<h3 class="${"no-post-title svelte-13bh7tz"}">You do not have any blog post <a href="${"/dashboard/write-a-post"}" class="${"svelte-13bh7tz"}">click here to create one.</a></h3>`}</div></div>
	${``}
	${``}
	${``}
</main>`;
});
var allPosts = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": All_posts,
  load: load$2
});
var css$7 = {
  code: ".main.svelte-xdritf{display:grid;grid-template-columns:225px calc(100vw - 225px);grid-template-rows:75px auto}",
  map: `{"version":3,"file":"resources.svelte","sources":["resources.svelte"],"sourcesContent":["<script>\\r\\n    import Sidebar from '../../components/dashboard.sidebar.svelte';\\r\\n    import Navbar from '../../components/dashboard.navbar.svelte';\\r\\n<\/script>\\r\\n\\r\\n<main class=\\"main\\" >\\r\\n    <Sidebar class=\\"sidebar\\" active=\\"resources\\" />\\r\\n    <Navbar class=\\"navbar\\" />\\r\\n</main>\\r\\n\\r\\n\\r\\n<style>\\r\\n    .main{\\r\\n        display:grid;\\r\\n        grid-template-columns: 225px calc(100vw - 225px);\\r\\n        grid-template-rows: 75px auto;\\r\\n    }\\r\\n\\r\\n    .sidebar{\\r\\n        grid-column: 1/2;\\r\\n        grid-row: 1/-1;\\r\\n    }\\r\\n\\r\\n    .navbar{\\r\\n        grid-column: 2/3;\\r\\n        grid-row: 1/2;\\r\\n    }\\r\\n</style>\\r\\n\\r\\n\\r\\n"],"names":[],"mappings":"AAYI,mBAAK,CAAC,AACF,QAAQ,IAAI,CACZ,qBAAqB,CAAE,KAAK,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAChD,kBAAkB,CAAE,IAAI,CAAC,IAAI,AACjC,CAAC"}`
};
var Resources = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  $$result.css.add(css$7);
  return `<main class="${"main svelte-xdritf"}">${validate_component(Dashboard_sidebar, "Sidebar").$$render($$result, { class: "sidebar", active: "resources" }, {}, {})}
    ${validate_component(Dashboard_navbar, "Navbar").$$render($$result, { class: "navbar" }, {}, {})}
</main>`;
});
var resources = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Resources
});
var css$6 = {
  code: ".tags-main.svelte-x4kktl{height:calc(100vh - 91px);display:flex;justify-content:center;align-items:center}.container.svelte-x4kktl{display:flex;flex-direction:column;justify-content:space-between;align-items:center}.search-bar.svelte-x4kktl{display:flex;border:1px solid #000;border-radius:25px;box-sizing:border-box;width:707px;height:60px;overflow:hidden}.search-input.svelte-x4kktl{border:0;outline:0;width:calc(100% - 30px);padding-left:15px}.search-button.svelte-x4kktl{border:0;outline:0;padding:0 5px;cursor:pointer;background-color:transparent}.tags-lists.svelte-x4kktl{margin-top:4em;display:flex;justify-content:center;flex-direction:column}.tags-list.svelte-x4kktl{margin:0.5em auto}.tag-select.svelte-x4kktl{padding:9px 14px;font-size:16px;border:1px solid #000;outline:0;border-radius:15px;margin:0 7px;background-color:transparent}",
  map: '{"version":3,"file":"tags.svelte","sources":["tags.svelte"],"sourcesContent":["<script lang=\\"ts\\" >let search = false;\\r\\n<\/script>\\r\\n\\r\\n<main on:click={() => search = false } class=\\"tags-main\\" >\\r\\n    <div class=\\"container\\" >\\r\\n        <form class=\\"search-bar\\" >\\r\\n            <input class=\\"search-input\\" type=\\"text\\" placeholder=\\"Find the topics you care about...\\" />\\r\\n            <button class=\\"search-button\\" >\\r\\n                <svg width=\\"30\\" height=\\"30\\" viewBox=\\"0 0 30 30\\" fill=\\"none\\" xmlns=\\"http://www.w3.org/2000/svg\\">\\r\\n                    <path d=\\"M13.75 23.75C19.2728 23.75 23.75 19.2728 23.75 13.75C23.75 8.22715 19.2728 3.75 13.75 3.75C8.22715 3.75 3.75 8.22715 3.75 13.75C3.75 19.2728 8.22715 23.75 13.75 23.75Z\\" stroke=\\"black\\" stroke-width=\\"2\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\"/>\\r\\n                    <path d=\\"M26.25 26.25L20.8125 20.8125\\" stroke=\\"black\\" stroke-width=\\"2\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\"/>\\r\\n                </svg>                    \\r\\n            </button>\\r\\n        </form>\\r\\n        <div class=\\"tags-lists\\" >\\r\\n            <div class=\\"tags-list tags-list-first\\" >\\r\\n                <button class=\\"tag-select\\" >#technology</button>\\r\\n                <button class=\\"tag-select\\" >#lifeandlove</button>\\r\\n                <button class=\\"tag-select\\" >#essenialism</button>\\r\\n                <button class=\\"tag-select\\" >#webdevelopment</button>\\r\\n                <button class=\\"tag-select\\" >#fashion</button>\\r\\n                <button class=\\"tag-select\\" >#lifestyle</button>\\r\\n    \\r\\n            </div>\\r\\n            <div class=\\"tags-list tags-list-second\\" >\\r\\n                <button class=\\"tag-select\\" >#technology</button>\\r\\n                <button class=\\"tag-select\\" >#lifeandlove</button>\\r\\n                <button class=\\"tag-select\\" >#essenialism</button>\\r\\n                <button class=\\"tag-select\\" >#webdevelopment</button>\\r\\n                <button class=\\"tag-select\\" >#fashion</button>\\r\\n                <button class=\\"tag-select\\" >#lifestyle</button>\\r\\n                <button class=\\"tag-select\\" >#architecture</button>\\r\\n                <button class=\\"tag-select\\" >#games</button>\\r\\n            </div>\\r\\n            <div class=\\"tags-list tags-list-third\\" >\\r\\n                <button class=\\"tag-select\\" >#technology</button>\\r\\n                <button class=\\"tag-select\\" >#lifeandlove</button>\\r\\n                <button class=\\"tag-select\\" >#essenialism</button>\\r\\n                <button class=\\"tag-select\\" >#webdevelopment</button>\\r\\n                <button class=\\"tag-select\\" >#fashion</button>\\r\\n                <button class=\\"tag-select\\" >#lifestyle</button>\\r\\n            </div>\\r\\n        </div>\\r\\n    </div>\\r\\n</main>\\r\\n\\r\\n<style>\\r\\n    .tags-main{\\r\\n        height: calc(100vh - 91px);\\r\\n        display: flex;\\r\\n        justify-content: center;\\r\\n        align-items: center;\\r\\n\\r\\n    }\\r\\n\\r\\n    .container{\\r\\n        display: flex;\\r\\n        flex-direction: column;\\r\\n        justify-content: space-between;\\r\\n        align-items: center;\\r\\n    }\\r\\n\\r\\n    .search-bar{\\r\\n        display: flex;\\r\\n        border: 1px solid #000;\\r\\n        border-radius: 25px;\\r\\n        box-sizing: border-box;\\r\\n        width: 707px;\\r\\n        height: 60px;\\r\\n        overflow: hidden;\\r\\n    }\\r\\n\\r\\n    .search-input{\\r\\n        border: 0;\\r\\n        outline: 0;\\r\\n        width: calc(100% - 30px);\\r\\n        padding-left: 15px;\\r\\n    }\\r\\n\\r\\n    .search-button{\\r\\n        border: 0;\\r\\n        outline: 0;\\r\\n        padding: 0 5px;\\r\\n        cursor:pointer;\\r\\n        background-color: transparent;\\r\\n    }\\r\\n\\r\\n    .tags-lists{\\r\\n        margin-top: 4em;\\r\\n        display: flex;\\r\\n        justify-content: center;\\r\\n        \\r\\n        flex-direction: column;\\r\\n    }\\r\\n\\r\\n    .tags-list{\\r\\n        margin: 0.5em auto;\\r\\n    }\\r\\n\\r\\n    .tag-select{\\r\\n        padding: 9px 14px;\\r\\n        font-size: 16px;\\r\\n        border: 1px solid #000;\\r\\n        outline: 0;\\r\\n        border-radius: 15px;\\r\\n        margin: 0 7px;\\r\\n        background-color: transparent;\\r\\n    }\\r\\n\\r\\n</style>"],"names":[],"mappings":"AA+CI,wBAAU,CAAC,AACP,MAAM,CAAE,KAAK,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAC1B,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,MAAM,CACvB,WAAW,CAAE,MAAM,AAEvB,CAAC,AAED,wBAAU,CAAC,AACP,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,eAAe,CAAE,aAAa,CAC9B,WAAW,CAAE,MAAM,AACvB,CAAC,AAED,yBAAW,CAAC,AACR,OAAO,CAAE,IAAI,CACb,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,CACtB,aAAa,CAAE,IAAI,CACnB,UAAU,CAAE,UAAU,CACtB,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,IAAI,CACZ,QAAQ,CAAE,MAAM,AACpB,CAAC,AAED,2BAAa,CAAC,AACV,MAAM,CAAE,CAAC,CACT,OAAO,CAAE,CAAC,CACV,KAAK,CAAE,KAAK,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,CACxB,YAAY,CAAE,IAAI,AACtB,CAAC,AAED,4BAAc,CAAC,AACX,MAAM,CAAE,CAAC,CACT,OAAO,CAAE,CAAC,CACV,OAAO,CAAE,CAAC,CAAC,GAAG,CACd,OAAO,OAAO,CACd,gBAAgB,CAAE,WAAW,AACjC,CAAC,AAED,yBAAW,CAAC,AACR,UAAU,CAAE,GAAG,CACf,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,MAAM,CAEvB,cAAc,CAAE,MAAM,AAC1B,CAAC,AAED,wBAAU,CAAC,AACP,MAAM,CAAE,KAAK,CAAC,IAAI,AACtB,CAAC,AAED,yBAAW,CAAC,AACR,OAAO,CAAE,GAAG,CAAC,IAAI,CACjB,SAAS,CAAE,IAAI,CACf,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,CACtB,OAAO,CAAE,CAAC,CACV,aAAa,CAAE,IAAI,CACnB,MAAM,CAAE,CAAC,CAAC,GAAG,CACb,gBAAgB,CAAE,WAAW,AACjC,CAAC"}'
};
var Tags = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  $$result.css.add(css$6);
  return `<main class="${"tags-main svelte-x4kktl"}"><div class="${"container svelte-x4kktl"}"><form class="${"search-bar svelte-x4kktl"}"><input class="${"search-input svelte-x4kktl"}" type="${"text"}" placeholder="${"Find the topics you care about..."}">
            <button class="${"search-button svelte-x4kktl"}"><svg width="${"30"}" height="${"30"}" viewBox="${"0 0 30 30"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}"><path d="${"M13.75 23.75C19.2728 23.75 23.75 19.2728 23.75 13.75C23.75 8.22715 19.2728 3.75 13.75 3.75C8.22715 3.75 3.75 8.22715 3.75 13.75C3.75 19.2728 8.22715 23.75 13.75 23.75Z"}" stroke="${"black"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}"></path><path d="${"M26.25 26.25L20.8125 20.8125"}" stroke="${"black"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}"></path></svg></button></form>
        <div class="${"tags-lists svelte-x4kktl"}"><div class="${"tags-list tags-list-first svelte-x4kktl"}"><button class="${"tag-select svelte-x4kktl"}">#technology</button>
                <button class="${"tag-select svelte-x4kktl"}">#lifeandlove</button>
                <button class="${"tag-select svelte-x4kktl"}">#essenialism</button>
                <button class="${"tag-select svelte-x4kktl"}">#webdevelopment</button>
                <button class="${"tag-select svelte-x4kktl"}">#fashion</button>
                <button class="${"tag-select svelte-x4kktl"}">#lifestyle</button></div>
            <div class="${"tags-list tags-list-second svelte-x4kktl"}"><button class="${"tag-select svelte-x4kktl"}">#technology</button>
                <button class="${"tag-select svelte-x4kktl"}">#lifeandlove</button>
                <button class="${"tag-select svelte-x4kktl"}">#essenialism</button>
                <button class="${"tag-select svelte-x4kktl"}">#webdevelopment</button>
                <button class="${"tag-select svelte-x4kktl"}">#fashion</button>
                <button class="${"tag-select svelte-x4kktl"}">#lifestyle</button>
                <button class="${"tag-select svelte-x4kktl"}">#architecture</button>
                <button class="${"tag-select svelte-x4kktl"}">#games</button></div>
            <div class="${"tags-list tags-list-third svelte-x4kktl"}"><button class="${"tag-select svelte-x4kktl"}">#technology</button>
                <button class="${"tag-select svelte-x4kktl"}">#lifeandlove</button>
                <button class="${"tag-select svelte-x4kktl"}">#essenialism</button>
                <button class="${"tag-select svelte-x4kktl"}">#webdevelopment</button>
                <button class="${"tag-select svelte-x4kktl"}">#fashion</button>
                <button class="${"tag-select svelte-x4kktl"}">#lifestyle</button></div></div></div>
</main>`;
});
var tags = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Tags
});
var css$5 = {
  code: "@import url('https://fonts.googleapis.com/css2?family=Libre+Baskerville:wght@400;700&display=swap');.svelte-qktyk1.svelte-qktyk1.svelte-qktyk1{font-family:'Libre Baskerville', serif}h1.svelte-qktyk1.svelte-qktyk1.svelte-qktyk1,p.svelte-qktyk1.svelte-qktyk1.svelte-qktyk1{margin:0}div.svelte-qktyk1.svelte-qktyk1.svelte-qktyk1{position:relative}.gray.svelte-qktyk1.svelte-qktyk1.svelte-qktyk1{color:rgba(28, 28, 28, 0.5);font-size:16px}.tag.svelte-qktyk1.svelte-qktyk1.svelte-qktyk1{margin-right:5px}.post-title.svelte-qktyk1.svelte-qktyk1.svelte-qktyk1{position:relative;text-align:center}.button-edit-title.svelte-qktyk1.svelte-qktyk1.svelte-qktyk1{position:absolute;right:0;top:calc(50% - 15px);outline:0;border:0;background-color:inherit}.read-time.svelte-qktyk1.svelte-qktyk1.svelte-qktyk1{font-size:14px}.title.svelte-qktyk1.svelte-qktyk1.svelte-qktyk1{font-size:42px;font-weight:700;text-align:center;margin:10px auto;width:600px}.title-edit.svelte-qktyk1.svelte-qktyk1.svelte-qktyk1{font-size:42px}.main.svelte-qktyk1.svelte-qktyk1.svelte-qktyk1{display:grid;height:100vh;grid-template-columns:225px calc(100vw - 225px);grid-template-rows:75px auto;overflow:hidden}.post.svelte-qktyk1.svelte-qktyk1.svelte-qktyk1{overflow:hidden;overflow-y:scroll;padding:2em 0;text-align:center}.post-header_author.svelte-qktyk1.svelte-qktyk1.svelte-qktyk1{display:flex;align-items:center;justify-content:center;margin:1em 0}.input-gray.svelte-qktyk1.svelte-qktyk1.svelte-qktyk1{padding:10px 5px;border-radius:5px;outline:0;border:1px solid #000}.tags.svelte-qktyk1.svelte-qktyk1.svelte-qktyk1{display:flex;align-items:center;justify-content:center;margin:1em 0}.tag-input.svelte-qktyk1.svelte-qktyk1.svelte-qktyk1{width:70px;outline:0;border:1px solid #000;border-radius:10px;height:20px;padding-left:5px;margin:0 0 0 10px}.tag-button.svelte-qktyk1.svelte-qktyk1.svelte-qktyk1{border:0;outline:0;background-color:inherit}.banner-container.svelte-qktyk1.svelte-qktyk1.svelte-qktyk1{position:relative}.banner.svelte-qktyk1.svelte-qktyk1.svelte-qktyk1{height:500px}#banner-upload.svelte-qktyk1.svelte-qktyk1.svelte-qktyk1{width:0;height:0;padding:0;border:0;outline:0}.banner-label.svelte-qktyk1.svelte-qktyk1.svelte-qktyk1{position:absolute;right:calc(50% - 27px);top:calc(50% - 27px);padding:1em;background-color:#fff;border-radius:5px}.banner-skeleton.svelte-qktyk1.svelte-qktyk1.svelte-qktyk1{background-color:rgb(239, 235, 235)}.post-body-text.svelte-qktyk1.svelte-qktyk1.svelte-qktyk1{text-align:center;padding:2em 0}.post-body.svelte-qktyk1.svelte-qktyk1.svelte-qktyk1{width:600px;padding-bottom:1.5em;margin:0 auto;text-align:left;font-size:16px;line-height:24px;font-family:-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell,\r\n			'Open Sans', 'Helvetica Neue', sans-serif}.submit-post-btn.svelte-qktyk1.svelte-qktyk1.svelte-qktyk1{padding:1em 2em;border-radius:5px;background-color:inherit;font-size:18px;border:1.5px solid #000;outline:0;font-family:'Libre Baskerville', serif;font-weight:bolder}.preloader.svelte-qktyk1.svelte-qktyk1.svelte-qktyk1{height:100vh;width:100%;background-color:rgba(28, 28, 28, 0.5);position:fixed;top:0;left:0;display:flex;align-items:center;justify-content:center}@keyframes svelte-qktyk1-ldio-mvluw7e021b-1{0%{transform:rotate(0deg)}50%{transform:rotate(-45deg)}100%{transform:rotate(0deg)}}@keyframes svelte-qktyk1-ldio-mvluw7e021b-2{0%{transform:rotate(180deg)}50%{transform:rotate(225deg)}100%{transform:rotate(180deg)}}.ldio-mvluw7e021b.svelte-qktyk1>div.svelte-qktyk1.svelte-qktyk1:nth-child(2){transform:translate(-15px, 0)}.ldio-mvluw7e021b.svelte-qktyk1>div.svelte-qktyk1:nth-child(2) div.svelte-qktyk1{position:absolute;top:40px;left:40px;width:120px;height:60px;border-radius:120px 120px 0 0;background:#f8b26a;animation:svelte-qktyk1-ldio-mvluw7e021b-1 1s linear infinite;transform-origin:60px 60px}.ldio-mvluw7e021b.svelte-qktyk1>div.svelte-qktyk1:nth-child(2) div.svelte-qktyk1:nth-child(2){animation:svelte-qktyk1-ldio-mvluw7e021b-2 1s linear infinite}.ldio-mvluw7e021b.svelte-qktyk1>div.svelte-qktyk1:nth-child(2) div.svelte-qktyk1:nth-child(3){transform:rotate(-90deg);animation:none}@keyframes svelte-qktyk1-ldio-mvluw7e021b-3{0%{transform:translate(190px, 0);opacity:0}20%{opacity:1}100%{transform:translate(70px, 0);opacity:1}}.ldio-mvluw7e021b.svelte-qktyk1>div.svelte-qktyk1.svelte-qktyk1:nth-child(1){display:block}.ldio-mvluw7e021b.svelte-qktyk1>div.svelte-qktyk1:nth-child(1) div.svelte-qktyk1{position:absolute;top:92px;left:-8px;width:16px;height:16px;border-radius:50%;background:#e15b64;animation:svelte-qktyk1-ldio-mvluw7e021b-3 1s linear infinite}.ldio-mvluw7e021b.svelte-qktyk1>div.svelte-qktyk1:nth-child(1) div.svelte-qktyk1:nth-child(1){animation-delay:-0.67s}.ldio-mvluw7e021b.svelte-qktyk1>div.svelte-qktyk1:nth-child(1) div.svelte-qktyk1:nth-child(2){animation-delay:-0.33s}.ldio-mvluw7e021b.svelte-qktyk1>div.svelte-qktyk1:nth-child(1) div.svelte-qktyk1:nth-child(3){animation-delay:0s}.loadingio-spinner-bean-eater-3cordrlrc9.svelte-qktyk1.svelte-qktyk1.svelte-qktyk1{width:200px;height:200px;display:inline-block;overflow:hidden;background:transparent}.ldio-mvluw7e021b.svelte-qktyk1.svelte-qktyk1.svelte-qktyk1{width:100%;height:100%;position:relative;transform:translateZ(0) scale(1);backface-visibility:hidden;transform-origin:0 0}.ldio-mvluw7e021b.svelte-qktyk1 div.svelte-qktyk1.svelte-qktyk1{box-sizing:content-box}",
  map: `{"version":3,"file":"[slug].svelte","sources":["[slug].svelte"],"sourcesContent":["<script context=\\"module\\">\\r\\n\\texport async function load({ page, fetch, session, stuff }) {\\r\\n\\t\\treturn {\\r\\n\\t\\t\\tprops: {\\r\\n\\t\\t\\t\\tpostId: page.params.slug\\r\\n\\t\\t\\t}\\r\\n\\t\\t};\\r\\n\\t}\\r\\n<\/script>\\r\\n\\r\\n<script lang=\\"ts\\">import Sidebar from '../../../components/dashboard.sidebar.svelte';\\r\\nimport Navbar from '../../../components/dashboard.navbar.svelte';\\r\\nimport '../../tags.svelte';\\r\\nimport { getImageUrl, getPost, updatePost } from '../../../utils/firebase.apis';\\r\\nimport { onMount } from 'svelte';\\r\\nexport let postId;\\r\\nlet banner = null;\\r\\nlet titleEdit = false;\\r\\nlet bodyEdit = false;\\r\\nlet author = false;\\r\\nlet isLoaderActive = false;\\r\\nconsole.log(postId);\\r\\nlet content = {\\r\\n    title: 'Enter title of the page here',\\r\\n    author: 'Aslam',\\r\\n    readingTime: '10',\\r\\n    postDate: 'October 18, 2021',\\r\\n    body: [],\\r\\n    tags: [],\\r\\n    tempTag: '',\\r\\n    paragraph: '',\\r\\n    featured: false\\r\\n};\\r\\nlet bannerImage;\\r\\nlet textRef;\\r\\nfunction handleBanner(e) {\\r\\n    const file = e.target.files[0];\\r\\n    bannerImage = file;\\r\\n    banner = URL.createObjectURL(file);\\r\\n}\\r\\nfunction handleChange(e) {\\r\\n    const { name, value } = e.target;\\r\\n    content[name] = value;\\r\\n}\\r\\nfunction handleAddTag() {\\r\\n    if (content.tempTag !== '') {\\r\\n        content.tags.push(content.tempTag);\\r\\n        content.tempTag = '';\\r\\n    }\\r\\n}\\r\\nfunction handleAddBodyPara(e) {\\r\\n    if (content.paragraph !== '') {\\r\\n        content.body.push(content.paragraph);\\r\\n        content.paragraph = '';\\r\\n    }\\r\\n}\\r\\nasync function handleSubmitPost(e) {\\r\\n    isLoaderActive = true;\\r\\n    const api = await updatePost(postId, content, bannerImage);\\r\\n    (await api) && (isLoaderActive = false);\\r\\n    (await api) &&\\r\\n        (content = {\\r\\n            ...content,\\r\\n            title: 'Enter title of the page here',\\r\\n            author: 'Aslam',\\r\\n            readingTime: '10',\\r\\n            postDate: 'October 18, 2021',\\r\\n            body: [],\\r\\n            tags: [],\\r\\n            tempTag: '',\\r\\n            paragraph: ''\\r\\n        });\\r\\n    (await api) && (bannerImage = null);\\r\\n}\\r\\nlet postData;\\r\\nonMount(() => {\\r\\n    getPost(postId)\\r\\n        .then((res) => {\\r\\n        postData = res;\\r\\n        getImageUrl(postData.data.imgSrc)\\r\\n            .then(img => banner = img)\\r\\n            .catch(err => console.log(err, 'img-url'));\\r\\n    })\\r\\n        .catch((err) => console.log(err));\\r\\n});\\r\\n$: console.log(postData);\\r\\n$: if (postData) {\\r\\n    content = {\\r\\n        ...postData.data\\r\\n    };\\r\\n}\\r\\n<\/script>\\r\\n\\r\\n<main class=\\"main\\">\\r\\n\\t<Sidebar active=\\"write-a-post\\" />\\r\\n\\t<Navbar active=\\"\\" />\\r\\n\\t<div class=\\"post\\">\\r\\n\\t\\t<div class=\\"banner-container\\">\\r\\n\\t\\t\\t{#if banner}\\r\\n\\t\\t\\t\\t<img class=\\"banner-img banner\\" src={banner} alt=\\"banner\\" />\\r\\n\\t\\t\\t{:else}\\r\\n\\t\\t\\t\\t<div class=\\"banner-skeleton banner \\" />\\r\\n\\t\\t\\t{/if}\\r\\n\\t\\t\\t<input on:change={handleBanner} id=\\"banner-upload\\" type=\\"file\\" />\\r\\n\\t\\t\\t<label class=\\"banner-label\\" for=\\"banner-upload\\">\\r\\n\\t\\t\\t\\t<svg\\r\\n\\t\\t\\t\\t\\twidth=\\"54\\"\\r\\n\\t\\t\\t\\t\\theight=\\"54\\"\\r\\n\\t\\t\\t\\t\\tviewBox=\\"0 0 24 24\\"\\r\\n\\t\\t\\t\\t\\tfill=\\"none\\"\\r\\n\\t\\t\\t\\t\\txmlns=\\"http://www.w3.org/2000/svg\\"\\r\\n\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\tfill-rule=\\"evenodd\\"\\r\\n\\t\\t\\t\\t\\t\\tclip-rule=\\"evenodd\\"\\r\\n\\t\\t\\t\\t\\t\\td=\\"M15.2411 2.24464L20.2916 7.55623C20.4252 7.69717 20.5 7.88443 20.5 8.07973V17.4435C20.5 19.9553 18.4971 22 16.0337 22H8.07002C5.46399 22 3.5 20.0409 3.5 17.4435V14.9206C3.5 14.5038 3.83498 14.1655 4.24771 14.1655C4.66045 14.1655 4.99543 14.5038 4.99543 14.9206V17.4435C4.99543 19.2083 6.28847 20.4899 8.07002 20.4899H16.0337C17.6726 20.4899 19.0046 19.1227 19.0046 17.4435V8.38276L15.1873 4.36887V5.68569C15.1873 6.69647 16.0018 7.51998 17.0027 7.522C17.4154 7.523 17.7494 7.86127 17.7484 8.27907C17.7474 8.69486 17.4134 9.03211 17.0007 9.03211H16.9997C15.1763 9.02809 13.6918 7.52703 13.6918 5.68569V3.5222H8.07002C6.40312 3.5222 4.99543 4.8954 4.99543 6.52129V10.8161C4.99543 11.2329 4.66045 11.5711 4.24771 11.5711C3.83498 11.5711 3.5 11.2329 3.5 10.8161V6.52129C3.5 4.07692 5.5926 2.01208 8.07002 2.01208H14.3817C14.3913 2.01116 14.4 2.00855 14.4086 2.006C14.4188 2.00296 14.4287 2 14.4395 2C14.4512 2 14.4616 2.00313 14.472 2.00624C14.4803 2.00872 14.4885 2.01119 14.4974 2.01208H14.7017C14.9051 2.01208 15.0995 2.09564 15.2411 2.24464ZM11.0698 10.5214C11.0698 10.1046 11.4048 9.76633 11.8176 9.76633C12.2303 9.76633 12.5653 10.1046 12.5653 10.5214V12.2339H14.2611C14.6738 12.2339 15.0088 12.5721 15.0088 12.9889C15.0088 13.4057 14.6738 13.744 14.2611 13.744H12.5653V15.4555C12.5653 15.8722 12.2303 16.2105 11.8176 16.2105C11.4048 16.2105 11.0698 15.8722 11.0698 15.4555V13.744H9.37503C8.96229 13.744 8.62732 13.4057 8.62732 12.9889C8.62732 12.5721 8.96229 12.2339 9.37503 12.2339H11.0698V10.5214Z\\"\\r\\n\\t\\t\\t\\t\\t\\tfill=\\"#200E32\\"\\r\\n\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t</svg>\\r\\n\\t\\t\\t</label>\\r\\n\\t\\t</div>\\r\\n\\t\\t<div class=\\"post-header\\">\\r\\n\\t\\t\\t<div class=\\"post-title\\">\\r\\n\\t\\t\\t\\t{#if titleEdit}\\r\\n\\t\\t\\t\\t\\t<input\\r\\n\\t\\t\\t\\t\\t\\ton:change={handleChange}\\r\\n\\t\\t\\t\\t\\t\\tname=\\"title\\"\\r\\n\\t\\t\\t\\t\\t\\tvalue={content.title}\\r\\n\\t\\t\\t\\t\\t\\tplaceholder=\\"Enter title of the post\\"\\r\\n\\t\\t\\t\\t\\t\\tclass=\\"title-edit\\"\\r\\n\\t\\t\\t\\t\\t\\ttype=\\"enter title\\"\\r\\n\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t<button on:click={() => (titleEdit = false)} class=\\"button-edit-title\\">\\r\\n\\t\\t\\t\\t\\t\\t<svg\\r\\n\\t\\t\\t\\t\\t\\t\\twidth=\\"24\\"\\r\\n\\t\\t\\t\\t\\t\\t\\theight=\\"24\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tviewBox=\\"0 0 24 24\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tfill=\\"none\\"\\r\\n\\t\\t\\t\\t\\t\\t\\txmlns=\\"http://www.w3.org/2000/svg\\"\\r\\n\\t\\t\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tfill-rule=\\"evenodd\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tclip-rule=\\"evenodd\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\td=\\"M5 22C3.34315 22 2 20.6569 2 19V13C2 11.3431 3.34315 10 5 10H6.381L9.55279 3.65836C10.0311 2.70179 10.9794 2.07683 12.0366 2.00661L12.2361 2H12.5C13.8255 2 14.91 3.03154 14.9947 4.33562L15 4.5V10H18.9983C19.1958 10 19.3929 10.0195 19.5866 10.0583C21.1533 10.3716 22.1889 11.8524 21.9696 13.4145L21.94 13.5883L20.74 19.5883C20.4712 20.9322 19.3293 21.9152 17.9759 21.9948L17.7983 22H5ZM6 12H5C4.44772 12 4 12.4477 4 13V19C4 19.5523 4.44772 20 5 20H6V12ZM12.5 4H12.2361C11.8994 4 11.5884 4.16909 11.4045 4.4446L11.3416 4.55279L8.10557 11.0249C8.0535 11.1291 8.02015 11.2412 8.00673 11.3563L8 11.4721V20H17.7983C18.2352 20 18.6165 19.7173 18.749 19.3101L18.7788 19.1961L19.9788 13.1961C20.0872 12.6546 19.7359 12.1277 19.1944 12.0194L19.0968 12.0049L18.9983 12H15C13.9456 12 13.0818 11.1841 13.0055 10.1493L13 10V4.5C13 4.25454 12.8231 4.05039 12.5899 4.00806L12.5 4Z\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tfill=\\"black\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t\\t</svg>\\r\\n\\t\\t\\t\\t\\t</button>\\r\\n\\t\\t\\t\\t{:else}\\r\\n\\t\\t\\t\\t\\t<h1 class=\\"title\\">{content.title}</h1>\\r\\n\\t\\t\\t\\t\\t<button on:click={() => (titleEdit = true)} class=\\"button-edit-title\\">\\r\\n\\t\\t\\t\\t\\t\\t<svg\\r\\n\\t\\t\\t\\t\\t\\t\\twidth=\\"25\\"\\r\\n\\t\\t\\t\\t\\t\\t\\theight=\\"25\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tviewBox=\\"0 0 25 25\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tfill=\\"none\\"\\r\\n\\t\\t\\t\\t\\t\\t\\txmlns=\\"http://www.w3.org/2000/svg\\"\\r\\n\\t\\t\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\t\\t\\td=\\"M19.7 8.60004L8.9 19.4C8.8 19.5 8.80002 19.5 8.70002 19.5L6.20002 20.3L4.60001 20.8C4.20001 20.9 3.8 20.5 3.9 20.1L5.20002 16.1C5.20002 16 5.3 15.9 5.3 15.9L16.1 5.10004C17.1 4.10004 18.6 4.10004 19.6 5.10004C20.7 6.10004 20.7 7.60004 19.7 8.60004Z\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke=\\"#1A1A1A\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-width=\\"1.5\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-miterlimit=\\"10\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-linecap=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-linejoin=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\t\\t\\td=\\"M14.6 6.90002L18 10.3\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke=\\"#1A1A1A\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-width=\\"1.5\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-miterlimit=\\"10\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-linecap=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-linejoin=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t\\t</svg>\\r\\n\\t\\t\\t\\t\\t</button>\\r\\n\\t\\t\\t\\t{/if}\\r\\n\\t\\t\\t</div>\\r\\n\\t\\t\\t<div class=\\"post-header_author\\">\\r\\n\\t\\t\\t\\t{#if author}\\r\\n\\t\\t\\t\\t\\t<input\\r\\n\\t\\t\\t\\t\\t\\tname=\\"author\\"\\r\\n\\t\\t\\t\\t\\t\\ton:change={handleChange}\\r\\n\\t\\t\\t\\t\\t\\tvalue={content.author}\\r\\n\\t\\t\\t\\t\\t\\tclass=\\"gray input-gray \\"\\r\\n\\t\\t\\t\\t\\t\\tplaceholder=\\"Enter author name\\"\\r\\n\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t<p class=\\"gray\\">.</p>\\r\\n\\t\\t\\t\\t\\t<input\\r\\n\\t\\t\\t\\t\\t\\tname=\\"postDate\\"\\r\\n\\t\\t\\t\\t\\t\\ton:change={handleChange}\\r\\n\\t\\t\\t\\t\\t\\tvalue={content.postDate}\\r\\n\\t\\t\\t\\t\\t\\tclass=\\"gray input-gray\\"\\r\\n\\t\\t\\t\\t\\t\\tplaceholder=\\"data\\"\\r\\n\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t<p class=\\"gray\\">(</p>\\r\\n\\t\\t\\t\\t\\t<input\\r\\n\\t\\t\\t\\t\\t\\tname=\\"readingTime\\"\\r\\n\\t\\t\\t\\t\\t\\ton:change={handleChange}\\r\\n\\t\\t\\t\\t\\t\\tvalue={content.readingTime}\\r\\n\\t\\t\\t\\t\\t\\tclass=\\"gray input-gray\\"\\r\\n\\t\\t\\t\\t\\t\\tplaceholder=\\"enter time\\"\\r\\n\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t<p class=\\"gray\\">)</p>\\r\\n\\t\\t\\t\\t\\t<button on:click={() => (author = false)} class=\\"button-edit-title\\">\\r\\n\\t\\t\\t\\t\\t\\t<svg\\r\\n\\t\\t\\t\\t\\t\\t\\twidth=\\"24\\"\\r\\n\\t\\t\\t\\t\\t\\t\\theight=\\"24\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tviewBox=\\"0 0 24 24\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tfill=\\"none\\"\\r\\n\\t\\t\\t\\t\\t\\t\\txmlns=\\"http://www.w3.org/2000/svg\\"\\r\\n\\t\\t\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tfill-rule=\\"evenodd\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tclip-rule=\\"evenodd\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\td=\\"M5 22C3.34315 22 2 20.6569 2 19V13C2 11.3431 3.34315 10 5 10H6.381L9.55279 3.65836C10.0311 2.70179 10.9794 2.07683 12.0366 2.00661L12.2361 2H12.5C13.8255 2 14.91 3.03154 14.9947 4.33562L15 4.5V10H18.9983C19.1958 10 19.3929 10.0195 19.5866 10.0583C21.1533 10.3716 22.1889 11.8524 21.9696 13.4145L21.94 13.5883L20.74 19.5883C20.4712 20.9322 19.3293 21.9152 17.9759 21.9948L17.7983 22H5ZM6 12H5C4.44772 12 4 12.4477 4 13V19C4 19.5523 4.44772 20 5 20H6V12ZM12.5 4H12.2361C11.8994 4 11.5884 4.16909 11.4045 4.4446L11.3416 4.55279L8.10557 11.0249C8.0535 11.1291 8.02015 11.2412 8.00673 11.3563L8 11.4721V20H17.7983C18.2352 20 18.6165 19.7173 18.749 19.3101L18.7788 19.1961L19.9788 13.1961C20.0872 12.6546 19.7359 12.1277 19.1944 12.0194L19.0968 12.0049L18.9983 12H15C13.9456 12 13.0818 11.1841 13.0055 10.1493L13 10V4.5C13 4.25454 12.8231 4.05039 12.5899 4.00806L12.5 4Z\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tfill=\\"black\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t\\t</svg>\\r\\n\\t\\t\\t\\t\\t</button>\\r\\n\\t\\t\\t\\t{:else}\\r\\n\\t\\t\\t\\t\\t<p class=\\"gray author-name\\">{content.author}</p>\\r\\n\\t\\t\\t\\t\\t<p class=\\"gray\\">.</p>\\r\\n\\t\\t\\t\\t\\t<p class=\\"gray post-time\\">{content.postDate}</p>\\r\\n\\t\\t\\t\\t\\t<p class=\\"gray read-time\\">({content.readingTime} min read)</p>\\r\\n\\t\\t\\t\\t\\t<button on:click={() => (author = true)} class=\\"button-edit-title\\">\\r\\n\\t\\t\\t\\t\\t\\t<svg\\r\\n\\t\\t\\t\\t\\t\\t\\twidth=\\"25\\"\\r\\n\\t\\t\\t\\t\\t\\t\\theight=\\"25\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tviewBox=\\"0 0 25 25\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tfill=\\"none\\"\\r\\n\\t\\t\\t\\t\\t\\t\\txmlns=\\"http://www.w3.org/2000/svg\\"\\r\\n\\t\\t\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\t\\t\\td=\\"M19.7 8.60004L8.9 19.4C8.8 19.5 8.80002 19.5 8.70002 19.5L6.20002 20.3L4.60001 20.8C4.20001 20.9 3.8 20.5 3.9 20.1L5.20002 16.1C5.20002 16 5.3 15.9 5.3 15.9L16.1 5.10004C17.1 4.10004 18.6 4.10004 19.6 5.10004C20.7 6.10004 20.7 7.60004 19.7 8.60004Z\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke=\\"#1A1A1A\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-width=\\"1.5\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-miterlimit=\\"10\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-linecap=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-linejoin=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\t\\t\\td=\\"M14.6 6.90002L18 10.3\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke=\\"#1A1A1A\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-width=\\"1.5\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-miterlimit=\\"10\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-linecap=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-linejoin=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t\\t</svg>\\r\\n\\t\\t\\t\\t\\t</button>\\r\\n\\t\\t\\t\\t{/if}\\r\\n\\t\\t\\t</div>\\r\\n\\t\\t\\t<div class=\\"tags gray\\">\\r\\n\\t\\t\\t\\t{#each content.tags as tag, i}\\r\\n\\t\\t\\t\\t\\t<p class=\\"gray tag\\">#{tag}</p>\\r\\n\\t\\t\\t\\t{/each}\\r\\n\\t\\t\\t\\t<input\\r\\n\\t\\t\\t\\t\\tvalue={content.tempTag}\\r\\n\\t\\t\\t\\t\\ton:change={handleChange}\\r\\n\\t\\t\\t\\t\\tname=\\"tempTag\\"\\r\\n\\t\\t\\t\\t\\tclass=\\"tag-input\\"\\r\\n\\t\\t\\t\\t\\tplaceholder=\\"Enter tag\\"\\r\\n\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t<button on:click={handleAddTag} class=\\"tag-button\\">\\r\\n\\t\\t\\t\\t\\t<svg\\r\\n\\t\\t\\t\\t\\t\\twidth=\\"24\\"\\r\\n\\t\\t\\t\\t\\t\\theight=\\"24\\"\\r\\n\\t\\t\\t\\t\\t\\tviewBox=\\"0 0 24 24\\"\\r\\n\\t\\t\\t\\t\\t\\tfill=\\"none\\"\\r\\n\\t\\t\\t\\t\\t\\txmlns=\\"http://www.w3.org/2000/svg\\"\\r\\n\\t\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\t\\td=\\"M12 8.3273V15.6537\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke=\\"#200E32\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke-width=\\"1.5\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke-linecap=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke-linejoin=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\t\\td=\\"M15.6667 11.9905H8.33334\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke=\\"#200E32\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke-width=\\"1.5\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke-linecap=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke-linejoin=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\t\\tfill-rule=\\"evenodd\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tclip-rule=\\"evenodd\\"\\r\\n\\t\\t\\t\\t\\t\\t\\td=\\"M16.6857 2H7.31429C4.04762 2 2 4.31208 2 7.58516V16.4148C2 19.6879 4.0381 22 7.31429 22H16.6857C19.9619 22 22 19.6879 22 16.4148V7.58516C22 4.31208 19.9619 2 16.6857 2Z\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke=\\"#200E32\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke-width=\\"1.5\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke-linecap=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke-linejoin=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t</svg>\\r\\n\\t\\t\\t\\t</button>\\r\\n\\t\\t\\t</div>\\r\\n\\t\\t\\t<div class=\\"post-body-text\\">\\r\\n\\t\\t\\t\\t{#each content.body as paragraph}\\r\\n\\t\\t\\t\\t\\t<p class=\\"post-body\\">{paragraph}</p>\\r\\n\\t\\t\\t\\t{/each}\\r\\n\\t\\t\\t\\t{#if bodyEdit}\\r\\n\\t\\t\\t\\t\\t<textarea\\r\\n\\t\\t\\t\\t\\t\\tvalue={content.paragraph}\\r\\n\\t\\t\\t\\t\\t\\tname=\\"paragraph\\"\\r\\n\\t\\t\\t\\t\\t\\ton:change={handleChange}\\r\\n\\t\\t\\t\\t\\t\\tclass=\\"post-body\\"\\r\\n\\t\\t\\t\\t\\t\\tplaceholder=\\"enter post content\\"\\r\\n\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t<button\\r\\n\\t\\t\\t\\t\\t\\ton:click={(e) => {\\r\\n\\t\\t\\t\\t\\t\\t\\tbodyEdit = false;\\r\\n\\t\\t\\t\\t\\t\\t\\thandleAddBodyPara(e);\\r\\n\\t\\t\\t\\t\\t\\t}}\\r\\n\\t\\t\\t\\t\\t\\tclass=\\"button-edit-title\\"\\r\\n\\t\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t\\t\\t<svg\\r\\n\\t\\t\\t\\t\\t\\t\\twidth=\\"24\\"\\r\\n\\t\\t\\t\\t\\t\\t\\theight=\\"24\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tviewBox=\\"0 0 24 24\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tfill=\\"none\\"\\r\\n\\t\\t\\t\\t\\t\\t\\txmlns=\\"http://www.w3.org/2000/svg\\"\\r\\n\\t\\t\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tfill-rule=\\"evenodd\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tclip-rule=\\"evenodd\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\td=\\"M5 22C3.34315 22 2 20.6569 2 19V13C2 11.3431 3.34315 10 5 10H6.381L9.55279 3.65836C10.0311 2.70179 10.9794 2.07683 12.0366 2.00661L12.2361 2H12.5C13.8255 2 14.91 3.03154 14.9947 4.33562L15 4.5V10H18.9983C19.1958 10 19.3929 10.0195 19.5866 10.0583C21.1533 10.3716 22.1889 11.8524 21.9696 13.4145L21.94 13.5883L20.74 19.5883C20.4712 20.9322 19.3293 21.9152 17.9759 21.9948L17.7983 22H5ZM6 12H5C4.44772 12 4 12.4477 4 13V19C4 19.5523 4.44772 20 5 20H6V12ZM12.5 4H12.2361C11.8994 4 11.5884 4.16909 11.4045 4.4446L11.3416 4.55279L8.10557 11.0249C8.0535 11.1291 8.02015 11.2412 8.00673 11.3563L8 11.4721V20H17.7983C18.2352 20 18.6165 19.7173 18.749 19.3101L18.7788 19.1961L19.9788 13.1961C20.0872 12.6546 19.7359 12.1277 19.1944 12.0194L19.0968 12.0049L18.9983 12H15C13.9456 12 13.0818 11.1841 13.0055 10.1493L13 10V4.5C13 4.25454 12.8231 4.05039 12.5899 4.00806L12.5 4Z\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tfill=\\"black\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t\\t</svg>\\r\\n\\t\\t\\t\\t\\t</button>\\r\\n\\t\\t\\t\\t{:else}\\r\\n\\t\\t\\t\\t\\t<button on:click={() => (bodyEdit = true)} class=\\"button-edit-title\\">\\r\\n\\t\\t\\t\\t\\t\\t<svg\\r\\n\\t\\t\\t\\t\\t\\t\\twidth=\\"25\\"\\r\\n\\t\\t\\t\\t\\t\\t\\theight=\\"25\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tviewBox=\\"0 0 25 25\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tfill=\\"none\\"\\r\\n\\t\\t\\t\\t\\t\\t\\txmlns=\\"http://www.w3.org/2000/svg\\"\\r\\n\\t\\t\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\t\\t\\td=\\"M19.7 8.60004L8.9 19.4C8.8 19.5 8.80002 19.5 8.70002 19.5L6.20002 20.3L4.60001 20.8C4.20001 20.9 3.8 20.5 3.9 20.1L5.20002 16.1C5.20002 16 5.3 15.9 5.3 15.9L16.1 5.10004C17.1 4.10004 18.6 4.10004 19.6 5.10004C20.7 6.10004 20.7 7.60004 19.7 8.60004Z\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke=\\"#1A1A1A\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-width=\\"1.5\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-miterlimit=\\"10\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-linecap=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-linejoin=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\t\\t\\td=\\"M14.6 6.90002L18 10.3\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke=\\"#1A1A1A\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-width=\\"1.5\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-miterlimit=\\"10\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-linecap=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-linejoin=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t\\t</svg>\\r\\n\\t\\t\\t\\t\\t</button>\\r\\n\\t\\t\\t\\t{/if}\\r\\n\\t\\t\\t</div>\\r\\n\\t\\t\\t<button on:click={handleSubmitPost} class=\\"submit-post-btn\\">Update Post</button>\\r\\n\\t\\t</div>\\r\\n\\t</div>\\r\\n\\r\\n\\t{#if isLoaderActive}\\r\\n\\t\\t<div class=\\"preloader\\">\\r\\n\\t\\t\\t<div class=\\"loadingio-spinner-bean-eater-3cordrlrc9\\">\\r\\n\\t\\t\\t\\t<div class=\\"ldio-mvluw7e021b\\">\\r\\n\\t\\t\\t\\t\\t<div>\\r\\n\\t\\t\\t\\t\\t\\t<div />\\r\\n\\t\\t\\t\\t\\t\\t<div />\\r\\n\\t\\t\\t\\t\\t\\t<div />\\r\\n\\t\\t\\t\\t\\t</div>\\r\\n\\t\\t\\t\\t\\t<div>\\r\\n\\t\\t\\t\\t\\t\\t<div />\\r\\n\\t\\t\\t\\t\\t\\t<div />\\r\\n\\t\\t\\t\\t\\t\\t<div />\\r\\n\\t\\t\\t\\t\\t</div>\\r\\n\\t\\t\\t\\t</div>\\r\\n\\t\\t\\t</div>\\r\\n\\t\\t</div>\\r\\n\\t{/if}\\r\\n</main>\\r\\n\\r\\n<style>\\r\\n\\t@import url('https://fonts.googleapis.com/css2?family=Libre+Baskerville:wght@400;700&display=swap');\\r\\n\\r\\n\\t* {\\r\\n\\t\\tfont-family: 'Libre Baskerville', serif;\\r\\n\\t}\\r\\n\\r\\n\\th1,\\r\\n\\tp {\\r\\n\\t\\tmargin: 0;\\r\\n\\t}\\r\\n\\r\\n\\tdiv {\\r\\n\\t\\tposition: relative;\\r\\n\\t}\\r\\n\\r\\n\\t.gray {\\r\\n\\t\\tcolor: rgba(28, 28, 28, 0.5);\\r\\n\\t\\tfont-size: 16px;\\r\\n\\t}\\r\\n\\r\\n\\t.tag {\\r\\n\\t\\tmargin-right: 5px;\\r\\n\\t}\\r\\n\\r\\n\\t.post-title {\\r\\n\\t\\tposition: relative;\\r\\n\\t\\ttext-align: center;\\r\\n\\t}\\r\\n\\r\\n\\t.button-edit-title {\\r\\n\\t\\tposition: absolute;\\r\\n\\t\\tright: 0;\\r\\n\\t\\ttop: calc(50% - 15px);\\r\\n\\t\\toutline: 0;\\r\\n\\t\\tborder: 0;\\r\\n\\t\\tbackground-color: inherit;\\r\\n\\t}\\r\\n\\r\\n\\t.read-time {\\r\\n\\t\\tfont-size: 14px;\\r\\n\\t}\\r\\n\\r\\n\\t.title {\\r\\n\\t\\tfont-size: 42px;\\r\\n\\t\\tfont-weight: 700;\\r\\n\\t\\ttext-align: center;\\r\\n\\t\\tmargin: 10px auto;\\r\\n\\t\\twidth: 600px;\\r\\n\\t}\\r\\n\\r\\n\\t.title-edit {\\r\\n\\t\\tfont-size: 42px;\\r\\n\\t}\\r\\n\\r\\n\\t.main {\\r\\n\\t\\tdisplay: grid;\\r\\n\\t\\theight: 100vh;\\r\\n\\t\\tgrid-template-columns: 225px calc(100vw - 225px);\\r\\n\\t\\tgrid-template-rows: 75px auto;\\r\\n\\t\\toverflow: hidden;\\r\\n\\t}\\r\\n\\r\\n\\t.post {\\r\\n\\t\\toverflow: hidden;\\r\\n\\t\\toverflow-y: scroll;\\r\\n\\t\\tpadding: 2em 0;\\r\\n\\t\\ttext-align: center;\\r\\n\\t}\\r\\n\\r\\n\\t.post-header_author {\\r\\n\\t\\tdisplay: flex;\\r\\n\\t\\talign-items: center;\\r\\n\\t\\tjustify-content: center;\\r\\n\\t\\tmargin: 1em 0;\\r\\n\\t}\\r\\n\\r\\n\\t.input-gray {\\r\\n\\t\\tpadding: 10px 5px;\\r\\n\\t\\tborder-radius: 5px;\\r\\n\\t\\toutline: 0;\\r\\n\\t\\tborder: 1px solid #000;\\r\\n\\t}\\r\\n\\r\\n\\t.tags {\\r\\n\\t\\tdisplay: flex;\\r\\n\\t\\talign-items: center;\\r\\n\\t\\tjustify-content: center;\\r\\n\\t\\tmargin: 1em 0;\\r\\n\\t}\\r\\n\\r\\n\\t.tag-input {\\r\\n\\t\\twidth: 70px;\\r\\n\\t\\toutline: 0;\\r\\n\\t\\tborder: 1px solid #000;\\r\\n\\t\\tborder-radius: 10px;\\r\\n\\t\\theight: 20px;\\r\\n\\t\\tpadding-left: 5px;\\r\\n\\t\\tmargin: 0 0 0 10px;\\r\\n\\t}\\r\\n\\r\\n\\t.tag-button {\\r\\n\\t\\tborder: 0;\\r\\n\\t\\toutline: 0;\\r\\n\\t\\tbackground-color: inherit;\\r\\n\\t}\\r\\n\\r\\n\\t.banner-container {\\r\\n\\t\\tposition: relative;\\r\\n\\t}\\r\\n\\r\\n\\t.banner {\\r\\n\\t\\theight: 500px;\\r\\n\\t}\\r\\n\\r\\n\\t#banner-upload {\\r\\n\\t\\twidth: 0;\\r\\n\\t\\theight: 0;\\r\\n\\t\\tpadding: 0;\\r\\n\\t\\tborder: 0;\\r\\n\\t\\toutline: 0;\\r\\n\\t}\\r\\n\\r\\n\\t.banner-label {\\r\\n\\t\\tposition: absolute;\\r\\n\\t\\tright: calc(50% - 27px);\\r\\n\\t\\ttop: calc(50% - 27px);\\r\\n\\t\\tpadding: 1em;\\r\\n\\t\\tbackground-color: #fff;\\r\\n\\t\\tborder-radius: 5px;\\r\\n\\t}\\r\\n\\r\\n\\t.banner-skeleton {\\r\\n\\t\\tbackground-color: rgb(239, 235, 235);\\r\\n\\t}\\r\\n\\r\\n\\t.post-body-text {\\r\\n\\t\\ttext-align: center;\\r\\n\\t\\tpadding: 2em 0;\\r\\n\\t}\\r\\n\\r\\n\\t.post-body {\\r\\n\\t\\twidth: 600px;\\r\\n\\t\\tpadding-bottom: 1.5em;\\r\\n\\t\\tmargin: 0 auto;\\r\\n\\t\\ttext-align: left;\\r\\n\\t\\tfont-size: 16px;\\r\\n\\t\\tline-height: 24px;\\r\\n\\t\\tfont-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell,\\r\\n\\t\\t\\t'Open Sans', 'Helvetica Neue', sans-serif;\\r\\n\\t}\\r\\n\\r\\n\\t.submit-post-btn {\\r\\n\\t\\tpadding: 1em 2em;\\r\\n\\t\\tborder-radius: 5px;\\r\\n\\t\\tbackground-color: inherit;\\r\\n\\t\\tfont-size: 18px;\\r\\n\\t\\tborder: 1.5px solid #000;\\r\\n\\t\\toutline: 0;\\r\\n\\t\\tfont-family: 'Libre Baskerville', serif;\\r\\n\\t\\tfont-weight: bolder;\\r\\n\\t}\\r\\n\\r\\n\\t.preloader {\\r\\n\\t\\theight: 100vh;\\r\\n\\t\\twidth: 100%;\\r\\n\\t\\tbackground-color: rgba(28, 28, 28, 0.5);\\r\\n\\t\\tposition: fixed;\\r\\n\\t\\ttop: 0;\\r\\n\\t\\tleft: 0;\\r\\n\\t\\tdisplay: flex;\\r\\n\\t\\talign-items: center;\\r\\n\\t\\tjustify-content: center;\\r\\n\\t}\\r\\n\\r\\n\\t@keyframes ldio-mvluw7e021b-1 {\\r\\n\\t\\t0% {\\r\\n\\t\\t\\ttransform: rotate(0deg);\\r\\n\\t\\t}\\r\\n\\t\\t50% {\\r\\n\\t\\t\\ttransform: rotate(-45deg);\\r\\n\\t\\t}\\r\\n\\t\\t100% {\\r\\n\\t\\t\\ttransform: rotate(0deg);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t@keyframes ldio-mvluw7e021b-2 {\\r\\n\\t\\t0% {\\r\\n\\t\\t\\ttransform: rotate(180deg);\\r\\n\\t\\t}\\r\\n\\t\\t50% {\\r\\n\\t\\t\\ttransform: rotate(225deg);\\r\\n\\t\\t}\\r\\n\\t\\t100% {\\r\\n\\t\\t\\ttransform: rotate(180deg);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t.ldio-mvluw7e021b > div:nth-child(2) {\\r\\n\\t\\ttransform: translate(-15px, 0);\\r\\n\\t}\\r\\n\\t.ldio-mvluw7e021b > div:nth-child(2) div {\\r\\n\\t\\tposition: absolute;\\r\\n\\t\\ttop: 40px;\\r\\n\\t\\tleft: 40px;\\r\\n\\t\\twidth: 120px;\\r\\n\\t\\theight: 60px;\\r\\n\\t\\tborder-radius: 120px 120px 0 0;\\r\\n\\t\\tbackground: #f8b26a;\\r\\n\\t\\tanimation: ldio-mvluw7e021b-1 1s linear infinite;\\r\\n\\t\\ttransform-origin: 60px 60px;\\r\\n\\t}\\r\\n\\t.ldio-mvluw7e021b > div:nth-child(2) div:nth-child(2) {\\r\\n\\t\\tanimation: ldio-mvluw7e021b-2 1s linear infinite;\\r\\n\\t}\\r\\n\\t.ldio-mvluw7e021b > div:nth-child(2) div:nth-child(3) {\\r\\n\\t\\ttransform: rotate(-90deg);\\r\\n\\t\\tanimation: none;\\r\\n\\t}\\r\\n\\t@keyframes ldio-mvluw7e021b-3 {\\r\\n\\t\\t0% {\\r\\n\\t\\t\\ttransform: translate(190px, 0);\\r\\n\\t\\t\\topacity: 0;\\r\\n\\t\\t}\\r\\n\\t\\t20% {\\r\\n\\t\\t\\topacity: 1;\\r\\n\\t\\t}\\r\\n\\t\\t100% {\\r\\n\\t\\t\\ttransform: translate(70px, 0);\\r\\n\\t\\t\\topacity: 1;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t.ldio-mvluw7e021b > div:nth-child(1) {\\r\\n\\t\\tdisplay: block;\\r\\n\\t}\\r\\n\\t.ldio-mvluw7e021b > div:nth-child(1) div {\\r\\n\\t\\tposition: absolute;\\r\\n\\t\\ttop: 92px;\\r\\n\\t\\tleft: -8px;\\r\\n\\t\\twidth: 16px;\\r\\n\\t\\theight: 16px;\\r\\n\\t\\tborder-radius: 50%;\\r\\n\\t\\tbackground: #e15b64;\\r\\n\\t\\tanimation: ldio-mvluw7e021b-3 1s linear infinite;\\r\\n\\t}\\r\\n\\t.ldio-mvluw7e021b > div:nth-child(1) div:nth-child(1) {\\r\\n\\t\\tanimation-delay: -0.67s;\\r\\n\\t}\\r\\n\\t.ldio-mvluw7e021b > div:nth-child(1) div:nth-child(2) {\\r\\n\\t\\tanimation-delay: -0.33s;\\r\\n\\t}\\r\\n\\t.ldio-mvluw7e021b > div:nth-child(1) div:nth-child(3) {\\r\\n\\t\\tanimation-delay: 0s;\\r\\n\\t}\\r\\n\\t.loadingio-spinner-bean-eater-3cordrlrc9 {\\r\\n\\t\\twidth: 200px;\\r\\n\\t\\theight: 200px;\\r\\n\\t\\tdisplay: inline-block;\\r\\n\\t\\toverflow: hidden;\\r\\n\\t\\tbackground: transparent;\\r\\n\\t}\\r\\n\\t.ldio-mvluw7e021b {\\r\\n\\t\\twidth: 100%;\\r\\n\\t\\theight: 100%;\\r\\n\\t\\tposition: relative;\\r\\n\\t\\ttransform: translateZ(0) scale(1);\\r\\n\\t\\tbackface-visibility: hidden;\\r\\n\\t\\ttransform-origin: 0 0; /* see note above */\\r\\n\\t}\\r\\n\\t.ldio-mvluw7e021b div {\\r\\n\\t\\tbox-sizing: content-box;\\r\\n\\t}\\r\\n\\t/* generated by https://loading.io/ */\\r\\n</style>\\r\\n"],"names":[],"mappings":"AAkYC,QAAQ,IAAI,sFAAsF,CAAC,CAAC,AAEpG,0CAAE,CAAC,AACF,WAAW,CAAE,mBAAmB,CAAC,CAAC,KAAK,AACxC,CAAC,AAED,4CAAE,CACF,CAAC,0CAAC,CAAC,AACF,MAAM,CAAE,CAAC,AACV,CAAC,AAED,GAAG,0CAAC,CAAC,AACJ,QAAQ,CAAE,QAAQ,AACnB,CAAC,AAED,KAAK,0CAAC,CAAC,AACN,KAAK,CAAE,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAC5B,SAAS,CAAE,IAAI,AAChB,CAAC,AAED,IAAI,0CAAC,CAAC,AACL,YAAY,CAAE,GAAG,AAClB,CAAC,AAED,WAAW,0CAAC,CAAC,AACZ,QAAQ,CAAE,QAAQ,CAClB,UAAU,CAAE,MAAM,AACnB,CAAC,AAED,kBAAkB,0CAAC,CAAC,AACnB,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,CAAC,CACR,GAAG,CAAE,KAAK,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,CACrB,OAAO,CAAE,CAAC,CACV,MAAM,CAAE,CAAC,CACT,gBAAgB,CAAE,OAAO,AAC1B,CAAC,AAED,UAAU,0CAAC,CAAC,AACX,SAAS,CAAE,IAAI,AAChB,CAAC,AAED,MAAM,0CAAC,CAAC,AACP,SAAS,CAAE,IAAI,CACf,WAAW,CAAE,GAAG,CAChB,UAAU,CAAE,MAAM,CAClB,MAAM,CAAE,IAAI,CAAC,IAAI,CACjB,KAAK,CAAE,KAAK,AACb,CAAC,AAED,WAAW,0CAAC,CAAC,AACZ,SAAS,CAAE,IAAI,AAChB,CAAC,AAED,KAAK,0CAAC,CAAC,AACN,OAAO,CAAE,IAAI,CACb,MAAM,CAAE,KAAK,CACb,qBAAqB,CAAE,KAAK,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAChD,kBAAkB,CAAE,IAAI,CAAC,IAAI,CAC7B,QAAQ,CAAE,MAAM,AACjB,CAAC,AAED,KAAK,0CAAC,CAAC,AACN,QAAQ,CAAE,MAAM,CAChB,UAAU,CAAE,MAAM,CAClB,OAAO,CAAE,GAAG,CAAC,CAAC,CACd,UAAU,CAAE,MAAM,AACnB,CAAC,AAED,mBAAmB,0CAAC,CAAC,AACpB,OAAO,CAAE,IAAI,CACb,WAAW,CAAE,MAAM,CACnB,eAAe,CAAE,MAAM,CACvB,MAAM,CAAE,GAAG,CAAC,CAAC,AACd,CAAC,AAED,WAAW,0CAAC,CAAC,AACZ,OAAO,CAAE,IAAI,CAAC,GAAG,CACjB,aAAa,CAAE,GAAG,CAClB,OAAO,CAAE,CAAC,CACV,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,AACvB,CAAC,AAED,KAAK,0CAAC,CAAC,AACN,OAAO,CAAE,IAAI,CACb,WAAW,CAAE,MAAM,CACnB,eAAe,CAAE,MAAM,CACvB,MAAM,CAAE,GAAG,CAAC,CAAC,AACd,CAAC,AAED,UAAU,0CAAC,CAAC,AACX,KAAK,CAAE,IAAI,CACX,OAAO,CAAE,CAAC,CACV,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,CACtB,aAAa,CAAE,IAAI,CACnB,MAAM,CAAE,IAAI,CACZ,YAAY,CAAE,GAAG,CACjB,MAAM,CAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,AACnB,CAAC,AAED,WAAW,0CAAC,CAAC,AACZ,MAAM,CAAE,CAAC,CACT,OAAO,CAAE,CAAC,CACV,gBAAgB,CAAE,OAAO,AAC1B,CAAC,AAED,iBAAiB,0CAAC,CAAC,AAClB,QAAQ,CAAE,QAAQ,AACnB,CAAC,AAED,OAAO,0CAAC,CAAC,AACR,MAAM,CAAE,KAAK,AACd,CAAC,AAED,cAAc,0CAAC,CAAC,AACf,KAAK,CAAE,CAAC,CACR,MAAM,CAAE,CAAC,CACT,OAAO,CAAE,CAAC,CACV,MAAM,CAAE,CAAC,CACT,OAAO,CAAE,CAAC,AACX,CAAC,AAED,aAAa,0CAAC,CAAC,AACd,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,KAAK,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,CACvB,GAAG,CAAE,KAAK,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,CACrB,OAAO,CAAE,GAAG,CACZ,gBAAgB,CAAE,IAAI,CACtB,aAAa,CAAE,GAAG,AACnB,CAAC,AAED,gBAAgB,0CAAC,CAAC,AACjB,gBAAgB,CAAE,IAAI,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,AACrC,CAAC,AAED,eAAe,0CAAC,CAAC,AAChB,UAAU,CAAE,MAAM,CAClB,OAAO,CAAE,GAAG,CAAC,CAAC,AACf,CAAC,AAED,UAAU,0CAAC,CAAC,AACX,KAAK,CAAE,KAAK,CACZ,cAAc,CAAE,KAAK,CACrB,MAAM,CAAE,CAAC,CAAC,IAAI,CACd,UAAU,CAAE,IAAI,CAChB,SAAS,CAAE,IAAI,CACf,WAAW,CAAE,IAAI,CACjB,WAAW,CAAE,aAAa,CAAC,CAAC,kBAAkB,CAAC,CAAC,UAAU,CAAC,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC;GAC7F,WAAW,CAAC,CAAC,gBAAgB,CAAC,CAAC,UAAU,AAC3C,CAAC,AAED,gBAAgB,0CAAC,CAAC,AACjB,OAAO,CAAE,GAAG,CAAC,GAAG,CAChB,aAAa,CAAE,GAAG,CAClB,gBAAgB,CAAE,OAAO,CACzB,SAAS,CAAE,IAAI,CACf,MAAM,CAAE,KAAK,CAAC,KAAK,CAAC,IAAI,CACxB,OAAO,CAAE,CAAC,CACV,WAAW,CAAE,mBAAmB,CAAC,CAAC,KAAK,CACvC,WAAW,CAAE,MAAM,AACpB,CAAC,AAED,UAAU,0CAAC,CAAC,AACX,MAAM,CAAE,KAAK,CACb,KAAK,CAAE,IAAI,CACX,gBAAgB,CAAE,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CACvC,QAAQ,CAAE,KAAK,CACf,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,CAAC,CACP,OAAO,CAAE,IAAI,CACb,WAAW,CAAE,MAAM,CACnB,eAAe,CAAE,MAAM,AACxB,CAAC,AAED,WAAW,gCAAmB,CAAC,AAC9B,EAAE,AAAC,CAAC,AACH,SAAS,CAAE,OAAO,IAAI,CAAC,AACxB,CAAC,AACD,GAAG,AAAC,CAAC,AACJ,SAAS,CAAE,OAAO,MAAM,CAAC,AAC1B,CAAC,AACD,IAAI,AAAC,CAAC,AACL,SAAS,CAAE,OAAO,IAAI,CAAC,AACxB,CAAC,AACF,CAAC,AACD,WAAW,gCAAmB,CAAC,AAC9B,EAAE,AAAC,CAAC,AACH,SAAS,CAAE,OAAO,MAAM,CAAC,AAC1B,CAAC,AACD,GAAG,AAAC,CAAC,AACJ,SAAS,CAAE,OAAO,MAAM,CAAC,AAC1B,CAAC,AACD,IAAI,AAAC,CAAC,AACL,SAAS,CAAE,OAAO,MAAM,CAAC,AAC1B,CAAC,AACF,CAAC,AACD,+BAAiB,CAAG,+BAAG,WAAW,CAAC,CAAC,AAAC,CAAC,AACrC,SAAS,CAAE,UAAU,KAAK,CAAC,CAAC,CAAC,CAAC,AAC/B,CAAC,AACD,+BAAiB,CAAG,iBAAG,WAAW,CAAC,CAAC,CAAC,GAAG,cAAC,CAAC,AACzC,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,IAAI,CACT,IAAI,CAAE,IAAI,CACV,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,IAAI,CACZ,aAAa,CAAE,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAC9B,UAAU,CAAE,OAAO,CACnB,SAAS,CAAE,gCAAkB,CAAC,EAAE,CAAC,MAAM,CAAC,QAAQ,CAChD,gBAAgB,CAAE,IAAI,CAAC,IAAI,AAC5B,CAAC,AACD,+BAAiB,CAAG,iBAAG,WAAW,CAAC,CAAC,CAAC,iBAAG,WAAW,CAAC,CAAC,AAAC,CAAC,AACtD,SAAS,CAAE,gCAAkB,CAAC,EAAE,CAAC,MAAM,CAAC,QAAQ,AACjD,CAAC,AACD,+BAAiB,CAAG,iBAAG,WAAW,CAAC,CAAC,CAAC,iBAAG,WAAW,CAAC,CAAC,AAAC,CAAC,AACtD,SAAS,CAAE,OAAO,MAAM,CAAC,CACzB,SAAS,CAAE,IAAI,AAChB,CAAC,AACD,WAAW,gCAAmB,CAAC,AAC9B,EAAE,AAAC,CAAC,AACH,SAAS,CAAE,UAAU,KAAK,CAAC,CAAC,CAAC,CAAC,CAC9B,OAAO,CAAE,CAAC,AACX,CAAC,AACD,GAAG,AAAC,CAAC,AACJ,OAAO,CAAE,CAAC,AACX,CAAC,AACD,IAAI,AAAC,CAAC,AACL,SAAS,CAAE,UAAU,IAAI,CAAC,CAAC,CAAC,CAAC,CAC7B,OAAO,CAAE,CAAC,AACX,CAAC,AACF,CAAC,AACD,+BAAiB,CAAG,+BAAG,WAAW,CAAC,CAAC,AAAC,CAAC,AACrC,OAAO,CAAE,KAAK,AACf,CAAC,AACD,+BAAiB,CAAG,iBAAG,WAAW,CAAC,CAAC,CAAC,GAAG,cAAC,CAAC,AACzC,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,IAAI,CACT,IAAI,CAAE,IAAI,CACV,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,aAAa,CAAE,GAAG,CAClB,UAAU,CAAE,OAAO,CACnB,SAAS,CAAE,gCAAkB,CAAC,EAAE,CAAC,MAAM,CAAC,QAAQ,AACjD,CAAC,AACD,+BAAiB,CAAG,iBAAG,WAAW,CAAC,CAAC,CAAC,iBAAG,WAAW,CAAC,CAAC,AAAC,CAAC,AACtD,eAAe,CAAE,MAAM,AACxB,CAAC,AACD,+BAAiB,CAAG,iBAAG,WAAW,CAAC,CAAC,CAAC,iBAAG,WAAW,CAAC,CAAC,AAAC,CAAC,AACtD,eAAe,CAAE,MAAM,AACxB,CAAC,AACD,+BAAiB,CAAG,iBAAG,WAAW,CAAC,CAAC,CAAC,iBAAG,WAAW,CAAC,CAAC,AAAC,CAAC,AACtD,eAAe,CAAE,EAAE,AACpB,CAAC,AACD,wCAAwC,0CAAC,CAAC,AACzC,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,CACb,OAAO,CAAE,YAAY,CACrB,QAAQ,CAAE,MAAM,CAChB,UAAU,CAAE,WAAW,AACxB,CAAC,AACD,iBAAiB,0CAAC,CAAC,AAClB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,QAAQ,CAAE,QAAQ,CAClB,SAAS,CAAE,WAAW,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CACjC,mBAAmB,CAAE,MAAM,CAC3B,gBAAgB,CAAE,CAAC,CAAC,CAAC,AACtB,CAAC,AACD,+BAAiB,CAAC,GAAG,4BAAC,CAAC,AACtB,UAAU,CAAE,WAAW,AACxB,CAAC"}`
};
async function load$1({ page, fetch: fetch2, session, stuff }) {
  return { props: { postId: page.params.slug } };
}
var U5Bslugu5D = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { postId } = $$props;
  console.log(postId);
  let content = {
    title: "Enter title of the page here",
    author: "Aslam",
    readingTime: "10",
    postDate: "October 18, 2021",
    body: [],
    tags: [],
    tempTag: "",
    paragraph: "",
    featured: false
  };
  let postData;
  if ($$props.postId === void 0 && $$bindings.postId && postId !== void 0)
    $$bindings.postId(postId);
  $$result.css.add(css$5);
  {
    console.log(postData);
  }
  return `<main class="${"main svelte-qktyk1"}">${validate_component(Dashboard_sidebar, "Sidebar").$$render($$result, { active: "write-a-post" }, {}, {})}
	${validate_component(Dashboard_navbar, "Navbar").$$render($$result, { active: "" }, {}, {})}
	<div class="${"post svelte-qktyk1"}"><div class="${"banner-container svelte-qktyk1"}">${`<div class="${"banner-skeleton banner  svelte-qktyk1"}"></div>`}
			<input id="${"banner-upload"}" type="${"file"}" class="${"svelte-qktyk1"}">
			<label class="${"banner-label svelte-qktyk1"}" for="${"banner-upload"}"><svg width="${"54"}" height="${"54"}" viewBox="${"0 0 24 24"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}" class="${"svelte-qktyk1"}"><path fill-rule="${"evenodd"}" clip-rule="${"evenodd"}" d="${"M15.2411 2.24464L20.2916 7.55623C20.4252 7.69717 20.5 7.88443 20.5 8.07973V17.4435C20.5 19.9553 18.4971 22 16.0337 22H8.07002C5.46399 22 3.5 20.0409 3.5 17.4435V14.9206C3.5 14.5038 3.83498 14.1655 4.24771 14.1655C4.66045 14.1655 4.99543 14.5038 4.99543 14.9206V17.4435C4.99543 19.2083 6.28847 20.4899 8.07002 20.4899H16.0337C17.6726 20.4899 19.0046 19.1227 19.0046 17.4435V8.38276L15.1873 4.36887V5.68569C15.1873 6.69647 16.0018 7.51998 17.0027 7.522C17.4154 7.523 17.7494 7.86127 17.7484 8.27907C17.7474 8.69486 17.4134 9.03211 17.0007 9.03211H16.9997C15.1763 9.02809 13.6918 7.52703 13.6918 5.68569V3.5222H8.07002C6.40312 3.5222 4.99543 4.8954 4.99543 6.52129V10.8161C4.99543 11.2329 4.66045 11.5711 4.24771 11.5711C3.83498 11.5711 3.5 11.2329 3.5 10.8161V6.52129C3.5 4.07692 5.5926 2.01208 8.07002 2.01208H14.3817C14.3913 2.01116 14.4 2.00855 14.4086 2.006C14.4188 2.00296 14.4287 2 14.4395 2C14.4512 2 14.4616 2.00313 14.472 2.00624C14.4803 2.00872 14.4885 2.01119 14.4974 2.01208H14.7017C14.9051 2.01208 15.0995 2.09564 15.2411 2.24464ZM11.0698 10.5214C11.0698 10.1046 11.4048 9.76633 11.8176 9.76633C12.2303 9.76633 12.5653 10.1046 12.5653 10.5214V12.2339H14.2611C14.6738 12.2339 15.0088 12.5721 15.0088 12.9889C15.0088 13.4057 14.6738 13.744 14.2611 13.744H12.5653V15.4555C12.5653 15.8722 12.2303 16.2105 11.8176 16.2105C11.4048 16.2105 11.0698 15.8722 11.0698 15.4555V13.744H9.37503C8.96229 13.744 8.62732 13.4057 8.62732 12.9889C8.62732 12.5721 8.96229 12.2339 9.37503 12.2339H11.0698V10.5214Z"}" fill="${"#200E32"}" class="${"svelte-qktyk1"}"></path></svg></label></div>
		<div class="${"post-header svelte-qktyk1"}"><div class="${"post-title svelte-qktyk1"}">${`<h1 class="${"title svelte-qktyk1"}">${escape(content.title)}</h1>
					<button class="${"button-edit-title svelte-qktyk1"}"><svg width="${"25"}" height="${"25"}" viewBox="${"0 0 25 25"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}" class="${"svelte-qktyk1"}"><path d="${"M19.7 8.60004L8.9 19.4C8.8 19.5 8.80002 19.5 8.70002 19.5L6.20002 20.3L4.60001 20.8C4.20001 20.9 3.8 20.5 3.9 20.1L5.20002 16.1C5.20002 16 5.3 15.9 5.3 15.9L16.1 5.10004C17.1 4.10004 18.6 4.10004 19.6 5.10004C20.7 6.10004 20.7 7.60004 19.7 8.60004Z"}" stroke="${"#1A1A1A"}" stroke-width="${"1.5"}" stroke-miterlimit="${"10"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-qktyk1"}"></path><path d="${"M14.6 6.90002L18 10.3"}" stroke="${"#1A1A1A"}" stroke-width="${"1.5"}" stroke-miterlimit="${"10"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-qktyk1"}"></path></svg></button>`}</div>
			<div class="${"post-header_author svelte-qktyk1"}">${`<p class="${"gray author-name svelte-qktyk1"}">${escape(content.author)}</p>
					<p class="${"gray svelte-qktyk1"}">.</p>
					<p class="${"gray post-time svelte-qktyk1"}">${escape(content.postDate)}</p>
					<p class="${"gray read-time svelte-qktyk1"}">(${escape(content.readingTime)} min read)</p>
					<button class="${"button-edit-title svelte-qktyk1"}"><svg width="${"25"}" height="${"25"}" viewBox="${"0 0 25 25"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}" class="${"svelte-qktyk1"}"><path d="${"M19.7 8.60004L8.9 19.4C8.8 19.5 8.80002 19.5 8.70002 19.5L6.20002 20.3L4.60001 20.8C4.20001 20.9 3.8 20.5 3.9 20.1L5.20002 16.1C5.20002 16 5.3 15.9 5.3 15.9L16.1 5.10004C17.1 4.10004 18.6 4.10004 19.6 5.10004C20.7 6.10004 20.7 7.60004 19.7 8.60004Z"}" stroke="${"#1A1A1A"}" stroke-width="${"1.5"}" stroke-miterlimit="${"10"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-qktyk1"}"></path><path d="${"M14.6 6.90002L18 10.3"}" stroke="${"#1A1A1A"}" stroke-width="${"1.5"}" stroke-miterlimit="${"10"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-qktyk1"}"></path></svg></button>`}</div>
			<div class="${"tags gray svelte-qktyk1"}">${each(content.tags, (tag, i) => `<p class="${"gray tag svelte-qktyk1"}">#${escape(tag)}</p>`)}
				<input${add_attribute("value", content.tempTag, 0)} name="${"tempTag"}" class="${"tag-input svelte-qktyk1"}" placeholder="${"Enter tag"}">
				<button class="${"tag-button svelte-qktyk1"}"><svg width="${"24"}" height="${"24"}" viewBox="${"0 0 24 24"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}" class="${"svelte-qktyk1"}"><path d="${"M12 8.3273V15.6537"}" stroke="${"#200E32"}" stroke-width="${"1.5"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-qktyk1"}"></path><path d="${"M15.6667 11.9905H8.33334"}" stroke="${"#200E32"}" stroke-width="${"1.5"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-qktyk1"}"></path><path fill-rule="${"evenodd"}" clip-rule="${"evenodd"}" d="${"M16.6857 2H7.31429C4.04762 2 2 4.31208 2 7.58516V16.4148C2 19.6879 4.0381 22 7.31429 22H16.6857C19.9619 22 22 19.6879 22 16.4148V7.58516C22 4.31208 19.9619 2 16.6857 2Z"}" stroke="${"#200E32"}" stroke-width="${"1.5"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-qktyk1"}"></path></svg></button></div>
			<div class="${"post-body-text svelte-qktyk1"}">${each(content.body, (paragraph) => `<p class="${"post-body svelte-qktyk1"}">${escape(paragraph)}</p>`)}
				${`<button class="${"button-edit-title svelte-qktyk1"}"><svg width="${"25"}" height="${"25"}" viewBox="${"0 0 25 25"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}" class="${"svelte-qktyk1"}"><path d="${"M19.7 8.60004L8.9 19.4C8.8 19.5 8.80002 19.5 8.70002 19.5L6.20002 20.3L4.60001 20.8C4.20001 20.9 3.8 20.5 3.9 20.1L5.20002 16.1C5.20002 16 5.3 15.9 5.3 15.9L16.1 5.10004C17.1 4.10004 18.6 4.10004 19.6 5.10004C20.7 6.10004 20.7 7.60004 19.7 8.60004Z"}" stroke="${"#1A1A1A"}" stroke-width="${"1.5"}" stroke-miterlimit="${"10"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-qktyk1"}"></path><path d="${"M14.6 6.90002L18 10.3"}" stroke="${"#1A1A1A"}" stroke-width="${"1.5"}" stroke-miterlimit="${"10"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-qktyk1"}"></path></svg></button>`}</div>
			<button class="${"submit-post-btn svelte-qktyk1"}">Update Post</button></div></div>

	${``}
</main>`;
});
var _slug_ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": U5Bslugu5D,
  load: load$1
});
var css$4 = {
  code: "@import url('https://fonts.googleapis.com/css2?family=Libre+Baskerville:wght@400;700&display=swap');.svelte-1bo7sn4.svelte-1bo7sn4.svelte-1bo7sn4{font-family:'Libre Baskerville', serif}h1.svelte-1bo7sn4.svelte-1bo7sn4.svelte-1bo7sn4,p.svelte-1bo7sn4.svelte-1bo7sn4.svelte-1bo7sn4{margin:0}div.svelte-1bo7sn4.svelte-1bo7sn4.svelte-1bo7sn4{position:relative}.gray.svelte-1bo7sn4.svelte-1bo7sn4.svelte-1bo7sn4{color:rgba(28, 28, 28, 0.5);font-size:16px}.tag.svelte-1bo7sn4.svelte-1bo7sn4.svelte-1bo7sn4{margin-right:5px}.post-top-icons.svelte-1bo7sn4.svelte-1bo7sn4.svelte-1bo7sn4{display:flex;justify-content:flex-end;align-items:center;padding:5px 0}.btn.svelte-1bo7sn4.svelte-1bo7sn4.svelte-1bo7sn4{margin:0 5px;border:0;outline:0;background-color:transparent}.post-title.svelte-1bo7sn4.svelte-1bo7sn4.svelte-1bo7sn4{position:relative;text-align:center}.button-edit-title.svelte-1bo7sn4.svelte-1bo7sn4.svelte-1bo7sn4{position:absolute;right:0;top:calc(50% - 15px);outline:0;border:0;background-color:inherit}.read-time.svelte-1bo7sn4.svelte-1bo7sn4.svelte-1bo7sn4{font-size:14px}.title.svelte-1bo7sn4.svelte-1bo7sn4.svelte-1bo7sn4{font-size:42px;font-weight:700;text-align:center;margin:10px auto;width:600px}.title-edit.svelte-1bo7sn4.svelte-1bo7sn4.svelte-1bo7sn4{font-size:42px}.main.svelte-1bo7sn4.svelte-1bo7sn4.svelte-1bo7sn4{display:grid;height:100vh;grid-template-columns:225px calc(100vw - 225px);grid-template-rows:75px auto;overflow:hidden}.post.svelte-1bo7sn4.svelte-1bo7sn4.svelte-1bo7sn4{overflow:hidden;overflow-y:scroll;padding:2em 0;text-align:center}.post-header_author.svelte-1bo7sn4.svelte-1bo7sn4.svelte-1bo7sn4{display:flex;align-items:center;justify-content:center;margin:1em 0}.input-gray.svelte-1bo7sn4.svelte-1bo7sn4.svelte-1bo7sn4{padding:10px 5px;border-radius:5px;outline:0;border:1px solid #000}.tags.svelte-1bo7sn4.svelte-1bo7sn4.svelte-1bo7sn4{display:flex;align-items:center;justify-content:center;margin:1em 0}.tag-input.svelte-1bo7sn4.svelte-1bo7sn4.svelte-1bo7sn4{width:70px;outline:0;border:1px solid #000;border-radius:10px;height:20px;padding-left:5px;margin:0 0 0 10px}.tag-button.svelte-1bo7sn4.svelte-1bo7sn4.svelte-1bo7sn4{border:0;outline:0;background-color:inherit}.banner-container.svelte-1bo7sn4.svelte-1bo7sn4.svelte-1bo7sn4{position:relative}.banner.svelte-1bo7sn4.svelte-1bo7sn4.svelte-1bo7sn4{height:500px}#banner-upload.svelte-1bo7sn4.svelte-1bo7sn4.svelte-1bo7sn4{width:0;height:0;padding:0;border:0;outline:0}.banner-label.svelte-1bo7sn4.svelte-1bo7sn4.svelte-1bo7sn4{position:absolute;right:calc(50% - 27px);top:calc(50% - 27px);padding:1em;background-color:#fff;border-radius:5px}.banner-skeleton.svelte-1bo7sn4.svelte-1bo7sn4.svelte-1bo7sn4{background-color:rgb(239, 235, 235)}.post-body-text.svelte-1bo7sn4.svelte-1bo7sn4.svelte-1bo7sn4{text-align:center;padding:2em 0}.post-body.svelte-1bo7sn4.svelte-1bo7sn4.svelte-1bo7sn4{width:600px;padding-bottom:1.5em;margin:0 auto;text-align:left;font-size:16px;line-height:24px;font-family:-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell,\r\n			'Open Sans', 'Helvetica Neue', sans-serif}.submit-post-btn.svelte-1bo7sn4.svelte-1bo7sn4.svelte-1bo7sn4{padding:1em 2em;border-radius:5px;background-color:inherit;font-size:18px;border:1.5px solid #000;outline:0;font-family:'Libre Baskerville', serif;font-weight:bolder}.preloader.svelte-1bo7sn4.svelte-1bo7sn4.svelte-1bo7sn4{height:100vh;width:100%;background-color:rgba(28, 28, 28, 0.5);position:fixed;top:0;left:0;display:flex;align-items:center;justify-content:center}@keyframes svelte-1bo7sn4-ldio-mvluw7e021b-1{0%{transform:rotate(0deg)}50%{transform:rotate(-45deg)}100%{transform:rotate(0deg)}}@keyframes svelte-1bo7sn4-ldio-mvluw7e021b-2{0%{transform:rotate(180deg)}50%{transform:rotate(225deg)}100%{transform:rotate(180deg)}}.ldio-mvluw7e021b.svelte-1bo7sn4>div.svelte-1bo7sn4.svelte-1bo7sn4:nth-child(2){transform:translate(-15px, 0)}.ldio-mvluw7e021b.svelte-1bo7sn4>div.svelte-1bo7sn4:nth-child(2) div.svelte-1bo7sn4{position:absolute;top:40px;left:40px;width:120px;height:60px;border-radius:120px 120px 0 0;background:#f8b26a;animation:svelte-1bo7sn4-ldio-mvluw7e021b-1 1s linear infinite;transform-origin:60px 60px}.ldio-mvluw7e021b.svelte-1bo7sn4>div.svelte-1bo7sn4:nth-child(2) div.svelte-1bo7sn4:nth-child(2){animation:svelte-1bo7sn4-ldio-mvluw7e021b-2 1s linear infinite}.ldio-mvluw7e021b.svelte-1bo7sn4>div.svelte-1bo7sn4:nth-child(2) div.svelte-1bo7sn4:nth-child(3){transform:rotate(-90deg);animation:none}@keyframes svelte-1bo7sn4-ldio-mvluw7e021b-3{0%{transform:translate(190px, 0);opacity:0}20%{opacity:1}100%{transform:translate(70px, 0);opacity:1}}.ldio-mvluw7e021b.svelte-1bo7sn4>div.svelte-1bo7sn4.svelte-1bo7sn4:nth-child(1){display:block}.ldio-mvluw7e021b.svelte-1bo7sn4>div.svelte-1bo7sn4:nth-child(1) div.svelte-1bo7sn4{position:absolute;top:92px;left:-8px;width:16px;height:16px;border-radius:50%;background:#e15b64;animation:svelte-1bo7sn4-ldio-mvluw7e021b-3 1s linear infinite}.ldio-mvluw7e021b.svelte-1bo7sn4>div.svelte-1bo7sn4:nth-child(1) div.svelte-1bo7sn4:nth-child(1){animation-delay:-0.67s}.ldio-mvluw7e021b.svelte-1bo7sn4>div.svelte-1bo7sn4:nth-child(1) div.svelte-1bo7sn4:nth-child(2){animation-delay:-0.33s}.ldio-mvluw7e021b.svelte-1bo7sn4>div.svelte-1bo7sn4:nth-child(1) div.svelte-1bo7sn4:nth-child(3){animation-delay:0s}.loadingio-spinner-bean-eater-3cordrlrc9.svelte-1bo7sn4.svelte-1bo7sn4.svelte-1bo7sn4{width:200px;height:200px;display:inline-block;overflow:hidden;background:transparent}.ldio-mvluw7e021b.svelte-1bo7sn4.svelte-1bo7sn4.svelte-1bo7sn4{width:100%;height:100%;position:relative;transform:translateZ(0) scale(1);backface-visibility:hidden;transform-origin:0 0}.ldio-mvluw7e021b.svelte-1bo7sn4 div.svelte-1bo7sn4.svelte-1bo7sn4{box-sizing:content-box}",
  map: `{"version":3,"file":"writepost.svelte","sources":["writepost.svelte"],"sourcesContent":["<script lang=\\"ts\\">import Sidebar from '../../components/dashboard.sidebar.svelte';\\r\\nimport Navbar from '../../components/dashboard.navbar.svelte';\\r\\nimport { submitPost } from '../../utils/firebase.apis';\\r\\nlet banner = null;\\r\\nlet titleEdit = false;\\r\\nlet bodyEdit = false;\\r\\nlet author = false;\\r\\nlet isLoaderActive = false;\\r\\nlet content = {\\r\\n    title: 'Enter title of the page here',\\r\\n    author: 'Aslam',\\r\\n    readingTime: '10',\\r\\n    postDate: 'October 18, 2021',\\r\\n    body: [],\\r\\n    tags: [],\\r\\n    tempTag: '',\\r\\n    paragraph: '',\\r\\n    featured: false,\\r\\n    editorsPick: false\\r\\n};\\r\\nlet bannerImage;\\r\\nlet textRef;\\r\\nfunction handleBanner(e) {\\r\\n    const file = e.target.files[0];\\r\\n    bannerImage = file;\\r\\n    banner = URL.createObjectURL(file);\\r\\n}\\r\\nfunction handleChange(e) {\\r\\n    const { name, value } = e.target;\\r\\n    content[name] = value;\\r\\n}\\r\\nfunction handleAddTag() {\\r\\n    if (content.tempTag !== '') {\\r\\n        content.tags.push(content.tempTag);\\r\\n        content.tempTag = '';\\r\\n    }\\r\\n}\\r\\nfunction handleAddBodyPara(e) {\\r\\n    if (content.paragraph !== '') {\\r\\n        content.body.push(content.paragraph);\\r\\n        content.paragraph = '';\\r\\n    }\\r\\n}\\r\\nfunction handleEditorsPick() {\\r\\n    content = { ...content, editorsPick: !content.editorsPick };\\r\\n}\\r\\nfunction handleFeatured() {\\r\\n    content = { ...content, featured: !content.featured };\\r\\n}\\r\\nasync function handleSubmitPost(e) {\\r\\n    isLoaderActive = true;\\r\\n    const api = await submitPost(content, bannerImage);\\r\\n    (await api) && (isLoaderActive = false);\\r\\n    (await api) &&\\r\\n        (content = {\\r\\n            ...content,\\r\\n            title: 'Enter title of the page here',\\r\\n            author: 'Aslam',\\r\\n            readingTime: '10',\\r\\n            postDate: 'October 18, 2021',\\r\\n            body: [],\\r\\n            tags: [],\\r\\n            tempTag: '',\\r\\n            paragraph: '',\\r\\n            editorsPick: false\\r\\n        });\\r\\n    (await api) && (bannerImage = null);\\r\\n}\\r\\n<\/script>\\r\\n\\r\\n<main class=\\"main\\">\\r\\n\\t<Sidebar active=\\"write-a-post\\" />\\r\\n\\t<Navbar active=\\"\\" />\\r\\n\\t<div class=\\"post\\">\\r\\n\\t\\t<div class=\\"post-top-icons\\">\\r\\n\\t\\t\\t<button on:click={handleEditorsPick} class=\\"editors-pick btn\\">\\r\\n\\t\\t\\t\\t<svg\\r\\n\\t\\t\\t\\t\\twidth=\\"29\\"\\r\\n\\t\\t\\t\\t\\theight=\\"29\\"\\r\\n\\t\\t\\t\\t\\tviewBox=\\"0 0 24 24\\"\\r\\n\\t\\t\\t\\t\\tfill=\\"none\\"\\r\\n\\t\\t\\t\\t\\txmlns=\\"http://www.w3.org/2000/svg\\"\\r\\n\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\tstroke-width=\\"0.5\\"\\r\\n\\t\\t\\t\\t\\t\\tstroke=\\"#000\\"\\r\\n\\t\\t\\t\\t\\t\\td=\\"M17.9185 14.3201C17.6595 14.5711 17.5405 14.9341 17.5995 15.2901L18.4885 20.2101C18.5635 20.6271 18.3875 21.0491 18.0385 21.2901C17.6965 21.5401 17.2415 21.5701 16.8685 21.3701L12.4395 19.0601C12.2855 18.9781 12.1145 18.9341 11.9395 18.9291H11.6685C11.5745 18.9431 11.4825 18.9731 11.3985 19.0191L6.96851 21.3401C6.74951 21.4501 6.50151 21.4891 6.25851 21.4501C5.66651 21.3381 5.27151 20.7741 5.36851 20.1791L6.25851 15.2591C6.31751 14.9001 6.19851 14.5351 5.93951 14.2801L2.32851 10.7801C2.02651 10.4871 1.92151 10.0471 2.05951 9.65009C2.19351 9.25409 2.53551 8.96509 2.94851 8.90009L7.91851 8.17909C8.29651 8.14009 8.62851 7.91009 8.79851 7.57009L10.9885 3.08009C11.0405 2.98009 11.1075 2.88809 11.1885 2.81009L11.2785 2.74009C11.3255 2.68809 11.3795 2.64509 11.4395 2.61009L11.5485 2.57009L11.7185 2.50009H12.1395C12.5155 2.53909 12.8465 2.76409 13.0195 3.10009L15.2385 7.57009C15.3985 7.89709 15.7095 8.12409 16.0685 8.17909L21.0385 8.90009C21.4585 8.96009 21.8095 9.25009 21.9485 9.65009C22.0795 10.0511 21.9665 10.4911 21.6585 10.7801L17.9185 14.3201Z\\"\\r\\n\\t\\t\\t\\t\\t\\tfill={content.editorsPick ? 'yellow' : '#fff'}\\r\\n\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t</svg>\\r\\n\\t\\t\\t</button>\\r\\n\\t\\t\\t<button on:click={handleFeatured} class=\\"btn featured\\">\\r\\n\\t\\t\\t\\t<svg\\r\\n\\t\\t\\t\\t\\twidth=\\"29\\"\\r\\n\\t\\t\\t\\t\\theight=\\"29\\"\\r\\n\\t\\t\\t\\t\\tviewBox=\\"0 0 24 24\\"\\r\\n\\t\\t\\t\\t\\tfill=\\"none\\"\\r\\n\\t\\t\\t\\t\\txmlns=\\"http://www.w3.org/2000/svg\\"\\r\\n\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\tfill-rule=\\"evenodd\\"\\r\\n\\t\\t\\t\\t\\t\\tclip-rule=\\"evenodd\\"\\r\\n\\t\\t\\t\\t\\t\\tstroke-width=\\"1\\"\\r\\n\\t\\t\\t\\t\\t\\tstroke=\\"#000\\"\\r\\n\\t\\t\\t\\t\\t\\td=\\"M15.8498 2.50071C16.4808 2.50071 17.1108 2.58971 17.7098 2.79071C21.4008 3.99071 22.7308 8.04071 21.6198 11.5807C20.9898 13.3897 19.9598 15.0407 18.6108 16.3897C16.6798 18.2597 14.5608 19.9197 12.2798 21.3497L12.0298 21.5007L11.7698 21.3397C9.4808 19.9197 7.3498 18.2597 5.4008 16.3797C4.0608 15.0307 3.0298 13.3897 2.3898 11.5807C1.2598 8.04071 2.5898 3.99071 6.3208 2.76971C6.6108 2.66971 6.9098 2.59971 7.2098 2.56071H7.3298C7.6108 2.51971 7.8898 2.50071 8.1698 2.50071H8.2798C8.9098 2.51971 9.5198 2.62971 10.1108 2.83071H10.1698C10.2098 2.84971 10.2398 2.87071 10.2598 2.88971C10.4808 2.96071 10.6898 3.04071 10.8898 3.15071L11.2698 3.32071C11.3616 3.36968 11.4647 3.44451 11.5538 3.50918C11.6102 3.55015 11.661 3.58705 11.6998 3.61071C11.7161 3.62034 11.7327 3.63002 11.7494 3.63978C11.8352 3.68983 11.9245 3.74197 11.9998 3.79971C13.1108 2.95071 14.4598 2.49071 15.8498 2.50071ZM18.5098 9.70071C18.9198 9.68971 19.2698 9.36071 19.2998 8.93971V8.82071C19.3298 7.41971 18.4808 6.15071 17.1898 5.66071C16.7798 5.51971 16.3298 5.74071 16.1798 6.16071C16.0398 6.58071 16.2598 7.04071 16.6798 7.18971C17.3208 7.42971 17.7498 8.06071 17.7498 8.75971V8.79071C17.7308 9.01971 17.7998 9.24071 17.9398 9.41071C18.0798 9.58071 18.2898 9.67971 18.5098 9.70071Z\\"\\r\\n\\t\\t\\t\\t\\t\\tfill={content.featured ? 'red' : '#fff'}\\r\\n\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t</svg>\\r\\n\\t\\t\\t</button>\\r\\n\\t\\t</div>\\r\\n\\t\\t<div class=\\"banner-container\\">\\r\\n\\t\\t\\t{#if banner}\\r\\n\\t\\t\\t\\t<img class=\\"banner-img banner\\" src={banner} alt=\\"banner\\" />\\r\\n\\t\\t\\t{:else}\\r\\n\\t\\t\\t\\t<div class=\\"banner-skeleton banner \\" />\\r\\n\\t\\t\\t{/if}\\r\\n\\t\\t\\t<input on:change={handleBanner} id=\\"banner-upload\\" type=\\"file\\" />\\r\\n\\t\\t\\t<label class=\\"banner-label\\" for=\\"banner-upload\\">\\r\\n\\t\\t\\t\\t<svg\\r\\n\\t\\t\\t\\t\\twidth=\\"54\\"\\r\\n\\t\\t\\t\\t\\theight=\\"54\\"\\r\\n\\t\\t\\t\\t\\tviewBox=\\"0 0 24 24\\"\\r\\n\\t\\t\\t\\t\\tfill=\\"none\\"\\r\\n\\t\\t\\t\\t\\txmlns=\\"http://www.w3.org/2000/svg\\"\\r\\n\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\tfill-rule=\\"evenodd\\"\\r\\n\\t\\t\\t\\t\\t\\tclip-rule=\\"evenodd\\"\\r\\n\\t\\t\\t\\t\\t\\td=\\"M15.2411 2.24464L20.2916 7.55623C20.4252 7.69717 20.5 7.88443 20.5 8.07973V17.4435C20.5 19.9553 18.4971 22 16.0337 22H8.07002C5.46399 22 3.5 20.0409 3.5 17.4435V14.9206C3.5 14.5038 3.83498 14.1655 4.24771 14.1655C4.66045 14.1655 4.99543 14.5038 4.99543 14.9206V17.4435C4.99543 19.2083 6.28847 20.4899 8.07002 20.4899H16.0337C17.6726 20.4899 19.0046 19.1227 19.0046 17.4435V8.38276L15.1873 4.36887V5.68569C15.1873 6.69647 16.0018 7.51998 17.0027 7.522C17.4154 7.523 17.7494 7.86127 17.7484 8.27907C17.7474 8.69486 17.4134 9.03211 17.0007 9.03211H16.9997C15.1763 9.02809 13.6918 7.52703 13.6918 5.68569V3.5222H8.07002C6.40312 3.5222 4.99543 4.8954 4.99543 6.52129V10.8161C4.99543 11.2329 4.66045 11.5711 4.24771 11.5711C3.83498 11.5711 3.5 11.2329 3.5 10.8161V6.52129C3.5 4.07692 5.5926 2.01208 8.07002 2.01208H14.3817C14.3913 2.01116 14.4 2.00855 14.4086 2.006C14.4188 2.00296 14.4287 2 14.4395 2C14.4512 2 14.4616 2.00313 14.472 2.00624C14.4803 2.00872 14.4885 2.01119 14.4974 2.01208H14.7017C14.9051 2.01208 15.0995 2.09564 15.2411 2.24464ZM11.0698 10.5214C11.0698 10.1046 11.4048 9.76633 11.8176 9.76633C12.2303 9.76633 12.5653 10.1046 12.5653 10.5214V12.2339H14.2611C14.6738 12.2339 15.0088 12.5721 15.0088 12.9889C15.0088 13.4057 14.6738 13.744 14.2611 13.744H12.5653V15.4555C12.5653 15.8722 12.2303 16.2105 11.8176 16.2105C11.4048 16.2105 11.0698 15.8722 11.0698 15.4555V13.744H9.37503C8.96229 13.744 8.62732 13.4057 8.62732 12.9889C8.62732 12.5721 8.96229 12.2339 9.37503 12.2339H11.0698V10.5214Z\\"\\r\\n\\t\\t\\t\\t\\t\\tfill=\\"#200E32\\"\\r\\n\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t</svg>\\r\\n\\t\\t\\t</label>\\r\\n\\t\\t</div>\\r\\n\\t\\t<div class=\\"post-header\\">\\r\\n\\t\\t\\t<div class=\\"post-title\\">\\r\\n\\t\\t\\t\\t{#if titleEdit}\\r\\n\\t\\t\\t\\t\\t<input\\r\\n\\t\\t\\t\\t\\t\\ton:change={handleChange}\\r\\n\\t\\t\\t\\t\\t\\tname=\\"title\\"\\r\\n\\t\\t\\t\\t\\t\\tvalue={content.title}\\r\\n\\t\\t\\t\\t\\t\\tplaceholder=\\"Enter title of the post\\"\\r\\n\\t\\t\\t\\t\\t\\tclass=\\"title-edit\\"\\r\\n\\t\\t\\t\\t\\t\\ttype=\\"enter title\\"\\r\\n\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t<button on:click={() => (titleEdit = false)} class=\\"button-edit-title\\">\\r\\n\\t\\t\\t\\t\\t\\t<svg\\r\\n\\t\\t\\t\\t\\t\\t\\twidth=\\"24\\"\\r\\n\\t\\t\\t\\t\\t\\t\\theight=\\"24\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tviewBox=\\"0 0 24 24\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tfill=\\"none\\"\\r\\n\\t\\t\\t\\t\\t\\t\\txmlns=\\"http://www.w3.org/2000/svg\\"\\r\\n\\t\\t\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tfill-rule=\\"evenodd\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tclip-rule=\\"evenodd\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\td=\\"M5 22C3.34315 22 2 20.6569 2 19V13C2 11.3431 3.34315 10 5 10H6.381L9.55279 3.65836C10.0311 2.70179 10.9794 2.07683 12.0366 2.00661L12.2361 2H12.5C13.8255 2 14.91 3.03154 14.9947 4.33562L15 4.5V10H18.9983C19.1958 10 19.3929 10.0195 19.5866 10.0583C21.1533 10.3716 22.1889 11.8524 21.9696 13.4145L21.94 13.5883L20.74 19.5883C20.4712 20.9322 19.3293 21.9152 17.9759 21.9948L17.7983 22H5ZM6 12H5C4.44772 12 4 12.4477 4 13V19C4 19.5523 4.44772 20 5 20H6V12ZM12.5 4H12.2361C11.8994 4 11.5884 4.16909 11.4045 4.4446L11.3416 4.55279L8.10557 11.0249C8.0535 11.1291 8.02015 11.2412 8.00673 11.3563L8 11.4721V20H17.7983C18.2352 20 18.6165 19.7173 18.749 19.3101L18.7788 19.1961L19.9788 13.1961C20.0872 12.6546 19.7359 12.1277 19.1944 12.0194L19.0968 12.0049L18.9983 12H15C13.9456 12 13.0818 11.1841 13.0055 10.1493L13 10V4.5C13 4.25454 12.8231 4.05039 12.5899 4.00806L12.5 4Z\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tfill=\\"black\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t\\t</svg>\\r\\n\\t\\t\\t\\t\\t</button>\\r\\n\\t\\t\\t\\t{:else}\\r\\n\\t\\t\\t\\t\\t<h1 class=\\"title\\">{content.title}</h1>\\r\\n\\t\\t\\t\\t\\t<button on:click={() => (titleEdit = true)} class=\\"button-edit-title\\">\\r\\n\\t\\t\\t\\t\\t\\t<svg\\r\\n\\t\\t\\t\\t\\t\\t\\twidth=\\"25\\"\\r\\n\\t\\t\\t\\t\\t\\t\\theight=\\"25\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tviewBox=\\"0 0 25 25\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tfill=\\"none\\"\\r\\n\\t\\t\\t\\t\\t\\t\\txmlns=\\"http://www.w3.org/2000/svg\\"\\r\\n\\t\\t\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\t\\t\\td=\\"M19.7 8.60004L8.9 19.4C8.8 19.5 8.80002 19.5 8.70002 19.5L6.20002 20.3L4.60001 20.8C4.20001 20.9 3.8 20.5 3.9 20.1L5.20002 16.1C5.20002 16 5.3 15.9 5.3 15.9L16.1 5.10004C17.1 4.10004 18.6 4.10004 19.6 5.10004C20.7 6.10004 20.7 7.60004 19.7 8.60004Z\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke=\\"#1A1A1A\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-width=\\"1.5\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-miterlimit=\\"10\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-linecap=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-linejoin=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\t\\t\\td=\\"M14.6 6.90002L18 10.3\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke=\\"#1A1A1A\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-width=\\"1.5\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-miterlimit=\\"10\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-linecap=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-linejoin=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t\\t</svg>\\r\\n\\t\\t\\t\\t\\t</button>\\r\\n\\t\\t\\t\\t{/if}\\r\\n\\t\\t\\t</div>\\r\\n\\t\\t\\t<div class=\\"post-header_author\\">\\r\\n\\t\\t\\t\\t{#if author}\\r\\n\\t\\t\\t\\t\\t<input\\r\\n\\t\\t\\t\\t\\t\\tname=\\"author\\"\\r\\n\\t\\t\\t\\t\\t\\ton:change={handleChange}\\r\\n\\t\\t\\t\\t\\t\\tvalue={content.author}\\r\\n\\t\\t\\t\\t\\t\\tclass=\\"gray input-gray \\"\\r\\n\\t\\t\\t\\t\\t\\tplaceholder=\\"Enter author name\\"\\r\\n\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t<p class=\\"gray\\">.</p>\\r\\n\\t\\t\\t\\t\\t<input\\r\\n\\t\\t\\t\\t\\t\\tname=\\"postDate\\"\\r\\n\\t\\t\\t\\t\\t\\ton:change={handleChange}\\r\\n\\t\\t\\t\\t\\t\\tvalue={content.postDate}\\r\\n\\t\\t\\t\\t\\t\\tclass=\\"gray input-gray\\"\\r\\n\\t\\t\\t\\t\\t\\tplaceholder=\\"data\\"\\r\\n\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t<p class=\\"gray\\">(</p>\\r\\n\\t\\t\\t\\t\\t<input\\r\\n\\t\\t\\t\\t\\t\\tname=\\"readingTime\\"\\r\\n\\t\\t\\t\\t\\t\\ton:change={handleChange}\\r\\n\\t\\t\\t\\t\\t\\tvalue={content.readingTime}\\r\\n\\t\\t\\t\\t\\t\\tclass=\\"gray input-gray\\"\\r\\n\\t\\t\\t\\t\\t\\tplaceholder=\\"enter time\\"\\r\\n\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t<p class=\\"gray\\">)</p>\\r\\n\\t\\t\\t\\t\\t<button on:click={() => (author = false)} class=\\"button-edit-title\\">\\r\\n\\t\\t\\t\\t\\t\\t<svg\\r\\n\\t\\t\\t\\t\\t\\t\\twidth=\\"24\\"\\r\\n\\t\\t\\t\\t\\t\\t\\theight=\\"24\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tviewBox=\\"0 0 24 24\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tfill=\\"none\\"\\r\\n\\t\\t\\t\\t\\t\\t\\txmlns=\\"http://www.w3.org/2000/svg\\"\\r\\n\\t\\t\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tfill-rule=\\"evenodd\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tclip-rule=\\"evenodd\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\td=\\"M5 22C3.34315 22 2 20.6569 2 19V13C2 11.3431 3.34315 10 5 10H6.381L9.55279 3.65836C10.0311 2.70179 10.9794 2.07683 12.0366 2.00661L12.2361 2H12.5C13.8255 2 14.91 3.03154 14.9947 4.33562L15 4.5V10H18.9983C19.1958 10 19.3929 10.0195 19.5866 10.0583C21.1533 10.3716 22.1889 11.8524 21.9696 13.4145L21.94 13.5883L20.74 19.5883C20.4712 20.9322 19.3293 21.9152 17.9759 21.9948L17.7983 22H5ZM6 12H5C4.44772 12 4 12.4477 4 13V19C4 19.5523 4.44772 20 5 20H6V12ZM12.5 4H12.2361C11.8994 4 11.5884 4.16909 11.4045 4.4446L11.3416 4.55279L8.10557 11.0249C8.0535 11.1291 8.02015 11.2412 8.00673 11.3563L8 11.4721V20H17.7983C18.2352 20 18.6165 19.7173 18.749 19.3101L18.7788 19.1961L19.9788 13.1961C20.0872 12.6546 19.7359 12.1277 19.1944 12.0194L19.0968 12.0049L18.9983 12H15C13.9456 12 13.0818 11.1841 13.0055 10.1493L13 10V4.5C13 4.25454 12.8231 4.05039 12.5899 4.00806L12.5 4Z\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tfill=\\"black\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t\\t</svg>\\r\\n\\t\\t\\t\\t\\t</button>\\r\\n\\t\\t\\t\\t{:else}\\r\\n\\t\\t\\t\\t\\t<p class=\\"gray author-name\\">{content.author}</p>\\r\\n\\t\\t\\t\\t\\t<p class=\\"gray\\">.</p>\\r\\n\\t\\t\\t\\t\\t<p class=\\"gray post-time\\">{content.postDate}</p>\\r\\n\\t\\t\\t\\t\\t<p class=\\"gray read-time\\">({content.readingTime} min read)</p>\\r\\n\\t\\t\\t\\t\\t<button on:click={() => (author = true)} class=\\"button-edit-title\\">\\r\\n\\t\\t\\t\\t\\t\\t<svg\\r\\n\\t\\t\\t\\t\\t\\t\\twidth=\\"25\\"\\r\\n\\t\\t\\t\\t\\t\\t\\theight=\\"25\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tviewBox=\\"0 0 25 25\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tfill=\\"none\\"\\r\\n\\t\\t\\t\\t\\t\\t\\txmlns=\\"http://www.w3.org/2000/svg\\"\\r\\n\\t\\t\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\t\\t\\td=\\"M19.7 8.60004L8.9 19.4C8.8 19.5 8.80002 19.5 8.70002 19.5L6.20002 20.3L4.60001 20.8C4.20001 20.9 3.8 20.5 3.9 20.1L5.20002 16.1C5.20002 16 5.3 15.9 5.3 15.9L16.1 5.10004C17.1 4.10004 18.6 4.10004 19.6 5.10004C20.7 6.10004 20.7 7.60004 19.7 8.60004Z\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke=\\"#1A1A1A\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-width=\\"1.5\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-miterlimit=\\"10\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-linecap=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-linejoin=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\t\\t\\td=\\"M14.6 6.90002L18 10.3\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke=\\"#1A1A1A\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-width=\\"1.5\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-miterlimit=\\"10\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-linecap=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-linejoin=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t\\t</svg>\\r\\n\\t\\t\\t\\t\\t</button>\\r\\n\\t\\t\\t\\t{/if}\\r\\n\\t\\t\\t</div>\\r\\n\\t\\t\\t<div class=\\"tags gray\\">\\r\\n\\t\\t\\t\\t{#each content.tags as tag, i}\\r\\n\\t\\t\\t\\t\\t<p class=\\"gray tag\\">#{tag}</p>\\r\\n\\t\\t\\t\\t{/each}\\r\\n\\t\\t\\t\\t<input\\r\\n\\t\\t\\t\\t\\tvalue={content.tempTag}\\r\\n\\t\\t\\t\\t\\ton:change={handleChange}\\r\\n\\t\\t\\t\\t\\tname=\\"tempTag\\"\\r\\n\\t\\t\\t\\t\\tclass=\\"tag-input\\"\\r\\n\\t\\t\\t\\t\\tplaceholder=\\"Enter tag\\"\\r\\n\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t<button on:click={handleAddTag} class=\\"tag-button\\">\\r\\n\\t\\t\\t\\t\\t<svg\\r\\n\\t\\t\\t\\t\\t\\twidth=\\"24\\"\\r\\n\\t\\t\\t\\t\\t\\theight=\\"24\\"\\r\\n\\t\\t\\t\\t\\t\\tviewBox=\\"0 0 24 24\\"\\r\\n\\t\\t\\t\\t\\t\\tfill=\\"none\\"\\r\\n\\t\\t\\t\\t\\t\\txmlns=\\"http://www.w3.org/2000/svg\\"\\r\\n\\t\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\t\\td=\\"M12 8.3273V15.6537\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke=\\"#200E32\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke-width=\\"1.5\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke-linecap=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke-linejoin=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\t\\td=\\"M15.6667 11.9905H8.33334\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke=\\"#200E32\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke-width=\\"1.5\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke-linecap=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke-linejoin=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\t\\tfill-rule=\\"evenodd\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tclip-rule=\\"evenodd\\"\\r\\n\\t\\t\\t\\t\\t\\t\\td=\\"M16.6857 2H7.31429C4.04762 2 2 4.31208 2 7.58516V16.4148C2 19.6879 4.0381 22 7.31429 22H16.6857C19.9619 22 22 19.6879 22 16.4148V7.58516C22 4.31208 19.9619 2 16.6857 2Z\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke=\\"#200E32\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke-width=\\"1.5\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke-linecap=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tstroke-linejoin=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t</svg>\\r\\n\\t\\t\\t\\t</button>\\r\\n\\t\\t\\t</div>\\r\\n\\t\\t\\t<div class=\\"post-body-text\\">\\r\\n\\t\\t\\t\\t{#each content.body as paragraph}\\r\\n\\t\\t\\t\\t\\t<p class=\\"post-body\\">{paragraph}</p>\\r\\n\\t\\t\\t\\t{/each}\\r\\n\\t\\t\\t\\t{#if bodyEdit}\\r\\n\\t\\t\\t\\t\\t<textarea\\r\\n\\t\\t\\t\\t\\t\\tvalue={content.paragraph}\\r\\n\\t\\t\\t\\t\\t\\tname=\\"paragraph\\"\\r\\n\\t\\t\\t\\t\\t\\ton:change={handleChange}\\r\\n\\t\\t\\t\\t\\t\\tclass=\\"post-body\\"\\r\\n\\t\\t\\t\\t\\t\\tplaceholder=\\"enter post content\\"\\r\\n\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t<button\\r\\n\\t\\t\\t\\t\\t\\ton:click={(e) => {\\r\\n\\t\\t\\t\\t\\t\\t\\tbodyEdit = false;\\r\\n\\t\\t\\t\\t\\t\\t\\thandleAddBodyPara(e);\\r\\n\\t\\t\\t\\t\\t\\t}}\\r\\n\\t\\t\\t\\t\\t\\tclass=\\"button-edit-title\\"\\r\\n\\t\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t\\t\\t<svg\\r\\n\\t\\t\\t\\t\\t\\t\\twidth=\\"24\\"\\r\\n\\t\\t\\t\\t\\t\\t\\theight=\\"24\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tviewBox=\\"0 0 24 24\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tfill=\\"none\\"\\r\\n\\t\\t\\t\\t\\t\\t\\txmlns=\\"http://www.w3.org/2000/svg\\"\\r\\n\\t\\t\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tfill-rule=\\"evenodd\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tclip-rule=\\"evenodd\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\td=\\"M5 22C3.34315 22 2 20.6569 2 19V13C2 11.3431 3.34315 10 5 10H6.381L9.55279 3.65836C10.0311 2.70179 10.9794 2.07683 12.0366 2.00661L12.2361 2H12.5C13.8255 2 14.91 3.03154 14.9947 4.33562L15 4.5V10H18.9983C19.1958 10 19.3929 10.0195 19.5866 10.0583C21.1533 10.3716 22.1889 11.8524 21.9696 13.4145L21.94 13.5883L20.74 19.5883C20.4712 20.9322 19.3293 21.9152 17.9759 21.9948L17.7983 22H5ZM6 12H5C4.44772 12 4 12.4477 4 13V19C4 19.5523 4.44772 20 5 20H6V12ZM12.5 4H12.2361C11.8994 4 11.5884 4.16909 11.4045 4.4446L11.3416 4.55279L8.10557 11.0249C8.0535 11.1291 8.02015 11.2412 8.00673 11.3563L8 11.4721V20H17.7983C18.2352 20 18.6165 19.7173 18.749 19.3101L18.7788 19.1961L19.9788 13.1961C20.0872 12.6546 19.7359 12.1277 19.1944 12.0194L19.0968 12.0049L18.9983 12H15C13.9456 12 13.0818 11.1841 13.0055 10.1493L13 10V4.5C13 4.25454 12.8231 4.05039 12.5899 4.00806L12.5 4Z\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tfill=\\"black\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t\\t</svg>\\r\\n\\t\\t\\t\\t\\t</button>\\r\\n\\t\\t\\t\\t{:else}\\r\\n\\t\\t\\t\\t\\t<button on:click={() => (bodyEdit = true)} class=\\"button-edit-title\\">\\r\\n\\t\\t\\t\\t\\t\\t<svg\\r\\n\\t\\t\\t\\t\\t\\t\\twidth=\\"25\\"\\r\\n\\t\\t\\t\\t\\t\\t\\theight=\\"25\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tviewBox=\\"0 0 25 25\\"\\r\\n\\t\\t\\t\\t\\t\\t\\tfill=\\"none\\"\\r\\n\\t\\t\\t\\t\\t\\t\\txmlns=\\"http://www.w3.org/2000/svg\\"\\r\\n\\t\\t\\t\\t\\t\\t>\\r\\n\\t\\t\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\t\\t\\td=\\"M19.7 8.60004L8.9 19.4C8.8 19.5 8.80002 19.5 8.70002 19.5L6.20002 20.3L4.60001 20.8C4.20001 20.9 3.8 20.5 3.9 20.1L5.20002 16.1C5.20002 16 5.3 15.9 5.3 15.9L16.1 5.10004C17.1 4.10004 18.6 4.10004 19.6 5.10004C20.7 6.10004 20.7 7.60004 19.7 8.60004Z\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke=\\"#1A1A1A\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-width=\\"1.5\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-miterlimit=\\"10\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-linecap=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-linejoin=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t\\t\\t<path\\r\\n\\t\\t\\t\\t\\t\\t\\t\\td=\\"M14.6 6.90002L18 10.3\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke=\\"#1A1A1A\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-width=\\"1.5\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-miterlimit=\\"10\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-linecap=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t\\tstroke-linejoin=\\"round\\"\\r\\n\\t\\t\\t\\t\\t\\t\\t/>\\r\\n\\t\\t\\t\\t\\t\\t</svg>\\r\\n\\t\\t\\t\\t\\t</button>\\r\\n\\t\\t\\t\\t{/if}\\r\\n\\t\\t\\t</div>\\r\\n\\t\\t\\t<button on:click={handleSubmitPost} class=\\"submit-post-btn\\">Submit Post</button>\\r\\n\\t\\t</div>\\r\\n\\t</div>\\r\\n\\r\\n\\t{#if isLoaderActive}\\r\\n\\t\\t<div class=\\"preloader\\">\\r\\n\\t\\t\\t<div class=\\"loadingio-spinner-bean-eater-3cordrlrc9\\">\\r\\n\\t\\t\\t\\t<div class=\\"ldio-mvluw7e021b\\">\\r\\n\\t\\t\\t\\t\\t<div>\\r\\n\\t\\t\\t\\t\\t\\t<div />\\r\\n\\t\\t\\t\\t\\t\\t<div />\\r\\n\\t\\t\\t\\t\\t\\t<div />\\r\\n\\t\\t\\t\\t\\t</div>\\r\\n\\t\\t\\t\\t\\t<div>\\r\\n\\t\\t\\t\\t\\t\\t<div />\\r\\n\\t\\t\\t\\t\\t\\t<div />\\r\\n\\t\\t\\t\\t\\t\\t<div />\\r\\n\\t\\t\\t\\t\\t</div>\\r\\n\\t\\t\\t\\t</div>\\r\\n\\t\\t\\t</div>\\r\\n\\t\\t</div>\\r\\n\\t{/if}\\r\\n</main>\\r\\n\\r\\n<style>\\r\\n\\t@import url('https://fonts.googleapis.com/css2?family=Libre+Baskerville:wght@400;700&display=swap');\\r\\n\\r\\n\\t* {\\r\\n\\t\\tfont-family: 'Libre Baskerville', serif;\\r\\n\\t}\\r\\n\\r\\n\\th1,\\r\\n\\tp {\\r\\n\\t\\tmargin: 0;\\r\\n\\t}\\r\\n\\r\\n\\tdiv {\\r\\n\\t\\tposition: relative;\\r\\n\\t}\\r\\n\\r\\n\\t.gray {\\r\\n\\t\\tcolor: rgba(28, 28, 28, 0.5);\\r\\n\\t\\tfont-size: 16px;\\r\\n\\t}\\r\\n\\r\\n\\t.tag {\\r\\n\\t\\tmargin-right: 5px;\\r\\n\\t}\\r\\n\\r\\n\\t.post-top-icons{\\r\\n\\t\\tdisplay: flex;\\r\\n\\t\\tjustify-content: flex-end;\\r\\n\\t\\talign-items: center;\\r\\n\\t\\tpadding: 5px 0;\\r\\n\\t}\\r\\n\\r\\n\\t.btn{\\r\\n\\t\\tmargin: 0 5px;\\r\\n\\t\\tborder: 0;\\r\\n\\t\\toutline: 0;\\r\\n\\t\\tbackground-color: transparent;\\r\\n\\t}\\r\\n\\r\\n\\t.post-title {\\r\\n\\t\\tposition: relative;\\r\\n\\t\\ttext-align: center;\\r\\n\\t}\\r\\n\\r\\n\\t.button-edit-title {\\r\\n\\t\\tposition: absolute;\\r\\n\\t\\tright: 0;\\r\\n\\t\\ttop: calc(50% - 15px);\\r\\n\\t\\toutline: 0;\\r\\n\\t\\tborder: 0;\\r\\n\\t\\tbackground-color: inherit;\\r\\n\\t}\\r\\n\\r\\n\\t.read-time {\\r\\n\\t\\tfont-size: 14px;\\r\\n\\t}\\r\\n\\r\\n\\t.title {\\r\\n\\t\\tfont-size: 42px;\\r\\n\\t\\tfont-weight: 700;\\r\\n\\t\\ttext-align: center;\\r\\n\\t\\tmargin: 10px auto;\\r\\n\\t\\twidth: 600px;\\r\\n\\t}\\r\\n\\r\\n\\t.title-edit {\\r\\n\\t\\tfont-size: 42px;\\r\\n\\t}\\r\\n\\r\\n\\t.main {\\r\\n\\t\\tdisplay: grid;\\r\\n\\t\\theight: 100vh;\\r\\n\\t\\tgrid-template-columns: 225px calc(100vw - 225px);\\r\\n\\t\\tgrid-template-rows: 75px auto;\\r\\n\\t\\toverflow: hidden;\\r\\n\\t}\\r\\n\\r\\n\\t.post {\\r\\n\\t\\toverflow: hidden;\\r\\n\\t\\toverflow-y: scroll;\\r\\n\\t\\tpadding: 2em 0;\\r\\n\\t\\ttext-align: center;\\r\\n\\t}\\r\\n\\r\\n\\t.post-header_author {\\r\\n\\t\\tdisplay: flex;\\r\\n\\t\\talign-items: center;\\r\\n\\t\\tjustify-content: center;\\r\\n\\t\\tmargin: 1em 0;\\r\\n\\t}\\r\\n\\r\\n\\t.input-gray {\\r\\n\\t\\tpadding: 10px 5px;\\r\\n\\t\\tborder-radius: 5px;\\r\\n\\t\\toutline: 0;\\r\\n\\t\\tborder: 1px solid #000;\\r\\n\\t}\\r\\n\\r\\n\\t.tags {\\r\\n\\t\\tdisplay: flex;\\r\\n\\t\\talign-items: center;\\r\\n\\t\\tjustify-content: center;\\r\\n\\t\\tmargin: 1em 0;\\r\\n\\t}\\r\\n\\r\\n\\t.tag-input {\\r\\n\\t\\twidth: 70px;\\r\\n\\t\\toutline: 0;\\r\\n\\t\\tborder: 1px solid #000;\\r\\n\\t\\tborder-radius: 10px;\\r\\n\\t\\theight: 20px;\\r\\n\\t\\tpadding-left: 5px;\\r\\n\\t\\tmargin: 0 0 0 10px;\\r\\n\\t}\\r\\n\\r\\n\\t.tag-button {\\r\\n\\t\\tborder: 0;\\r\\n\\t\\toutline: 0;\\r\\n\\t\\tbackground-color: inherit;\\r\\n\\t}\\r\\n\\r\\n\\t.banner-container {\\r\\n\\t\\tposition: relative;\\r\\n\\t}\\r\\n\\r\\n\\t.banner {\\r\\n\\t\\theight: 500px;\\r\\n\\t}\\r\\n\\r\\n\\t#banner-upload {\\r\\n\\t\\twidth: 0;\\r\\n\\t\\theight: 0;\\r\\n\\t\\tpadding: 0;\\r\\n\\t\\tborder: 0;\\r\\n\\t\\toutline: 0;\\r\\n\\t}\\r\\n\\r\\n\\t.banner-label {\\r\\n\\t\\tposition: absolute;\\r\\n\\t\\tright: calc(50% - 27px);\\r\\n\\t\\ttop: calc(50% - 27px);\\r\\n\\t\\tpadding: 1em;\\r\\n\\t\\tbackground-color: #fff;\\r\\n\\t\\tborder-radius: 5px;\\r\\n\\t}\\r\\n\\r\\n\\t.banner-skeleton {\\r\\n\\t\\tbackground-color: rgb(239, 235, 235);\\r\\n\\t}\\r\\n\\r\\n\\t.post-body-text {\\r\\n\\t\\ttext-align: center;\\r\\n\\t\\tpadding: 2em 0;\\r\\n\\t}\\r\\n\\r\\n\\t.post-body {\\r\\n\\t\\twidth: 600px;\\r\\n\\t\\tpadding-bottom: 1.5em;\\r\\n\\t\\tmargin: 0 auto;\\r\\n\\t\\ttext-align: left;\\r\\n\\t\\tfont-size: 16px;\\r\\n\\t\\tline-height: 24px;\\r\\n\\t\\tfont-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell,\\r\\n\\t\\t\\t'Open Sans', 'Helvetica Neue', sans-serif;\\r\\n\\t}\\r\\n\\r\\n\\t.submit-post-btn {\\r\\n\\t\\tpadding: 1em 2em;\\r\\n\\t\\tborder-radius: 5px;\\r\\n\\t\\tbackground-color: inherit;\\r\\n\\t\\tfont-size: 18px;\\r\\n\\t\\tborder: 1.5px solid #000;\\r\\n\\t\\toutline: 0;\\r\\n\\t\\tfont-family: 'Libre Baskerville', serif;\\r\\n\\t\\tfont-weight: bolder;\\r\\n\\t}\\r\\n\\r\\n\\t.preloader {\\r\\n\\t\\theight: 100vh;\\r\\n\\t\\twidth: 100%;\\r\\n\\t\\tbackground-color: rgba(28, 28, 28, 0.5);\\r\\n\\t\\tposition: fixed;\\r\\n\\t\\ttop: 0;\\r\\n\\t\\tleft: 0;\\r\\n\\t\\tdisplay: flex;\\r\\n\\t\\talign-items: center;\\r\\n\\t\\tjustify-content: center;\\r\\n\\t}\\r\\n\\r\\n\\t@keyframes ldio-mvluw7e021b-1 {\\r\\n\\t\\t0% {\\r\\n\\t\\t\\ttransform: rotate(0deg);\\r\\n\\t\\t}\\r\\n\\t\\t50% {\\r\\n\\t\\t\\ttransform: rotate(-45deg);\\r\\n\\t\\t}\\r\\n\\t\\t100% {\\r\\n\\t\\t\\ttransform: rotate(0deg);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t@keyframes ldio-mvluw7e021b-2 {\\r\\n\\t\\t0% {\\r\\n\\t\\t\\ttransform: rotate(180deg);\\r\\n\\t\\t}\\r\\n\\t\\t50% {\\r\\n\\t\\t\\ttransform: rotate(225deg);\\r\\n\\t\\t}\\r\\n\\t\\t100% {\\r\\n\\t\\t\\ttransform: rotate(180deg);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t.ldio-mvluw7e021b > div:nth-child(2) {\\r\\n\\t\\ttransform: translate(-15px, 0);\\r\\n\\t}\\r\\n\\t.ldio-mvluw7e021b > div:nth-child(2) div {\\r\\n\\t\\tposition: absolute;\\r\\n\\t\\ttop: 40px;\\r\\n\\t\\tleft: 40px;\\r\\n\\t\\twidth: 120px;\\r\\n\\t\\theight: 60px;\\r\\n\\t\\tborder-radius: 120px 120px 0 0;\\r\\n\\t\\tbackground: #f8b26a;\\r\\n\\t\\tanimation: ldio-mvluw7e021b-1 1s linear infinite;\\r\\n\\t\\ttransform-origin: 60px 60px;\\r\\n\\t}\\r\\n\\t.ldio-mvluw7e021b > div:nth-child(2) div:nth-child(2) {\\r\\n\\t\\tanimation: ldio-mvluw7e021b-2 1s linear infinite;\\r\\n\\t}\\r\\n\\t.ldio-mvluw7e021b > div:nth-child(2) div:nth-child(3) {\\r\\n\\t\\ttransform: rotate(-90deg);\\r\\n\\t\\tanimation: none;\\r\\n\\t}\\r\\n\\t@keyframes ldio-mvluw7e021b-3 {\\r\\n\\t\\t0% {\\r\\n\\t\\t\\ttransform: translate(190px, 0);\\r\\n\\t\\t\\topacity: 0;\\r\\n\\t\\t}\\r\\n\\t\\t20% {\\r\\n\\t\\t\\topacity: 1;\\r\\n\\t\\t}\\r\\n\\t\\t100% {\\r\\n\\t\\t\\ttransform: translate(70px, 0);\\r\\n\\t\\t\\topacity: 1;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t.ldio-mvluw7e021b > div:nth-child(1) {\\r\\n\\t\\tdisplay: block;\\r\\n\\t}\\r\\n\\t.ldio-mvluw7e021b > div:nth-child(1) div {\\r\\n\\t\\tposition: absolute;\\r\\n\\t\\ttop: 92px;\\r\\n\\t\\tleft: -8px;\\r\\n\\t\\twidth: 16px;\\r\\n\\t\\theight: 16px;\\r\\n\\t\\tborder-radius: 50%;\\r\\n\\t\\tbackground: #e15b64;\\r\\n\\t\\tanimation: ldio-mvluw7e021b-3 1s linear infinite;\\r\\n\\t}\\r\\n\\t.ldio-mvluw7e021b > div:nth-child(1) div:nth-child(1) {\\r\\n\\t\\tanimation-delay: -0.67s;\\r\\n\\t}\\r\\n\\t.ldio-mvluw7e021b > div:nth-child(1) div:nth-child(2) {\\r\\n\\t\\tanimation-delay: -0.33s;\\r\\n\\t}\\r\\n\\t.ldio-mvluw7e021b > div:nth-child(1) div:nth-child(3) {\\r\\n\\t\\tanimation-delay: 0s;\\r\\n\\t}\\r\\n\\t.loadingio-spinner-bean-eater-3cordrlrc9 {\\r\\n\\t\\twidth: 200px;\\r\\n\\t\\theight: 200px;\\r\\n\\t\\tdisplay: inline-block;\\r\\n\\t\\toverflow: hidden;\\r\\n\\t\\tbackground: transparent;\\r\\n\\t}\\r\\n\\t.ldio-mvluw7e021b {\\r\\n\\t\\twidth: 100%;\\r\\n\\t\\theight: 100%;\\r\\n\\t\\tposition: relative;\\r\\n\\t\\ttransform: translateZ(0) scale(1);\\r\\n\\t\\tbackface-visibility: hidden;\\r\\n\\t\\ttransform-origin: 0 0; /* see note above */\\r\\n\\t}\\r\\n\\t.ldio-mvluw7e021b div {\\r\\n\\t\\tbox-sizing: content-box;\\r\\n\\t}\\r\\n\\t/* generated by https://loading.io/ */\\r\\n</style>\\r\\n"],"names":[],"mappings":"AA+YC,QAAQ,IAAI,sFAAsF,CAAC,CAAC,AAEpG,6CAAE,CAAC,AACF,WAAW,CAAE,mBAAmB,CAAC,CAAC,KAAK,AACxC,CAAC,AAED,+CAAE,CACF,CAAC,6CAAC,CAAC,AACF,MAAM,CAAE,CAAC,AACV,CAAC,AAED,GAAG,6CAAC,CAAC,AACJ,QAAQ,CAAE,QAAQ,AACnB,CAAC,AAED,KAAK,6CAAC,CAAC,AACN,KAAK,CAAE,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAC5B,SAAS,CAAE,IAAI,AAChB,CAAC,AAED,IAAI,6CAAC,CAAC,AACL,YAAY,CAAE,GAAG,AAClB,CAAC,AAED,4DAAe,CAAC,AACf,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,QAAQ,CACzB,WAAW,CAAE,MAAM,CACnB,OAAO,CAAE,GAAG,CAAC,CAAC,AACf,CAAC,AAED,iDAAI,CAAC,AACJ,MAAM,CAAE,CAAC,CAAC,GAAG,CACb,MAAM,CAAE,CAAC,CACT,OAAO,CAAE,CAAC,CACV,gBAAgB,CAAE,WAAW,AAC9B,CAAC,AAED,WAAW,6CAAC,CAAC,AACZ,QAAQ,CAAE,QAAQ,CAClB,UAAU,CAAE,MAAM,AACnB,CAAC,AAED,kBAAkB,6CAAC,CAAC,AACnB,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,CAAC,CACR,GAAG,CAAE,KAAK,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,CACrB,OAAO,CAAE,CAAC,CACV,MAAM,CAAE,CAAC,CACT,gBAAgB,CAAE,OAAO,AAC1B,CAAC,AAED,UAAU,6CAAC,CAAC,AACX,SAAS,CAAE,IAAI,AAChB,CAAC,AAED,MAAM,6CAAC,CAAC,AACP,SAAS,CAAE,IAAI,CACf,WAAW,CAAE,GAAG,CAChB,UAAU,CAAE,MAAM,CAClB,MAAM,CAAE,IAAI,CAAC,IAAI,CACjB,KAAK,CAAE,KAAK,AACb,CAAC,AAED,WAAW,6CAAC,CAAC,AACZ,SAAS,CAAE,IAAI,AAChB,CAAC,AAED,KAAK,6CAAC,CAAC,AACN,OAAO,CAAE,IAAI,CACb,MAAM,CAAE,KAAK,CACb,qBAAqB,CAAE,KAAK,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAChD,kBAAkB,CAAE,IAAI,CAAC,IAAI,CAC7B,QAAQ,CAAE,MAAM,AACjB,CAAC,AAED,KAAK,6CAAC,CAAC,AACN,QAAQ,CAAE,MAAM,CAChB,UAAU,CAAE,MAAM,CAClB,OAAO,CAAE,GAAG,CAAC,CAAC,CACd,UAAU,CAAE,MAAM,AACnB,CAAC,AAED,mBAAmB,6CAAC,CAAC,AACpB,OAAO,CAAE,IAAI,CACb,WAAW,CAAE,MAAM,CACnB,eAAe,CAAE,MAAM,CACvB,MAAM,CAAE,GAAG,CAAC,CAAC,AACd,CAAC,AAED,WAAW,6CAAC,CAAC,AACZ,OAAO,CAAE,IAAI,CAAC,GAAG,CACjB,aAAa,CAAE,GAAG,CAClB,OAAO,CAAE,CAAC,CACV,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,AACvB,CAAC,AAED,KAAK,6CAAC,CAAC,AACN,OAAO,CAAE,IAAI,CACb,WAAW,CAAE,MAAM,CACnB,eAAe,CAAE,MAAM,CACvB,MAAM,CAAE,GAAG,CAAC,CAAC,AACd,CAAC,AAED,UAAU,6CAAC,CAAC,AACX,KAAK,CAAE,IAAI,CACX,OAAO,CAAE,CAAC,CACV,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,IAAI,CACtB,aAAa,CAAE,IAAI,CACnB,MAAM,CAAE,IAAI,CACZ,YAAY,CAAE,GAAG,CACjB,MAAM,CAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,AACnB,CAAC,AAED,WAAW,6CAAC,CAAC,AACZ,MAAM,CAAE,CAAC,CACT,OAAO,CAAE,CAAC,CACV,gBAAgB,CAAE,OAAO,AAC1B,CAAC,AAED,iBAAiB,6CAAC,CAAC,AAClB,QAAQ,CAAE,QAAQ,AACnB,CAAC,AAED,OAAO,6CAAC,CAAC,AACR,MAAM,CAAE,KAAK,AACd,CAAC,AAED,cAAc,6CAAC,CAAC,AACf,KAAK,CAAE,CAAC,CACR,MAAM,CAAE,CAAC,CACT,OAAO,CAAE,CAAC,CACV,MAAM,CAAE,CAAC,CACT,OAAO,CAAE,CAAC,AACX,CAAC,AAED,aAAa,6CAAC,CAAC,AACd,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,KAAK,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,CACvB,GAAG,CAAE,KAAK,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,CACrB,OAAO,CAAE,GAAG,CACZ,gBAAgB,CAAE,IAAI,CACtB,aAAa,CAAE,GAAG,AACnB,CAAC,AAED,gBAAgB,6CAAC,CAAC,AACjB,gBAAgB,CAAE,IAAI,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,AACrC,CAAC,AAED,eAAe,6CAAC,CAAC,AAChB,UAAU,CAAE,MAAM,CAClB,OAAO,CAAE,GAAG,CAAC,CAAC,AACf,CAAC,AAED,UAAU,6CAAC,CAAC,AACX,KAAK,CAAE,KAAK,CACZ,cAAc,CAAE,KAAK,CACrB,MAAM,CAAE,CAAC,CAAC,IAAI,CACd,UAAU,CAAE,IAAI,CAChB,SAAS,CAAE,IAAI,CACf,WAAW,CAAE,IAAI,CACjB,WAAW,CAAE,aAAa,CAAC,CAAC,kBAAkB,CAAC,CAAC,UAAU,CAAC,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC;GAC7F,WAAW,CAAC,CAAC,gBAAgB,CAAC,CAAC,UAAU,AAC3C,CAAC,AAED,gBAAgB,6CAAC,CAAC,AACjB,OAAO,CAAE,GAAG,CAAC,GAAG,CAChB,aAAa,CAAE,GAAG,CAClB,gBAAgB,CAAE,OAAO,CACzB,SAAS,CAAE,IAAI,CACf,MAAM,CAAE,KAAK,CAAC,KAAK,CAAC,IAAI,CACxB,OAAO,CAAE,CAAC,CACV,WAAW,CAAE,mBAAmB,CAAC,CAAC,KAAK,CACvC,WAAW,CAAE,MAAM,AACpB,CAAC,AAED,UAAU,6CAAC,CAAC,AACX,MAAM,CAAE,KAAK,CACb,KAAK,CAAE,IAAI,CACX,gBAAgB,CAAE,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CACvC,QAAQ,CAAE,KAAK,CACf,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,CAAC,CACP,OAAO,CAAE,IAAI,CACb,WAAW,CAAE,MAAM,CACnB,eAAe,CAAE,MAAM,AACxB,CAAC,AAED,WAAW,iCAAmB,CAAC,AAC9B,EAAE,AAAC,CAAC,AACH,SAAS,CAAE,OAAO,IAAI,CAAC,AACxB,CAAC,AACD,GAAG,AAAC,CAAC,AACJ,SAAS,CAAE,OAAO,MAAM,CAAC,AAC1B,CAAC,AACD,IAAI,AAAC,CAAC,AACL,SAAS,CAAE,OAAO,IAAI,CAAC,AACxB,CAAC,AACF,CAAC,AACD,WAAW,iCAAmB,CAAC,AAC9B,EAAE,AAAC,CAAC,AACH,SAAS,CAAE,OAAO,MAAM,CAAC,AAC1B,CAAC,AACD,GAAG,AAAC,CAAC,AACJ,SAAS,CAAE,OAAO,MAAM,CAAC,AAC1B,CAAC,AACD,IAAI,AAAC,CAAC,AACL,SAAS,CAAE,OAAO,MAAM,CAAC,AAC1B,CAAC,AACF,CAAC,AACD,gCAAiB,CAAG,iCAAG,WAAW,CAAC,CAAC,AAAC,CAAC,AACrC,SAAS,CAAE,UAAU,KAAK,CAAC,CAAC,CAAC,CAAC,AAC/B,CAAC,AACD,gCAAiB,CAAG,kBAAG,WAAW,CAAC,CAAC,CAAC,GAAG,eAAC,CAAC,AACzC,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,IAAI,CACT,IAAI,CAAE,IAAI,CACV,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,IAAI,CACZ,aAAa,CAAE,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAC9B,UAAU,CAAE,OAAO,CACnB,SAAS,CAAE,iCAAkB,CAAC,EAAE,CAAC,MAAM,CAAC,QAAQ,CAChD,gBAAgB,CAAE,IAAI,CAAC,IAAI,AAC5B,CAAC,AACD,gCAAiB,CAAG,kBAAG,WAAW,CAAC,CAAC,CAAC,kBAAG,WAAW,CAAC,CAAC,AAAC,CAAC,AACtD,SAAS,CAAE,iCAAkB,CAAC,EAAE,CAAC,MAAM,CAAC,QAAQ,AACjD,CAAC,AACD,gCAAiB,CAAG,kBAAG,WAAW,CAAC,CAAC,CAAC,kBAAG,WAAW,CAAC,CAAC,AAAC,CAAC,AACtD,SAAS,CAAE,OAAO,MAAM,CAAC,CACzB,SAAS,CAAE,IAAI,AAChB,CAAC,AACD,WAAW,iCAAmB,CAAC,AAC9B,EAAE,AAAC,CAAC,AACH,SAAS,CAAE,UAAU,KAAK,CAAC,CAAC,CAAC,CAAC,CAC9B,OAAO,CAAE,CAAC,AACX,CAAC,AACD,GAAG,AAAC,CAAC,AACJ,OAAO,CAAE,CAAC,AACX,CAAC,AACD,IAAI,AAAC,CAAC,AACL,SAAS,CAAE,UAAU,IAAI,CAAC,CAAC,CAAC,CAAC,CAC7B,OAAO,CAAE,CAAC,AACX,CAAC,AACF,CAAC,AACD,gCAAiB,CAAG,iCAAG,WAAW,CAAC,CAAC,AAAC,CAAC,AACrC,OAAO,CAAE,KAAK,AACf,CAAC,AACD,gCAAiB,CAAG,kBAAG,WAAW,CAAC,CAAC,CAAC,GAAG,eAAC,CAAC,AACzC,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,IAAI,CACT,IAAI,CAAE,IAAI,CACV,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,aAAa,CAAE,GAAG,CAClB,UAAU,CAAE,OAAO,CACnB,SAAS,CAAE,iCAAkB,CAAC,EAAE,CAAC,MAAM,CAAC,QAAQ,AACjD,CAAC,AACD,gCAAiB,CAAG,kBAAG,WAAW,CAAC,CAAC,CAAC,kBAAG,WAAW,CAAC,CAAC,AAAC,CAAC,AACtD,eAAe,CAAE,MAAM,AACxB,CAAC,AACD,gCAAiB,CAAG,kBAAG,WAAW,CAAC,CAAC,CAAC,kBAAG,WAAW,CAAC,CAAC,AAAC,CAAC,AACtD,eAAe,CAAE,MAAM,AACxB,CAAC,AACD,gCAAiB,CAAG,kBAAG,WAAW,CAAC,CAAC,CAAC,kBAAG,WAAW,CAAC,CAAC,AAAC,CAAC,AACtD,eAAe,CAAE,EAAE,AACpB,CAAC,AACD,wCAAwC,6CAAC,CAAC,AACzC,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,CACb,OAAO,CAAE,YAAY,CACrB,QAAQ,CAAE,MAAM,CAChB,UAAU,CAAE,WAAW,AACxB,CAAC,AACD,iBAAiB,6CAAC,CAAC,AAClB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,QAAQ,CAAE,QAAQ,CAClB,SAAS,CAAE,WAAW,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CACjC,mBAAmB,CAAE,MAAM,CAC3B,gBAAgB,CAAE,CAAC,CAAC,CAAC,AACtB,CAAC,AACD,gCAAiB,CAAC,GAAG,8BAAC,CAAC,AACtB,UAAU,CAAE,WAAW,AACxB,CAAC"}`
};
var Writepost = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let content = {
    title: "Enter title of the page here",
    author: "Aslam",
    readingTime: "10",
    postDate: "October 18, 2021",
    body: [],
    tags: [],
    tempTag: "",
    paragraph: "",
    featured: false,
    editorsPick: false
  };
  $$result.css.add(css$4);
  return `<main class="${"main svelte-1bo7sn4"}">${validate_component(Dashboard_sidebar, "Sidebar").$$render($$result, { active: "write-a-post" }, {}, {})}
	${validate_component(Dashboard_navbar, "Navbar").$$render($$result, { active: "" }, {}, {})}
	<div class="${"post svelte-1bo7sn4"}"><div class="${"post-top-icons svelte-1bo7sn4"}"><button class="${"editors-pick btn svelte-1bo7sn4"}"><svg width="${"29"}" height="${"29"}" viewBox="${"0 0 24 24"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}" class="${"svelte-1bo7sn4"}"><path stroke-width="${"0.5"}" stroke="${"#000"}" d="${"M17.9185 14.3201C17.6595 14.5711 17.5405 14.9341 17.5995 15.2901L18.4885 20.2101C18.5635 20.6271 18.3875 21.0491 18.0385 21.2901C17.6965 21.5401 17.2415 21.5701 16.8685 21.3701L12.4395 19.0601C12.2855 18.9781 12.1145 18.9341 11.9395 18.9291H11.6685C11.5745 18.9431 11.4825 18.9731 11.3985 19.0191L6.96851 21.3401C6.74951 21.4501 6.50151 21.4891 6.25851 21.4501C5.66651 21.3381 5.27151 20.7741 5.36851 20.1791L6.25851 15.2591C6.31751 14.9001 6.19851 14.5351 5.93951 14.2801L2.32851 10.7801C2.02651 10.4871 1.92151 10.0471 2.05951 9.65009C2.19351 9.25409 2.53551 8.96509 2.94851 8.90009L7.91851 8.17909C8.29651 8.14009 8.62851 7.91009 8.79851 7.57009L10.9885 3.08009C11.0405 2.98009 11.1075 2.88809 11.1885 2.81009L11.2785 2.74009C11.3255 2.68809 11.3795 2.64509 11.4395 2.61009L11.5485 2.57009L11.7185 2.50009H12.1395C12.5155 2.53909 12.8465 2.76409 13.0195 3.10009L15.2385 7.57009C15.3985 7.89709 15.7095 8.12409 16.0685 8.17909L21.0385 8.90009C21.4585 8.96009 21.8095 9.25009 21.9485 9.65009C22.0795 10.0511 21.9665 10.4911 21.6585 10.7801L17.9185 14.3201Z"}"${add_attribute("fill", "#fff", 0)} class="${"svelte-1bo7sn4"}"></path></svg></button>
			<button class="${"btn featured svelte-1bo7sn4"}"><svg width="${"29"}" height="${"29"}" viewBox="${"0 0 24 24"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}" class="${"svelte-1bo7sn4"}"><path fill-rule="${"evenodd"}" clip-rule="${"evenodd"}" stroke-width="${"1"}" stroke="${"#000"}" d="${"M15.8498 2.50071C16.4808 2.50071 17.1108 2.58971 17.7098 2.79071C21.4008 3.99071 22.7308 8.04071 21.6198 11.5807C20.9898 13.3897 19.9598 15.0407 18.6108 16.3897C16.6798 18.2597 14.5608 19.9197 12.2798 21.3497L12.0298 21.5007L11.7698 21.3397C9.4808 19.9197 7.3498 18.2597 5.4008 16.3797C4.0608 15.0307 3.0298 13.3897 2.3898 11.5807C1.2598 8.04071 2.5898 3.99071 6.3208 2.76971C6.6108 2.66971 6.9098 2.59971 7.2098 2.56071H7.3298C7.6108 2.51971 7.8898 2.50071 8.1698 2.50071H8.2798C8.9098 2.51971 9.5198 2.62971 10.1108 2.83071H10.1698C10.2098 2.84971 10.2398 2.87071 10.2598 2.88971C10.4808 2.96071 10.6898 3.04071 10.8898 3.15071L11.2698 3.32071C11.3616 3.36968 11.4647 3.44451 11.5538 3.50918C11.6102 3.55015 11.661 3.58705 11.6998 3.61071C11.7161 3.62034 11.7327 3.63002 11.7494 3.63978C11.8352 3.68983 11.9245 3.74197 11.9998 3.79971C13.1108 2.95071 14.4598 2.49071 15.8498 2.50071ZM18.5098 9.70071C18.9198 9.68971 19.2698 9.36071 19.2998 8.93971V8.82071C19.3298 7.41971 18.4808 6.15071 17.1898 5.66071C16.7798 5.51971 16.3298 5.74071 16.1798 6.16071C16.0398 6.58071 16.2598 7.04071 16.6798 7.18971C17.3208 7.42971 17.7498 8.06071 17.7498 8.75971V8.79071C17.7308 9.01971 17.7998 9.24071 17.9398 9.41071C18.0798 9.58071 18.2898 9.67971 18.5098 9.70071Z"}"${add_attribute("fill", "#fff", 0)} class="${"svelte-1bo7sn4"}"></path></svg></button></div>
		<div class="${"banner-container svelte-1bo7sn4"}">${`<div class="${"banner-skeleton banner  svelte-1bo7sn4"}"></div>`}
			<input id="${"banner-upload"}" type="${"file"}" class="${"svelte-1bo7sn4"}">
			<label class="${"banner-label svelte-1bo7sn4"}" for="${"banner-upload"}"><svg width="${"54"}" height="${"54"}" viewBox="${"0 0 24 24"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}" class="${"svelte-1bo7sn4"}"><path fill-rule="${"evenodd"}" clip-rule="${"evenodd"}" d="${"M15.2411 2.24464L20.2916 7.55623C20.4252 7.69717 20.5 7.88443 20.5 8.07973V17.4435C20.5 19.9553 18.4971 22 16.0337 22H8.07002C5.46399 22 3.5 20.0409 3.5 17.4435V14.9206C3.5 14.5038 3.83498 14.1655 4.24771 14.1655C4.66045 14.1655 4.99543 14.5038 4.99543 14.9206V17.4435C4.99543 19.2083 6.28847 20.4899 8.07002 20.4899H16.0337C17.6726 20.4899 19.0046 19.1227 19.0046 17.4435V8.38276L15.1873 4.36887V5.68569C15.1873 6.69647 16.0018 7.51998 17.0027 7.522C17.4154 7.523 17.7494 7.86127 17.7484 8.27907C17.7474 8.69486 17.4134 9.03211 17.0007 9.03211H16.9997C15.1763 9.02809 13.6918 7.52703 13.6918 5.68569V3.5222H8.07002C6.40312 3.5222 4.99543 4.8954 4.99543 6.52129V10.8161C4.99543 11.2329 4.66045 11.5711 4.24771 11.5711C3.83498 11.5711 3.5 11.2329 3.5 10.8161V6.52129C3.5 4.07692 5.5926 2.01208 8.07002 2.01208H14.3817C14.3913 2.01116 14.4 2.00855 14.4086 2.006C14.4188 2.00296 14.4287 2 14.4395 2C14.4512 2 14.4616 2.00313 14.472 2.00624C14.4803 2.00872 14.4885 2.01119 14.4974 2.01208H14.7017C14.9051 2.01208 15.0995 2.09564 15.2411 2.24464ZM11.0698 10.5214C11.0698 10.1046 11.4048 9.76633 11.8176 9.76633C12.2303 9.76633 12.5653 10.1046 12.5653 10.5214V12.2339H14.2611C14.6738 12.2339 15.0088 12.5721 15.0088 12.9889C15.0088 13.4057 14.6738 13.744 14.2611 13.744H12.5653V15.4555C12.5653 15.8722 12.2303 16.2105 11.8176 16.2105C11.4048 16.2105 11.0698 15.8722 11.0698 15.4555V13.744H9.37503C8.96229 13.744 8.62732 13.4057 8.62732 12.9889C8.62732 12.5721 8.96229 12.2339 9.37503 12.2339H11.0698V10.5214Z"}" fill="${"#200E32"}" class="${"svelte-1bo7sn4"}"></path></svg></label></div>
		<div class="${"post-header svelte-1bo7sn4"}"><div class="${"post-title svelte-1bo7sn4"}">${`<h1 class="${"title svelte-1bo7sn4"}">${escape(content.title)}</h1>
					<button class="${"button-edit-title svelte-1bo7sn4"}"><svg width="${"25"}" height="${"25"}" viewBox="${"0 0 25 25"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}" class="${"svelte-1bo7sn4"}"><path d="${"M19.7 8.60004L8.9 19.4C8.8 19.5 8.80002 19.5 8.70002 19.5L6.20002 20.3L4.60001 20.8C4.20001 20.9 3.8 20.5 3.9 20.1L5.20002 16.1C5.20002 16 5.3 15.9 5.3 15.9L16.1 5.10004C17.1 4.10004 18.6 4.10004 19.6 5.10004C20.7 6.10004 20.7 7.60004 19.7 8.60004Z"}" stroke="${"#1A1A1A"}" stroke-width="${"1.5"}" stroke-miterlimit="${"10"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-1bo7sn4"}"></path><path d="${"M14.6 6.90002L18 10.3"}" stroke="${"#1A1A1A"}" stroke-width="${"1.5"}" stroke-miterlimit="${"10"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-1bo7sn4"}"></path></svg></button>`}</div>
			<div class="${"post-header_author svelte-1bo7sn4"}">${`<p class="${"gray author-name svelte-1bo7sn4"}">${escape(content.author)}</p>
					<p class="${"gray svelte-1bo7sn4"}">.</p>
					<p class="${"gray post-time svelte-1bo7sn4"}">${escape(content.postDate)}</p>
					<p class="${"gray read-time svelte-1bo7sn4"}">(${escape(content.readingTime)} min read)</p>
					<button class="${"button-edit-title svelte-1bo7sn4"}"><svg width="${"25"}" height="${"25"}" viewBox="${"0 0 25 25"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}" class="${"svelte-1bo7sn4"}"><path d="${"M19.7 8.60004L8.9 19.4C8.8 19.5 8.80002 19.5 8.70002 19.5L6.20002 20.3L4.60001 20.8C4.20001 20.9 3.8 20.5 3.9 20.1L5.20002 16.1C5.20002 16 5.3 15.9 5.3 15.9L16.1 5.10004C17.1 4.10004 18.6 4.10004 19.6 5.10004C20.7 6.10004 20.7 7.60004 19.7 8.60004Z"}" stroke="${"#1A1A1A"}" stroke-width="${"1.5"}" stroke-miterlimit="${"10"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-1bo7sn4"}"></path><path d="${"M14.6 6.90002L18 10.3"}" stroke="${"#1A1A1A"}" stroke-width="${"1.5"}" stroke-miterlimit="${"10"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-1bo7sn4"}"></path></svg></button>`}</div>
			<div class="${"tags gray svelte-1bo7sn4"}">${each(content.tags, (tag, i) => `<p class="${"gray tag svelte-1bo7sn4"}">#${escape(tag)}</p>`)}
				<input${add_attribute("value", content.tempTag, 0)} name="${"tempTag"}" class="${"tag-input svelte-1bo7sn4"}" placeholder="${"Enter tag"}">
				<button class="${"tag-button svelte-1bo7sn4"}"><svg width="${"24"}" height="${"24"}" viewBox="${"0 0 24 24"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}" class="${"svelte-1bo7sn4"}"><path d="${"M12 8.3273V15.6537"}" stroke="${"#200E32"}" stroke-width="${"1.5"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-1bo7sn4"}"></path><path d="${"M15.6667 11.9905H8.33334"}" stroke="${"#200E32"}" stroke-width="${"1.5"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-1bo7sn4"}"></path><path fill-rule="${"evenodd"}" clip-rule="${"evenodd"}" d="${"M16.6857 2H7.31429C4.04762 2 2 4.31208 2 7.58516V16.4148C2 19.6879 4.0381 22 7.31429 22H16.6857C19.9619 22 22 19.6879 22 16.4148V7.58516C22 4.31208 19.9619 2 16.6857 2Z"}" stroke="${"#200E32"}" stroke-width="${"1.5"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-1bo7sn4"}"></path></svg></button></div>
			<div class="${"post-body-text svelte-1bo7sn4"}">${each(content.body, (paragraph) => `<p class="${"post-body svelte-1bo7sn4"}">${escape(paragraph)}</p>`)}
				${`<button class="${"button-edit-title svelte-1bo7sn4"}"><svg width="${"25"}" height="${"25"}" viewBox="${"0 0 25 25"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}" class="${"svelte-1bo7sn4"}"><path d="${"M19.7 8.60004L8.9 19.4C8.8 19.5 8.80002 19.5 8.70002 19.5L6.20002 20.3L4.60001 20.8C4.20001 20.9 3.8 20.5 3.9 20.1L5.20002 16.1C5.20002 16 5.3 15.9 5.3 15.9L16.1 5.10004C17.1 4.10004 18.6 4.10004 19.6 5.10004C20.7 6.10004 20.7 7.60004 19.7 8.60004Z"}" stroke="${"#1A1A1A"}" stroke-width="${"1.5"}" stroke-miterlimit="${"10"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-1bo7sn4"}"></path><path d="${"M14.6 6.90002L18 10.3"}" stroke="${"#1A1A1A"}" stroke-width="${"1.5"}" stroke-miterlimit="${"10"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-1bo7sn4"}"></path></svg></button>`}</div>
			<button class="${"submit-post-btn svelte-1bo7sn4"}">Submit Post</button></div></div>

	${``}
</main>`;
});
var writepost = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Writepost
});
var css$3 = {
  code: ".main.svelte-xdritf{display:grid;grid-template-columns:225px calc(100vw - 225px);grid-template-rows:75px auto}",
  map: `{"version":3,"file":"settings.svelte","sources":["settings.svelte"],"sourcesContent":["<script>\\r\\n    import Sidebar from '../../components/dashboard.sidebar.svelte';\\r\\n    import Navbar from '../../components/dashboard.navbar.svelte';\\r\\n<\/script>\\r\\n\\r\\n<main class=\\"main\\" >\\r\\n    <Sidebar class=\\"sidebar\\" active=\\"settings\\" />\\r\\n    <Navbar class=\\"navbar\\" />\\r\\n</main>\\r\\n\\r\\n\\r\\n<style>\\r\\n    .main{\\r\\n        display:grid;\\r\\n        grid-template-columns: 225px calc(100vw - 225px);\\r\\n        grid-template-rows: 75px auto;\\r\\n    }\\r\\n\\r\\n    .sidebar{\\r\\n        grid-column: 1/2;\\r\\n        grid-row: 1/-1;\\r\\n    }\\r\\n\\r\\n    .navbar{\\r\\n        grid-column: 2/3;\\r\\n        grid-row: 1/2;\\r\\n    }\\r\\n</style>\\r\\n\\r\\n\\r\\n"],"names":[],"mappings":"AAYI,mBAAK,CAAC,AACF,QAAQ,IAAI,CACZ,qBAAqB,CAAE,KAAK,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAChD,kBAAkB,CAAE,IAAI,CAAC,IAAI,AACjC,CAAC"}`
};
var Settings = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  $$result.css.add(css$3);
  return `<main class="${"main svelte-xdritf"}">${validate_component(Dashboard_sidebar, "Sidebar").$$render($$result, { class: "sidebar", active: "settings" }, {}, {})}
    ${validate_component(Dashboard_navbar, "Navbar").$$render($$result, { class: "navbar" }, {}, {})}
</main>`;
});
var settings = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Settings
});
var css$2 = {
  code: ".main.svelte-xdritf{display:grid;grid-template-columns:225px calc(100vw - 225px);grid-template-rows:75px auto}",
  map: `{"version":3,"file":"profile.svelte","sources":["profile.svelte"],"sourcesContent":["<script>\\r\\n    import Sidebar from '../../components/dashboard.sidebar.svelte';\\r\\n    import Navbar from '../../components/dashboard.navbar.svelte';\\r\\n<\/script>\\r\\n\\r\\n<main class=\\"main\\" >\\r\\n    <Sidebar class=\\"sidebar\\" active=\\"profile\\" />\\r\\n    <Navbar class=\\"navbar\\" />\\r\\n</main>\\r\\n\\r\\n\\r\\n<style>\\r\\n    .main{\\r\\n        display:grid;\\r\\n        grid-template-columns: 225px calc(100vw - 225px);\\r\\n        grid-template-rows: 75px auto;\\r\\n    }\\r\\n\\r\\n    .sidebar{\\r\\n        grid-column: 1/2;\\r\\n        grid-row: 1/-1;\\r\\n    }\\r\\n\\r\\n    .navbar{\\r\\n        grid-column: 2/3;\\r\\n        grid-row: 1/2;\\r\\n    }\\r\\n</style>\\r\\n\\r\\n\\r\\n"],"names":[],"mappings":"AAYI,mBAAK,CAAC,AACF,QAAQ,IAAI,CACZ,qBAAqB,CAAE,KAAK,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,CAChD,kBAAkB,CAAE,IAAI,CAAC,IAAI,AACjC,CAAC"}`
};
var Profile = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  $$result.css.add(css$2);
  return `<main class="${"main svelte-xdritf"}">${validate_component(Dashboard_sidebar, "Sidebar").$$render($$result, { class: "sidebar", active: "profile" }, {}, {})}
    ${validate_component(Dashboard_navbar, "Navbar").$$render($$result, { class: "navbar" }, {}, {})}
</main>`;
});
var profile = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Profile
});
var css$1 = {
  code: "p.svelte-18ricl8,h1.svelte-18ricl8{margin:0}@import url('https://fonts.googleapis.com/css2?family=Libre+Baskerville:wght@400;700&display=swap');a.svelte-18ricl8{text-decoration:none;color:#1c1c1c}a.svelte-18ricl8,.svelte-18ricl8{font-family:'Libre Baskerville', serif}a.svelte-18ricl8{cursor:pointer;transform:scale(1)}a.svelte-18ricl8:hover{transition:transform 400ms;transform:scale(1.05)}.gray.svelte-18ricl8{color:rgba(28, 28, 28, 0.5)}.admin-details_name.svelte-18ricl8{font-size:42px;font-weight:bold;color:#1c1c1c}.about-main.svelte-18ricl8{width:100%;height:350px;display:flex;justify-content:center;align-items:center}.about-admin.svelte-18ricl8{width:718px;height:200px;display:grid;grid-template-columns:30% 10% 60%}.admin-image-container.svelte-18ricl8{grid-column:1/2;display:flex;justify-content:center;align-items:center;border-radius:50%;overflow:hidden}.admin_image.svelte-18ricl8{width:200px;height:200px;object-fit:cover}.admin-details-container.svelte-18ricl8{grid-column:3/4;display:flex;flex-direction:column;justify-content:space-between;align-items:flex-start}.admin-details-container-footer.svelte-18ricl8{display:flex;justify-content:space-between;width:100%;align-items:center}.admin-details-container-footer_left.svelte-18ricl8{display:flex;justify-content:space-between;align-items:center;width:165px}.admin-details-container-footer_right.svelte-18ricl8{display:flex;justify-content:space-between;width:90px;align-items:center}",
  map: `{"version":3,"file":"about.svelte","sources":["about.svelte"],"sourcesContent":["<script lang=\\"ts\\">import profile from '../assets/images/user/profile_picture.jpg';\\r\\n<\/script>\\r\\n\\r\\n<main class=\\"about-main\\">\\r\\n\\t<div class=\\"about-admin\\">\\r\\n\\t\\t<div class=\\"admin-image-container\\">\\r\\n\\t\\t\\t<img class=\\"admin_image\\" src={profile} alt=\\"admin\\" />\\r\\n\\t\\t</div>\\r\\n\\t\\t<div class=\\"admin-details-container\\">\\r\\n\\t\\t\\t<div class=\\"admin-details-header\\" >\\r\\n                <h1 class=\\"admin-details_name\\">Arthur Black</h1>\\r\\n\\t\\t\\t    <p class=\\"gray admin-details_info\\">@arthurblack</p>\\r\\n            </div>\\r\\n\\t\\t\\t<p class=\\"admin-details-body\\">\\r\\n\\t\\t\\t\\tIpsum adipisicing culpa est nisi consequat ex amet magna culpa veniam tempor irure ea.\\r\\n\\t\\t\\t\\tReprehenderit labore do tempor eiusmod in consectetur ex sunt id mollit commodo ipsum\\r\\n\\t\\t\\t\\tdeserunt quis.\\r\\n\\t\\t\\t</p>\\r\\n\\t\\t\\t<div class=\\"admin-details-container-footer\\" >\\r\\n                <div class=\\"admin-details-container-footer_left\\">\\r\\n                    <svg\\r\\n                        width=\\"24\\"\\r\\n                        height=\\"24\\"\\r\\n                        viewBox=\\"0 0 24 24\\"\\r\\n                        fill=\\"none\\"\\r\\n                        xmlns=\\"http://www.w3.org/2000/svg\\"\\r\\n                    >\\r\\n                        <path\\r\\n                            d=\\"M10 13C10.4295 13.5741 10.9774 14.0491 11.6066 14.3929C12.2357 14.7367 12.9315 14.9411 13.6467 14.9923C14.3618 15.0435 15.0796 14.9403 15.7513 14.6897C16.4231 14.4392 17.0331 14.047 17.54 13.54L20.54 10.54C21.4508 9.59695 21.9548 8.33394 21.9434 7.02296C21.932 5.71198 21.4061 4.45791 20.4791 3.53087C19.5521 2.60383 18.298 2.07799 16.987 2.0666C15.676 2.0552 14.413 2.55918 13.47 3.46997L11.75 5.17997\\"\\r\\n                            stroke=\\"#1C1C1C\\"\\r\\n                            stroke-width=\\"2\\"\\r\\n                            stroke-linecap=\\"round\\"\\r\\n                            stroke-linejoin=\\"round\\"\\r\\n                        />\\r\\n                        <path\\r\\n                            d=\\"M14 11.0002C13.5705 10.4261 13.0226 9.95104 12.3934 9.60729C11.7642 9.26353 11.0684 9.05911 10.3533 9.00789C9.63816 8.95667 8.92037 9.05986 8.24861 9.31044C7.57685 9.56103 6.96684 9.95316 6.45996 10.4602L3.45996 13.4602C2.54917 14.4032 2.04519 15.6662 2.05659 16.9772C2.06798 18.2882 2.59382 19.5423 3.52086 20.4693C4.4479 21.3964 5.70197 21.9222 7.01295 21.9336C8.32393 21.945 9.58694 21.441 10.53 20.5302L12.24 18.8202\\"\\r\\n                            stroke=\\"#1C1C1C\\"\\r\\n                            stroke-width=\\"2\\"\\r\\n                            stroke-linecap=\\"round\\"\\r\\n                            stroke-linejoin=\\"round\\"\\r\\n                        />\\r\\n                    </svg>\\r\\n                    <a href=\\"#\\" class=\\"footer_left-text\\">arthurblack.com</a>\\r\\n                </div>\\r\\n                <div class=\\"admin-details-container-footer_right\\">\\r\\n                    <a href=\\"#\\" class=\\"footer_right-social\\">\\r\\n                        <svg\\r\\n                            width=\\"24\\"\\r\\n                            height=\\"24\\"\\r\\n                            viewBox=\\"0 0 24 24\\"\\r\\n                            fill=\\"none\\"\\r\\n                            xmlns=\\"http://www.w3.org/2000/svg\\"\\r\\n                        >\\r\\n                            <path\\r\\n                                d=\\"M16 8C17.5913 8 19.1174 8.63214 20.2426 9.75736C21.3679 10.8826 22 12.4087 22 14V21H18V14C18 13.4696 17.7893 12.9609 17.4142 12.5858C17.0391 12.2107 16.5304 12 16 12C15.4696 12 14.9609 12.2107 14.5858 12.5858C14.2107 12.9609 14 13.4696 14 14V21H10V14C10 12.4087 10.6321 10.8826 11.7574 9.75736C12.8826 8.63214 14.4087 8 16 8V8Z\\"\\r\\n                                stroke=\\"#1C1C1C\\"\\r\\n                                stroke-width=\\"2\\"\\r\\n                                stroke-linecap=\\"round\\"\\r\\n                                stroke-linejoin=\\"round\\"\\r\\n                            />\\r\\n                            <path\\r\\n                                d=\\"M6 9H2V21H6V9Z\\"\\r\\n                                stroke=\\"#1C1C1C\\"\\r\\n                                stroke-width=\\"2\\"\\r\\n                                stroke-linecap=\\"round\\"\\r\\n                                stroke-linejoin=\\"round\\"\\r\\n                            />\\r\\n                            <path\\r\\n                                d=\\"M4 6C5.10457 6 6 5.10457 6 4C6 2.89543 5.10457 2 4 2C2.89543 2 2 2.89543 2 4C2 5.10457 2.89543 6 4 6Z\\"\\r\\n                                stroke=\\"#1C1C1C\\"\\r\\n                                stroke-width=\\"2\\"\\r\\n                                stroke-linecap=\\"round\\"\\r\\n                                stroke-linejoin=\\"round\\"\\r\\n                            />\\r\\n                        </svg>\\r\\n                    </a>\\r\\n                    <a href=\\"#\\" class=\\"footer_right-social\\">\\r\\n                        <svg\\r\\n                            width=\\"24\\"\\r\\n                            height=\\"24\\"\\r\\n                            viewBox=\\"0 0 24 24\\"\\r\\n                            fill=\\"none\\"\\r\\n                            xmlns=\\"http://www.w3.org/2000/svg\\"\\r\\n                        >\\r\\n                            <path\\r\\n                                d=\\"M23 2.9998C22.0424 3.67528 20.9821 4.19191 19.86 4.5298C19.2577 3.83731 18.4573 3.34649 17.567 3.12373C16.6767 2.90096 15.7395 2.957 14.8821 3.28426C14.0247 3.61151 13.2884 4.1942 12.773 4.95352C12.2575 5.71283 11.9877 6.61214 12 7.5298V8.5298C10.2426 8.57537 8.50127 8.18561 6.93101 7.39525C5.36074 6.60488 4.01032 5.43844 3 3.9998C3 3.9998 -1 12.9998 8 16.9998C5.94053 18.3978 3.48716 19.0987 1 18.9998C10 23.9998 21 18.9998 21 7.4998C20.9991 7.22126 20.9723 6.9434 20.92 6.6698C21.9406 5.6633 22.6608 4.39251 23 2.9998V2.9998Z\\"\\r\\n                                stroke=\\"#1C1C1C\\"\\r\\n                                stroke-width=\\"2\\"\\r\\n                                stroke-linecap=\\"round\\"\\r\\n                                stroke-linejoin=\\"round\\"\\r\\n                            />\\r\\n                        </svg>\\r\\n                    </a>\\r\\n                    <a href=\\"#\\" class=\\"footer_right-social\\">\\r\\n                        <svg\\r\\n                            width=\\"24\\"\\r\\n                            height=\\"24\\"\\r\\n                            viewBox=\\"0 0 24 24\\"\\r\\n                            fill=\\"none\\"\\r\\n                            xmlns=\\"http://www.w3.org/2000/svg\\"\\r\\n                        >\\r\\n                            <path\\r\\n                                d=\\"M17 2H7C4.23858 2 2 4.23858 2 7V17C2 19.7614 4.23858 22 7 22H17C19.7614 22 22 19.7614 22 17V7C22 4.23858 19.7614 2 17 2Z\\"\\r\\n                                stroke=\\"#1C1C1C\\"\\r\\n                                stroke-width=\\"2\\"\\r\\n                                stroke-linecap=\\"round\\"\\r\\n                                stroke-linejoin=\\"round\\"\\r\\n                            />\\r\\n                            <path\\r\\n                                d=\\"M16 11.3698C16.1234 12.2021 15.9812 13.052 15.5937 13.7988C15.2062 14.5456 14.5931 15.1512 13.8416 15.5295C13.0901 15.9077 12.2384 16.0394 11.4077 15.9057C10.5771 15.7721 9.80971 15.3799 9.21479 14.785C8.61987 14.1901 8.22768 13.4227 8.09402 12.592C7.96035 11.7614 8.09202 10.9097 8.47028 10.1582C8.84854 9.40667 9.45414 8.79355 10.2009 8.40605C10.9477 8.01856 11.7977 7.8764 12.63 7.99981C13.4789 8.1257 14.2648 8.52128 14.8716 9.12812C15.4785 9.73496 15.8741 10.5209 16 11.3698Z\\"\\r\\n                                stroke=\\"#1C1C1C\\"\\r\\n                                stroke-width=\\"2\\"\\r\\n                                stroke-linecap=\\"round\\"\\r\\n                                stroke-linejoin=\\"round\\"\\r\\n                            />\\r\\n                            <path\\r\\n                                d=\\"M17.5 6.5H17.51\\"\\r\\n                                stroke=\\"#1C1C1C\\"\\r\\n                                stroke-width=\\"2\\"\\r\\n                                stroke-linecap=\\"round\\"\\r\\n                                stroke-linejoin=\\"round\\"\\r\\n                            />\\r\\n                        </svg>\\r\\n                    </a>\\r\\n                </div>\\r\\n            </div>\\r\\n\\t\\t</div>\\r\\n\\t</div>\\r\\n</main>\\r\\n\\r\\n<style>\\r\\n\\r\\n    p, \\r\\n    h1{\\r\\n        margin: 0;\\r\\n    }\\r\\n\\r\\n    @import url('https://fonts.googleapis.com/css2?family=Libre+Baskerville:wght@400;700&display=swap');\\r\\n\\ta {\\r\\n\\t\\ttext-decoration: none;\\r\\n        color: #1c1c1c;\\r\\n\\t}\\r\\n\\r\\n\\ta,\\r\\n\\t* {\\r\\n\\t\\tfont-family: 'Libre Baskerville', serif;\\r\\n\\t}\\r\\n\\r\\n\\tbutton,\\r\\n\\ta {\\r\\n\\t\\tcursor: pointer;\\r\\n\\t\\ttransform: scale(1);\\r\\n\\t}\\r\\n\\r\\n\\ta:hover,\\r\\n\\tbutton:hover {\\r\\n\\t\\ttransition: transform 400ms;\\r\\n\\t\\ttransform: scale(1.05);\\r\\n\\t}\\r\\n\\r\\n    .gray{\\r\\n        color: rgba(28, 28, 28, 0.5);\\r\\n    }\\r\\n\\r\\n\\r\\n    /*  typography */\\r\\n\\r\\n    .admin-details_name{\\r\\n        font-size: 42px;\\r\\n        font-weight: bold;\\r\\n        color: #1c1c1c;\\r\\n    }\\r\\n\\r\\n    .about-main{\\r\\n        width: 100%;\\r\\n        height: 350px;\\r\\n        display: flex;\\r\\n        justify-content: center;\\r\\n        align-items: center;\\r\\n    }\\r\\n\\r\\n    .about-admin{\\r\\n        width: 718px;\\r\\n        height: 200px;\\r\\n        display: grid;\\r\\n        grid-template-columns: 30% 10% 60%;\\r\\n    }\\r\\n\\r\\n    .admin-image-container{\\r\\n        grid-column: 1/2;\\r\\n        display: flex;\\r\\n        justify-content: center;\\r\\n        align-items: center;\\r\\n        border-radius: 50%;\\r\\n        overflow: hidden;\\r\\n    }\\r\\n\\r\\n    .admin_image{\\r\\n        width: 200px;\\r\\n        height: 200px;\\r\\n        object-fit: cover;\\r\\n    }\\r\\n\\r\\n    .admin-details-container{\\r\\n        grid-column:  3/4;\\r\\n        display: flex;\\r\\n        flex-direction: column;\\r\\n        justify-content: space-between;\\r\\n        align-items: flex-start;\\r\\n      \\r\\n    }\\r\\n\\r\\n    .admin-details-container-footer{\\r\\n        display: flex;\\r\\n        justify-content: space-between;\\r\\n        width: 100%;\\r\\n        align-items: center;\\r\\n    }\\r\\n\\r\\n    .admin-details-container-footer_left{\\r\\n        display: flex;\\r\\n        justify-content: space-between;\\r\\n        align-items: center;\\r\\n        width: 165px;\\r\\n    }\\r\\n\\r\\n    .admin-details-container-footer_right{\\r\\n        display: flex;\\r\\n        justify-content: space-between;\\r\\n        width: 90px;\\r\\n        align-items: center;\\r\\n    }\\r\\n</style>\\r\\n"],"names":[],"mappings":"AAoII,gBAAC,CACD,iBAAE,CAAC,AACC,MAAM,CAAE,CAAC,AACb,CAAC,AAED,QAAQ,IAAI,sFAAsF,CAAC,CAAC,AACvG,CAAC,eAAC,CAAC,AACF,eAAe,CAAE,IAAI,CACf,KAAK,CAAE,OAAO,AACrB,CAAC,AAED,gBAAC,CACD,eAAE,CAAC,AACF,WAAW,CAAE,mBAAmB,CAAC,CAAC,KAAK,AACxC,CAAC,AAGD,CAAC,eAAC,CAAC,AACF,MAAM,CAAE,OAAO,CACf,SAAS,CAAE,MAAM,CAAC,CAAC,AACpB,CAAC,AAED,gBAAC,MAAM,AACM,CAAC,AACb,UAAU,CAAE,SAAS,CAAC,KAAK,CAC3B,SAAS,CAAE,MAAM,IAAI,CAAC,AACvB,CAAC,AAEE,oBAAK,CAAC,AACF,KAAK,CAAE,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,AAChC,CAAC,AAKD,kCAAmB,CAAC,AAChB,SAAS,CAAE,IAAI,CACf,WAAW,CAAE,IAAI,CACjB,KAAK,CAAE,OAAO,AAClB,CAAC,AAED,0BAAW,CAAC,AACR,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,KAAK,CACb,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,MAAM,CACvB,WAAW,CAAE,MAAM,AACvB,CAAC,AAED,2BAAY,CAAC,AACT,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,CACb,OAAO,CAAE,IAAI,CACb,qBAAqB,CAAE,GAAG,CAAC,GAAG,CAAC,GAAG,AACtC,CAAC,AAED,qCAAsB,CAAC,AACnB,WAAW,CAAE,CAAC,CAAC,CAAC,CAChB,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,MAAM,CACvB,WAAW,CAAE,MAAM,CACnB,aAAa,CAAE,GAAG,CAClB,QAAQ,CAAE,MAAM,AACpB,CAAC,AAED,2BAAY,CAAC,AACT,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,CACb,UAAU,CAAE,KAAK,AACrB,CAAC,AAED,uCAAwB,CAAC,AACrB,WAAW,CAAG,CAAC,CAAC,CAAC,CACjB,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,eAAe,CAAE,aAAa,CAC9B,WAAW,CAAE,UAAU,AAE3B,CAAC,AAED,8CAA+B,CAAC,AAC5B,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,aAAa,CAC9B,KAAK,CAAE,IAAI,CACX,WAAW,CAAE,MAAM,AACvB,CAAC,AAED,mDAAoC,CAAC,AACjC,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,aAAa,CAC9B,WAAW,CAAE,MAAM,CACnB,KAAK,CAAE,KAAK,AAChB,CAAC,AAED,oDAAqC,CAAC,AAClC,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,aAAa,CAC9B,KAAK,CAAE,IAAI,CACX,WAAW,CAAE,MAAM,AACvB,CAAC"}`
};
var About = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  $$result.css.add(css$1);
  return `<main class="${"about-main svelte-18ricl8"}"><div class="${"about-admin svelte-18ricl8"}"><div class="${"admin-image-container svelte-18ricl8"}"><img class="${"admin_image svelte-18ricl8"}"${add_attribute("src", profile$1, 0)} alt="${"admin"}"></div>
		<div class="${"admin-details-container svelte-18ricl8"}"><div class="${"admin-details-header svelte-18ricl8"}"><h1 class="${"admin-details_name svelte-18ricl8"}">Arthur Black</h1>
			    <p class="${"gray admin-details_info svelte-18ricl8"}">@arthurblack</p></div>
			<p class="${"admin-details-body svelte-18ricl8"}">Ipsum adipisicing culpa est nisi consequat ex amet magna culpa veniam tempor irure ea.
				Reprehenderit labore do tempor eiusmod in consectetur ex sunt id mollit commodo ipsum
				deserunt quis.
			</p>
			<div class="${"admin-details-container-footer svelte-18ricl8"}"><div class="${"admin-details-container-footer_left svelte-18ricl8"}"><svg width="${"24"}" height="${"24"}" viewBox="${"0 0 24 24"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}" class="${"svelte-18ricl8"}"><path d="${"M10 13C10.4295 13.5741 10.9774 14.0491 11.6066 14.3929C12.2357 14.7367 12.9315 14.9411 13.6467 14.9923C14.3618 15.0435 15.0796 14.9403 15.7513 14.6897C16.4231 14.4392 17.0331 14.047 17.54 13.54L20.54 10.54C21.4508 9.59695 21.9548 8.33394 21.9434 7.02296C21.932 5.71198 21.4061 4.45791 20.4791 3.53087C19.5521 2.60383 18.298 2.07799 16.987 2.0666C15.676 2.0552 14.413 2.55918 13.47 3.46997L11.75 5.17997"}" stroke="${"#1C1C1C"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-18ricl8"}"></path><path d="${"M14 11.0002C13.5705 10.4261 13.0226 9.95104 12.3934 9.60729C11.7642 9.26353 11.0684 9.05911 10.3533 9.00789C9.63816 8.95667 8.92037 9.05986 8.24861 9.31044C7.57685 9.56103 6.96684 9.95316 6.45996 10.4602L3.45996 13.4602C2.54917 14.4032 2.04519 15.6662 2.05659 16.9772C2.06798 18.2882 2.59382 19.5423 3.52086 20.4693C4.4479 21.3964 5.70197 21.9222 7.01295 21.9336C8.32393 21.945 9.58694 21.441 10.53 20.5302L12.24 18.8202"}" stroke="${"#1C1C1C"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-18ricl8"}"></path></svg>
                    <a href="${"#"}" class="${"footer_left-text svelte-18ricl8"}">arthurblack.com</a></div>
                <div class="${"admin-details-container-footer_right svelte-18ricl8"}"><a href="${"#"}" class="${"footer_right-social svelte-18ricl8"}"><svg width="${"24"}" height="${"24"}" viewBox="${"0 0 24 24"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}" class="${"svelte-18ricl8"}"><path d="${"M16 8C17.5913 8 19.1174 8.63214 20.2426 9.75736C21.3679 10.8826 22 12.4087 22 14V21H18V14C18 13.4696 17.7893 12.9609 17.4142 12.5858C17.0391 12.2107 16.5304 12 16 12C15.4696 12 14.9609 12.2107 14.5858 12.5858C14.2107 12.9609 14 13.4696 14 14V21H10V14C10 12.4087 10.6321 10.8826 11.7574 9.75736C12.8826 8.63214 14.4087 8 16 8V8Z"}" stroke="${"#1C1C1C"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-18ricl8"}"></path><path d="${"M6 9H2V21H6V9Z"}" stroke="${"#1C1C1C"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-18ricl8"}"></path><path d="${"M4 6C5.10457 6 6 5.10457 6 4C6 2.89543 5.10457 2 4 2C2.89543 2 2 2.89543 2 4C2 5.10457 2.89543 6 4 6Z"}" stroke="${"#1C1C1C"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-18ricl8"}"></path></svg></a>
                    <a href="${"#"}" class="${"footer_right-social svelte-18ricl8"}"><svg width="${"24"}" height="${"24"}" viewBox="${"0 0 24 24"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}" class="${"svelte-18ricl8"}"><path d="${"M23 2.9998C22.0424 3.67528 20.9821 4.19191 19.86 4.5298C19.2577 3.83731 18.4573 3.34649 17.567 3.12373C16.6767 2.90096 15.7395 2.957 14.8821 3.28426C14.0247 3.61151 13.2884 4.1942 12.773 4.95352C12.2575 5.71283 11.9877 6.61214 12 7.5298V8.5298C10.2426 8.57537 8.50127 8.18561 6.93101 7.39525C5.36074 6.60488 4.01032 5.43844 3 3.9998C3 3.9998 -1 12.9998 8 16.9998C5.94053 18.3978 3.48716 19.0987 1 18.9998C10 23.9998 21 18.9998 21 7.4998C20.9991 7.22126 20.9723 6.9434 20.92 6.6698C21.9406 5.6633 22.6608 4.39251 23 2.9998V2.9998Z"}" stroke="${"#1C1C1C"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-18ricl8"}"></path></svg></a>
                    <a href="${"#"}" class="${"footer_right-social svelte-18ricl8"}"><svg width="${"24"}" height="${"24"}" viewBox="${"0 0 24 24"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}" class="${"svelte-18ricl8"}"><path d="${"M17 2H7C4.23858 2 2 4.23858 2 7V17C2 19.7614 4.23858 22 7 22H17C19.7614 22 22 19.7614 22 17V7C22 4.23858 19.7614 2 17 2Z"}" stroke="${"#1C1C1C"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-18ricl8"}"></path><path d="${"M16 11.3698C16.1234 12.2021 15.9812 13.052 15.5937 13.7988C15.2062 14.5456 14.5931 15.1512 13.8416 15.5295C13.0901 15.9077 12.2384 16.0394 11.4077 15.9057C10.5771 15.7721 9.80971 15.3799 9.21479 14.785C8.61987 14.1901 8.22768 13.4227 8.09402 12.592C7.96035 11.7614 8.09202 10.9097 8.47028 10.1582C8.84854 9.40667 9.45414 8.79355 10.2009 8.40605C10.9477 8.01856 11.7977 7.8764 12.63 7.99981C13.4789 8.1257 14.2648 8.52128 14.8716 9.12812C15.4785 9.73496 15.8741 10.5209 16 11.3698Z"}" stroke="${"#1C1C1C"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-18ricl8"}"></path><path d="${"M17.5 6.5H17.51"}" stroke="${"#1C1C1C"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-18ricl8"}"></path></svg></a></div></div></div></div>
</main>`;
});
var about = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": About
});
var css = {
  code: "@import url('https://fonts.googleapis.com/css2?family=Libre+Baskerville:wght@400;700&display=swap');a.svelte-k9rgss{text-decoration:none}a.svelte-k9rgss,.svelte-k9rgss{font-family:'Libre Baskerville', serif}button.svelte-k9rgss,a.svelte-k9rgss{cursor:pointer;transform:scale(1)}a.svelte-k9rgss:hover,button.svelte-k9rgss:hover{transition:transform 400ms;transform:scale(1.05)}.gray.svelte-k9rgss{color:rgba(28, 28, 28, 0.5);font-family:-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif}.main-heading.svelte-k9rgss{font-size:33px;font-weight:bold;color:#000;margin:0}.main-heading-info.svelte-k9rgss{font-size:1rem;margin:0.7em 0;color:#000}.input-container.svelte-k9rgss{display:flex;justify-content:space-between;align-items:center;width:324px;height:58px;box-sizing:border-box;border-radius:10px;background-color:#f8f8f8;overflow:hidden;margin:10px 0;padding:0 10px}.remember-container.svelte-k9rgss{height:20px;background-color:transparent;margin:0;padding:0;width:150px}.login-form-center.svelte-k9rgss{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}.login-input.svelte-k9rgss{border:0;outline:0;width:calc(100% - 30px);height:100%;background-color:transparent;padding-left:10px}.login-main.svelte-k9rgss{height:calc(100vh - 91px);display:flex;justify-content:center;align-items:center}.container.svelte-k9rgss{display:flex;flex-direction:column;align-items:center;width:324px;height:322px}.remember-checkbox.svelte-k9rgss{width:18px;height:17px}.login-button.svelte-k9rgss{width:323px;height:58px;border-radius:10px;border:1.5px solid #000;color:#1c1c1c;font-size:20px;background-color:#fefefe}",
  map: `{"version":3,"file":"login.svelte","sources":["login.svelte"],"sourcesContent":["<script context=\\"module\\">\\r\\n    import { localStore } from '../services/localStorage';\\r\\n\\timport { useAuthListener } from '../utils/authListener';\\r\\n    let user;\\r\\n    user = useAuthListener();\\r\\n\\texport async function load({ page, fetch, session, stuff }) {\\r\\n       // localStore.subscribe((value) => value && (user = JSON.parse(value)));\\r\\n\\r\\n\\t\\tif (user) {\\r\\n\\t\\t\\treturn {\\r\\n\\t\\t\\t\\tstatus: 302,\\r\\n\\t\\t\\t\\tredirect: '/'\\r\\n                \\r\\n\\t\\t\\t};\\r\\n\\t\\t}\\r\\n\\r\\n        return {};\\r\\n\\t}\\r\\n<\/script>\\r\\n\\r\\n<script lang=\\"ts\\" >import { loginAdmin } from '../utils/firebase.apis';\\r\\nlet email = '';\\r\\nlet password = '';\\r\\nfunction handleChange(e) {\\r\\n    const { name, value } = e.target;\\r\\n    if (name === \\"email\\") {\\r\\n        email = value;\\r\\n    }\\r\\n    else if (name === \\"password\\") {\\r\\n        password = value;\\r\\n    }\\r\\n}\\r\\nfunction handleSubmit(e) {\\r\\n    e.preventDefault();\\r\\n    loginAdmin(email, password);\\r\\n}\\r\\n<\/script>\\r\\n\\r\\n\\r\\n<main class=\\"login-main\\" >\\r\\n    <div class=\\"container\\" >\\r\\n        <h1 class=\\"main-heading\\" >Welcome back!</h1>\\r\\n        <p class=\\"main-heading-info\\" >Sign in to get the most out of nuntium</p>\\r\\n        <form on:submit={handleSubmit} class=\\"login-form\\" >\\r\\n            <div class=\\"input-container\\" >\\r\\n                <label class=\\"login-label\\" for=\\"username\\" >\\r\\n                    <svg width=\\"24\\" height=\\"24\\" viewBox=\\"0 0 24 24\\" fill=\\"none\\" xmlns=\\"http://www.w3.org/2000/svg\\">\\r\\n                        <path d=\\"M20 21V19C20 17.9391 19.5786 16.9217 18.8284 16.1716C18.0783 15.4214 17.0609 15 16 15H8C6.93913 15 5.92172 15.4214 5.17157 16.1716C4.42143 16.9217 4 17.9391 4 19V21\\" stroke=\\"#1C1C1C\\" stroke-opacity=\\"0.5\\" stroke-width=\\"2\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\"/>\\r\\n                        <path d=\\"M12 11C14.2091 11 16 9.20914 16 7C16 4.79086 14.2091 3 12 3C9.79086 3 8 4.79086 8 7C8 9.20914 9.79086 11 12 11Z\\" stroke=\\"#1C1C1C\\" stroke-opacity=\\"0.5\\" stroke-width=\\"2\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\"/>\\r\\n                    </svg>                        \\r\\n                </label>\\r\\n                <input on:change={handleChange} class=\\"login-input\\" id=\\"username\\" name=\\"email\\" type=\\"text\\" placeholder=\\"Email\\" />\\r\\n            </div>\\r\\n            <div class=\\"input-container\\" >\\r\\n                <label class=\\"login-label\\" for=\\"password\\" >\\r\\n                    <svg width=\\"24\\" height=\\"24\\" viewBox=\\"0 0 24 24\\" fill=\\"none\\" xmlns=\\"http://www.w3.org/2000/svg\\">\\r\\n                        <path d=\\"M15.5 7.5L19 4M21 2L19 4L21 2ZM11.39 11.61C11.9064 12.1195 12.3168 12.726 12.5978 13.3948C12.8787 14.0635 13.0246 14.7813 13.0271 15.5066C13.0295 16.232 12.8884 16.9507 12.6119 17.6213C12.3355 18.2919 11.9291 18.9012 11.4162 19.4141C10.9033 19.9271 10.294 20.3334 9.62333 20.6099C8.95271 20.8864 8.23403 21.0275 7.50866 21.025C6.7833 21.0226 6.06557 20.8767 5.39682 20.5958C4.72807 20.3148 4.1215 19.9043 3.61203 19.388C2.61016 18.3507 2.05579 16.9614 2.06832 15.5193C2.08085 14.0772 2.65928 12.6977 3.67903 11.678C4.69877 10.6583 6.07824 10.0798 7.52032 10.0673C8.96241 10.0548 10.3517 10.6091 11.389 11.611L11.39 11.61ZM11.39 11.61L15.5 7.5L11.39 11.61ZM15.5 7.5L18.5 10.5L22 7L19 4L15.5 7.5Z\\" stroke=\\"#1C1C1C\\" stroke-opacity=\\"0.5\\" stroke-width=\\"2\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\"/>\\r\\n                    </svg>                        \\r\\n                </label>\\r\\n                <input on:change={handleChange} class=\\"login-input\\" id=\\"password\\" name=\\"password\\" type=\\"password\\" placeholder=\\"password\\" />\\r\\n            </div>\\r\\n            <div class=\\"login-form-center\\" >\\r\\n                <div class=\\"input-container remember-container \\" >\\r\\n                    <input class=\\"remember-checkbox\\" id=\\"remember\\" type=\\"checkbox\\" checked={false} />\\r\\n                    <label for=\\"remember\\" class=\\"gray checkbox-label\\" >Remember me</label>\\r\\n                </div>\\r\\n                <a class=\\"forgot-password-link gray \\" href=\\"/forgot-password\\" >Forgot Password?</a>\\r\\n            </div>\\r\\n            <button class=\\"login-button\\" >Login</button>\\r\\n            \\r\\n        </form>\\r\\n    </div>\\r\\n</main>\\r\\n\\r\\n<style>\\r\\n    @import url('https://fonts.googleapis.com/css2?family=Libre+Baskerville:wght@400;700&display=swap');\\r\\n    a{\\r\\n        text-decoration: none;\\r\\n    }\\r\\n\\r\\n    a,\\r\\n    *{\\r\\n        font-family: 'Libre Baskerville', serif;\\r\\n    }\\r\\n\\r\\n    button, a{\\r\\n        cursor: pointer;\\r\\n        transform: scale(1);\\r\\n    }\\r\\n\\r\\n    a:hover,\\r\\n    button:hover{\\r\\n        transition: transform 400ms;\\r\\n        transform: scale(1.05);\\r\\n    }\\r\\n\\r\\n    .gray{\\r\\n        color: rgba(28, 28, 28, 0.5);\\r\\n        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;\\r\\n    }\\r\\n\\r\\n    .main-heading{\\r\\n        font-size: 33px;\\r\\n        font-weight: bold;\\r\\n        color: #000;\\r\\n        margin: 0;\\r\\n    }\\r\\n\\r\\n    .main-heading-info{\\r\\n        font-size: 1rem;\\r\\n        margin: 0.7em 0;\\r\\n        color: #000;\\r\\n\\r\\n    }\\r\\n\\r\\n    .input-container{\\r\\n        display: flex;\\r\\n        justify-content: space-between;\\r\\n        align-items: center;\\r\\n        width: 324px;\\r\\n        height: 58px;\\r\\n        box-sizing: border-box;\\r\\n        border-radius: 10px;\\r\\n        background-color: #f8f8f8;\\r\\n        overflow: hidden;\\r\\n        margin: 10px 0;\\r\\n        padding: 0 10px;\\r\\n    }\\r\\n\\r\\n    .remember-container{\\r\\n        height: 20px;\\r\\n        background-color: transparent;\\r\\n        margin: 0;\\r\\n        padding: 0;\\r\\n        \\r\\n        width: 150px;\\r\\n        \\r\\n    }\\r\\n\\r\\n    .login-form-center{\\r\\n        display: flex;\\r\\n        justify-content: space-between;\\r\\n        align-items: center;\\r\\n        margin-bottom: 10px;\\r\\n    }\\r\\n\\r\\n    .login-input{\\r\\n        border: 0;\\r\\n        outline: 0;\\r\\n        width: calc(100% - 30px);\\r\\n        height: 100%;\\r\\n        background-color: transparent;\\r\\n        padding-left: 10px;\\r\\n        \\r\\n    }\\r\\n\\r\\n\\r\\n    .login-main{\\r\\n        height: calc(100vh - 91px);\\r\\n        display: flex;\\r\\n        justify-content: center;\\r\\n        align-items: center;\\r\\n    }\\r\\n\\r\\n    .container{\\r\\n        display: flex;\\r\\n        flex-direction: column;\\r\\n        align-items: center;\\r\\n        width: 324px;\\r\\n        height: 322px;\\r\\n    }\\r\\n\\r\\n    .remember-checkbox{\\r\\n        width: 18px;\\r\\n        height: 17px;\\r\\n    }\\r\\n\\r\\n    .login-button{\\r\\n        width: 323px;\\r\\n        height: 58px;\\r\\n        border-radius: 10px;\\r\\n        border: 1.5px solid #000;\\r\\n        color: #1c1c1c;\\r\\n        font-size: 20px;\\r\\n        background-color: #fefefe;\\r\\n    }\\r\\n\\r\\n</style>"],"names":[],"mappings":"AA2EI,QAAQ,IAAI,sFAAsF,CAAC,CAAC,AACpG,eAAC,CAAC,AACE,eAAe,CAAE,IAAI,AACzB,CAAC,AAED,eAAC,CACD,cAAC,CAAC,AACE,WAAW,CAAE,mBAAmB,CAAC,CAAC,KAAK,AAC3C,CAAC,AAED,oBAAM,CAAE,eAAC,CAAC,AACN,MAAM,CAAE,OAAO,CACf,SAAS,CAAE,MAAM,CAAC,CAAC,AACvB,CAAC,AAED,eAAC,MAAM,CACP,oBAAM,MAAM,CAAC,AACT,UAAU,CAAE,SAAS,CAAC,KAAK,CAC3B,SAAS,CAAE,MAAM,IAAI,CAAC,AAC1B,CAAC,AAED,mBAAK,CAAC,AACF,KAAK,CAAE,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,CAC5B,WAAW,CAAE,aAAa,CAAC,CAAC,kBAAkB,CAAC,CAAC,UAAU,CAAC,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC,SAAS,CAAC,CAAC,WAAW,CAAC,CAAC,gBAAgB,CAAC,CAAC,UAAU,AAC5I,CAAC,AAED,2BAAa,CAAC,AACV,SAAS,CAAE,IAAI,CACf,WAAW,CAAE,IAAI,CACjB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,CAAC,AACb,CAAC,AAED,gCAAkB,CAAC,AACf,SAAS,CAAE,IAAI,CACf,MAAM,CAAE,KAAK,CAAC,CAAC,CACf,KAAK,CAAE,IAAI,AAEf,CAAC,AAED,8BAAgB,CAAC,AACb,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,aAAa,CAC9B,WAAW,CAAE,MAAM,CACnB,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,IAAI,CACZ,UAAU,CAAE,UAAU,CACtB,aAAa,CAAE,IAAI,CACnB,gBAAgB,CAAE,OAAO,CACzB,QAAQ,CAAE,MAAM,CAChB,MAAM,CAAE,IAAI,CAAC,CAAC,CACd,OAAO,CAAE,CAAC,CAAC,IAAI,AACnB,CAAC,AAED,iCAAmB,CAAC,AAChB,MAAM,CAAE,IAAI,CACZ,gBAAgB,CAAE,WAAW,CAC7B,MAAM,CAAE,CAAC,CACT,OAAO,CAAE,CAAC,CAEV,KAAK,CAAE,KAAK,AAEhB,CAAC,AAED,gCAAkB,CAAC,AACf,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,aAAa,CAC9B,WAAW,CAAE,MAAM,CACnB,aAAa,CAAE,IAAI,AACvB,CAAC,AAED,0BAAY,CAAC,AACT,MAAM,CAAE,CAAC,CACT,OAAO,CAAE,CAAC,CACV,KAAK,CAAE,KAAK,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,CACxB,MAAM,CAAE,IAAI,CACZ,gBAAgB,CAAE,WAAW,CAC7B,YAAY,CAAE,IAAI,AAEtB,CAAC,AAGD,yBAAW,CAAC,AACR,MAAM,CAAE,KAAK,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAC1B,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,MAAM,CACvB,WAAW,CAAE,MAAM,AACvB,CAAC,AAED,wBAAU,CAAC,AACP,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,WAAW,CAAE,MAAM,CACnB,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,AACjB,CAAC,AAED,gCAAkB,CAAC,AACf,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,AAChB,CAAC,AAED,2BAAa,CAAC,AACV,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,IAAI,CACZ,aAAa,CAAE,IAAI,CACnB,MAAM,CAAE,KAAK,CAAC,KAAK,CAAC,IAAI,CACxB,KAAK,CAAE,OAAO,CACd,SAAS,CAAE,IAAI,CACf,gBAAgB,CAAE,OAAO,AAC7B,CAAC"}`
};
var user;
user = useAuthListener();
async function load({ page, fetch: fetch2, session, stuff }) {
  if (user) {
    return { status: 302, redirect: "/" };
  }
  return {};
}
var Login = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  $$result.css.add(css);
  return `<main class="${"login-main svelte-k9rgss"}"><div class="${"container svelte-k9rgss"}"><h1 class="${"main-heading svelte-k9rgss"}">Welcome back!</h1>
        <p class="${"main-heading-info svelte-k9rgss"}">Sign in to get the most out of nuntium</p>
        <form class="${"login-form svelte-k9rgss"}"><div class="${"input-container svelte-k9rgss"}"><label class="${"login-label svelte-k9rgss"}" for="${"username"}"><svg width="${"24"}" height="${"24"}" viewBox="${"0 0 24 24"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}" class="${"svelte-k9rgss"}"><path d="${"M20 21V19C20 17.9391 19.5786 16.9217 18.8284 16.1716C18.0783 15.4214 17.0609 15 16 15H8C6.93913 15 5.92172 15.4214 5.17157 16.1716C4.42143 16.9217 4 17.9391 4 19V21"}" stroke="${"#1C1C1C"}" stroke-opacity="${"0.5"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-k9rgss"}"></path><path d="${"M12 11C14.2091 11 16 9.20914 16 7C16 4.79086 14.2091 3 12 3C9.79086 3 8 4.79086 8 7C8 9.20914 9.79086 11 12 11Z"}" stroke="${"#1C1C1C"}" stroke-opacity="${"0.5"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-k9rgss"}"></path></svg></label>
                <input class="${"login-input svelte-k9rgss"}" id="${"username"}" name="${"email"}" type="${"text"}" placeholder="${"Email"}"></div>
            <div class="${"input-container svelte-k9rgss"}"><label class="${"login-label svelte-k9rgss"}" for="${"password"}"><svg width="${"24"}" height="${"24"}" viewBox="${"0 0 24 24"}" fill="${"none"}" xmlns="${"http://www.w3.org/2000/svg"}" class="${"svelte-k9rgss"}"><path d="${"M15.5 7.5L19 4M21 2L19 4L21 2ZM11.39 11.61C11.9064 12.1195 12.3168 12.726 12.5978 13.3948C12.8787 14.0635 13.0246 14.7813 13.0271 15.5066C13.0295 16.232 12.8884 16.9507 12.6119 17.6213C12.3355 18.2919 11.9291 18.9012 11.4162 19.4141C10.9033 19.9271 10.294 20.3334 9.62333 20.6099C8.95271 20.8864 8.23403 21.0275 7.50866 21.025C6.7833 21.0226 6.06557 20.8767 5.39682 20.5958C4.72807 20.3148 4.1215 19.9043 3.61203 19.388C2.61016 18.3507 2.05579 16.9614 2.06832 15.5193C2.08085 14.0772 2.65928 12.6977 3.67903 11.678C4.69877 10.6583 6.07824 10.0798 7.52032 10.0673C8.96241 10.0548 10.3517 10.6091 11.389 11.611L11.39 11.61ZM11.39 11.61L15.5 7.5L11.39 11.61ZM15.5 7.5L18.5 10.5L22 7L19 4L15.5 7.5Z"}" stroke="${"#1C1C1C"}" stroke-opacity="${"0.5"}" stroke-width="${"2"}" stroke-linecap="${"round"}" stroke-linejoin="${"round"}" class="${"svelte-k9rgss"}"></path></svg></label>
                <input class="${"login-input svelte-k9rgss"}" id="${"password"}" name="${"password"}" type="${"password"}" placeholder="${"password"}"></div>
            <div class="${"login-form-center svelte-k9rgss"}"><div class="${"input-container remember-container  svelte-k9rgss"}"><input class="${"remember-checkbox svelte-k9rgss"}" id="${"remember"}" type="${"checkbox"}" ${""}>
                    <label for="${"remember"}" class="${"gray checkbox-label svelte-k9rgss"}">Remember me</label></div>
                <a class="${"forgot-password-link gray  svelte-k9rgss"}" href="${"/forgot-password"}">Forgot Password?</a></div>
            <button class="${"login-button svelte-k9rgss"}">Login</button></form></div>
</main>`;
});
var login = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": Login,
  load
});

// .svelte-kit/netlify/entry.js
init();
async function handler(event) {
  const { path, httpMethod, headers, rawQuery, body, isBase64Encoded } = event;
  const query = new URLSearchParams(rawQuery);
  const encoding = isBase64Encoded ? "base64" : headers["content-encoding"] || "utf-8";
  const rawBody = typeof body === "string" ? Buffer.from(body, encoding) : body;
  const rendered = await render({
    method: httpMethod,
    headers,
    path,
    query,
    rawBody
  });
  if (rendered) {
    return {
      isBase64Encoded: false,
      statusCode: rendered.status,
      ...splitHeaders(rendered.headers),
      body: rendered.body
    };
  }
  return {
    statusCode: 404,
    body: "Not found"
  };
}
function splitHeaders(headers) {
  const h = {};
  const m = {};
  for (const key in headers) {
    const value = headers[key];
    const target = Array.isArray(value) ? m : h;
    target[key] = value;
  }
  return {
    headers: h,
    multiValueHeaders: m
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  handler
});
/*!
 * @kurkle/color v0.1.9
 * https://github.com/kurkle/color#readme
 * (c) 2020 Jukka Kurkela
 * Released under the MIT License
 */
/*!
 * Chart.js v3.5.1
 * https://www.chartjs.org
 * (c) 2021 Chart.js Contributors
 * Released under the MIT License
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2018 gRPC authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
